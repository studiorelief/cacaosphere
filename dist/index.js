"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // bin/live-reload.js
  var init_live_reload = __esm({
    "bin/live-reload.js"() {
      "use strict";
      new EventSource(`${"http://localhost:3000"}/esbuild`).addEventListener("change", () => location.reload());
    }
  });

  // node_modules/.pnpm/mapbox-gl@3.7.0/node_modules/mapbox-gl/dist/mapbox-gl.js
  var require_mapbox_gl = __commonJS({
    "node_modules/.pnpm/mapbox-gl@3.7.0/node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
      init_live_reload();
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, mapboxgl2;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl2 = chunk(sharedChunk);
            if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
              mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          function e(t2) {
            return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
          }
          var r, n = {}, i = {};
          function s() {
            if (r)
              return i;
            r = 1, Object.defineProperty(i, "__esModule", { value: true }), i.setMatrixArrayType = function(t3) {
              i.ARRAY_TYPE = e2 = t3;
            }, i.toRadian = function(t3) {
              return t3 * s2;
            }, i.equals = function(e3, r2) {
              return Math.abs(e3 - r2) <= t2 * Math.max(1, Math.abs(e3), Math.abs(r2));
            }, i.RANDOM = i.ARRAY_TYPE = i.EPSILON = void 0;
            var t2 = 1e-6;
            i.EPSILON = t2;
            var e2 = "undefined" != typeof Float32Array ? Float32Array : Array;
            i.ARRAY_TYPE = e2;
            var n2 = Math.random;
            i.RANDOM = n2;
            var s2 = Math.PI / 180;
            return Math.hypot || (Math.hypot = function() {
              for (var t3 = 0, e3 = arguments.length; e3--; )
                t3 += arguments[e3] * arguments[e3];
              return Math.sqrt(t3);
            }), i;
          }
          var a, o = {};
          function l() {
            if (a)
              return o;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            a = 1, Object.defineProperty(o, "__esModule", { value: true }), o.create = function() {
              var t3 = new e2.ARRAY_TYPE(4);
              return e2.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
            }, o.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(4);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3;
            }, o.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3;
            }, o.identity = function(t3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
            }, o.fromValues = function(t3, r3, n3, i3) {
              var s2 = new e2.ARRAY_TYPE(4);
              return s2[0] = t3, s2[1] = r3, s2[2] = n3, s2[3] = i3, s2;
            }, o.set = function(t3, e3, r3, n3, i3) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3;
            }, o.transpose = function(t3, e3) {
              if (t3 === e3) {
                var r3 = e3[1];
                t3[1] = e3[2], t3[2] = r3;
              } else
                t3[0] = e3[0], t3[1] = e3[2], t3[2] = e3[1], t3[3] = e3[3];
              return t3;
            }, o.invert = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3 * s2 - i3 * n3;
              return a2 ? (t3[0] = s2 * (a2 = 1 / a2), t3[1] = -n3 * a2, t3[2] = -i3 * a2, t3[3] = r3 * a2, t3) : null;
            }, o.adjoint = function(t3, e3) {
              var r3 = e3[0];
              return t3[0] = e3[3], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = r3, t3;
            }, o.determinant = function(t3) {
              return t3[0] * t3[3] - t3[2] * t3[1];
            }, o.multiply = n2, o.rotate = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
              return t3[0] = n3 * l2 + s2 * o2, t3[1] = i3 * l2 + a2 * o2, t3[2] = n3 * -o2 + s2 * l2, t3[3] = i3 * -o2 + a2 * l2, t3;
            }, o.scale = function(t3, e3, r3) {
              var n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3[0], o2 = r3[1];
              return t3[0] = e3[0] * a2, t3[1] = n3 * a2, t3[2] = i3 * o2, t3[3] = s2 * o2, t3;
            }, o.fromRotation = function(t3, e3) {
              var r3 = Math.sin(e3), n3 = Math.cos(e3);
              return t3[0] = n3, t3[1] = r3, t3[2] = -r3, t3[3] = n3, t3;
            }, o.fromScaling = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = e3[1], t3;
            }, o.str = function(t3) {
              return "mat2(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
            }, o.frob = function(t3) {
              return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
            }, o.LDU = function(t3, e3, r3, n3) {
              return t3[2] = n3[2] / n3[0], r3[0] = n3[0], r3[1] = n3[1], r3[3] = n3[3] - t3[2] * r3[1], [t3, e3, r3];
            }, o.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3;
            }, o.subtract = i2, o.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
            }, o.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a2 = t3[3], o2 = r3[0], l2 = r3[1], u2 = r3[2], c2 = r3[3];
              return Math.abs(n3 - o2) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o2)) && Math.abs(i3 - l2) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l2)) && Math.abs(s2 - u2) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(u2)) && Math.abs(a2 - c2) <= e2.EPSILON * Math.max(1, Math.abs(a2), Math.abs(c2));
            }, o.multiplyScalar = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3;
            }, o.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3;
            }, o.sub = o.mul = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o2 in e3)
                if ("default" !== o2 && Object.prototype.hasOwnProperty.call(e3, o2)) {
                  var l2 = a2 ? Object.getOwnPropertyDescriptor(e3, o2) : null;
                  l2 && (l2.get || l2.set) ? Object.defineProperty(s2, o2, l2) : s2[o2] = e3[o2];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = r3[0], l2 = r3[1], u2 = r3[2], c2 = r3[3];
              return t3[0] = n3 * o2 + s2 * l2, t3[1] = i3 * o2 + a2 * l2, t3[2] = n3 * u2 + s2 * c2, t3[3] = i3 * u2 + a2 * c2, t3;
            }
            function i2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3;
            }
            return o.mul = n2, o.sub = i2, o;
          }
          var u, c = {};
          function h() {
            if (u)
              return c;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            u = 1, Object.defineProperty(c, "__esModule", { value: true }), c.create = function() {
              var t3 = new e2.ARRAY_TYPE(6);
              return e2.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[4] = 0, t3[5] = 0), t3[0] = 1, t3[3] = 1, t3;
            }, c.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(6);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3;
            }, c.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3;
            }, c.identity = function(t3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0, t3[5] = 0, t3;
            }, c.fromValues = function(t3, r3, n3, i3, s2, a2) {
              var o2 = new e2.ARRAY_TYPE(6);
              return o2[0] = t3, o2[1] = r3, o2[2] = n3, o2[3] = i3, o2[4] = s2, o2[5] = a2, o2;
            }, c.set = function(t3, e3, r3, n3, i3, s2, a2) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a2, t3;
            }, c.invert = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l2 = r3 * s2 - n3 * i3;
              return l2 ? (t3[0] = s2 * (l2 = 1 / l2), t3[1] = -n3 * l2, t3[2] = -i3 * l2, t3[3] = r3 * l2, t3[4] = (i3 * o2 - s2 * a2) * l2, t3[5] = (n3 * a2 - r3 * o2) * l2, t3) : null;
            }, c.determinant = function(t3) {
              return t3[0] * t3[3] - t3[1] * t3[2];
            }, c.multiply = n2, c.rotate = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = Math.sin(r3), c2 = Math.cos(r3);
              return t3[0] = n3 * c2 + s2 * u2, t3[1] = i3 * c2 + a2 * u2, t3[2] = n3 * -u2 + s2 * c2, t3[3] = i3 * -u2 + a2 * c2, t3[4] = o2, t3[5] = l2, t3;
            }, c.scale = function(t3, e3, r3) {
              var n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l2 = r3[0], u2 = r3[1];
              return t3[0] = e3[0] * l2, t3[1] = n3 * l2, t3[2] = i3 * u2, t3[3] = s2 * u2, t3[4] = a2, t3[5] = o2, t3;
            }, c.translate = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = r3[0], c2 = r3[1];
              return t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a2, t3[4] = n3 * u2 + s2 * c2 + o2, t3[5] = i3 * u2 + a2 * c2 + l2, t3;
            }, c.fromRotation = function(t3, e3) {
              var r3 = Math.sin(e3), n3 = Math.cos(e3);
              return t3[0] = n3, t3[1] = r3, t3[2] = -r3, t3[3] = n3, t3[4] = 0, t3[5] = 0, t3;
            }, c.fromScaling = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = e3[1], t3[4] = 0, t3[5] = 0, t3;
            }, c.fromTranslation = function(t3, e3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = e3[0], t3[5] = e3[1], t3;
            }, c.str = function(t3) {
              return "mat2d(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ")";
            }, c.frob = function(t3) {
              return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], 1);
            }, c.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3;
            }, c.subtract = i2, c.multiplyScalar = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3;
            }, c.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3[4] = e3[4] + r3[4] * n3, t3[5] = e3[5] + r3[5] * n3, t3;
            }, c.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5];
            }, c.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a2 = t3[3], o2 = t3[4], l2 = t3[5], u2 = r3[0], c2 = r3[1], h2 = r3[2], p2 = r3[3], f2 = r3[4], d2 = r3[5];
              return Math.abs(n3 - u2) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(u2)) && Math.abs(i3 - c2) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(c2)) && Math.abs(s2 - h2) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(h2)) && Math.abs(a2 - p2) <= e2.EPSILON * Math.max(1, Math.abs(a2), Math.abs(p2)) && Math.abs(o2 - f2) <= e2.EPSILON * Math.max(1, Math.abs(o2), Math.abs(f2)) && Math.abs(l2 - d2) <= e2.EPSILON * Math.max(1, Math.abs(l2), Math.abs(d2));
            }, c.sub = c.mul = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o2 in e3)
                if ("default" !== o2 && Object.prototype.hasOwnProperty.call(e3, o2)) {
                  var l2 = a2 ? Object.getOwnPropertyDescriptor(e3, o2) : null;
                  l2 && (l2.get || l2.set) ? Object.defineProperty(s2, o2, l2) : s2[o2] = e3[o2];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = r3[0], c2 = r3[1], h2 = r3[2], p2 = r3[3], f2 = r3[4], d2 = r3[5];
              return t3[0] = n3 * u2 + s2 * c2, t3[1] = i3 * u2 + a2 * c2, t3[2] = n3 * h2 + s2 * p2, t3[3] = i3 * h2 + a2 * p2, t3[4] = n3 * f2 + s2 * d2 + o2, t3[5] = i3 * f2 + a2 * d2 + l2, t3;
            }
            function i2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3[4] = e3[4] - r3[4], t3[5] = e3[5] - r3[5], t3;
            }
            return c.mul = n2, c.sub = i2, c;
          }
          var p, f = {};
          function d() {
            if (p)
              return f;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            p = 1, Object.defineProperty(f, "__esModule", { value: true }), f.create = function() {
              var t3 = new e2.ARRAY_TYPE(9);
              return e2.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
            }, f.fromMat4 = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[4], t3[4] = e3[5], t3[5] = e3[6], t3[6] = e3[8], t3[7] = e3[9], t3[8] = e3[10], t3;
            }, f.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(9);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3[6] = t3[6], r3[7] = t3[7], r3[8] = t3[8], r3;
            }, f.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3;
            }, f.fromValues = function(t3, r3, n3, i3, s2, a2, o2, l2, u2) {
              var c2 = new e2.ARRAY_TYPE(9);
              return c2[0] = t3, c2[1] = r3, c2[2] = n3, c2[3] = i3, c2[4] = s2, c2[5] = a2, c2[6] = o2, c2[7] = l2, c2[8] = u2, c2;
            }, f.set = function(t3, e3, r3, n3, i3, s2, a2, o2, l2, u2) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a2, t3[6] = o2, t3[7] = l2, t3[8] = u2, t3;
            }, f.identity = function(t3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 1, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
            }, f.transpose = function(t3, e3) {
              if (t3 === e3) {
                var r3 = e3[1], n3 = e3[2], i3 = e3[5];
                t3[1] = e3[3], t3[2] = e3[6], t3[3] = r3, t3[5] = e3[7], t3[6] = n3, t3[7] = i3;
              } else
                t3[0] = e3[0], t3[1] = e3[3], t3[2] = e3[6], t3[3] = e3[1], t3[4] = e3[4], t3[5] = e3[7], t3[6] = e3[2], t3[7] = e3[5], t3[8] = e3[8];
              return t3;
            }, f.invert = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8], h2 = c2 * a2 - o2 * u2, p2 = -c2 * s2 + o2 * l2, f2 = u2 * s2 - a2 * l2, d2 = r3 * h2 + n3 * p2 + i3 * f2;
              return d2 ? (t3[0] = h2 * (d2 = 1 / d2), t3[1] = (-c2 * n3 + i3 * u2) * d2, t3[2] = (o2 * n3 - i3 * a2) * d2, t3[3] = p2 * d2, t3[4] = (c2 * r3 - i3 * l2) * d2, t3[5] = (-o2 * r3 + i3 * s2) * d2, t3[6] = f2 * d2, t3[7] = (-u2 * r3 + n3 * l2) * d2, t3[8] = (a2 * r3 - n3 * s2) * d2, t3) : null;
            }, f.adjoint = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8];
              return t3[0] = a2 * c2 - o2 * u2, t3[1] = i3 * u2 - n3 * c2, t3[2] = n3 * o2 - i3 * a2, t3[3] = o2 * l2 - s2 * c2, t3[4] = r3 * c2 - i3 * l2, t3[5] = i3 * s2 - r3 * o2, t3[6] = s2 * u2 - a2 * l2, t3[7] = n3 * l2 - r3 * u2, t3[8] = r3 * a2 - n3 * s2, t3;
            }, f.determinant = function(t3) {
              var e3 = t3[3], r3 = t3[4], n3 = t3[5], i3 = t3[6], s2 = t3[7], a2 = t3[8];
              return t3[0] * (a2 * r3 - n3 * s2) + t3[1] * (-a2 * e3 + n3 * i3) + t3[2] * (s2 * e3 - r3 * i3);
            }, f.multiply = n2, f.translate = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = r3[0], f2 = r3[1];
              return t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a2, t3[4] = o2, t3[5] = l2, t3[6] = p2 * n3 + f2 * a2 + u2, t3[7] = p2 * i3 + f2 * o2 + c2, t3[8] = p2 * s2 + f2 * l2 + h2, t3;
            }, f.rotate = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = Math.sin(r3), f2 = Math.cos(r3);
              return t3[0] = f2 * n3 + p2 * a2, t3[1] = f2 * i3 + p2 * o2, t3[2] = f2 * s2 + p2 * l2, t3[3] = f2 * a2 - p2 * n3, t3[4] = f2 * o2 - p2 * i3, t3[5] = f2 * l2 - p2 * s2, t3[6] = u2, t3[7] = c2, t3[8] = h2, t3;
            }, f.scale = function(t3, e3, r3) {
              var n3 = r3[0], i3 = r3[1];
              return t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = i3 * e3[3], t3[4] = i3 * e3[4], t3[5] = i3 * e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3;
            }, f.fromTranslation = function(t3, e3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 1, t3[5] = 0, t3[6] = e3[0], t3[7] = e3[1], t3[8] = 1, t3;
            }, f.fromRotation = function(t3, e3) {
              var r3 = Math.sin(e3), n3 = Math.cos(e3);
              return t3[0] = n3, t3[1] = r3, t3[2] = 0, t3[3] = -r3, t3[4] = n3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
            }, f.fromScaling = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = e3[1], t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
            }, f.fromMat2d = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = 0, t3[3] = e3[2], t3[4] = e3[3], t3[5] = 0, t3[6] = e3[4], t3[7] = e3[5], t3[8] = 1, t3;
            }, f.fromQuat = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = r3 + r3, o2 = n3 + n3, l2 = i3 + i3, u2 = r3 * a2, c2 = n3 * a2, h2 = n3 * o2, p2 = i3 * a2, f2 = i3 * o2, d2 = i3 * l2, m2 = s2 * a2, y2 = s2 * o2, g2 = s2 * l2;
              return t3[0] = 1 - h2 - d2, t3[3] = c2 - g2, t3[6] = p2 + y2, t3[1] = c2 + g2, t3[4] = 1 - u2 - d2, t3[7] = f2 - m2, t3[2] = p2 - y2, t3[5] = f2 + m2, t3[8] = 1 - u2 - h2, t3;
            }, f.normalFromMat4 = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8], h2 = e3[9], p2 = e3[10], f2 = e3[11], d2 = e3[12], m2 = e3[13], y2 = e3[14], g2 = e3[15], x2 = r3 * o2 - n3 * a2, b2 = r3 * l2 - i3 * a2, v2 = r3 * u2 - s2 * a2, w2 = n3 * l2 - i3 * o2, _2 = n3 * u2 - s2 * o2, M2 = i3 * u2 - s2 * l2, A2 = c2 * m2 - h2 * d2, S2 = c2 * y2 - p2 * d2, I2 = c2 * g2 - f2 * d2, P2 = h2 * y2 - p2 * m2, z2 = h2 * g2 - f2 * m2, k2 = p2 * g2 - f2 * y2, T2 = x2 * k2 - b2 * z2 + v2 * P2 + w2 * I2 - _2 * S2 + M2 * A2;
              return T2 ? (t3[0] = (o2 * k2 - l2 * z2 + u2 * P2) * (T2 = 1 / T2), t3[1] = (l2 * I2 - a2 * k2 - u2 * S2) * T2, t3[2] = (a2 * z2 - o2 * I2 + u2 * A2) * T2, t3[3] = (i3 * z2 - n3 * k2 - s2 * P2) * T2, t3[4] = (r3 * k2 - i3 * I2 + s2 * S2) * T2, t3[5] = (n3 * I2 - r3 * z2 - s2 * A2) * T2, t3[6] = (m2 * M2 - y2 * _2 + g2 * w2) * T2, t3[7] = (y2 * v2 - d2 * M2 - g2 * b2) * T2, t3[8] = (d2 * _2 - m2 * v2 + g2 * x2) * T2, t3) : null;
            }, f.projection = function(t3, e3, r3) {
              return t3[0] = 2 / e3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = -2 / r3, t3[5] = 0, t3[6] = -1, t3[7] = 1, t3[8] = 1, t3;
            }, f.str = function(t3) {
              return "mat3(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ", " + t3[8] + ")";
            }, f.frob = function(t3) {
              return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6], t3[7], t3[8]);
            }, f.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3[6] = e3[6] + r3[6], t3[7] = e3[7] + r3[7], t3[8] = e3[8] + r3[8], t3;
            }, f.subtract = i2, f.multiplyScalar = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3[6] = e3[6] * r3, t3[7] = e3[7] * r3, t3[8] = e3[8] * r3, t3;
            }, f.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3[4] = e3[4] + r3[4] * n3, t3[5] = e3[5] + r3[5] * n3, t3[6] = e3[6] + r3[6] * n3, t3[7] = e3[7] + r3[7] * n3, t3[8] = e3[8] + r3[8] * n3, t3;
            }, f.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5] && t3[6] === e3[6] && t3[7] === e3[7] && t3[8] === e3[8];
            }, f.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a2 = t3[3], o2 = t3[4], l2 = t3[5], u2 = t3[6], c2 = t3[7], h2 = t3[8], p2 = r3[0], f2 = r3[1], d2 = r3[2], m2 = r3[3], y2 = r3[4], g2 = r3[5], x2 = r3[6], b2 = r3[7], v2 = r3[8];
              return Math.abs(n3 - p2) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(p2)) && Math.abs(i3 - f2) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(f2)) && Math.abs(s2 - d2) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(d2)) && Math.abs(a2 - m2) <= e2.EPSILON * Math.max(1, Math.abs(a2), Math.abs(m2)) && Math.abs(o2 - y2) <= e2.EPSILON * Math.max(1, Math.abs(o2), Math.abs(y2)) && Math.abs(l2 - g2) <= e2.EPSILON * Math.max(1, Math.abs(l2), Math.abs(g2)) && Math.abs(u2 - x2) <= e2.EPSILON * Math.max(1, Math.abs(u2), Math.abs(x2)) && Math.abs(c2 - b2) <= e2.EPSILON * Math.max(1, Math.abs(c2), Math.abs(b2)) && Math.abs(h2 - v2) <= e2.EPSILON * Math.max(1, Math.abs(h2), Math.abs(v2));
            }, f.sub = f.mul = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o2 in e3)
                if ("default" !== o2 && Object.prototype.hasOwnProperty.call(e3, o2)) {
                  var l2 = a2 ? Object.getOwnPropertyDescriptor(e3, o2) : null;
                  l2 && (l2.get || l2.set) ? Object.defineProperty(s2, o2, l2) : s2[o2] = e3[o2];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = r3[0], f2 = r3[1], d2 = r3[2], m2 = r3[3], y2 = r3[4], g2 = r3[5], x2 = r3[6], b2 = r3[7], v2 = r3[8];
              return t3[0] = p2 * n3 + f2 * a2 + d2 * u2, t3[1] = p2 * i3 + f2 * o2 + d2 * c2, t3[2] = p2 * s2 + f2 * l2 + d2 * h2, t3[3] = m2 * n3 + y2 * a2 + g2 * u2, t3[4] = m2 * i3 + y2 * o2 + g2 * c2, t3[5] = m2 * s2 + y2 * l2 + g2 * h2, t3[6] = x2 * n3 + b2 * a2 + v2 * u2, t3[7] = x2 * i3 + b2 * o2 + v2 * c2, t3[8] = x2 * s2 + b2 * l2 + v2 * h2, t3;
            }
            function i2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3[4] = e3[4] - r3[4], t3[5] = e3[5] - r3[5], t3[6] = e3[6] - r3[6], t3[7] = e3[7] - r3[7], t3[8] = e3[8] - r3[8], t3;
            }
            return f.mul = n2, f.sub = i2, f;
          }
          var m, y = {};
          function g() {
            if (m)
              return y;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            m = 1, Object.defineProperty(y, "__esModule", { value: true }), y.create = function() {
              var t3 = new e2.ARRAY_TYPE(16);
              return e2.ARRAY_TYPE != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
            }, y.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(16);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3[6] = t3[6], r3[7] = t3[7], r3[8] = t3[8], r3[9] = t3[9], r3[10] = t3[10], r3[11] = t3[11], r3[12] = t3[12], r3[13] = t3[13], r3[14] = t3[14], r3[15] = t3[15], r3;
            }, y.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
            }, y.fromValues = function(t3, r3, n3, i3, s2, a3, o3, l3, u3, c3, h2, p2, f2, d2, m2, y2) {
              var g2 = new e2.ARRAY_TYPE(16);
              return g2[0] = t3, g2[1] = r3, g2[2] = n3, g2[3] = i3, g2[4] = s2, g2[5] = a3, g2[6] = o3, g2[7] = l3, g2[8] = u3, g2[9] = c3, g2[10] = h2, g2[11] = p2, g2[12] = f2, g2[13] = d2, g2[14] = m2, g2[15] = y2, g2;
            }, y.set = function(t3, e3, r3, n3, i3, s2, a3, o3, l3, u3, c3, h2, p2, f2, d2, m2, y2) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3[8] = u3, t3[9] = c3, t3[10] = h2, t3[11] = p2, t3[12] = f2, t3[13] = d2, t3[14] = m2, t3[15] = y2, t3;
            }, y.identity = n2, y.transpose = function(t3, e3) {
              if (t3 === e3) {
                var r3 = e3[1], n3 = e3[2], i3 = e3[3], s2 = e3[6], a3 = e3[7], o3 = e3[11];
                t3[1] = e3[4], t3[2] = e3[8], t3[3] = e3[12], t3[4] = r3, t3[6] = e3[9], t3[7] = e3[13], t3[8] = n3, t3[9] = s2, t3[11] = e3[14], t3[12] = i3, t3[13] = a3, t3[14] = o3;
              } else
                t3[0] = e3[0], t3[1] = e3[4], t3[2] = e3[8], t3[3] = e3[12], t3[4] = e3[1], t3[5] = e3[5], t3[6] = e3[9], t3[7] = e3[13], t3[8] = e3[2], t3[9] = e3[6], t3[10] = e3[10], t3[11] = e3[14], t3[12] = e3[3], t3[13] = e3[7], t3[14] = e3[11], t3[15] = e3[15];
              return t3;
            }, y.invert = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = e3[4], o3 = e3[5], l3 = e3[6], u3 = e3[7], c3 = e3[8], h2 = e3[9], p2 = e3[10], f2 = e3[11], d2 = e3[12], m2 = e3[13], y2 = e3[14], g2 = e3[15], x2 = r3 * o3 - n3 * a3, b2 = r3 * l3 - i3 * a3, v2 = r3 * u3 - s2 * a3, w2 = n3 * l3 - i3 * o3, _2 = n3 * u3 - s2 * o3, M2 = i3 * u3 - s2 * l3, A2 = c3 * m2 - h2 * d2, S2 = c3 * y2 - p2 * d2, I2 = c3 * g2 - f2 * d2, P2 = h2 * y2 - p2 * m2, z2 = h2 * g2 - f2 * m2, k2 = p2 * g2 - f2 * y2, T2 = x2 * k2 - b2 * z2 + v2 * P2 + w2 * I2 - _2 * S2 + M2 * A2;
              return T2 ? (t3[0] = (o3 * k2 - l3 * z2 + u3 * P2) * (T2 = 1 / T2), t3[1] = (i3 * z2 - n3 * k2 - s2 * P2) * T2, t3[2] = (m2 * M2 - y2 * _2 + g2 * w2) * T2, t3[3] = (p2 * _2 - h2 * M2 - f2 * w2) * T2, t3[4] = (l3 * I2 - a3 * k2 - u3 * S2) * T2, t3[5] = (r3 * k2 - i3 * I2 + s2 * S2) * T2, t3[6] = (y2 * v2 - d2 * M2 - g2 * b2) * T2, t3[7] = (c3 * M2 - p2 * v2 + f2 * b2) * T2, t3[8] = (a3 * z2 - o3 * I2 + u3 * A2) * T2, t3[9] = (n3 * I2 - r3 * z2 - s2 * A2) * T2, t3[10] = (d2 * _2 - m2 * v2 + g2 * x2) * T2, t3[11] = (h2 * v2 - c3 * _2 - f2 * x2) * T2, t3[12] = (o3 * S2 - a3 * P2 - l3 * A2) * T2, t3[13] = (r3 * P2 - n3 * S2 + i3 * A2) * T2, t3[14] = (m2 * b2 - d2 * w2 - y2 * x2) * T2, t3[15] = (c3 * w2 - h2 * b2 + p2 * x2) * T2, t3) : null;
            }, y.adjoint = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = e3[4], o3 = e3[5], l3 = e3[6], u3 = e3[7], c3 = e3[8], h2 = e3[9], p2 = e3[10], f2 = e3[11], d2 = e3[12], m2 = e3[13], y2 = e3[14], g2 = e3[15];
              return t3[0] = o3 * (p2 * g2 - f2 * y2) - h2 * (l3 * g2 - u3 * y2) + m2 * (l3 * f2 - u3 * p2), t3[1] = -(n3 * (p2 * g2 - f2 * y2) - h2 * (i3 * g2 - s2 * y2) + m2 * (i3 * f2 - s2 * p2)), t3[2] = n3 * (l3 * g2 - u3 * y2) - o3 * (i3 * g2 - s2 * y2) + m2 * (i3 * u3 - s2 * l3), t3[3] = -(n3 * (l3 * f2 - u3 * p2) - o3 * (i3 * f2 - s2 * p2) + h2 * (i3 * u3 - s2 * l3)), t3[4] = -(a3 * (p2 * g2 - f2 * y2) - c3 * (l3 * g2 - u3 * y2) + d2 * (l3 * f2 - u3 * p2)), t3[5] = r3 * (p2 * g2 - f2 * y2) - c3 * (i3 * g2 - s2 * y2) + d2 * (i3 * f2 - s2 * p2), t3[6] = -(r3 * (l3 * g2 - u3 * y2) - a3 * (i3 * g2 - s2 * y2) + d2 * (i3 * u3 - s2 * l3)), t3[7] = r3 * (l3 * f2 - u3 * p2) - a3 * (i3 * f2 - s2 * p2) + c3 * (i3 * u3 - s2 * l3), t3[8] = a3 * (h2 * g2 - f2 * m2) - c3 * (o3 * g2 - u3 * m2) + d2 * (o3 * f2 - u3 * h2), t3[9] = -(r3 * (h2 * g2 - f2 * m2) - c3 * (n3 * g2 - s2 * m2) + d2 * (n3 * f2 - s2 * h2)), t3[10] = r3 * (o3 * g2 - u3 * m2) - a3 * (n3 * g2 - s2 * m2) + d2 * (n3 * u3 - s2 * o3), t3[11] = -(r3 * (o3 * f2 - u3 * h2) - a3 * (n3 * f2 - s2 * h2) + c3 * (n3 * u3 - s2 * o3)), t3[12] = -(a3 * (h2 * y2 - p2 * m2) - c3 * (o3 * y2 - l3 * m2) + d2 * (o3 * p2 - l3 * h2)), t3[13] = r3 * (h2 * y2 - p2 * m2) - c3 * (n3 * y2 - i3 * m2) + d2 * (n3 * p2 - i3 * h2), t3[14] = -(r3 * (o3 * y2 - l3 * m2) - a3 * (n3 * y2 - i3 * m2) + d2 * (n3 * l3 - i3 * o3)), t3[15] = r3 * (o3 * p2 - l3 * h2) - a3 * (n3 * p2 - i3 * h2) + c3 * (n3 * l3 - i3 * o3), t3;
            }, y.determinant = function(t3) {
              var e3 = t3[0], r3 = t3[1], n3 = t3[2], i3 = t3[3], s2 = t3[4], a3 = t3[5], o3 = t3[6], l3 = t3[7], u3 = t3[8], c3 = t3[9], h2 = t3[10], p2 = t3[11], f2 = t3[12], d2 = t3[13], m2 = t3[14], y2 = t3[15];
              return (e3 * a3 - r3 * s2) * (h2 * y2 - p2 * m2) - (e3 * o3 - n3 * s2) * (c3 * y2 - p2 * d2) + (e3 * l3 - i3 * s2) * (c3 * m2 - h2 * d2) + (r3 * o3 - n3 * a3) * (u3 * y2 - p2 * f2) - (r3 * l3 - i3 * a3) * (u3 * m2 - h2 * f2) + (n3 * l3 - i3 * o3) * (u3 * d2 - c3 * f2);
            }, y.multiply = i2, y.translate = function(t3, e3, r3) {
              var n3, i3, s2, a3, o3, l3, u3, c3, h2, p2, f2, d2, m2 = r3[0], y2 = r3[1], g2 = r3[2];
              return e3 === t3 ? (t3[12] = e3[0] * m2 + e3[4] * y2 + e3[8] * g2 + e3[12], t3[13] = e3[1] * m2 + e3[5] * y2 + e3[9] * g2 + e3[13], t3[14] = e3[2] * m2 + e3[6] * y2 + e3[10] * g2 + e3[14], t3[15] = e3[3] * m2 + e3[7] * y2 + e3[11] * g2 + e3[15]) : (i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = e3[4], l3 = e3[5], u3 = e3[6], c3 = e3[7], h2 = e3[8], p2 = e3[9], f2 = e3[10], d2 = e3[11], t3[0] = n3 = e3[0], t3[1] = i3, t3[2] = s2, t3[3] = a3, t3[4] = o3, t3[5] = l3, t3[6] = u3, t3[7] = c3, t3[8] = h2, t3[9] = p2, t3[10] = f2, t3[11] = d2, t3[12] = n3 * m2 + o3 * y2 + h2 * g2 + e3[12], t3[13] = i3 * m2 + l3 * y2 + p2 * g2 + e3[13], t3[14] = s2 * m2 + u3 * y2 + f2 * g2 + e3[14], t3[15] = a3 * m2 + c3 * y2 + d2 * g2 + e3[15]), t3;
            }, y.scale = function(t3, e3, r3) {
              var n3 = r3[0], i3 = r3[1], s2 = r3[2];
              return t3[0] = e3[0] * n3, t3[1] = e3[1] * n3, t3[2] = e3[2] * n3, t3[3] = e3[3] * n3, t3[4] = e3[4] * i3, t3[5] = e3[5] * i3, t3[6] = e3[6] * i3, t3[7] = e3[7] * i3, t3[8] = e3[8] * s2, t3[9] = e3[9] * s2, t3[10] = e3[10] * s2, t3[11] = e3[11] * s2, t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
            }, y.rotate = function(t3, r3, n3, i3) {
              var s2, a3, o3, l3, u3, c3, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2, w2, _2, M2, A2, S2, I2, P2, z2, k2 = i3[0], T2 = i3[1], E2 = i3[2], B2 = Math.hypot(k2, T2, E2);
              return B2 < e2.EPSILON ? null : (k2 *= B2 = 1 / B2, T2 *= B2, E2 *= B2, s2 = Math.sin(n3), a3 = Math.cos(n3), u3 = r3[1], c3 = r3[2], h2 = r3[3], f2 = r3[5], d2 = r3[6], m2 = r3[7], g2 = r3[9], x2 = r3[10], b2 = r3[11], v2 = k2 * k2 * (o3 = 1 - a3) + a3, M2 = k2 * T2 * o3 - E2 * s2, A2 = T2 * T2 * o3 + a3, S2 = E2 * T2 * o3 + k2 * s2, I2 = k2 * E2 * o3 + T2 * s2, P2 = T2 * E2 * o3 - k2 * s2, z2 = E2 * E2 * o3 + a3, t3[0] = (l3 = r3[0]) * v2 + (p2 = r3[4]) * (w2 = T2 * k2 * o3 + E2 * s2) + (y2 = r3[8]) * (_2 = E2 * k2 * o3 - T2 * s2), t3[1] = u3 * v2 + f2 * w2 + g2 * _2, t3[2] = c3 * v2 + d2 * w2 + x2 * _2, t3[3] = h2 * v2 + m2 * w2 + b2 * _2, t3[4] = l3 * M2 + p2 * A2 + y2 * S2, t3[5] = u3 * M2 + f2 * A2 + g2 * S2, t3[6] = c3 * M2 + d2 * A2 + x2 * S2, t3[7] = h2 * M2 + m2 * A2 + b2 * S2, t3[8] = l3 * I2 + p2 * P2 + y2 * z2, t3[9] = u3 * I2 + f2 * P2 + g2 * z2, t3[10] = c3 * I2 + d2 * P2 + x2 * z2, t3[11] = h2 * I2 + m2 * P2 + b2 * z2, r3 !== t3 && (t3[12] = r3[12], t3[13] = r3[13], t3[14] = r3[14], t3[15] = r3[15]), t3);
            }, y.rotateX = function(t3, e3, r3) {
              var n3 = Math.sin(r3), i3 = Math.cos(r3), s2 = e3[4], a3 = e3[5], o3 = e3[6], l3 = e3[7], u3 = e3[8], c3 = e3[9], h2 = e3[10], p2 = e3[11];
              return e3 !== t3 && (t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[4] = s2 * i3 + u3 * n3, t3[5] = a3 * i3 + c3 * n3, t3[6] = o3 * i3 + h2 * n3, t3[7] = l3 * i3 + p2 * n3, t3[8] = u3 * i3 - s2 * n3, t3[9] = c3 * i3 - a3 * n3, t3[10] = h2 * i3 - o3 * n3, t3[11] = p2 * i3 - l3 * n3, t3;
            }, y.rotateY = function(t3, e3, r3) {
              var n3 = Math.sin(r3), i3 = Math.cos(r3), s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = e3[3], u3 = e3[8], c3 = e3[9], h2 = e3[10], p2 = e3[11];
              return e3 !== t3 && (t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s2 * i3 - u3 * n3, t3[1] = a3 * i3 - c3 * n3, t3[2] = o3 * i3 - h2 * n3, t3[3] = l3 * i3 - p2 * n3, t3[8] = s2 * n3 + u3 * i3, t3[9] = a3 * n3 + c3 * i3, t3[10] = o3 * n3 + h2 * i3, t3[11] = l3 * n3 + p2 * i3, t3;
            }, y.rotateZ = function(t3, e3, r3) {
              var n3 = Math.sin(r3), i3 = Math.cos(r3), s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = e3[3], u3 = e3[4], c3 = e3[5], h2 = e3[6], p2 = e3[7];
              return e3 !== t3 && (t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s2 * i3 + u3 * n3, t3[1] = a3 * i3 + c3 * n3, t3[2] = o3 * i3 + h2 * n3, t3[3] = l3 * i3 + p2 * n3, t3[4] = u3 * i3 - s2 * n3, t3[5] = c3 * i3 - a3 * n3, t3[6] = h2 * i3 - o3 * n3, t3[7] = p2 * i3 - l3 * n3, t3;
            }, y.fromTranslation = function(t3, e3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = e3[0], t3[13] = e3[1], t3[14] = e3[2], t3[15] = 1, t3;
            }, y.fromScaling = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e3[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e3[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
            }, y.fromRotation = function(t3, r3, n3) {
              var i3, s2, a3, o3 = n3[0], l3 = n3[1], u3 = n3[2], c3 = Math.hypot(o3, l3, u3);
              return c3 < e2.EPSILON ? null : (o3 *= c3 = 1 / c3, l3 *= c3, u3 *= c3, i3 = Math.sin(r3), s2 = Math.cos(r3), t3[0] = o3 * o3 * (a3 = 1 - s2) + s2, t3[1] = l3 * o3 * a3 + u3 * i3, t3[2] = u3 * o3 * a3 - l3 * i3, t3[3] = 0, t3[4] = o3 * l3 * a3 - u3 * i3, t3[5] = l3 * l3 * a3 + s2, t3[6] = u3 * l3 * a3 + o3 * i3, t3[7] = 0, t3[8] = o3 * u3 * a3 + l3 * i3, t3[9] = l3 * u3 * a3 - o3 * i3, t3[10] = u3 * u3 * a3 + s2, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3);
            }, y.fromXRotation = function(t3, e3) {
              var r3 = Math.sin(e3), n3 = Math.cos(e3);
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = n3, t3[6] = r3, t3[7] = 0, t3[8] = 0, t3[9] = -r3, t3[10] = n3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
            }, y.fromYRotation = function(t3, e3) {
              var r3 = Math.sin(e3), n3 = Math.cos(e3);
              return t3[0] = n3, t3[1] = 0, t3[2] = -r3, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = r3, t3[9] = 0, t3[10] = n3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
            }, y.fromZRotation = function(t3, e3) {
              var r3 = Math.sin(e3), n3 = Math.cos(e3);
              return t3[0] = n3, t3[1] = r3, t3[2] = 0, t3[3] = 0, t3[4] = -r3, t3[5] = n3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
            }, y.fromRotationTranslation = a2, y.fromQuat2 = function(t3, r3) {
              var n3 = new e2.ARRAY_TYPE(3), i3 = -r3[0], s2 = -r3[1], o3 = -r3[2], l3 = r3[3], u3 = r3[4], c3 = r3[5], h2 = r3[6], p2 = r3[7], f2 = i3 * i3 + s2 * s2 + o3 * o3 + l3 * l3;
              return f2 > 0 ? (n3[0] = 2 * (u3 * l3 + p2 * i3 + c3 * o3 - h2 * s2) / f2, n3[1] = 2 * (c3 * l3 + p2 * s2 + h2 * i3 - u3 * o3) / f2, n3[2] = 2 * (h2 * l3 + p2 * o3 + u3 * s2 - c3 * i3) / f2) : (n3[0] = 2 * (u3 * l3 + p2 * i3 + c3 * o3 - h2 * s2), n3[1] = 2 * (c3 * l3 + p2 * s2 + h2 * i3 - u3 * o3), n3[2] = 2 * (h2 * l3 + p2 * o3 + u3 * s2 - c3 * i3)), a2(t3, r3, n3), t3;
            }, y.getTranslation = function(t3, e3) {
              return t3[0] = e3[12], t3[1] = e3[13], t3[2] = e3[14], t3;
            }, y.getScaling = o2, y.getRotation = function(t3, r3) {
              var n3 = new e2.ARRAY_TYPE(3);
              o2(n3, r3);
              var i3 = 1 / n3[0], s2 = 1 / n3[1], a3 = 1 / n3[2], l3 = r3[0] * i3, u3 = r3[1] * s2, c3 = r3[2] * a3, h2 = r3[4] * i3, p2 = r3[5] * s2, f2 = r3[6] * a3, d2 = r3[8] * i3, m2 = r3[9] * s2, y2 = r3[10] * a3, g2 = l3 + p2 + y2, x2 = 0;
              return g2 > 0 ? (x2 = 2 * Math.sqrt(g2 + 1), t3[3] = 0.25 * x2, t3[0] = (f2 - m2) / x2, t3[1] = (d2 - c3) / x2, t3[2] = (u3 - h2) / x2) : l3 > p2 && l3 > y2 ? (x2 = 2 * Math.sqrt(1 + l3 - p2 - y2), t3[3] = (f2 - m2) / x2, t3[0] = 0.25 * x2, t3[1] = (u3 + h2) / x2, t3[2] = (d2 + c3) / x2) : p2 > y2 ? (x2 = 2 * Math.sqrt(1 + p2 - l3 - y2), t3[3] = (d2 - c3) / x2, t3[0] = (u3 + h2) / x2, t3[1] = 0.25 * x2, t3[2] = (f2 + m2) / x2) : (x2 = 2 * Math.sqrt(1 + y2 - l3 - p2), t3[3] = (u3 - h2) / x2, t3[0] = (d2 + c3) / x2, t3[1] = (f2 + m2) / x2, t3[2] = 0.25 * x2), t3;
            }, y.fromRotationTranslationScale = function(t3, e3, r3, n3) {
              var i3 = e3[0], s2 = e3[1], a3 = e3[2], o3 = e3[3], l3 = i3 + i3, u3 = s2 + s2, c3 = a3 + a3, h2 = i3 * l3, p2 = i3 * u3, f2 = i3 * c3, d2 = s2 * u3, m2 = s2 * c3, y2 = a3 * c3, g2 = o3 * l3, x2 = o3 * u3, b2 = o3 * c3, v2 = n3[0], w2 = n3[1], _2 = n3[2];
              return t3[0] = (1 - (d2 + y2)) * v2, t3[1] = (p2 + b2) * v2, t3[2] = (f2 - x2) * v2, t3[3] = 0, t3[4] = (p2 - b2) * w2, t3[5] = (1 - (h2 + y2)) * w2, t3[6] = (m2 + g2) * w2, t3[7] = 0, t3[8] = (f2 + x2) * _2, t3[9] = (m2 - g2) * _2, t3[10] = (1 - (h2 + d2)) * _2, t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
            }, y.fromRotationTranslationScaleOrigin = function(t3, e3, r3, n3, i3) {
              var s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = e3[3], u3 = s2 + s2, c3 = a3 + a3, h2 = o3 + o3, p2 = s2 * u3, f2 = s2 * c3, d2 = s2 * h2, m2 = a3 * c3, y2 = a3 * h2, g2 = o3 * h2, x2 = l3 * u3, b2 = l3 * c3, v2 = l3 * h2, w2 = n3[0], _2 = n3[1], M2 = n3[2], A2 = i3[0], S2 = i3[1], I2 = i3[2], P2 = (1 - (m2 + g2)) * w2, z2 = (f2 + v2) * w2, k2 = (d2 - b2) * w2, T2 = (f2 - v2) * _2, E2 = (1 - (p2 + g2)) * _2, B2 = (y2 + x2) * _2, V2 = (d2 + b2) * M2, C2 = (y2 - x2) * M2, R2 = (1 - (p2 + m2)) * M2;
              return t3[0] = P2, t3[1] = z2, t3[2] = k2, t3[3] = 0, t3[4] = T2, t3[5] = E2, t3[6] = B2, t3[7] = 0, t3[8] = V2, t3[9] = C2, t3[10] = R2, t3[11] = 0, t3[12] = r3[0] + A2 - (P2 * A2 + T2 * S2 + V2 * I2), t3[13] = r3[1] + S2 - (z2 * A2 + E2 * S2 + C2 * I2), t3[14] = r3[2] + I2 - (k2 * A2 + B2 * S2 + R2 * I2), t3[15] = 1, t3;
            }, y.fromQuat = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = r3 + r3, o3 = n3 + n3, l3 = i3 + i3, u3 = r3 * a3, c3 = n3 * a3, h2 = n3 * o3, p2 = i3 * a3, f2 = i3 * o3, d2 = i3 * l3, m2 = s2 * a3, y2 = s2 * o3, g2 = s2 * l3;
              return t3[0] = 1 - h2 - d2, t3[1] = c3 + g2, t3[2] = p2 - y2, t3[3] = 0, t3[4] = c3 - g2, t3[5] = 1 - u3 - d2, t3[6] = f2 + m2, t3[7] = 0, t3[8] = p2 + y2, t3[9] = f2 - m2, t3[10] = 1 - u3 - h2, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
            }, y.frustum = function(t3, e3, r3, n3, i3, s2, a3) {
              var o3 = 1 / (r3 - e3), l3 = 1 / (i3 - n3), u3 = 1 / (s2 - a3);
              return t3[0] = 2 * s2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 2 * s2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = (r3 + e3) * o3, t3[9] = (i3 + n3) * l3, t3[10] = (a3 + s2) * u3, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = a3 * s2 * 2 * u3, t3[15] = 0, t3;
            }, y.perspectiveNO = l2, y.perspectiveZO = function(t3, e3, r3, n3, i3) {
              var s2, a3 = 1 / Math.tan(e3 / 2);
              return t3[0] = a3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = i3 * (s2 = 1 / (n3 - i3)), t3[14] = i3 * n3 * s2) : (t3[10] = -1, t3[14] = -n3), t3;
            }, y.perspectiveFromFieldOfView = function(t3, e3, r3, n3) {
              var i3 = Math.tan(e3.upDegrees * Math.PI / 180), s2 = Math.tan(e3.downDegrees * Math.PI / 180), a3 = Math.tan(e3.leftDegrees * Math.PI / 180), o3 = Math.tan(e3.rightDegrees * Math.PI / 180), l3 = 2 / (a3 + o3), u3 = 2 / (i3 + s2);
              return t3[0] = l3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = u3, t3[6] = 0, t3[7] = 0, t3[8] = -(a3 - o3) * l3 * 0.5, t3[9] = (i3 - s2) * u3 * 0.5, t3[10] = n3 / (r3 - n3), t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[14] = n3 * r3 / (r3 - n3), t3[15] = 0, t3;
            }, y.orthoNO = u2, y.orthoZO = function(t3, e3, r3, n3, i3, s2, a3) {
              var o3 = 1 / (e3 - r3), l3 = 1 / (n3 - i3), u3 = 1 / (s2 - a3);
              return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = u3, t3[11] = 0, t3[12] = (e3 + r3) * o3, t3[13] = (i3 + n3) * l3, t3[14] = s2 * u3, t3[15] = 1, t3;
            }, y.lookAt = function(t3, r3, i3, s2) {
              var a3, o3, l3, u3, c3, h2, p2, f2, d2, m2, y2 = r3[0], g2 = r3[1], x2 = r3[2], b2 = s2[0], v2 = s2[1], w2 = s2[2], _2 = i3[0], M2 = i3[1], A2 = i3[2];
              return Math.abs(y2 - _2) < e2.EPSILON && Math.abs(g2 - M2) < e2.EPSILON && Math.abs(x2 - A2) < e2.EPSILON ? n2(t3) : (p2 = y2 - _2, f2 = g2 - M2, d2 = x2 - A2, a3 = v2 * (d2 *= m2 = 1 / Math.hypot(p2, f2, d2)) - w2 * (f2 *= m2), o3 = w2 * (p2 *= m2) - b2 * d2, l3 = b2 * f2 - v2 * p2, (m2 = Math.hypot(a3, o3, l3)) ? (a3 *= m2 = 1 / m2, o3 *= m2, l3 *= m2) : (a3 = 0, o3 = 0, l3 = 0), u3 = f2 * l3 - d2 * o3, c3 = d2 * a3 - p2 * l3, h2 = p2 * o3 - f2 * a3, (m2 = Math.hypot(u3, c3, h2)) ? (u3 *= m2 = 1 / m2, c3 *= m2, h2 *= m2) : (u3 = 0, c3 = 0, h2 = 0), t3[0] = a3, t3[1] = u3, t3[2] = p2, t3[3] = 0, t3[4] = o3, t3[5] = c3, t3[6] = f2, t3[7] = 0, t3[8] = l3, t3[9] = h2, t3[10] = d2, t3[11] = 0, t3[12] = -(a3 * y2 + o3 * g2 + l3 * x2), t3[13] = -(u3 * y2 + c3 * g2 + h2 * x2), t3[14] = -(p2 * y2 + f2 * g2 + d2 * x2), t3[15] = 1, t3);
            }, y.targetTo = function(t3, e3, r3, n3) {
              var i3 = e3[0], s2 = e3[1], a3 = e3[2], o3 = n3[0], l3 = n3[1], u3 = n3[2], c3 = i3 - r3[0], h2 = s2 - r3[1], p2 = a3 - r3[2], f2 = c3 * c3 + h2 * h2 + p2 * p2;
              f2 > 0 && (c3 *= f2 = 1 / Math.sqrt(f2), h2 *= f2, p2 *= f2);
              var d2 = l3 * p2 - u3 * h2, m2 = u3 * c3 - o3 * p2, y2 = o3 * h2 - l3 * c3;
              return (f2 = d2 * d2 + m2 * m2 + y2 * y2) > 0 && (d2 *= f2 = 1 / Math.sqrt(f2), m2 *= f2, y2 *= f2), t3[0] = d2, t3[1] = m2, t3[2] = y2, t3[3] = 0, t3[4] = h2 * y2 - p2 * m2, t3[5] = p2 * d2 - c3 * y2, t3[6] = c3 * m2 - h2 * d2, t3[7] = 0, t3[8] = c3, t3[9] = h2, t3[10] = p2, t3[11] = 0, t3[12] = i3, t3[13] = s2, t3[14] = a3, t3[15] = 1, t3;
            }, y.str = function(t3) {
              return "mat4(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ", " + t3[8] + ", " + t3[9] + ", " + t3[10] + ", " + t3[11] + ", " + t3[12] + ", " + t3[13] + ", " + t3[14] + ", " + t3[15] + ")";
            }, y.frob = function(t3) {
              return Math.hypot(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6], t3[7], t3[8], t3[9], t3[10], t3[11], t3[12], t3[13], t3[14], t3[15]);
            }, y.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3[6] = e3[6] + r3[6], t3[7] = e3[7] + r3[7], t3[8] = e3[8] + r3[8], t3[9] = e3[9] + r3[9], t3[10] = e3[10] + r3[10], t3[11] = e3[11] + r3[11], t3[12] = e3[12] + r3[12], t3[13] = e3[13] + r3[13], t3[14] = e3[14] + r3[14], t3[15] = e3[15] + r3[15], t3;
            }, y.subtract = c2, y.multiplyScalar = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3[6] = e3[6] * r3, t3[7] = e3[7] * r3, t3[8] = e3[8] * r3, t3[9] = e3[9] * r3, t3[10] = e3[10] * r3, t3[11] = e3[11] * r3, t3[12] = e3[12] * r3, t3[13] = e3[13] * r3, t3[14] = e3[14] * r3, t3[15] = e3[15] * r3, t3;
            }, y.multiplyScalarAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3[4] = e3[4] + r3[4] * n3, t3[5] = e3[5] + r3[5] * n3, t3[6] = e3[6] + r3[6] * n3, t3[7] = e3[7] + r3[7] * n3, t3[8] = e3[8] + r3[8] * n3, t3[9] = e3[9] + r3[9] * n3, t3[10] = e3[10] + r3[10] * n3, t3[11] = e3[11] + r3[11] * n3, t3[12] = e3[12] + r3[12] * n3, t3[13] = e3[13] + r3[13] * n3, t3[14] = e3[14] + r3[14] * n3, t3[15] = e3[15] + r3[15] * n3, t3;
            }, y.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5] && t3[6] === e3[6] && t3[7] === e3[7] && t3[8] === e3[8] && t3[9] === e3[9] && t3[10] === e3[10] && t3[11] === e3[11] && t3[12] === e3[12] && t3[13] === e3[13] && t3[14] === e3[14] && t3[15] === e3[15];
            }, y.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = t3[3], o3 = t3[4], l3 = t3[5], u3 = t3[6], c3 = t3[7], h2 = t3[8], p2 = t3[9], f2 = t3[10], d2 = t3[11], m2 = t3[12], y2 = t3[13], g2 = t3[14], x2 = t3[15], b2 = r3[0], v2 = r3[1], w2 = r3[2], _2 = r3[3], M2 = r3[4], A2 = r3[5], S2 = r3[6], I2 = r3[7], P2 = r3[8], z2 = r3[9], k2 = r3[10], T2 = r3[11], E2 = r3[12], B2 = r3[13], V2 = r3[14], C2 = r3[15];
              return Math.abs(n3 - b2) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(b2)) && Math.abs(i3 - v2) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(v2)) && Math.abs(s2 - w2) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(w2)) && Math.abs(a3 - _2) <= e2.EPSILON * Math.max(1, Math.abs(a3), Math.abs(_2)) && Math.abs(o3 - M2) <= e2.EPSILON * Math.max(1, Math.abs(o3), Math.abs(M2)) && Math.abs(l3 - A2) <= e2.EPSILON * Math.max(1, Math.abs(l3), Math.abs(A2)) && Math.abs(u3 - S2) <= e2.EPSILON * Math.max(1, Math.abs(u3), Math.abs(S2)) && Math.abs(c3 - I2) <= e2.EPSILON * Math.max(1, Math.abs(c3), Math.abs(I2)) && Math.abs(h2 - P2) <= e2.EPSILON * Math.max(1, Math.abs(h2), Math.abs(P2)) && Math.abs(p2 - z2) <= e2.EPSILON * Math.max(1, Math.abs(p2), Math.abs(z2)) && Math.abs(f2 - k2) <= e2.EPSILON * Math.max(1, Math.abs(f2), Math.abs(k2)) && Math.abs(d2 - T2) <= e2.EPSILON * Math.max(1, Math.abs(d2), Math.abs(T2)) && Math.abs(m2 - E2) <= e2.EPSILON * Math.max(1, Math.abs(m2), Math.abs(E2)) && Math.abs(y2 - B2) <= e2.EPSILON * Math.max(1, Math.abs(y2), Math.abs(B2)) && Math.abs(g2 - V2) <= e2.EPSILON * Math.max(1, Math.abs(g2), Math.abs(V2)) && Math.abs(x2 - C2) <= e2.EPSILON * Math.max(1, Math.abs(x2), Math.abs(C2));
            }, y.sub = y.mul = y.ortho = y.perspective = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o3 in e3)
                if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
                  var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
                  l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2(t3) {
              return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
            }
            function i2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = e3[4], l3 = e3[5], u3 = e3[6], c3 = e3[7], h2 = e3[8], p2 = e3[9], f2 = e3[10], d2 = e3[11], m2 = e3[12], y2 = e3[13], g2 = e3[14], x2 = e3[15], b2 = r3[0], v2 = r3[1], w2 = r3[2], _2 = r3[3];
              return t3[0] = b2 * n3 + v2 * o3 + w2 * h2 + _2 * m2, t3[1] = b2 * i3 + v2 * l3 + w2 * p2 + _2 * y2, t3[2] = b2 * s2 + v2 * u3 + w2 * f2 + _2 * g2, t3[3] = b2 * a3 + v2 * c3 + w2 * d2 + _2 * x2, t3[4] = (b2 = r3[4]) * n3 + (v2 = r3[5]) * o3 + (w2 = r3[6]) * h2 + (_2 = r3[7]) * m2, t3[5] = b2 * i3 + v2 * l3 + w2 * p2 + _2 * y2, t3[6] = b2 * s2 + v2 * u3 + w2 * f2 + _2 * g2, t3[7] = b2 * a3 + v2 * c3 + w2 * d2 + _2 * x2, t3[8] = (b2 = r3[8]) * n3 + (v2 = r3[9]) * o3 + (w2 = r3[10]) * h2 + (_2 = r3[11]) * m2, t3[9] = b2 * i3 + v2 * l3 + w2 * p2 + _2 * y2, t3[10] = b2 * s2 + v2 * u3 + w2 * f2 + _2 * g2, t3[11] = b2 * a3 + v2 * c3 + w2 * d2 + _2 * x2, t3[12] = (b2 = r3[12]) * n3 + (v2 = r3[13]) * o3 + (w2 = r3[14]) * h2 + (_2 = r3[15]) * m2, t3[13] = b2 * i3 + v2 * l3 + w2 * p2 + _2 * y2, t3[14] = b2 * s2 + v2 * u3 + w2 * f2 + _2 * g2, t3[15] = b2 * a3 + v2 * c3 + w2 * d2 + _2 * x2, t3;
            }
            function a2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = n3 + n3, l3 = i3 + i3, u3 = s2 + s2, c3 = n3 * o3, h2 = n3 * l3, p2 = n3 * u3, f2 = i3 * l3, d2 = i3 * u3, m2 = s2 * u3, y2 = a3 * o3, g2 = a3 * l3, x2 = a3 * u3;
              return t3[0] = 1 - (f2 + m2), t3[1] = h2 + x2, t3[2] = p2 - g2, t3[3] = 0, t3[4] = h2 - x2, t3[5] = 1 - (c3 + m2), t3[6] = d2 + y2, t3[7] = 0, t3[8] = p2 + g2, t3[9] = d2 - y2, t3[10] = 1 - (c3 + f2), t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
            }
            function o2(t3, e3) {
              var r3 = e3[4], n3 = e3[5], i3 = e3[6], s2 = e3[8], a3 = e3[9], o3 = e3[10];
              return t3[0] = Math.hypot(e3[0], e3[1], e3[2]), t3[1] = Math.hypot(r3, n3, i3), t3[2] = Math.hypot(s2, a3, o3), t3;
            }
            function l2(t3, e3, r3, n3, i3) {
              var s2, a3 = 1 / Math.tan(e3 / 2);
              return t3[0] = a3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (s2 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * s2) : (t3[10] = -1, t3[14] = -2 * n3), t3;
            }
            function u2(t3, e3, r3, n3, i3, s2, a3) {
              var o3 = 1 / (e3 - r3), l3 = 1 / (n3 - i3), u3 = 1 / (s2 - a3);
              return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e3 + r3) * o3, t3[13] = (i3 + n3) * l3, t3[14] = (a3 + s2) * u3, t3[15] = 1, t3;
            }
            function c2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3[4] = e3[4] - r3[4], t3[5] = e3[5] - r3[5], t3[6] = e3[6] - r3[6], t3[7] = e3[7] - r3[7], t3[8] = e3[8] - r3[8], t3[9] = e3[9] - r3[9], t3[10] = e3[10] - r3[10], t3[11] = e3[11] - r3[11], t3[12] = e3[12] - r3[12], t3[13] = e3[13] - r3[13], t3[14] = e3[14] - r3[14], t3[15] = e3[15] - r3[15], t3;
            }
            return y.perspective = l2, y.ortho = u2, y.mul = i2, y.sub = c2, y;
          }
          var x, b = {}, v = {};
          function w() {
            if (x)
              return v;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            x = 1, Object.defineProperty(v, "__esModule", { value: true }), v.create = n2, v.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(3);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3;
            }, v.length = i2, v.fromValues = function(t3, r3, n3) {
              var i3 = new e2.ARRAY_TYPE(3);
              return i3[0] = t3, i3[1] = r3, i3[2] = n3, i3;
            }, v.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3;
            }, v.set = function(t3, e3, r3, n3) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3;
            }, v.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3;
            }, v.subtract = a2, v.multiply = o2, v.divide = l2, v.ceil = function(t3, e3) {
              return t3[0] = Math.ceil(e3[0]), t3[1] = Math.ceil(e3[1]), t3[2] = Math.ceil(e3[2]), t3;
            }, v.floor = function(t3, e3) {
              return t3[0] = Math.floor(e3[0]), t3[1] = Math.floor(e3[1]), t3[2] = Math.floor(e3[2]), t3;
            }, v.min = function(t3, e3, r3) {
              return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3[2] = Math.min(e3[2], r3[2]), t3;
            }, v.max = function(t3, e3, r3) {
              return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3[2] = Math.max(e3[2], r3[2]), t3;
            }, v.round = function(t3, e3) {
              return t3[0] = Math.round(e3[0]), t3[1] = Math.round(e3[1]), t3[2] = Math.round(e3[2]), t3;
            }, v.scale = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3;
            }, v.scaleAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3;
            }, v.distance = u2, v.squaredDistance = c2, v.squaredLength = h2, v.negate = function(t3, e3) {
              return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3;
            }, v.inverse = function(t3, e3) {
              return t3[0] = 1 / e3[0], t3[1] = 1 / e3[1], t3[2] = 1 / e3[2], t3;
            }, v.normalize = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = r3 * r3 + n3 * n3 + i3 * i3;
              return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t3[0] = e3[0] * s2, t3[1] = e3[1] * s2, t3[2] = e3[2] * s2, t3;
            }, v.dot = p2, v.cross = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2];
              return t3[0] = i3 * l3 - s2 * o3, t3[1] = s2 * a3 - n3 * l3, t3[2] = n3 * o3 - i3 * a3, t3;
            }, v.lerp = function(t3, e3, r3, n3) {
              var i3 = e3[0], s2 = e3[1], a3 = e3[2];
              return t3[0] = i3 + n3 * (r3[0] - i3), t3[1] = s2 + n3 * (r3[1] - s2), t3[2] = a3 + n3 * (r3[2] - a3), t3;
            }, v.hermite = function(t3, e3, r3, n3, i3, s2) {
              var a3 = s2 * s2, o3 = a3 * (2 * s2 - 3) + 1, l3 = a3 * (s2 - 2) + s2, u3 = a3 * (s2 - 1), c3 = a3 * (3 - 2 * s2);
              return t3[0] = e3[0] * o3 + r3[0] * l3 + n3[0] * u3 + i3[0] * c3, t3[1] = e3[1] * o3 + r3[1] * l3 + n3[1] * u3 + i3[1] * c3, t3[2] = e3[2] * o3 + r3[2] * l3 + n3[2] * u3 + i3[2] * c3, t3;
            }, v.bezier = function(t3, e3, r3, n3, i3, s2) {
              var a3 = 1 - s2, o3 = a3 * a3, l3 = s2 * s2, u3 = o3 * a3, c3 = 3 * s2 * o3, h3 = 3 * l3 * a3, p3 = l3 * s2;
              return t3[0] = e3[0] * u3 + r3[0] * c3 + n3[0] * h3 + i3[0] * p3, t3[1] = e3[1] * u3 + r3[1] * c3 + n3[1] * h3 + i3[1] * p3, t3[2] = e3[2] * u3 + r3[2] * c3 + n3[2] * h3 + i3[2] * p3, t3;
            }, v.random = function(t3, r3) {
              r3 = r3 || 1;
              var n3 = 2 * e2.RANDOM() * Math.PI, i3 = 2 * e2.RANDOM() - 1, s2 = Math.sqrt(1 - i3 * i3) * r3;
              return t3[0] = Math.cos(n3) * s2, t3[1] = Math.sin(n3) * s2, t3[2] = i3 * r3, t3;
            }, v.transformMat4 = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = r3[3] * n3 + r3[7] * i3 + r3[11] * s2 + r3[15];
              return t3[0] = (r3[0] * n3 + r3[4] * i3 + r3[8] * s2 + r3[12]) / (a3 = a3 || 1), t3[1] = (r3[1] * n3 + r3[5] * i3 + r3[9] * s2 + r3[13]) / a3, t3[2] = (r3[2] * n3 + r3[6] * i3 + r3[10] * s2 + r3[14]) / a3, t3;
            }, v.transformMat3 = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2];
              return t3[0] = n3 * r3[0] + i3 * r3[3] + s2 * r3[6], t3[1] = n3 * r3[1] + i3 * r3[4] + s2 * r3[7], t3[2] = n3 * r3[2] + i3 * r3[5] + s2 * r3[8], t3;
            }, v.transformQuat = function(t3, e3, r3) {
              var n3 = r3[0], i3 = r3[1], s2 = r3[2], a3 = e3[0], o3 = e3[1], l3 = e3[2], u3 = i3 * l3 - s2 * o3, c3 = s2 * a3 - n3 * l3, h3 = n3 * o3 - i3 * a3, p3 = i3 * h3 - s2 * c3, f3 = s2 * u3 - n3 * h3, d3 = n3 * c3 - i3 * u3, m2 = 2 * r3[3];
              return c3 *= m2, h3 *= m2, f3 *= 2, d3 *= 2, t3[0] = a3 + (u3 *= m2) + (p3 *= 2), t3[1] = o3 + c3 + f3, t3[2] = l3 + h3 + d3, t3;
            }, v.rotateX = function(t3, e3, r3, n3) {
              var i3 = [], s2 = [];
              return i3[0] = e3[0] - r3[0], i3[1] = e3[1] - r3[1], i3[2] = e3[2] - r3[2], s2[0] = i3[0], s2[1] = i3[1] * Math.cos(n3) - i3[2] * Math.sin(n3), s2[2] = i3[1] * Math.sin(n3) + i3[2] * Math.cos(n3), t3[0] = s2[0] + r3[0], t3[1] = s2[1] + r3[1], t3[2] = s2[2] + r3[2], t3;
            }, v.rotateY = function(t3, e3, r3, n3) {
              var i3 = [], s2 = [];
              return i3[0] = e3[0] - r3[0], i3[1] = e3[1] - r3[1], i3[2] = e3[2] - r3[2], s2[0] = i3[2] * Math.sin(n3) + i3[0] * Math.cos(n3), s2[1] = i3[1], s2[2] = i3[2] * Math.cos(n3) - i3[0] * Math.sin(n3), t3[0] = s2[0] + r3[0], t3[1] = s2[1] + r3[1], t3[2] = s2[2] + r3[2], t3;
            }, v.rotateZ = function(t3, e3, r3, n3) {
              var i3 = [], s2 = [];
              return i3[0] = e3[0] - r3[0], i3[1] = e3[1] - r3[1], i3[2] = e3[2] - r3[2], s2[0] = i3[0] * Math.cos(n3) - i3[1] * Math.sin(n3), s2[1] = i3[0] * Math.sin(n3) + i3[1] * Math.cos(n3), s2[2] = i3[2], t3[0] = s2[0] + r3[0], t3[1] = s2[1] + r3[1], t3[2] = s2[2] + r3[2], t3;
            }, v.angle = function(t3, e3) {
              var r3 = t3[0], n3 = t3[1], i3 = t3[2], s2 = e3[0], a3 = e3[1], o3 = e3[2], l3 = Math.sqrt(r3 * r3 + n3 * n3 + i3 * i3) * Math.sqrt(s2 * s2 + a3 * a3 + o3 * o3), u3 = l3 && p2(t3, e3) / l3;
              return Math.acos(Math.min(Math.max(u3, -1), 1));
            }, v.zero = function(t3) {
              return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3;
            }, v.str = function(t3) {
              return "vec3(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ")";
            }, v.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2];
            }, v.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2];
              return Math.abs(n3 - a3) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(a3)) && Math.abs(i3 - o3) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(o3)) && Math.abs(s2 - l3) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(l3));
            }, v.forEach = v.sqrLen = v.len = v.sqrDist = v.dist = v.div = v.mul = v.sub = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o3 in e3)
                if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
                  var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
                  l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2() {
              var t3 = new e2.ARRAY_TYPE(3);
              return e2.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3;
            }
            function i2(t3) {
              return Math.hypot(t3[0], t3[1], t3[2]);
            }
            function a2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3;
            }
            function o2(t3, e3, r3) {
              return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3[2] = e3[2] * r3[2], t3;
            }
            function l2(t3, e3, r3) {
              return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3[2] = e3[2] / r3[2], t3;
            }
            function u2(t3, e3) {
              return Math.hypot(e3[0] - t3[0], e3[1] - t3[1], e3[2] - t3[2]);
            }
            function c2(t3, e3) {
              var r3 = e3[0] - t3[0], n3 = e3[1] - t3[1], i3 = e3[2] - t3[2];
              return r3 * r3 + n3 * n3 + i3 * i3;
            }
            function h2(t3) {
              var e3 = t3[0], r3 = t3[1], n3 = t3[2];
              return e3 * e3 + r3 * r3 + n3 * n3;
            }
            function p2(t3, e3) {
              return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2];
            }
            v.sub = a2, v.mul = o2, v.div = l2, v.dist = u2, v.sqrDist = c2, v.len = i2, v.sqrLen = h2;
            var f2, d2 = (f2 = n2(), function(t3, e3, r3, n3, i3, s2) {
              var a3, o3;
              for (e3 || (e3 = 3), r3 || (r3 = 0), o3 = n3 ? Math.min(n3 * e3 + r3, t3.length) : t3.length, a3 = r3; a3 < o3; a3 += e3)
                f2[0] = t3[a3], f2[1] = t3[a3 + 1], f2[2] = t3[a3 + 2], i3(f2, f2, s2), t3[a3] = f2[0], t3[a3 + 1] = f2[1], t3[a3 + 2] = f2[2];
              return t3;
            });
            return v.forEach = d2, v;
          }
          var _, M, A = {};
          function S() {
            if (_)
              return A;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            _ = 1, Object.defineProperty(A, "__esModule", { value: true }), A.create = n2, A.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(4);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3;
            }, A.fromValues = function(t3, r3, n3, i3) {
              var s2 = new e2.ARRAY_TYPE(4);
              return s2[0] = t3, s2[1] = r3, s2[2] = n3, s2[3] = i3, s2;
            }, A.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3;
            }, A.set = function(t3, e3, r3, n3, i3) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3;
            }, A.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3;
            }, A.subtract = i2, A.multiply = a2, A.divide = o2, A.ceil = function(t3, e3) {
              return t3[0] = Math.ceil(e3[0]), t3[1] = Math.ceil(e3[1]), t3[2] = Math.ceil(e3[2]), t3[3] = Math.ceil(e3[3]), t3;
            }, A.floor = function(t3, e3) {
              return t3[0] = Math.floor(e3[0]), t3[1] = Math.floor(e3[1]), t3[2] = Math.floor(e3[2]), t3[3] = Math.floor(e3[3]), t3;
            }, A.min = function(t3, e3, r3) {
              return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3[2] = Math.min(e3[2], r3[2]), t3[3] = Math.min(e3[3], r3[3]), t3;
            }, A.max = function(t3, e3, r3) {
              return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3[2] = Math.max(e3[2], r3[2]), t3[3] = Math.max(e3[3], r3[3]), t3;
            }, A.round = function(t3, e3) {
              return t3[0] = Math.round(e3[0]), t3[1] = Math.round(e3[1]), t3[2] = Math.round(e3[2]), t3[3] = Math.round(e3[3]), t3;
            }, A.scale = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3;
            }, A.scaleAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3[3] = e3[3] + r3[3] * n3, t3;
            }, A.distance = l2, A.squaredDistance = u2, A.length = c2, A.squaredLength = h2, A.negate = function(t3, e3) {
              return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = -e3[3], t3;
            }, A.inverse = function(t3, e3) {
              return t3[0] = 1 / e3[0], t3[1] = 1 / e3[1], t3[2] = 1 / e3[2], t3[3] = 1 / e3[3], t3;
            }, A.normalize = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2;
              return a3 > 0 && (a3 = 1 / Math.sqrt(a3)), t3[0] = r3 * a3, t3[1] = n3 * a3, t3[2] = i3 * a3, t3[3] = s2 * a3, t3;
            }, A.dot = function(t3, e3) {
              return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2] + t3[3] * e3[3];
            }, A.cross = function(t3, e3, r3, n3) {
              var i3 = r3[0] * n3[1] - r3[1] * n3[0], s2 = r3[0] * n3[2] - r3[2] * n3[0], a3 = r3[0] * n3[3] - r3[3] * n3[0], o3 = r3[1] * n3[2] - r3[2] * n3[1], l3 = r3[1] * n3[3] - r3[3] * n3[1], u3 = r3[2] * n3[3] - r3[3] * n3[2], c3 = e3[0], h3 = e3[1], p3 = e3[2], f3 = e3[3];
              return t3[0] = h3 * u3 - p3 * l3 + f3 * o3, t3[1] = -c3 * u3 + p3 * a3 - f3 * s2, t3[2] = c3 * l3 - h3 * a3 + f3 * i3, t3[3] = -c3 * o3 + h3 * s2 - p3 * i3, t3;
            }, A.lerp = function(t3, e3, r3, n3) {
              var i3 = e3[0], s2 = e3[1], a3 = e3[2], o3 = e3[3];
              return t3[0] = i3 + n3 * (r3[0] - i3), t3[1] = s2 + n3 * (r3[1] - s2), t3[2] = a3 + n3 * (r3[2] - a3), t3[3] = o3 + n3 * (r3[3] - o3), t3;
            }, A.random = function(t3, r3) {
              var n3, i3, s2, a3, o3, l3;
              r3 = r3 || 1;
              do {
                o3 = (n3 = 2 * e2.RANDOM() - 1) * n3 + (i3 = 2 * e2.RANDOM() - 1) * i3;
              } while (o3 >= 1);
              do {
                l3 = (s2 = 2 * e2.RANDOM() - 1) * s2 + (a3 = 2 * e2.RANDOM() - 1) * a3;
              } while (l3 >= 1);
              var u3 = Math.sqrt((1 - o3) / l3);
              return t3[0] = r3 * n3, t3[1] = r3 * i3, t3[2] = r3 * s2 * u3, t3[3] = r3 * a3 * u3, t3;
            }, A.transformMat4 = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3];
              return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[8] * s2 + r3[12] * a3, t3[1] = r3[1] * n3 + r3[5] * i3 + r3[9] * s2 + r3[13] * a3, t3[2] = r3[2] * n3 + r3[6] * i3 + r3[10] * s2 + r3[14] * a3, t3[3] = r3[3] * n3 + r3[7] * i3 + r3[11] * s2 + r3[15] * a3, t3;
            }, A.transformQuat = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = r3[0], o3 = r3[1], l3 = r3[2], u3 = r3[3], c3 = u3 * n3 + o3 * s2 - l3 * i3, h3 = u3 * i3 + l3 * n3 - a3 * s2, p3 = u3 * s2 + a3 * i3 - o3 * n3, f3 = -a3 * n3 - o3 * i3 - l3 * s2;
              return t3[0] = c3 * u3 + f3 * -a3 + h3 * -l3 - p3 * -o3, t3[1] = h3 * u3 + f3 * -o3 + p3 * -a3 - c3 * -l3, t3[2] = p3 * u3 + f3 * -l3 + c3 * -o3 - h3 * -a3, t3[3] = e3[3], t3;
            }, A.zero = function(t3) {
              return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3;
            }, A.str = function(t3) {
              return "vec4(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
            }, A.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
            }, A.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = t3[3], o3 = r3[0], l3 = r3[1], u3 = r3[2], c3 = r3[3];
              return Math.abs(n3 - o3) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i3 - l3) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(l3)) && Math.abs(s2 - u3) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(u3)) && Math.abs(a3 - c3) <= e2.EPSILON * Math.max(1, Math.abs(a3), Math.abs(c3));
            }, A.forEach = A.sqrLen = A.len = A.sqrDist = A.dist = A.div = A.mul = A.sub = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o3 in e3)
                if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
                  var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
                  l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2() {
              var t3 = new e2.ARRAY_TYPE(4);
              return e2.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0), t3;
            }
            function i2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3[3] = e3[3] - r3[3], t3;
            }
            function a2(t3, e3, r3) {
              return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3[2] = e3[2] * r3[2], t3[3] = e3[3] * r3[3], t3;
            }
            function o2(t3, e3, r3) {
              return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3[2] = e3[2] / r3[2], t3[3] = e3[3] / r3[3], t3;
            }
            function l2(t3, e3) {
              return Math.hypot(e3[0] - t3[0], e3[1] - t3[1], e3[2] - t3[2], e3[3] - t3[3]);
            }
            function u2(t3, e3) {
              var r3 = e3[0] - t3[0], n3 = e3[1] - t3[1], i3 = e3[2] - t3[2], s2 = e3[3] - t3[3];
              return r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2;
            }
            function c2(t3) {
              return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
            }
            function h2(t3) {
              var e3 = t3[0], r3 = t3[1], n3 = t3[2], i3 = t3[3];
              return e3 * e3 + r3 * r3 + n3 * n3 + i3 * i3;
            }
            A.sub = i2, A.mul = a2, A.div = o2, A.dist = l2, A.sqrDist = u2, A.len = c2, A.sqrLen = h2;
            var p2, f2 = (p2 = n2(), function(t3, e3, r3, n3, i3, s2) {
              var a3, o3;
              for (e3 || (e3 = 4), r3 || (r3 = 0), o3 = n3 ? Math.min(n3 * e3 + r3, t3.length) : t3.length, a3 = r3; a3 < o3; a3 += e3)
                p2[0] = t3[a3], p2[1] = t3[a3 + 1], p2[2] = t3[a3 + 2], p2[3] = t3[a3 + 3], i3(p2, p2, s2), t3[a3] = p2[0], t3[a3 + 1] = p2[1], t3[a3 + 2] = p2[2], t3[a3 + 3] = p2[3];
              return t3;
            });
            return A.forEach = f2, A;
          }
          function I() {
            if (M)
              return b;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            M = 1, Object.defineProperty(b, "__esModule", { value: true }), b.create = l2, b.identity = function(t3) {
              return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
            }, b.setAxisAngle = u2, b.getAxisAngle = function(t3, r3) {
              var n3 = 2 * Math.acos(r3[3]), i3 = Math.sin(n3 / 2);
              return i3 > e2.EPSILON ? (t3[0] = r3[0] / i3, t3[1] = r3[1] / i3, t3[2] = r3[2] / i3) : (t3[0] = 1, t3[1] = 0, t3[2] = 0), n3;
            }, b.getAngle = function(t3, e3) {
              var r3 = g2(t3, e3);
              return Math.acos(2 * r3 * r3 - 1);
            }, b.multiply = c2, b.rotateX = function(t3, e3, r3) {
              r3 *= 0.5;
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l3 = Math.cos(r3);
              return t3[0] = n3 * l3 + a3 * o3, t3[1] = i3 * l3 + s2 * o3, t3[2] = s2 * l3 - i3 * o3, t3[3] = a3 * l3 - n3 * o3, t3;
            }, b.rotateY = function(t3, e3, r3) {
              r3 *= 0.5;
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l3 = Math.cos(r3);
              return t3[0] = n3 * l3 - s2 * o3, t3[1] = i3 * l3 + a3 * o3, t3[2] = s2 * l3 + n3 * o3, t3[3] = a3 * l3 - i3 * o3, t3;
            }, b.rotateZ = function(t3, e3, r3) {
              r3 *= 0.5;
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l3 = Math.cos(r3);
              return t3[0] = n3 * l3 + i3 * o3, t3[1] = i3 * l3 - n3 * o3, t3[2] = s2 * l3 + a3 * o3, t3[3] = a3 * l3 - s2 * o3, t3;
            }, b.calculateW = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2];
              return t3[0] = r3, t3[1] = n3, t3[2] = i3, t3[3] = Math.sqrt(Math.abs(1 - r3 * r3 - n3 * n3 - i3 * i3)), t3;
            }, b.exp = h2, b.ln = p2, b.pow = function(t3, e3, r3) {
              return p2(t3, e3), y2(t3, t3, r3), h2(t3, t3), t3;
            }, b.slerp = f2, b.random = function(t3) {
              var r3 = e2.RANDOM(), n3 = e2.RANDOM(), i3 = e2.RANDOM(), s2 = Math.sqrt(1 - r3), a3 = Math.sqrt(r3);
              return t3[0] = s2 * Math.sin(2 * Math.PI * n3), t3[1] = s2 * Math.cos(2 * Math.PI * n3), t3[2] = a3 * Math.sin(2 * Math.PI * i3), t3[3] = a3 * Math.cos(2 * Math.PI * i3), t3;
            }, b.invert = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2, o3 = a3 ? 1 / a3 : 0;
              return t3[0] = -r3 * o3, t3[1] = -n3 * o3, t3[2] = -i3 * o3, t3[3] = s2 * o3, t3;
            }, b.conjugate = function(t3, e3) {
              return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = e3[3], t3;
            }, b.fromMat3 = m2, b.fromEuler = function(t3, e3, r3, n3) {
              var i3 = 0.5 * Math.PI / 180;
              e3 *= i3, r3 *= i3, n3 *= i3;
              var s2 = Math.sin(e3), a3 = Math.cos(e3), o3 = Math.sin(r3), l3 = Math.cos(r3), u3 = Math.sin(n3), c3 = Math.cos(n3);
              return t3[0] = s2 * l3 * c3 - a3 * o3 * u3, t3[1] = a3 * o3 * c3 + s2 * l3 * u3, t3[2] = a3 * l3 * u3 - s2 * o3 * c3, t3[3] = a3 * l3 * c3 + s2 * o3 * u3, t3;
            }, b.str = function(t3) {
              return "quat(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ")";
            }, b.setAxes = b.sqlerp = b.rotationTo = b.equals = b.exactEquals = b.normalize = b.sqrLen = b.squaredLength = b.len = b.length = b.lerp = b.dot = b.scale = b.mul = b.add = b.set = b.copy = b.fromValues = b.clone = void 0;
            var e2 = o2(s()), r2 = o2(d()), n2 = o2(w()), i2 = o2(S());
            function a2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
              return (a2 = function(t4) {
                return t4 ? r3 : e3;
              })(t3);
            }
            function o2(e3, r3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var n3 = a2(r3);
              if (n3 && n3.has(e3))
                return n3.get(e3);
              var i3 = {}, s2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o3 in e3)
                if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
                  var l3 = s2 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
                  l3 && (l3.get || l3.set) ? Object.defineProperty(i3, o3, l3) : i3[o3] = e3[o3];
                }
              return i3.default = e3, n3 && n3.set(e3, i3), i3;
            }
            function l2() {
              var t3 = new e2.ARRAY_TYPE(4);
              return e2.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3[3] = 1, t3;
            }
            function u2(t3, e3, r3) {
              r3 *= 0.5;
              var n3 = Math.sin(r3);
              return t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = Math.cos(r3), t3;
            }
            function c2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = r3[0], l3 = r3[1], u3 = r3[2], c3 = r3[3];
              return t3[0] = n3 * c3 + a3 * o3 + i3 * u3 - s2 * l3, t3[1] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3, t3[2] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[3] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3, t3;
            }
            function h2(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = Math.sqrt(r3 * r3 + n3 * n3 + i3 * i3), o3 = Math.exp(s2), l3 = a3 > 0 ? o3 * Math.sin(a3) / a3 : 0;
              return t3[0] = r3 * l3, t3[1] = n3 * l3, t3[2] = i3 * l3, t3[3] = o3 * Math.cos(a3), t3;
            }
            function p2(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = e3[2], s2 = e3[3], a3 = Math.sqrt(r3 * r3 + n3 * n3 + i3 * i3), o3 = a3 > 0 ? Math.atan2(a3, s2) / a3 : 0;
              return t3[0] = r3 * o3, t3[1] = n3 * o3, t3[2] = i3 * o3, t3[3] = 0.5 * Math.log(r3 * r3 + n3 * n3 + i3 * i3 + s2 * s2), t3;
            }
            function f2(t3, r3, n3, i3) {
              var s2, a3, o3, l3, u3, c3 = r3[0], h3 = r3[1], p3 = r3[2], f3 = r3[3], d2 = n3[0], m3 = n3[1], y3 = n3[2], g3 = n3[3];
              return (a3 = c3 * d2 + h3 * m3 + p3 * y3 + f3 * g3) < 0 && (a3 = -a3, d2 = -d2, m3 = -m3, y3 = -y3, g3 = -g3), 1 - a3 > e2.EPSILON ? (s2 = Math.acos(a3), o3 = Math.sin(s2), l3 = Math.sin((1 - i3) * s2) / o3, u3 = Math.sin(i3 * s2) / o3) : (l3 = 1 - i3, u3 = i3), t3[0] = l3 * c3 + u3 * d2, t3[1] = l3 * h3 + u3 * m3, t3[2] = l3 * p3 + u3 * y3, t3[3] = l3 * f3 + u3 * g3, t3;
            }
            function m2(t3, e3) {
              var r3, n3 = e3[0] + e3[4] + e3[8];
              if (n3 > 0)
                r3 = Math.sqrt(n3 + 1), t3[3] = 0.5 * r3, t3[0] = (e3[5] - e3[7]) * (r3 = 0.5 / r3), t3[1] = (e3[6] - e3[2]) * r3, t3[2] = (e3[1] - e3[3]) * r3;
              else {
                var i3 = 0;
                e3[4] > e3[0] && (i3 = 1), e3[8] > e3[3 * i3 + i3] && (i3 = 2);
                var s2 = (i3 + 1) % 3, a3 = (i3 + 2) % 3;
                r3 = Math.sqrt(e3[3 * i3 + i3] - e3[3 * s2 + s2] - e3[3 * a3 + a3] + 1), t3[i3] = 0.5 * r3, t3[3] = (e3[3 * s2 + a3] - e3[3 * a3 + s2]) * (r3 = 0.5 / r3), t3[s2] = (e3[3 * s2 + i3] + e3[3 * i3 + s2]) * r3, t3[a3] = (e3[3 * a3 + i3] + e3[3 * i3 + a3]) * r3;
              }
              return t3;
            }
            b.clone = i2.clone, b.fromValues = i2.fromValues, b.copy = i2.copy, b.set = i2.set, b.add = i2.add, b.mul = c2;
            var y2 = i2.scale;
            b.scale = y2;
            var g2 = i2.dot;
            b.dot = g2, b.lerp = i2.lerp;
            var x2 = i2.length;
            b.length = x2, b.len = x2;
            var v2 = i2.squaredLength;
            b.squaredLength = v2, b.sqrLen = v2;
            var _2 = i2.normalize;
            b.normalize = _2, b.exactEquals = i2.exactEquals, b.equals = i2.equals;
            var A2, I2, P2, z2 = (A2 = n2.create(), I2 = n2.fromValues(1, 0, 0), P2 = n2.fromValues(0, 1, 0), function(t3, e3, r3) {
              var i3 = n2.dot(e3, r3);
              return i3 < -0.999999 ? (n2.cross(A2, I2, e3), n2.len(A2) < 1e-6 && n2.cross(A2, P2, e3), n2.normalize(A2, A2), u2(t3, A2, Math.PI), t3) : i3 > 0.999999 ? (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3) : (n2.cross(A2, e3, r3), t3[0] = A2[0], t3[1] = A2[1], t3[2] = A2[2], t3[3] = 1 + i3, _2(t3, t3));
            });
            b.rotationTo = z2;
            var k2, T2, E2 = (k2 = l2(), T2 = l2(), function(t3, e3, r3, n3, i3, s2) {
              return f2(k2, e3, i3, s2), f2(T2, r3, n3, s2), f2(t3, k2, T2, 2 * s2 * (1 - s2)), t3;
            });
            b.sqlerp = E2;
            var B2, V2 = (B2 = r2.create(), function(t3, e3, r3, n3) {
              return B2[0] = r3[0], B2[3] = r3[1], B2[6] = r3[2], B2[1] = n3[0], B2[4] = n3[1], B2[7] = n3[2], B2[2] = -e3[0], B2[5] = -e3[1], B2[8] = -e3[2], _2(t3, m2(t3, B2));
            });
            return b.setAxes = V2, b;
          }
          var P, z = {};
          function k() {
            if (P)
              return z;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            P = 1, Object.defineProperty(z, "__esModule", { value: true }), z.create = function() {
              var t3 = new e2.ARRAY_TYPE(8);
              return e2.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[3] = 1, t3;
            }, z.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(8);
              return r3[0] = t3[0], r3[1] = t3[1], r3[2] = t3[2], r3[3] = t3[3], r3[4] = t3[4], r3[5] = t3[5], r3[6] = t3[6], r3[7] = t3[7], r3;
            }, z.fromValues = function(t3, r3, n3, i3, s2, a3, o3, l3) {
              var u3 = new e2.ARRAY_TYPE(8);
              return u3[0] = t3, u3[1] = r3, u3[2] = n3, u3[3] = i3, u3[4] = s2, u3[5] = a3, u3[6] = o3, u3[7] = l3, u3;
            }, z.fromRotationTranslationValues = function(t3, r3, n3, i3, s2, a3, o3) {
              var l3 = new e2.ARRAY_TYPE(8);
              l3[0] = t3, l3[1] = r3, l3[2] = n3, l3[3] = i3;
              var u3 = 0.5 * s2, c3 = 0.5 * a3, h3 = 0.5 * o3;
              return l3[4] = u3 * i3 + c3 * n3 - h3 * r3, l3[5] = c3 * i3 + h3 * t3 - u3 * n3, l3[6] = h3 * i3 + u3 * r3 - c3 * t3, l3[7] = -u3 * t3 - c3 * r3 - h3 * n3, l3;
            }, z.fromRotationTranslation = o2, z.fromTranslation = function(t3, e3) {
              return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0.5 * e3[0], t3[5] = 0.5 * e3[1], t3[6] = 0.5 * e3[2], t3[7] = 0, t3;
            }, z.fromRotation = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3;
            }, z.fromMat4 = function(t3, i3) {
              var s2 = r2.create();
              n2.getRotation(s2, i3);
              var a3 = new e2.ARRAY_TYPE(3);
              return n2.getTranslation(a3, i3), o2(t3, s2, a3), t3;
            }, z.copy = l2, z.identity = function(t3) {
              return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3[4] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3;
            }, z.set = function(t3, e3, r3, n3, i3, s2, a3, o3, l3) {
              return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3[3] = i3, t3[4] = s2, t3[5] = a3, t3[6] = o3, t3[7] = l3, t3;
            }, z.getDual = function(t3, e3) {
              return t3[0] = e3[4], t3[1] = e3[5], t3[2] = e3[6], t3[3] = e3[7], t3;
            }, z.setDual = function(t3, e3) {
              return t3[4] = e3[0], t3[5] = e3[1], t3[6] = e3[2], t3[7] = e3[3], t3;
            }, z.getTranslation = function(t3, e3) {
              var r3 = e3[4], n3 = e3[5], i3 = e3[6], s2 = e3[7], a3 = -e3[0], o3 = -e3[1], l3 = -e3[2], u3 = e3[3];
              return t3[0] = 2 * (r3 * u3 + s2 * a3 + n3 * l3 - i3 * o3), t3[1] = 2 * (n3 * u3 + s2 * o3 + i3 * a3 - r3 * l3), t3[2] = 2 * (i3 * u3 + s2 * l3 + r3 * o3 - n3 * a3), t3;
            }, z.translate = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = 0.5 * r3[0], l3 = 0.5 * r3[1], u3 = 0.5 * r3[2], c3 = e3[4], h3 = e3[5], p3 = e3[6], f2 = e3[7];
              return t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a3, t3[4] = a3 * o3 + i3 * u3 - s2 * l3 + c3, t3[5] = a3 * l3 + s2 * o3 - n3 * u3 + h3, t3[6] = a3 * u3 + n3 * l3 - i3 * o3 + p3, t3[7] = -n3 * o3 - i3 * l3 - s2 * u3 + f2, t3;
            }, z.rotateX = function(t3, e3, n3) {
              var i3 = -e3[0], s2 = -e3[1], a3 = -e3[2], o3 = e3[3], l3 = e3[4], u3 = e3[5], c3 = e3[6], h3 = e3[7], p3 = l3 * o3 + h3 * i3 + u3 * a3 - c3 * s2, f2 = u3 * o3 + h3 * s2 + c3 * i3 - l3 * a3, d2 = c3 * o3 + h3 * a3 + l3 * s2 - u3 * i3, m2 = h3 * o3 - l3 * i3 - u3 * s2 - c3 * a3;
              return r2.rotateX(t3, e3, n3), t3[4] = p3 * (o3 = t3[3]) + m2 * (i3 = t3[0]) + f2 * (a3 = t3[2]) - d2 * (s2 = t3[1]), t3[5] = f2 * o3 + m2 * s2 + d2 * i3 - p3 * a3, t3[6] = d2 * o3 + m2 * a3 + p3 * s2 - f2 * i3, t3[7] = m2 * o3 - p3 * i3 - f2 * s2 - d2 * a3, t3;
            }, z.rotateY = function(t3, e3, n3) {
              var i3 = -e3[0], s2 = -e3[1], a3 = -e3[2], o3 = e3[3], l3 = e3[4], u3 = e3[5], c3 = e3[6], h3 = e3[7], p3 = l3 * o3 + h3 * i3 + u3 * a3 - c3 * s2, f2 = u3 * o3 + h3 * s2 + c3 * i3 - l3 * a3, d2 = c3 * o3 + h3 * a3 + l3 * s2 - u3 * i3, m2 = h3 * o3 - l3 * i3 - u3 * s2 - c3 * a3;
              return r2.rotateY(t3, e3, n3), t3[4] = p3 * (o3 = t3[3]) + m2 * (i3 = t3[0]) + f2 * (a3 = t3[2]) - d2 * (s2 = t3[1]), t3[5] = f2 * o3 + m2 * s2 + d2 * i3 - p3 * a3, t3[6] = d2 * o3 + m2 * a3 + p3 * s2 - f2 * i3, t3[7] = m2 * o3 - p3 * i3 - f2 * s2 - d2 * a3, t3;
            }, z.rotateZ = function(t3, e3, n3) {
              var i3 = -e3[0], s2 = -e3[1], a3 = -e3[2], o3 = e3[3], l3 = e3[4], u3 = e3[5], c3 = e3[6], h3 = e3[7], p3 = l3 * o3 + h3 * i3 + u3 * a3 - c3 * s2, f2 = u3 * o3 + h3 * s2 + c3 * i3 - l3 * a3, d2 = c3 * o3 + h3 * a3 + l3 * s2 - u3 * i3, m2 = h3 * o3 - l3 * i3 - u3 * s2 - c3 * a3;
              return r2.rotateZ(t3, e3, n3), t3[4] = p3 * (o3 = t3[3]) + m2 * (i3 = t3[0]) + f2 * (a3 = t3[2]) - d2 * (s2 = t3[1]), t3[5] = f2 * o3 + m2 * s2 + d2 * i3 - p3 * a3, t3[6] = d2 * o3 + m2 * a3 + p3 * s2 - f2 * i3, t3[7] = m2 * o3 - p3 * i3 - f2 * s2 - d2 * a3, t3;
            }, z.rotateByQuatAppend = function(t3, e3, r3) {
              var n3 = r3[0], i3 = r3[1], s2 = r3[2], a3 = r3[3], o3 = e3[0], l3 = e3[1], u3 = e3[2], c3 = e3[3];
              return t3[0] = o3 * a3 + c3 * n3 + l3 * s2 - u3 * i3, t3[1] = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s2, t3[2] = u3 * a3 + c3 * s2 + o3 * i3 - l3 * n3, t3[3] = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s2, t3[4] = (o3 = e3[4]) * a3 + (c3 = e3[7]) * n3 + (l3 = e3[5]) * s2 - (u3 = e3[6]) * i3, t3[5] = l3 * a3 + c3 * i3 + u3 * n3 - o3 * s2, t3[6] = u3 * a3 + c3 * s2 + o3 * i3 - l3 * n3, t3[7] = c3 * a3 - o3 * n3 - l3 * i3 - u3 * s2, t3;
            }, z.rotateByQuatPrepend = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = r3[0], l3 = r3[1], u3 = r3[2], c3 = r3[3];
              return t3[0] = n3 * c3 + a3 * o3 + i3 * u3 - s2 * l3, t3[1] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3, t3[2] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[3] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3, t3[4] = n3 * (c3 = r3[7]) + a3 * (o3 = r3[4]) + i3 * (u3 = r3[6]) - s2 * (l3 = r3[5]), t3[5] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3, t3[6] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3, t3[7] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3, t3;
            }, z.rotateAroundAxis = function(t3, r3, n3, i3) {
              if (Math.abs(i3) < e2.EPSILON)
                return l2(t3, r3);
              var s2 = Math.hypot(n3[0], n3[1], n3[2]);
              i3 *= 0.5;
              var a3 = Math.sin(i3), o3 = a3 * n3[0] / s2, u3 = a3 * n3[1] / s2, c3 = a3 * n3[2] / s2, h3 = Math.cos(i3), p3 = r3[0], f2 = r3[1], d2 = r3[2], m2 = r3[3];
              t3[0] = p3 * h3 + m2 * o3 + f2 * c3 - d2 * u3, t3[1] = f2 * h3 + m2 * u3 + d2 * o3 - p3 * c3, t3[2] = d2 * h3 + m2 * c3 + p3 * u3 - f2 * o3, t3[3] = m2 * h3 - p3 * o3 - f2 * u3 - d2 * c3;
              var y2 = r3[4], g2 = r3[5], x2 = r3[6], b2 = r3[7];
              return t3[4] = y2 * h3 + b2 * o3 + g2 * c3 - x2 * u3, t3[5] = g2 * h3 + b2 * u3 + x2 * o3 - y2 * c3, t3[6] = x2 * h3 + b2 * c3 + y2 * u3 - g2 * o3, t3[7] = b2 * h3 - y2 * o3 - g2 * u3 - x2 * c3, t3;
            }, z.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3[3] = e3[3] + r3[3], t3[4] = e3[4] + r3[4], t3[5] = e3[5] + r3[5], t3[6] = e3[6] + r3[6], t3[7] = e3[7] + r3[7], t3;
            }, z.multiply = u2, z.scale = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3[4] = e3[4] * r3, t3[5] = e3[5] * r3, t3[6] = e3[6] * r3, t3[7] = e3[7] * r3, t3;
            }, z.lerp = function(t3, e3, r3, n3) {
              var i3 = 1 - n3;
              return c2(e3, r3) < 0 && (n3 = -n3), t3[0] = e3[0] * i3 + r3[0] * n3, t3[1] = e3[1] * i3 + r3[1] * n3, t3[2] = e3[2] * i3 + r3[2] * n3, t3[3] = e3[3] * i3 + r3[3] * n3, t3[4] = e3[4] * i3 + r3[4] * n3, t3[5] = e3[5] * i3 + r3[5] * n3, t3[6] = e3[6] * i3 + r3[6] * n3, t3[7] = e3[7] * i3 + r3[7] * n3, t3;
            }, z.invert = function(t3, e3) {
              var r3 = p2(e3);
              return t3[0] = -e3[0] / r3, t3[1] = -e3[1] / r3, t3[2] = -e3[2] / r3, t3[3] = e3[3] / r3, t3[4] = -e3[4] / r3, t3[5] = -e3[5] / r3, t3[6] = -e3[6] / r3, t3[7] = e3[7] / r3, t3;
            }, z.conjugate = function(t3, e3) {
              return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = e3[3], t3[4] = -e3[4], t3[5] = -e3[5], t3[6] = -e3[6], t3[7] = e3[7], t3;
            }, z.normalize = function(t3, e3) {
              var r3 = p2(e3);
              if (r3 > 0) {
                r3 = Math.sqrt(r3);
                var n3 = e3[0] / r3, i3 = e3[1] / r3, s2 = e3[2] / r3, a3 = e3[3] / r3, o3 = e3[4], l3 = e3[5], u3 = e3[6], c3 = e3[7], h3 = n3 * o3 + i3 * l3 + s2 * u3 + a3 * c3;
                t3[0] = n3, t3[1] = i3, t3[2] = s2, t3[3] = a3, t3[4] = (o3 - n3 * h3) / r3, t3[5] = (l3 - i3 * h3) / r3, t3[6] = (u3 - s2 * h3) / r3, t3[7] = (c3 - a3 * h3) / r3;
              }
              return t3;
            }, z.str = function(t3) {
              return "quat2(" + t3[0] + ", " + t3[1] + ", " + t3[2] + ", " + t3[3] + ", " + t3[4] + ", " + t3[5] + ", " + t3[6] + ", " + t3[7] + ")";
            }, z.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3] && t3[4] === e3[4] && t3[5] === e3[5] && t3[6] === e3[6] && t3[7] === e3[7];
            }, z.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = t3[2], a3 = t3[3], o3 = t3[4], l3 = t3[5], u3 = t3[6], c3 = t3[7], h3 = r3[0], p3 = r3[1], f2 = r3[2], d2 = r3[3], m2 = r3[4], y2 = r3[5], g2 = r3[6], x2 = r3[7];
              return Math.abs(n3 - h3) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(h3)) && Math.abs(i3 - p3) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(p3)) && Math.abs(s2 - f2) <= e2.EPSILON * Math.max(1, Math.abs(s2), Math.abs(f2)) && Math.abs(a3 - d2) <= e2.EPSILON * Math.max(1, Math.abs(a3), Math.abs(d2)) && Math.abs(o3 - m2) <= e2.EPSILON * Math.max(1, Math.abs(o3), Math.abs(m2)) && Math.abs(l3 - y2) <= e2.EPSILON * Math.max(1, Math.abs(l3), Math.abs(y2)) && Math.abs(u3 - g2) <= e2.EPSILON * Math.max(1, Math.abs(u3), Math.abs(g2)) && Math.abs(c3 - x2) <= e2.EPSILON * Math.max(1, Math.abs(c3), Math.abs(x2));
            }, z.sqrLen = z.squaredLength = z.len = z.length = z.dot = z.mul = z.setReal = z.getReal = void 0;
            var e2 = a2(s()), r2 = a2(I()), n2 = a2(g());
            function i2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
              return (i2 = function(t4) {
                return t4 ? r3 : e3;
              })(t3);
            }
            function a2(e3, r3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var n3 = i2(r3);
              if (n3 && n3.has(e3))
                return n3.get(e3);
              var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o3 in e3)
                if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
                  var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
                  l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
                }
              return s2.default = e3, n3 && n3.set(e3, s2), s2;
            }
            function o2(t3, e3, r3) {
              var n3 = 0.5 * r3[0], i3 = 0.5 * r3[1], s2 = 0.5 * r3[2], a3 = e3[0], o3 = e3[1], l3 = e3[2], u3 = e3[3];
              return t3[0] = a3, t3[1] = o3, t3[2] = l3, t3[3] = u3, t3[4] = n3 * u3 + i3 * l3 - s2 * o3, t3[5] = i3 * u3 + s2 * a3 - n3 * l3, t3[6] = s2 * u3 + n3 * o3 - i3 * a3, t3[7] = -n3 * a3 - i3 * o3 - s2 * l3, t3;
            }
            function l2(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3;
            }
            function u2(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1], s2 = e3[2], a3 = e3[3], o3 = r3[4], l3 = r3[5], u3 = r3[6], c3 = r3[7], h3 = e3[4], p3 = e3[5], f2 = e3[6], d2 = e3[7], m2 = r3[0], y2 = r3[1], g2 = r3[2], x2 = r3[3];
              return t3[0] = n3 * x2 + a3 * m2 + i3 * g2 - s2 * y2, t3[1] = i3 * x2 + a3 * y2 + s2 * m2 - n3 * g2, t3[2] = s2 * x2 + a3 * g2 + n3 * y2 - i3 * m2, t3[3] = a3 * x2 - n3 * m2 - i3 * y2 - s2 * g2, t3[4] = n3 * c3 + a3 * o3 + i3 * u3 - s2 * l3 + h3 * x2 + d2 * m2 + p3 * g2 - f2 * y2, t3[5] = i3 * c3 + a3 * l3 + s2 * o3 - n3 * u3 + p3 * x2 + d2 * y2 + f2 * m2 - h3 * g2, t3[6] = s2 * c3 + a3 * u3 + n3 * l3 - i3 * o3 + f2 * x2 + d2 * g2 + h3 * y2 - p3 * m2, t3[7] = a3 * c3 - n3 * o3 - i3 * l3 - s2 * u3 + d2 * x2 - h3 * m2 - p3 * y2 - f2 * g2, t3;
            }
            z.getReal = r2.copy, z.setReal = r2.copy, z.mul = u2;
            var c2 = r2.dot;
            z.dot = c2;
            var h2 = r2.length;
            z.length = h2, z.len = h2;
            var p2 = r2.squaredLength;
            return z.squaredLength = p2, z.sqrLen = p2, z;
          }
          var T, E, B = {};
          function V() {
            if (T)
              return B;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            T = 1, Object.defineProperty(B, "__esModule", { value: true }), B.create = n2, B.clone = function(t3) {
              var r3 = new e2.ARRAY_TYPE(2);
              return r3[0] = t3[0], r3[1] = t3[1], r3;
            }, B.fromValues = function(t3, r3) {
              var n3 = new e2.ARRAY_TYPE(2);
              return n3[0] = t3, n3[1] = r3, n3;
            }, B.copy = function(t3, e3) {
              return t3[0] = e3[0], t3[1] = e3[1], t3;
            }, B.set = function(t3, e3, r3) {
              return t3[0] = e3, t3[1] = r3, t3;
            }, B.add = function(t3, e3, r3) {
              return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3;
            }, B.subtract = i2, B.multiply = a2, B.divide = o2, B.ceil = function(t3, e3) {
              return t3[0] = Math.ceil(e3[0]), t3[1] = Math.ceil(e3[1]), t3;
            }, B.floor = function(t3, e3) {
              return t3[0] = Math.floor(e3[0]), t3[1] = Math.floor(e3[1]), t3;
            }, B.min = function(t3, e3, r3) {
              return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3;
            }, B.max = function(t3, e3, r3) {
              return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3;
            }, B.round = function(t3, e3) {
              return t3[0] = Math.round(e3[0]), t3[1] = Math.round(e3[1]), t3;
            }, B.scale = function(t3, e3, r3) {
              return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3;
            }, B.scaleAndAdd = function(t3, e3, r3, n3) {
              return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3;
            }, B.distance = l2, B.squaredDistance = u2, B.length = c2, B.squaredLength = h2, B.negate = function(t3, e3) {
              return t3[0] = -e3[0], t3[1] = -e3[1], t3;
            }, B.inverse = function(t3, e3) {
              return t3[0] = 1 / e3[0], t3[1] = 1 / e3[1], t3;
            }, B.normalize = function(t3, e3) {
              var r3 = e3[0], n3 = e3[1], i3 = r3 * r3 + n3 * n3;
              return i3 > 0 && (i3 = 1 / Math.sqrt(i3)), t3[0] = e3[0] * i3, t3[1] = e3[1] * i3, t3;
            }, B.dot = function(t3, e3) {
              return t3[0] * e3[0] + t3[1] * e3[1];
            }, B.cross = function(t3, e3, r3) {
              var n3 = e3[0] * r3[1] - e3[1] * r3[0];
              return t3[0] = t3[1] = 0, t3[2] = n3, t3;
            }, B.lerp = function(t3, e3, r3, n3) {
              var i3 = e3[0], s2 = e3[1];
              return t3[0] = i3 + n3 * (r3[0] - i3), t3[1] = s2 + n3 * (r3[1] - s2), t3;
            }, B.random = function(t3, r3) {
              r3 = r3 || 1;
              var n3 = 2 * e2.RANDOM() * Math.PI;
              return t3[0] = Math.cos(n3) * r3, t3[1] = Math.sin(n3) * r3, t3;
            }, B.transformMat2 = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1];
              return t3[0] = r3[0] * n3 + r3[2] * i3, t3[1] = r3[1] * n3 + r3[3] * i3, t3;
            }, B.transformMat2d = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1];
              return t3[0] = r3[0] * n3 + r3[2] * i3 + r3[4], t3[1] = r3[1] * n3 + r3[3] * i3 + r3[5], t3;
            }, B.transformMat3 = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1];
              return t3[0] = r3[0] * n3 + r3[3] * i3 + r3[6], t3[1] = r3[1] * n3 + r3[4] * i3 + r3[7], t3;
            }, B.transformMat4 = function(t3, e3, r3) {
              var n3 = e3[0], i3 = e3[1];
              return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[12], t3[1] = r3[1] * n3 + r3[5] * i3 + r3[13], t3;
            }, B.rotate = function(t3, e3, r3, n3) {
              var i3 = e3[0] - r3[0], s2 = e3[1] - r3[1], a3 = Math.sin(n3), o3 = Math.cos(n3);
              return t3[0] = i3 * o3 - s2 * a3 + r3[0], t3[1] = i3 * a3 + s2 * o3 + r3[1], t3;
            }, B.angle = function(t3, e3) {
              var r3 = t3[0], n3 = t3[1], i3 = e3[0], s2 = e3[1], a3 = Math.sqrt(r3 * r3 + n3 * n3) * Math.sqrt(i3 * i3 + s2 * s2);
              return Math.acos(Math.min(Math.max(a3 && (r3 * i3 + n3 * s2) / a3, -1), 1));
            }, B.zero = function(t3) {
              return t3[0] = 0, t3[1] = 0, t3;
            }, B.str = function(t3) {
              return "vec2(" + t3[0] + ", " + t3[1] + ")";
            }, B.exactEquals = function(t3, e3) {
              return t3[0] === e3[0] && t3[1] === e3[1];
            }, B.equals = function(t3, r3) {
              var n3 = t3[0], i3 = t3[1], s2 = r3[0], a3 = r3[1];
              return Math.abs(n3 - s2) <= e2.EPSILON * Math.max(1, Math.abs(n3), Math.abs(s2)) && Math.abs(i3 - a3) <= e2.EPSILON * Math.max(1, Math.abs(i3), Math.abs(a3));
            }, B.forEach = B.sqrLen = B.sqrDist = B.dist = B.div = B.mul = B.sub = B.len = void 0;
            var e2 = function(e3, n3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var i3 = r2(void 0);
              if (i3 && i3.has(e3))
                return i3.get(e3);
              var s2 = {}, a3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var o3 in e3)
                if ("default" !== o3 && Object.prototype.hasOwnProperty.call(e3, o3)) {
                  var l3 = a3 ? Object.getOwnPropertyDescriptor(e3, o3) : null;
                  l3 && (l3.get || l3.set) ? Object.defineProperty(s2, o3, l3) : s2[o3] = e3[o3];
                }
              return s2.default = e3, i3 && i3.set(e3, s2), s2;
            }(s());
            function r2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), n3 = /* @__PURE__ */ new WeakMap();
              return (r2 = function(t4) {
                return t4 ? n3 : e3;
              })(t3);
            }
            function n2() {
              var t3 = new e2.ARRAY_TYPE(2);
              return e2.ARRAY_TYPE != Float32Array && (t3[0] = 0, t3[1] = 0), t3;
            }
            function i2(t3, e3, r3) {
              return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3;
            }
            function a2(t3, e3, r3) {
              return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3;
            }
            function o2(t3, e3, r3) {
              return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3;
            }
            function l2(t3, e3) {
              return Math.hypot(e3[0] - t3[0], e3[1] - t3[1]);
            }
            function u2(t3, e3) {
              var r3 = e3[0] - t3[0], n3 = e3[1] - t3[1];
              return r3 * r3 + n3 * n3;
            }
            function c2(t3) {
              return Math.hypot(t3[0], t3[1]);
            }
            function h2(t3) {
              var e3 = t3[0], r3 = t3[1];
              return e3 * e3 + r3 * r3;
            }
            B.len = c2, B.sub = i2, B.mul = a2, B.div = o2, B.dist = l2, B.sqrDist = u2, B.sqrLen = h2;
            var p2, f2 = (p2 = n2(), function(t3, e3, r3, n3, i3, s2) {
              var a3, o3;
              for (e3 || (e3 = 2), r3 || (r3 = 0), o3 = n3 ? Math.min(n3 * e3 + r3, t3.length) : t3.length, a3 = r3; a3 < o3; a3 += e3)
                p2[0] = t3[a3], p2[1] = t3[a3 + 1], i3(p2, p2, s2), t3[a3] = p2[0], t3[a3 + 1] = p2[1];
              return t3;
            });
            return B.forEach = f2, B;
          }
          function C() {
            if (E)
              return n;
            function t2(e3) {
              return t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
                return typeof t3;
              } : function(t3) {
                return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
              }, t2(e3);
            }
            E = 1, Object.defineProperty(n, "__esModule", { value: true }), n.vec4 = n.vec3 = n.vec2 = n.quat2 = n.quat = n.mat4 = n.mat3 = n.mat2d = n.mat2 = n.glMatrix = void 0;
            var e2 = x2(s());
            n.glMatrix = e2;
            var r2 = x2(l());
            n.mat2 = r2;
            var i2 = x2(h());
            n.mat2d = i2;
            var a2 = x2(d());
            n.mat3 = a2;
            var o2 = x2(g());
            n.mat4 = o2;
            var u2 = x2(I());
            n.quat = u2;
            var c2 = x2(k());
            n.quat2 = c2;
            var p2 = x2(V());
            n.vec2 = p2;
            var f2 = x2(w());
            n.vec3 = f2;
            var m2 = x2(S());
            function y2(t3) {
              if ("function" != typeof WeakMap)
                return null;
              var e3 = /* @__PURE__ */ new WeakMap(), r3 = /* @__PURE__ */ new WeakMap();
              return (y2 = function(t4) {
                return t4 ? r3 : e3;
              })(t3);
            }
            function x2(e3, r3) {
              if (e3 && e3.__esModule)
                return e3;
              if (null === e3 || "object" !== t2(e3) && "function" != typeof e3)
                return { default: e3 };
              var n2 = y2(r3);
              if (n2 && n2.has(e3))
                return n2.get(e3);
              var i3 = {}, s2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var a3 in e3)
                if ("default" !== a3 && Object.prototype.hasOwnProperty.call(e3, a3)) {
                  var o3 = s2 ? Object.getOwnPropertyDescriptor(e3, a3) : null;
                  o3 && (o3.get || o3.set) ? Object.defineProperty(i3, a3, o3) : i3[a3] = e3[a3];
                }
              return i3.default = e3, n2 && n2.set(e3, i3), i3;
            }
            return n.vec4 = m2, n;
          }
          var R, D, L, F, O = C(), U = function() {
            if (D)
              return R;
            function t2(t3, e2, r2, n2) {
              this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
            }
            return D = 1, R = t2, t2.prototype = { sampleCurveX: function(t3) {
              return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
            }, sampleCurveY: function(t3) {
              return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
            }, sampleCurveDerivativeX: function(t3) {
              return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
            }, solveCurveX: function(t3, e2) {
              if (void 0 === e2 && (e2 = 1e-6), t3 < 0)
                return 0;
              if (t3 > 1)
                return 1;
              for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
                var i2 = this.sampleCurveX(r2) - t3;
                if (Math.abs(i2) < e2)
                  return r2;
                var s2 = this.sampleCurveDerivativeX(r2);
                if (Math.abs(s2) < 1e-6)
                  break;
                r2 -= i2 / s2;
              }
              var a2 = 0, o2 = 1;
              for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++)
                t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
              return r2;
            }, solve: function(t3, e2) {
              return this.sampleCurveY(this.solveCurveX(t3, e2));
            } }, R;
          }(), j = e(U);
          function N() {
            if (F)
              return L;
            function t2(t3, e2) {
              this.x = t3, this.y = e2;
            }
            return F = 1, L = t2, t2.prototype = { clone: function() {
              return new t2(this.x, this.y);
            }, add: function(t3) {
              return this.clone()._add(t3);
            }, sub: function(t3) {
              return this.clone()._sub(t3);
            }, multByPoint: function(t3) {
              return this.clone()._multByPoint(t3);
            }, divByPoint: function(t3) {
              return this.clone()._divByPoint(t3);
            }, mult: function(t3) {
              return this.clone()._mult(t3);
            }, div: function(t3) {
              return this.clone()._div(t3);
            }, rotate: function(t3) {
              return this.clone()._rotate(t3);
            }, rotateAround: function(t3, e2) {
              return this.clone()._rotateAround(t3, e2);
            }, matMult: function(t3) {
              return this.clone()._matMult(t3);
            }, unit: function() {
              return this.clone()._unit();
            }, perp: function() {
              return this.clone()._perp();
            }, round: function() {
              return this.clone()._round();
            }, mag: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            }, equals: function(t3) {
              return this.x === t3.x && this.y === t3.y;
            }, dist: function(t3) {
              return Math.sqrt(this.distSqr(t3));
            }, distSqr: function(t3) {
              var e2 = t3.x - this.x, r2 = t3.y - this.y;
              return e2 * e2 + r2 * r2;
            }, angle: function() {
              return Math.atan2(this.y, this.x);
            }, angleTo: function(t3) {
              return Math.atan2(this.y - t3.y, this.x - t3.x);
            }, angleWith: function(t3) {
              return this.angleWithSep(t3.x, t3.y);
            }, angleWithSep: function(t3, e2) {
              return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
            }, _matMult: function(t3) {
              var e2 = t3[2] * this.x + t3[3] * this.y;
              return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
            }, _add: function(t3) {
              return this.x += t3.x, this.y += t3.y, this;
            }, _sub: function(t3) {
              return this.x -= t3.x, this.y -= t3.y, this;
            }, _mult: function(t3) {
              return this.x *= t3, this.y *= t3, this;
            }, _div: function(t3) {
              return this.x /= t3, this.y /= t3, this;
            }, _multByPoint: function(t3) {
              return this.x *= t3.x, this.y *= t3.y, this;
            }, _divByPoint: function(t3) {
              return this.x /= t3.x, this.y /= t3.y, this;
            }, _unit: function() {
              return this._div(this.mag()), this;
            }, _perp: function() {
              var t3 = this.y;
              return this.y = this.x, this.x = -t3, this;
            }, _rotate: function(t3) {
              var e2 = Math.cos(t3), r2 = Math.sin(t3), n2 = r2 * this.x + e2 * this.y;
              return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
            }, _rotateAround: function(t3, e2) {
              var r2 = Math.cos(t3), n2 = Math.sin(t3), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
              return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
            }, _round: function() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            } }, t2.convert = function(e2) {
              return e2 instanceof t2 ? e2 : Array.isArray(e2) ? new t2(e2[0], e2[1]) : e2;
            }, L;
          }
          var q = e(N());
          function $(t2, e2) {
            if (Array.isArray(t2)) {
              if (!Array.isArray(e2) || t2.length !== e2.length)
                return false;
              for (let r2 = 0; r2 < t2.length; r2++)
                if (!$(t2[r2], e2[r2]))
                  return false;
              return true;
            }
            if ("object" == typeof t2 && null !== t2 && null !== e2) {
              if ("object" != typeof e2)
                return false;
              if (Object.keys(t2).length !== Object.keys(e2).length)
                return false;
              for (const r2 in t2)
                if (!$(t2[r2], e2[r2]))
                  return false;
              return true;
            }
            return t2 === e2;
          }
          const G = Math.PI / 180, X = 180 / Math.PI;
          function Y(t2) {
            return t2 * G;
          }
          function Z(t2) {
            return t2 * X;
          }
          const W = [[0, 0], [1, 0], [1, 1], [0, 1]];
          function H(t2) {
            if (t2 <= 0)
              return 0;
            if (t2 >= 1)
              return 1;
            const e2 = t2 * t2, r2 = e2 * t2;
            return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
          }
          function K(t2, e2, r2, n2) {
            const i2 = new j(t2, e2, r2, n2);
            return function(t3) {
              return i2.solve(t3);
            };
          }
          const J = K(0.25, 0.1, 0.25, 1);
          function Q(t2, e2, r2) {
            return Math.min(r2, Math.max(e2, t2));
          }
          function tt(t2, e2, r2) {
            return (r2 = Q((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
          }
          function et(t2, e2, r2) {
            const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r2 : i2;
          }
          function rt(t2, e2, r2) {
            if (!t2.length)
              return r2(null, []);
            let n2 = t2.length;
            const i2 = new Array(t2.length);
            let s2 = null;
            t2.forEach((t3, a2) => {
              e2(t3, (t4, e3) => {
                t4 && (s2 = t4), i2[a2] = e3, 0 == --n2 && r2(s2, i2);
              });
            });
          }
          function nt(t2, ...e2) {
            for (const r2 of e2)
              for (const e3 in r2)
                t2[e3] = r2[e3];
            return t2;
          }
          let it = 1;
          function st() {
            return it++;
          }
          function at(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }
          function ot(t2, e2) {
            t2.forEach((t3) => {
              e2[t3] && (e2[t3] = e2[t3].bind(e2));
            });
          }
          function lt(t2, e2) {
            return -1 !== t2.indexOf(e2, t2.length - e2.length);
          }
          function ut(t2, e2, r2) {
            const n2 = {};
            for (const r3 in t2)
              n2[r3] = e2.call(this, t2[r3], r3, t2);
            return n2;
          }
          function ct(t2, e2, r2) {
            const n2 = {};
            for (const r3 in t2)
              e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
            return n2;
          }
          function ht(t2) {
            return Array.isArray(t2) ? t2.map(ht) : "object" == typeof t2 && t2 ? ut(t2, ht) : t2;
          }
          const pt = {};
          function ft(t2) {
            pt[t2] || ("undefined" != typeof console && console.warn(t2), pt[t2] = true);
          }
          function dt(t2, e2, r2) {
            return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
          }
          function mt(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          function yt([t2, e2, r2]) {
            const n2 = Y(e2 + 90), i2 = Y(r2);
            return { x: t2 * Math.cos(n2) * Math.sin(i2), y: t2 * Math.sin(n2) * Math.sin(i2), z: t2 * Math.cos(i2), azimuthal: e2, polar: r2 };
          }
          function gt() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
          }
          function xt(t2) {
            const e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
              const s2 = n2 || i2;
              return e2[r2] = !s2 || s2.toLowerCase(), "";
            }), e2["max-age"]) {
              const t3 = parseInt(e2["max-age"], 10);
              isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
            }
            return e2;
          }
          let bt, vt = null;
          function wt(t2, e2) {
            return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
          }
          function _t(t2, e2, r2, n2) {
            for (; e2 < r2; ) {
              const i2 = e2 + r2 >> 1;
              t2[i2] < n2 ? e2 = i2 + 1 : r2 = i2;
            }
            return e2;
          }
          function Mt(t2, e2, r2, n2) {
            for (; e2 < r2; ) {
              const i2 = e2 + r2 >> 1;
              t2[i2] <= n2 ? e2 = i2 + 1 : r2 = i2;
            }
            return e2;
          }
          function At(t2) {
            return t2 > 0 ? 1 / (1.001 - t2) : 1 + t2;
          }
          function St(t2) {
            return t2 > 0 ? 1 - 1 / (1.001 - t2) : -t2;
          }
          const It = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
            if (null == bt) {
              const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
              try {
                bt = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t2;
              } catch (e2) {
                bt = t2;
              }
            }
            return bt;
          }, get API_TILEJSON_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
          }, get API_SPRITE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
          }, get API_FONTS_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
          }, get API_STYLE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
          }, get API_CDN_URL_REGEX() {
            return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
          }, get EVENTS_URL() {
            if (!It.API_URL)
              return null;
            try {
              const t2 = new URL(It.API_URL);
              return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
            } catch (t2) {
              return null;
            }
          }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
          function Pt(t2) {
            return It.API_URL_REGEX.test(t2);
          }
          function zt(t2) {
            return It.API_SPRITE_REGEX.test(t2);
          }
          let kt, Tt, Et, Bt, Vt, Ct;
          function Rt() {
            return null == kt && (kt = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), kt;
          }
          const Dt = { now: () => void 0 !== Bt ? Bt : performance.now(), setNow(t2) {
            Bt = t2;
          }, restoreNow() {
            Bt = void 0;
          }, frame(t2) {
            const e2 = requestAnimationFrame(t2);
            return { cancel: () => cancelAnimationFrame(e2) };
          }, getImageData(t2, e2 = 0) {
            const { width: r2, height: n2 } = t2;
            Vt || (Vt = document.createElement("canvas"));
            const i2 = Vt.getContext("2d", { willReadFrequently: true });
            if (!i2)
              throw new Error("failed to create canvas 2d context");
            return (r2 > Vt.width || n2 > Vt.height) && (Vt.width = r2, Vt.height = n2), i2.clearRect(-e2, -e2, r2 + 2 * e2, n2 + 2 * e2), i2.drawImage(t2, 0, 0, r2, n2), i2.getImageData(-e2, -e2, r2 + 2 * e2, n2 + 2 * e2);
          }, resolveURL: (t2) => (Tt || (Tt = document.createElement("a")), Tt.href = t2, Tt.href), get devicePixelRatio() {
            return window.devicePixelRatio;
          }, get prefersReducedMotion() {
            return !!window.matchMedia && (null == Et && (Et = window.matchMedia("(prefers-reduced-motion: reduce)")), Et.matches);
          }, hasCanvasFingerprintNoise() {
            if (void 0 !== Ct)
              return Ct;
            if (!Rt())
              return Ct = false, false;
            const t2 = new OffscreenCanvas(85, 1), e2 = t2.getContext("2d", { willReadFrequently: true });
            let r2 = 0;
            for (let n3 = 0; n3 < t2.width; ++n3)
              e2.fillStyle = `rgba(${r2++},${r2++},${r2++}, 255)`, e2.fillRect(n3, 0, 1, 1);
            const n2 = e2.getImageData(0, 0, t2.width, t2.height);
            r2 = 0;
            for (let t3 = 0; t3 < n2.data.length; ++t3)
              if (t3 % 4 != 3 && r2++ !== n2.data[t3])
                return Ct = true, true;
            return Ct = false, false;
          } };
          function Lt(t2, e2) {
            const r2 = t2.indexOf("?");
            if (r2 < 0)
              return `${t2}?${new URLSearchParams(e2).toString()}`;
            const n2 = new URLSearchParams(t2.slice(r2));
            for (const t3 in e2)
              n2.set(t3, e2[t3]);
            return `${t2.slice(0, r2)}?${n2.toString()}`;
          }
          function Ft(t2, e2 = { persistentParams: [] }) {
            const r2 = t2.indexOf("?");
            if (r2 < 0)
              return t2;
            const n2 = new URLSearchParams(), i2 = new URLSearchParams(t2.slice(r2));
            for (const t3 of e2.persistentParams) {
              const e3 = i2.get(t3);
              e3 && n2.set(t3, e3);
            }
            const s2 = n2.toString();
            return `${t2.slice(0, r2)}${s2.length > 0 ? `?${s2}` : ""}`;
          }
          const Ot = "mapbox-tiles";
          let Ut = 500, jt = 50;
          const Nt = ["language", "worldview", "jobid"];
          let qt, $t;
          function Gt() {
            try {
              return caches;
            } catch (t2) {
            }
          }
          function Xt() {
            const t2 = Gt();
            t2 && null == qt && (qt = t2.open(Ot));
          }
          let Yt = 1 / 0;
          const Zt = { supported: false, testSupport: function(t2) {
            !Kt && Ht && (Jt ? te(t2) : Wt = t2);
          } };
          let Wt, Ht, Kt = false, Jt = false;
          const Qt = "undefined" != typeof self ? self : {};
          function te(t2) {
            const e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, Ht), t2.isContextLost())
                return;
              Zt.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e2), Kt = true;
          }
          Qt.document && (Ht = Qt.document.createElement("img"), Ht.onload = function() {
            Wt && te(Wt), Wt = null, Jt = true;
          }, Ht.onerror = function() {
            Kt = true, Wt = null;
          }, Ht.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          const ee = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image", Model: "Model" };
          "function" == typeof Object.freeze && Object.freeze(ee);
          class re extends Error {
            constructor(t2, e2, r2) {
              401 === e2 && Pt(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
            }
            toString() {
              return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
          }
          const ne = gt() ? () => self.worker && self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
          const ie = function(t2, e2) {
            if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(ne()) && !/^\w+:/.test(r2))) {
              if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
                return function(t3, e3) {
                  const r3 = new AbortController(), n2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: ne(), referrerPolicy: t3.referrerPolicy, signal: r3.signal });
                  let i2 = false, s2 = false;
                  const a2 = (o2 = n2.url).indexOf("sku=") > 0 && Pt(o2);
                  var o2;
                  "json" === t3.type && n2.headers.set("Accept", "application/json");
                  const l2 = (r4, i3, o3) => {
                    if (s2)
                      return;
                    if (r4 && "SecurityError" !== r4.message && ft(r4.toString()), i3 && o3)
                      return u2(i3);
                    const l3 = Date.now();
                    fetch(n2).then((r5) => {
                      if (r5.ok) {
                        const t4 = a2 ? r5.clone() : null;
                        return u2(r5, t4, l3);
                      }
                      return e3(new re(r5.statusText, r5.status, t3.url));
                    }).catch((r5) => {
                      "AbortError" !== r5.name && e3(new Error(`${r5.message} ${t3.url}`));
                    });
                  }, u2 = (r4, a3, o3) => {
                    ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                      s2 || (a3 && o3 && function(t5, e4, r5) {
                        if (Xt(), null == qt)
                          return;
                        const n3 = xt(e4.headers.get("Cache-Control") || "");
                        if (n3["no-store"])
                          return;
                        const i3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                        e4.headers.forEach((t6, e5) => i3.headers.set(e5, t6)), n3["max-age"] && i3.headers.set("Expires", new Date(r5 + 1e3 * n3["max-age"]).toUTCString());
                        const s3 = i3.headers.get("Expires");
                        if (!s3)
                          return;
                        if (new Date(s3).getTime() - r5 < 42e4)
                          return;
                        let a4 = Ft(t5.url, { persistentParams: Nt });
                        if (206 === e4.status) {
                          const e5 = t5.headers.get("Range");
                          if (!e5)
                            return;
                          i3.status = 200, a4 = Lt(a4, { range: e5 });
                        }
                        !function(t6, e5) {
                          if (void 0 === $t)
                            try {
                              new Response(new ReadableStream()), $t = true;
                            } catch (t7) {
                              $t = false;
                            }
                          $t ? e5(t6.body) : t6.blob().then(e5);
                        }(e4, (t6) => {
                          const r6 = new Response(200 !== (n4 = e4.status) && 404 !== n4 && [101, 103, 204, 205, 304].includes(n4) ? null : t6, i3);
                          var n4;
                          Xt(), null != qt && qt.then((t7) => t7.put(a4, r6)).catch((t7) => ft(t7.message));
                        });
                      }(n2, a3, o3), i2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                    }).catch((t4) => {
                      s2 || e3(new Error(t4.message));
                    });
                  };
                  return a2 ? function(t4, e4) {
                    if (Xt(), null == qt)
                      return e4(null);
                    qt.then((r4) => {
                      let n3 = Ft(t4.url, { persistentParams: Nt });
                      const i3 = t4.headers.get("Range");
                      i3 && (n3 = Lt(n3, { range: i3 })), r4.match(n3).then((t5) => {
                        const i4 = function(t6) {
                          if (!t6)
                            return false;
                          const e5 = new Date(t6.headers.get("Expires") || 0), r5 = xt(t6.headers.get("Cache-Control") || "");
                          return e5 > Date.now() && !r5["no-cache"];
                        }(t5);
                        r4.delete(n3), i4 && r4.put(n3, t5.clone()), e4(null, t5, i4);
                      }).catch(e4);
                    }).catch(e4);
                  }(n2, l2) : l2(null, null), { cancel: () => {
                    s2 = true, i2 || r3.abort();
                  } };
                }(t2, e2);
              if (gt() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e2, void 0, true);
            }
            var r2;
            return function(t3, e3) {
              const r3 = new XMLHttpRequest();
              r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
              for (const e4 in t3.headers)
                r3.setRequestHeader(e4, t3.headers[e4]);
              return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
                e3(new Error(r3.statusText));
              }, r3.onload = () => {
                if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                  let n2 = r3.response;
                  if ("json" === t3.type)
                    try {
                      n2 = JSON.parse(r3.response);
                    } catch (t4) {
                      return e3(t4);
                    }
                  e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
                } else
                  e3(new re(r3.statusText, r3.status, t3.url));
              }, r3.send(t3.body), { cancel: () => r3.abort() };
            }(t2, e2);
          }, se = function(t2, e2) {
            return ie(nt(t2, { type: "arrayBuffer" }), e2);
          };
          function ae(t2) {
            const e2 = document.createElement("a");
            return e2.href = t2, e2.protocol === location.protocol && e2.host === location.host;
          }
          const oe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let le, ue;
          le = [], ue = 0;
          const ce = function(t2, e2) {
            if (Zt.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), ue >= It.MAX_PARALLEL_IMAGE_REQUESTS) {
              const r3 = { requestParameters: t2, callback: e2, cancelled: false, cancel() {
                this.cancelled = true;
              } };
              return le.push(r3), r3;
            }
            ue++;
            let r2 = false;
            const n2 = () => {
              if (!r2)
                for (r2 = true, ue--; le.length && ue < It.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  const t3 = le.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
                  n3 || (t3.cancel = ce(e3, r3).cancel);
                }
            }, i2 = se(t2, (t3, r3, i3, s2) => {
              n2(), t3 ? e2(t3) : r3 && (self.createImageBitmap ? function(t4, e3) {
                const r4 = new Blob([new Uint8Array(t4)], { type: "image/png" });
                createImageBitmap(r4).then((t5) => {
                  e3(null, t5);
                }).catch((t5) => {
                  e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                });
              }(r3, (t4, r4) => e2(t4, r4, i3, s2)) : function(t4, e3) {
                const r4 = new Image();
                r4.onload = () => {
                  e3(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, requestAnimationFrame(() => {
                    r4.src = oe;
                  });
                }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
                r4.src = t4.byteLength ? URL.createObjectURL(n3) : oe;
              }(r3, (t4, r4) => e2(t4, r4, i3, s2)));
            });
            return { cancel: () => {
              i2.cancel(), n2();
            } };
          };
          var he, pe, fe, de = { exports: {} }, me = { exports: {} }, ye = { exports: {} }, ge = function() {
            if (fe)
              return de.exports;
            fe = 1;
            var t2 = (he || (he = 1, me.exports = function(t3, e3) {
              var r2, n2, i2, s2, a2, o2, l2, u2;
              for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
                l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
              switch (l2 = 0, r2) {
                case 3:
                  l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
                case 2:
                  l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
                case 1:
                  i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
              }
              return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
            }), me.exports), e2 = (pe || (pe = 1, ye.exports = function(t3, e3) {
              for (var r2, n2 = t3.length, i2 = e3 ^ n2, s2 = 0; n2 >= 4; )
                r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
              switch (n2) {
                case 3:
                  i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
                case 2:
                  i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
                case 1:
                  i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
              }
              return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
            }), ye.exports);
            return de.exports = t2, de.exports.murmur3 = t2, de.exports.murmur2 = e2, de.exports;
          }(), xe = e(ge);
          class be {
            constructor(t2, ...e2) {
              nt(this, e2[0] || {}), this.type = t2;
            }
          }
          class ve extends be {
            constructor(t2, e2 = {}) {
              super("error", nt({ error: t2 }, e2));
            }
          }
          function we(t2, e2, r2) {
            r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
          }
          function _e(t2, e2, r2) {
            if (r2 && r2[t2]) {
              const n2 = r2[t2].indexOf(e2);
              -1 !== n2 && r2[t2].splice(n2, 1);
            }
          }
          class Me {
            on(t2, e2) {
              return this._listeners = this._listeners || {}, we(t2, e2, this._listeners), this;
            }
            off(t2, e2) {
              return _e(t2, e2, this._listeners), _e(t2, e2, this._oneTimeListeners), this;
            }
            once(t2, e2) {
              return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, we(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
            }
            fire(t2, e2) {
              const r2 = "string" == typeof t2 ? new be(t2, e2) : t2, n2 = r2.type;
              if (this.listens(n2)) {
                r2.target = this;
                const t3 = this._listeners && this._listeners[n2] ? this._listeners[n2].slice() : [];
                for (const e4 of t3)
                  e4.call(this, r2);
                const e3 = this._oneTimeListeners && this._oneTimeListeners[n2] ? this._oneTimeListeners[n2].slice() : [];
                for (const t4 of e3)
                  _e(n2, t4, this._oneTimeListeners), t4.call(this, r2);
                const i2 = this._eventedParent;
                i2 && (nt(r2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(r2));
              } else
                r2 instanceof ve && console.error(r2.error);
              return this;
            }
            listens(t2) {
              return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
            }
            setEventedParent(t2, e2) {
              return this._eventedParent = t2, this._eventedParentData = e2, this;
            }
          }
          var Ae, Se = {}, Ie = function() {
            if (Ae)
              return Se;
            Ae = 1;
            var t2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
            function e2(t3) {
              return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
            }
            function r2(t3) {
              return e2("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
            }
            function n2(t3) {
              return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
              var e3;
            }
            function i2(t3, e3, r3) {
              return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
            }
            try {
              Se.parseCSSColor = function(s2) {
                var a2, o2 = s2.replace(/ /g, "").toLowerCase();
                if (o2 in t2)
                  return t2[o2].slice();
                if ("#" === o2[0])
                  return 4 === o2.length ? (a2 = parseInt(o2.substr(1), 16)) >= 0 && a2 <= 4095 ? [(3840 & a2) >> 4 | (3840 & a2) >> 8, 240 & a2 | (240 & a2) >> 4, 15 & a2 | (15 & a2) << 4, 1] : null : 7 === o2.length && (a2 = parseInt(o2.substr(1), 16)) >= 0 && a2 <= 16777215 ? [(16711680 & a2) >> 16, (65280 & a2) >> 8, 255 & a2, 1] : null;
                var l2 = o2.indexOf("("), u2 = o2.indexOf(")");
                if (-1 !== l2 && u2 + 1 === o2.length) {
                  var c2 = o2.substr(0, l2), h2 = o2.substr(l2 + 1, u2 - (l2 + 1)).split(","), p2 = 1;
                  switch (c2) {
                    case "rgba":
                      if (4 !== h2.length)
                        return null;
                      p2 = n2(h2.pop());
                    case "rgb":
                      return 3 !== h2.length ? null : [r2(h2[0]), r2(h2[1]), r2(h2[2]), p2];
                    case "hsla":
                      if (4 !== h2.length)
                        return null;
                      p2 = n2(h2.pop());
                    case "hsl":
                      if (3 !== h2.length)
                        return null;
                      var f2 = (parseFloat(h2[0]) % 360 + 360) % 360 / 360, d2 = n2(h2[1]), m2 = n2(h2[2]), y2 = m2 <= 0.5 ? m2 * (d2 + 1) : m2 + d2 - m2 * d2, g2 = 2 * m2 - y2;
                      return [e2(255 * i2(g2, y2, f2 + 1 / 3)), e2(255 * i2(g2, y2, f2)), e2(255 * i2(g2, y2, f2 - 1 / 3)), p2];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch (t3) {
            }
            return Se;
          }();
          class Pe {
            constructor(t2, e2, r2, n2 = 1) {
              this.r = t2, this.g = e2, this.b = r2, this.a = n2;
            }
            static parse(t2) {
              if (!t2)
                return;
              if (t2 instanceof Pe)
                return t2;
              if ("string" != typeof t2)
                return;
              const e2 = Ie.parseCSSColor(t2);
              return e2 ? new Pe(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
            }
            toString() {
              const [t2, e2, r2, n2] = 0 === this.a ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
              return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
            }
            toRenderColor(t2) {
              const { r: e2, g: r2, b: n2, a: i2 } = this;
              return new ze(t2, e2, r2, n2, i2);
            }
          }
          class ze {
            constructor(t2, e2, r2, n2, i2) {
              if (t2) {
                const s2 = t2.image.height, a2 = s2 * s2;
                e2 = 0 === i2 ? 0 : e2 / i2 * (s2 - 1), r2 = 0 === i2 ? 0 : r2 / i2 * (s2 - 1), n2 = 0 === i2 ? 0 : n2 / i2 * (s2 - 1);
                const o2 = Math.floor(e2), l2 = Math.floor(r2), u2 = Math.floor(n2), c2 = Math.ceil(e2), h2 = Math.ceil(r2), p2 = Math.ceil(n2), f2 = e2 - o2, d2 = r2 - l2, m2 = n2 - u2, y2 = t2.image.data, g2 = 4 * (o2 + l2 * a2 + u2 * s2), x2 = 4 * (o2 + l2 * a2 + p2 * s2), b2 = 4 * (o2 + h2 * a2 + u2 * s2), v2 = 4 * (o2 + h2 * a2 + p2 * s2), w2 = 4 * (c2 + l2 * a2 + u2 * s2), _2 = 4 * (c2 + l2 * a2 + p2 * s2), M2 = 4 * (c2 + h2 * a2 + u2 * s2), A2 = 4 * (c2 + h2 * a2 + p2 * s2);
                if (g2 < 0 || A2 >= y2.length)
                  throw new Error("out of range");
                this.r = ke(ke(ke(y2[g2], y2[x2], m2), ke(y2[b2], y2[v2], m2), d2), ke(ke(y2[w2], y2[_2], m2), ke(y2[M2], y2[A2], m2), d2), f2) / 255 * i2, this.g = ke(ke(ke(y2[g2 + 1], y2[x2 + 1], m2), ke(y2[b2 + 1], y2[v2 + 1], m2), d2), ke(ke(y2[w2 + 1], y2[_2 + 1], m2), ke(y2[M2 + 1], y2[A2 + 1], m2), d2), f2) / 255 * i2, this.b = ke(ke(ke(y2[g2 + 2], y2[x2 + 2], m2), ke(y2[b2 + 2], y2[v2 + 2], m2), d2), ke(ke(y2[w2 + 2], y2[_2 + 2], m2), ke(y2[M2 + 2], y2[A2 + 2], m2), d2), f2) / 255 * i2, this.a = i2;
              } else
                this.r = e2, this.g = r2, this.b = n2, this.a = i2;
            }
            toArray() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
            }
            toArray01() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [t2 / n2, e2 / n2, r2 / n2, n2];
            }
            toArray01Scaled(t2) {
              const { r: e2, g: r2, b: n2, a: i2 } = this;
              return 0 === i2 ? [0, 0, 0] : [e2 / i2 * t2, r2 / i2 * t2, n2 / i2 * t2];
            }
            toArray01PremultipliedAlpha() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return [t2, e2, r2, n2];
            }
            toArray01Linear() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [Math.pow(t2 / n2, 2.2), Math.pow(e2 / n2, 2.2), Math.pow(r2 / n2, 2.2), n2];
            }
          }
          function ke(t2, e2, r2) {
            return t2 * (1 - r2) + e2 * r2;
          }
          function Te(t2, e2, r2) {
            return t2.map((t3, n2) => ke(t3, e2[n2], r2));
          }
          Pe.black = new Pe(0, 0, 0, 1), Pe.white = new Pe(1, 1, 1, 1), Pe.transparent = new Pe(0, 0, 0, 0), Pe.red = new Pe(1, 0, 0, 1), Pe.blue = new Pe(0, 0, 1, 1);
          var Ee = Object.freeze({ __proto__: null, array: Te, color: function(t2, e2, r2) {
            return new Pe(ke(t2.r, e2.r, r2), ke(t2.g, e2.g, r2), ke(t2.b, e2.b, r2), ke(t2.a, e2.a, r2));
          }, number: ke });
          function Be(t2, ...e2) {
            for (const r2 of e2)
              for (const e3 in r2)
                t2[e3] = r2[e3];
            return t2;
          }
          class Ve extends Error {
            constructor(t2, e2) {
              super(e2), this.message = e2, this.key = t2;
            }
          }
          class Ce {
            constructor(t2, e2 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r2] of e2)
                this.bindings[t3] = r2;
            }
            concat(t2) {
              return new Ce(this, t2);
            }
            get(t2) {
              if (this.bindings[t2])
                return this.bindings[t2];
              if (this.parent)
                return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          const Re = { kind: "null" }, De = { kind: "number" }, Le = { kind: "string" }, Fe = { kind: "boolean" }, Oe = { kind: "color" }, Ue = { kind: "object" }, je = { kind: "value" }, Ne = { kind: "collator" }, qe = { kind: "formatted" }, $e = { kind: "resolvedImage" };
          function Ge(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function Xe(t2) {
            if ("array" === t2.kind) {
              const e2 = Xe(t2.itemType);
              return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
            }
            return t2.kind;
          }
          const Ye = [Re, De, Le, Fe, Oe, qe, Ue, Ge(je), $e];
          function Ze(t2, e2) {
            if ("error" === e2.kind)
              return null;
            if ("array" === t2.kind) {
              if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Ze(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
                return null;
            } else {
              if (t2.kind === e2.kind)
                return null;
              if ("value" === t2.kind) {
                for (const t3 of Ye)
                  if (!Ze(t3, e2))
                    return null;
              }
            }
            return `Expected ${Xe(t2)} but found ${Xe(e2)} instead.`;
          }
          function We(t2, e2) {
            return e2.some((e3) => e3.kind === t2.kind);
          }
          function He(t2, e2) {
            return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
          }
          class Ke {
            constructor(t2, e2, r2) {
              this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e2) {
              return this.collator.compare(t2, e2);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class Je {
            constructor(t2, e2, r2, n2, i2) {
              this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
            }
          }
          class Qe {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new Qe([new Je(t2, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.namePrimary.length);
            }
            static factory(t2) {
              return t2 instanceof Qe ? t2 : Qe.fromString(t2);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                if (e2.image) {
                  t2.push(["image", e2.image.namePrimary]);
                  continue;
                }
                t2.push(e2.text);
                const r2 = {};
                e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toRenderColor(null).toArray())), t2.push(r2);
              }
              return t2;
            }
          }
          class tr {
            constructor(t2) {
              this.namePrimary = t2.namePrimary, t2.nameSecondary && (this.nameSecondary = t2.nameSecondary), this.available = t2.available;
            }
            toString() {
              return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
            }
            static fromString(t2, e2) {
              return t2 ? new tr({ namePrimary: t2, nameSecondary: e2, available: false }) : null;
            }
            serialize() {
              return this.nameSecondary ? ["image", this.namePrimary, this.nameSecondary] : ["image", this.namePrimary];
            }
          }
          function er(t2, e2, r2, n2) {
            return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function rr(t2) {
            if (null === t2)
              return true;
            if ("string" == typeof t2)
              return true;
            if ("boolean" == typeof t2)
              return true;
            if ("number" == typeof t2)
              return true;
            if (t2 instanceof Pe)
              return true;
            if (t2 instanceof Ke)
              return true;
            if (t2 instanceof Qe)
              return true;
            if (t2 instanceof tr)
              return true;
            if (Array.isArray(t2)) {
              for (const e2 of t2)
                if (!rr(e2))
                  return false;
              return true;
            }
            if ("object" == typeof t2) {
              for (const e2 in t2)
                if (!rr(t2[e2]))
                  return false;
              return true;
            }
            return false;
          }
          function nr(t2) {
            if (null === t2)
              return Re;
            if ("string" == typeof t2)
              return Le;
            if ("boolean" == typeof t2)
              return Fe;
            if ("number" == typeof t2)
              return De;
            if (t2 instanceof Pe)
              return Oe;
            if (t2 instanceof Ke)
              return Ne;
            if (t2 instanceof Qe)
              return qe;
            if (t2 instanceof tr)
              return $e;
            if (Array.isArray(t2)) {
              const e2 = t2.length;
              let r2;
              for (const e3 of t2) {
                const t3 = nr(e3);
                if (r2) {
                  if (r2 === t3)
                    continue;
                  r2 = je;
                  break;
                }
                r2 = t3;
              }
              return Ge(r2 || je, e2);
            }
            return Ue;
          }
          function ir(t2) {
            const e2 = typeof t2;
            return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Pe || t2 instanceof Qe || t2 instanceof tr ? t2.toString() : JSON.stringify(t2);
          }
          class sr {
            constructor(t2, e2) {
              this.type = t2, this.value = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!rr(t2[1]))
                return e2.error("invalid value");
              const r2 = t2[1];
              let n2 = nr(r2);
              const i2 = e2.expectedType;
              return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new sr(n2, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Pe ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Qe ? this.value.serialize() : this.value;
            }
          }
          class ar {
            constructor(t2) {
              this.name = "ExpressionEvaluationError", this.message = t2;
            }
            toJSON() {
              return this.message;
            }
          }
          const or = { string: Le, number: De, boolean: Fe, object: Ue };
          class lr {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              let r2, n2 = 1;
              const i2 = t2[0];
              if ("array" === i2) {
                let i3, s3;
                if (t2.length > 2) {
                  const r3 = t2[1];
                  if ("string" != typeof r3 || !(r3 in or) || "object" === r3)
                    return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = or[r3], n2++;
                } else
                  i3 = je;
                if (t2.length > 3) {
                  if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                    return e2.error('The length argument to "array" must be a positive integer literal', 2);
                  s3 = t2[2], n2++;
                }
                r2 = Ge(i3, s3);
              } else
                r2 = or[i2];
              const s2 = [];
              for (; n2 < t2.length; n2++) {
                const r3 = e2.parse(t2[n2], n2, je);
                if (!r3)
                  return null;
                s2.push(r3);
              }
              return new lr(r2, s2);
            }
            evaluate(t2) {
              for (let e2 = 0; e2 < this.args.length; e2++) {
                const r2 = this.args[e2].evaluate(t2);
                if (!Ze(this.type, nr(r2)))
                  return r2;
                if (e2 === this.args.length - 1)
                  throw new ar(`The expression ${JSON.stringify(this.args[e2].serialize())} evaluated to ${Xe(nr(r2))} but was expected to be of type ${Xe(this.type)}.`);
              }
              return null;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = this.type, e2 = [t2.kind];
              if ("array" === t2.kind) {
                const r2 = t2.itemType;
                if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                  e2.push(r2.kind);
                  const n2 = t2.N;
                  ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
                }
              }
              return e2.concat(this.args.map((t3) => t3.serialize()));
            }
          }
          class ur {
            constructor(t2) {
              this.type = qe, this.sections = t2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r2 = t2[1];
              if (!Array.isArray(r2) && "object" == typeof r2)
                return e2.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
                const s2 = t2[r3];
                if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                  i2 = false;
                  let t3 = null;
                  if (s2["font-scale"] && (t3 = e2.parseObjectValue(s2["font-scale"], r3, "font-scale", De), !t3))
                    return null;
                  let a2 = null;
                  if (s2["text-font"] && (a2 = e2.parseObjectValue(s2["text-font"], r3, "text-font", Ge(Le)), !a2))
                    return null;
                  let o2 = null;
                  if (s2["text-color"] && (o2 = e2.parseObjectValue(s2["text-color"], r3, "text-color", Oe), !o2))
                    return null;
                  const l2 = n2[n2.length - 1];
                  l2.scale = t3, l2.font = a2, l2.textColor = o2;
                } else {
                  const s3 = e2.parse(t2[r3], r3, je);
                  if (!s3)
                    return null;
                  const a2 = s3.type.kind;
                  if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                    return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
                }
              }
              return new ur(n2);
            }
            evaluate(t2) {
              return new Qe(this.sections.map((e2) => {
                const r2 = e2.content.evaluate(t2);
                return nr(r2) === $e ? new Je("", r2, null, null, null) : new Je(ir(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e2 of this.sections)
                t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                t2.push(e2.content.serialize());
                const r2 = {};
                e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
              }
              return t2;
            }
          }
          class cr {
            constructor(t2, e2) {
              this.type = $e, this.inputPrimary = t2, this.inputSecondary = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected two or more arguments.");
              const r2 = e2.parse(t2[1], 1, Le);
              if (!r2)
                return e2.error("No image name provided.");
              if (2 === t2.length)
                return new cr(r2);
              const n2 = e2.parse(t2[2], 1, Le);
              return n2 ? new cr(r2, n2) : e2.error("Secondary image variant is not a string.");
            }
            evaluate(t2) {
              const e2 = tr.fromString(this.inputPrimary.evaluate(t2), this.inputSecondary ? this.inputSecondary.evaluate(t2) : void 0);
              return e2 && t2.availableImages && (e2.available = t2.availableImages.indexOf(e2.namePrimary) > -1, e2.nameSecondary && e2.available && t2.availableImages && (e2.available = t2.availableImages.indexOf(e2.nameSecondary) > -1)), e2;
            }
            eachChild(t2) {
              t2(this.inputPrimary), this.inputSecondary && t2(this.inputSecondary);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return this.inputSecondary ? ["image", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ["image", this.inputPrimary.serialize()];
            }
          }
          function hr(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
          }
          const pr = { "to-boolean": Fe, "to-color": Oe, "to-number": De, "to-string": Le };
          class fr {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expected at least one argument.");
              const r2 = t2[0], n2 = [];
              let i2 = Re;
              if ("to-array" === r2) {
                if (!Array.isArray(t2[1]))
                  return null;
                const r3 = t2[1].length;
                if (e2.expectedType) {
                  if ("array" !== e2.expectedType.kind)
                    return e2.error(`Expected ${e2.expectedType.kind} but found array.`);
                  i2 = Ge(e2.expectedType.itemType, r3);
                } else {
                  if (!(r3 > 0 && rr(t2[1][0])))
                    return null;
                  i2 = Ge(nr(t2[1][0]), r3);
                }
                for (let s2 = 0; s2 < r3; s2++) {
                  const r4 = t2[1][s2];
                  let a2;
                  if ("array" === hr(r4))
                    a2 = e2.parse(r4, void 0, i2.itemType);
                  else {
                    const t3 = hr(r4);
                    if (t3 !== i2.itemType.kind)
                      return e2.error(`Expected ${i2.itemType.kind} but found ${t3}.`);
                    a2 = e2.registry.literal.parse(["literal", void 0 === r4 ? null : r4], e2);
                  }
                  if (!a2)
                    return null;
                  n2.push(a2);
                }
              } else {
                if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
                  return e2.error("Expected one argument.");
                i2 = pr[r2];
                for (let r3 = 1; r3 < t2.length; r3++) {
                  const i3 = e2.parse(t2[r3], r3, je);
                  if (!i3)
                    return null;
                  n2.push(i3);
                }
              }
              return new fr(i2, n2);
            }
            evaluate(t2) {
              if ("boolean" === this.type.kind)
                return Boolean(this.args[0].evaluate(t2));
              if ("color" === this.type.kind) {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Pe)
                    return e2;
                  if ("string" == typeof e2) {
                    const r3 = t2.parseColor(e2);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : er(e2[0], e2[1], e2[2], e2[3]), !r2))
                    return new Pe(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new ar(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
              }
              if ("number" === this.type.kind) {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), null === e2)
                    return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new ar(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              return "formatted" === this.type.kind ? Qe.fromString(ir(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? tr.fromString(ir(this.args[0].evaluate(t2))) : "array" === this.type.kind ? this.args.map((e2) => e2.evaluate(t2)) : ir(this.args[0].evaluate(t2));
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              if ("formatted" === this.type.kind)
                return new ur([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
              if ("resolvedImage" === this.type.kind)
                return new cr(this.args[0]).serialize();
              const t2 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const dr = ["Unknown", "Point", "LineString", "Polygon"];
          class mr {
            constructor(t2, e2) {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t2, this.options = e2;
            }
            id() {
              return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? dr[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            measureLight(t2) {
              return this.globals.brightness || 0;
            }
            distanceFromCenter() {
              if (this.featureTileCoord && this.featureDistanceData) {
                const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r2, y: n2 } = this.featureTileCoord;
                return this.featureDistanceData.bearing[0] * (r2 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e2 - t2[1]);
              }
              return 0;
            }
            parseColor(t2) {
              let e2 = this._parseColorCache[t2];
              return e2 || (e2 = this._parseColorCache[t2] = Pe.parse(t2)), e2;
            }
            getConfig(t2) {
              return this.options ? this.options.get(t2) : null;
            }
          }
          class yr {
            constructor(t2, e2, r2, n2, i2) {
              this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2, this._overloadIndex = i2;
            }
            evaluate(t2) {
              if (!this._evaluate) {
                const t3 = yr.definitions[this.name];
                this._evaluate = Array.isArray(t3) ? t3[2] : t3.overloads[this._overloadIndex][1];
              }
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return [this.name].concat(this.args.map((t2) => t2.serialize()));
            }
            static parse(t2, e2) {
              const r2 = t2[0], n2 = yr.definitions[r2];
              if (!n2)
                return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = [];
              let o2 = null, l2 = -1;
              for (const [n3, u2] of s2) {
                if (Array.isArray(n3) && n3.length !== t2.length - 1)
                  continue;
                a2.push(n3), l2++, o2 = new Ln(e2.registry, e2.path, null, e2.scope, void 0, e2._scope, e2.options);
                const s3 = [];
                let c2 = false;
                for (let e3 = 1; e3 < t2.length; e3++) {
                  const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, a3 = o2.parse(r3, 1 + s3.length, i3);
                  if (!a3) {
                    c2 = true;
                    break;
                  }
                  s3.push(a3);
                }
                if (!c2)
                  if (Array.isArray(n3) && n3.length !== s3.length)
                    o2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
                  else {
                    for (let t3 = 0; t3 < s3.length; t3++) {
                      const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                      o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                    }
                    if (0 === o2.errors.length)
                      return new yr(r2, i2, u2, s3, l2);
                  }
              }
              if (1 === a2.length)
                e2.errors.push(...o2.errors);
              else {
                const r3 = (a2.length ? a2 : s2.map(([t3]) => t3)).map(gr).join(" | "), n3 = [];
                for (let r4 = 1; r4 < t2.length; r4++) {
                  const i3 = e2.parse(t2[r4], 1 + n3.length);
                  if (!i3)
                    return null;
                  n3.push(Xe(i3.type));
                }
                e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e2) {
              yr.definitions = e2;
              for (const r2 in e2)
                t2[r2] = yr;
            }
          }
          function gr(t2) {
            return Array.isArray(t2) ? `(${t2.map(Xe).join(", ")})` : `(${Xe(t2.type)}...)`;
          }
          class xr {
            constructor(t2, e2, r2) {
              this.type = Ne, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error("Expected one argument.");
              const r2 = t2[1];
              if ("object" != typeof r2 || Array.isArray(r2))
                return e2.error("Collator options argument must be an object.");
              const n2 = void 0 === r2["case-sensitive"] ? e2.parse(false, 1, Fe) : e2.parseObjectValue(r2["case-sensitive"], 1, "case-sensitive", Fe);
              if (!n2)
                return null;
              const i2 = void 0 === r2["diacritic-sensitive"] ? e2.parse(false, 1, Fe) : e2.parseObjectValue(r2["diacritic-sensitive"], 1, "diacritic-sensitive", Fe);
              if (!i2)
                return null;
              let s2 = null;
              return r2.locale && (s2 = e2.parseObjectValue(r2.locale, 1, "locale", Le), !s2) ? null : new xr(n2, i2, s2);
            }
            evaluate(t2) {
              return new Ke(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
            }
          }
          function br(t2, e2, r2 = 0, n2 = t2.length - 1, i2 = wr) {
            for (; n2 > r2; ) {
              if (n2 - r2 > 600) {
                const s3 = n2 - r2 + 1, a3 = e2 - r2 + 1, o3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * o3 / 3), u2 = 0.5 * Math.sqrt(o3 * l2 * (s3 - l2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
                br(t2, e2, Math.max(r2, Math.floor(e2 - a3 * l2 / s3 + u2)), Math.min(n2, Math.floor(e2 + (s3 - a3) * l2 / s3 + u2)), i2);
              }
              const s2 = t2[e2];
              let a2 = r2, o2 = n2;
              for (vr(t2, r2, e2), i2(t2[n2], s2) > 0 && vr(t2, r2, n2); a2 < o2; ) {
                for (vr(t2, a2, o2), a2++, o2--; i2(t2[a2], s2) < 0; )
                  a2++;
                for (; i2(t2[o2], s2) > 0; )
                  o2--;
              }
              0 === i2(t2[r2], s2) ? vr(t2, r2, o2) : (o2++, vr(t2, o2, n2)), o2 <= e2 && (r2 = o2 + 1), e2 <= o2 && (n2 = o2 - 1);
            }
          }
          function vr(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function wr(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function _r(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
              r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          function Mr(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function Ar(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function Sr(t2, e2, r2) {
            const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
            return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
          }
          function Ir(t2, e2, r2 = false) {
            let n2 = false;
            for (let o2 = 0, l2 = e2.length; o2 < l2; o2++) {
              const l3 = e2[o2];
              for (let e3 = 0, o3 = l3.length, u2 = o3 - 1; e3 < o3; u2 = e3++) {
                const o4 = l3[u2], c2 = l3[e3];
                if (Sr(t2, o4, c2))
                  return r2;
                (s2 = o4)[1] > (i2 = t2)[1] != (a2 = c2)[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
              }
            }
            var i2, s2, a2;
            return n2;
          }
          function Pr(t2, e2, r2, n2) {
            const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
            return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
          }
          function zr(t2, e2, r2, n2) {
            return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] && !(!Pr(t2, e2, r2, n2) || !Pr(r2, n2, t2, e2));
            var i2, s2;
          }
          const kr = 8192;
          function Tr(t2, e2) {
            const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r2 * i2 * kr), Math.round(n2 * i2 * kr)];
          }
          function Er(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++)
              if (Ir(t2, e2[r2]))
                return true;
            return false;
          }
          function Br(t2, e2, r2) {
            for (const n2 of r2)
              for (let r3 = 0, i2 = n2.length, s2 = i2 - 1; r3 < i2; s2 = r3++)
                if (zr(t2, e2, n2[s2], n2[r3]))
                  return true;
            return false;
          }
          function Vr(t2, e2) {
            for (let r2 = 0; r2 < t2.length; ++r2)
              if (!Ir(t2[r2], e2))
                return false;
            for (let r2 = 0; r2 < t2.length - 1; ++r2)
              if (Br(t2[r2], t2[r2 + 1], e2))
                return false;
            return true;
          }
          function Cr(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++)
              if (Vr(t2, e2[r2]))
                return true;
            return false;
          }
          function Rr(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const a2 = Tr(t2[i2][n3], r2);
                Mr(e2, a2), s2.push(a2);
              }
              n2.push(s2);
            }
            return n2;
          }
          function Dr(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = Rr(t2[i2], e2, r2);
              n2.push(s2);
            }
            return n2;
          }
          function Lr(t2, e2, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              const e3 = 0.5 * n2;
              let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
              0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
            }
            Mr(e2, t2);
          }
          function Fr(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * kr, s2 = [n2.x * kr, n2.y * kr], a2 = [];
            if (!t2)
              return a2;
            for (const n3 of t2)
              for (const t3 of n3) {
                const n4 = [t3.x + s2[0], t3.y + s2[1]];
                Lr(n4, e2, r2, i2), a2.push(n4);
              }
            return a2;
          }
          function Or(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * kr, s2 = [n2.x * kr, n2.y * kr], a2 = [];
            if (!t2)
              return a2;
            for (const r3 of t2) {
              const t3 = [];
              for (const n3 of r3) {
                const r4 = [n3.x + s2[0], n3.y + s2[1]];
                Mr(e2, r4), t3.push(r4);
              }
              a2.push(t3);
            }
            if (e2[2] - e2[0] <= i2 / 2) {
              (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t3 of a2)
                for (const n3 of t3)
                  Lr(n3, e2, r2, i2);
            }
            var o2;
            return a2;
          }
          class Ur {
            constructor(t2, e2) {
              this.type = Fe, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (rr(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type)
                  for (let t3 = 0; t3 < e3.features.length; ++t3) {
                    const r2 = e3.features[t3].geometry.type;
                    if ("Polygon" === r2 || "MultiPolygon" === r2)
                      return new Ur(e3, e3.features[t3].geometry);
                  }
                else if ("Feature" === e3.type) {
                  const t3 = e3.geometry.type;
                  if ("Polygon" === t3 || "MultiPolygon" === t3)
                    return new Ur(e3, e3.geometry);
                } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
                  return new Ur(e3, e3);
              }
              return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (null != t2.geometry() && null != t2.canonicalID()) {
                if ("Point" === t2.geometryType())
                  return function(t3, e2) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (!i2)
                      return false;
                    if ("Polygon" === e2.type) {
                      const s2 = Rr(e2.coordinates, n2, i2), a2 = Fr(t3.geometry(), r2, n2, i2);
                      if (!Ar(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Ir(t4, s2))
                          return false;
                    }
                    if ("MultiPolygon" === e2.type) {
                      const s2 = Dr(e2.coordinates, n2, i2), a2 = Fr(t3.geometry(), r2, n2, i2);
                      if (!Ar(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Er(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
                if ("LineString" === t2.geometryType())
                  return function(t3, e2) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if (!i2)
                      return false;
                    if ("Polygon" === e2.type) {
                      const s2 = Rr(e2.coordinates, n2, i2), a2 = Or(t3.geometry(), r2, n2, i2);
                      if (!Ar(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Vr(t4, s2))
                          return false;
                    }
                    if ("MultiPolygon" === e2.type) {
                      const s2 = Dr(e2.coordinates, n2, i2), a2 = Or(t3.geometry(), r2, n2, i2);
                      if (!Ar(r2, n2))
                        return false;
                      for (const t4 of a2)
                        if (!Cr(t4, s2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["within", this.geojson];
            }
          }
          const jr = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, Nr = 1 / 298.257223563, qr = Nr * (2 - Nr), $r = Math.PI / 180;
          class Gr {
            static fromTile(t2, e2, r2) {
              const n2 = Math.PI * (1 - 2 * (t2 + 0.5) / Math.pow(2, e2)), i2 = Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2))) / $r;
              return new Gr(i2, r2);
            }
            static get units() {
              return jr;
            }
            constructor(t2, e2) {
              if (void 0 === t2)
                throw new Error("No latitude given.");
              if (e2 && !jr[e2])
                throw new Error(`Unknown unit ${e2}. Use one of: ${Object.keys(jr).join(", ")}`);
              const r2 = 6378.137 * $r * (e2 ? jr[e2] : 1), n2 = Math.cos(t2 * $r), i2 = 1 / (1 - qr * (1 - n2 * n2)), s2 = Math.sqrt(i2);
              this.kx = r2 * s2 * n2, this.ky = r2 * s2 * i2 * (1 - qr);
            }
            distance(t2, e2) {
              const r2 = Zr(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
              return Math.sqrt(r2 * r2 + n2 * n2);
            }
            bearing(t2, e2) {
              const r2 = Zr(e2[0] - t2[0]) * this.kx;
              return Math.atan2(r2, (e2[1] - t2[1]) * this.ky) / $r;
            }
            destination(t2, e2, r2) {
              const n2 = r2 * $r;
              return this.offset(t2, Math.sin(n2) * e2, Math.cos(n2) * e2);
            }
            offset(t2, e2, r2) {
              return [t2[0] + e2 / this.kx, t2[1] + r2 / this.ky];
            }
            lineDistance(t2) {
              let e2 = 0;
              for (let r2 = 0; r2 < t2.length - 1; r2++)
                e2 += this.distance(t2[r2], t2[r2 + 1]);
              return e2;
            }
            area(t2) {
              let e2 = 0;
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2[r2];
                for (let t3 = 0, i2 = n2.length, s2 = i2 - 1; t3 < i2; s2 = t3++)
                  e2 += Zr(n2[t3][0] - n2[s2][0]) * (n2[t3][1] + n2[s2][1]) * (r2 ? -1 : 1);
              }
              return Math.abs(e2) / 2 * this.kx * this.ky;
            }
            along(t2, e2) {
              let r2 = 0;
              if (e2 <= 0)
                return t2[0];
              for (let n2 = 0; n2 < t2.length - 1; n2++) {
                const i2 = t2[n2], s2 = t2[n2 + 1], a2 = this.distance(i2, s2);
                if (r2 += a2, r2 > e2)
                  return Yr(i2, s2, (e2 - (r2 - a2)) / a2);
              }
              return t2[t2.length - 1];
            }
            pointToSegmentDistance(t2, e2, r2) {
              let [n2, i2] = e2, s2 = Zr(r2[0] - n2) * this.kx, a2 = (r2[1] - i2) * this.ky;
              if (0 !== s2 || 0 !== a2) {
                const e3 = (Zr(t2[0] - n2) * this.kx * s2 + (t2[1] - i2) * this.ky * a2) / (s2 * s2 + a2 * a2);
                e3 > 1 ? (n2 = r2[0], i2 = r2[1]) : e3 > 0 && (n2 += s2 / this.kx * e3, i2 += a2 / this.ky * e3);
              }
              return s2 = Zr(t2[0] - n2) * this.kx, a2 = (t2[1] - i2) * this.ky, Math.sqrt(s2 * s2 + a2 * a2);
            }
            pointOnLine(t2, e2) {
              let r2 = 1 / 0, n2 = t2[0][0], i2 = t2[0][1], s2 = 0, a2 = 0;
              for (let o2 = 0; o2 < t2.length - 1; o2++) {
                let l2 = t2[o2][0], u2 = t2[o2][1], c2 = Zr(t2[o2 + 1][0] - l2) * this.kx, h2 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
                0 === c2 && 0 === h2 || (p2 = (Zr(e2[0] - l2) * this.kx * c2 + (e2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = Zr(e2[0] - l2) * this.kx, h2 = (e2[1] - u2) * this.ky;
                const f2 = c2 * c2 + h2 * h2;
                f2 < r2 && (r2 = f2, n2 = l2, i2 = u2, s2 = o2, a2 = p2);
              }
              return { point: [n2, i2], index: s2, t: Math.max(0, Math.min(1, a2)) };
            }
            lineSlice(t2, e2, r2) {
              let n2 = this.pointOnLine(r2, t2), i2 = this.pointOnLine(r2, e2);
              if (n2.index > i2.index || n2.index === i2.index && n2.t > i2.t) {
                const t3 = n2;
                n2 = i2, i2 = t3;
              }
              const s2 = [n2.point], a2 = n2.index + 1, o2 = i2.index;
              !Xr(r2[a2], s2[0]) && a2 <= o2 && s2.push(r2[a2]);
              for (let t3 = a2 + 1; t3 <= o2; t3++)
                s2.push(r2[t3]);
              return Xr(r2[o2], i2.point) || s2.push(i2.point), s2;
            }
            lineSliceAlong(t2, e2, r2) {
              let n2 = 0;
              const i2 = [];
              for (let s2 = 0; s2 < r2.length - 1; s2++) {
                const a2 = r2[s2], o2 = r2[s2 + 1], l2 = this.distance(a2, o2);
                if (n2 += l2, n2 > t2 && 0 === i2.length && i2.push(Yr(a2, o2, (t2 - (n2 - l2)) / l2)), n2 >= e2)
                  return i2.push(Yr(a2, o2, (e2 - (n2 - l2)) / l2)), i2;
                n2 > t2 && i2.push(o2);
              }
              return i2;
            }
            bufferPoint(t2, e2) {
              const r2 = e2 / this.ky, n2 = e2 / this.kx;
              return [t2[0] - n2, t2[1] - r2, t2[0] + n2, t2[1] + r2];
            }
            bufferBBox(t2, e2) {
              const r2 = e2 / this.ky, n2 = e2 / this.kx;
              return [t2[0] - n2, t2[1] - r2, t2[2] + n2, t2[3] + r2];
            }
            insideBBox(t2, e2) {
              return Zr(t2[0] - e2[0]) >= 0 && Zr(t2[0] - e2[2]) <= 0 && t2[1] >= e2[1] && t2[1] <= e2[3];
            }
          }
          function Xr(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1];
          }
          function Yr(t2, e2, r2) {
            const n2 = Zr(e2[0] - t2[0]);
            return [t2[0] + n2 * r2, t2[1] + (e2[1] - t2[1]) * r2];
          }
          function Zr(t2) {
            for (; t2 < -180; )
              t2 += 360;
            for (; t2 > 180; )
              t2 -= 360;
            return t2;
          }
          class Wr {
            constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
                for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                  this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this._up(this.length++);
            }
            pop() {
              if (0 === this.length)
                return;
              const t2 = this.data[0], e2 = this.data.pop();
              return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r2 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r2(n2, s2) >= 0)
                  break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1);
                const s2 = n3 + 1;
                if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
                  break;
                e2[t2] = e2[n3], t2 = n3;
              }
              e2[t2] = i2;
            }
          }
          var Hr = 8192;
          function Kr(t2, e2) {
            return e2.dist - t2.dist;
          }
          const Jr = 100, Qr = 50;
          function tn(t2) {
            const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            if (e2.length !== t2.length)
              return false;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (e2[r2] !== t2[r2])
                return false;
            return true;
          }
          function en(t2) {
            return t2[1] - t2[0] + 1;
          }
          function rn(t2, e2) {
            const r2 = t2[1] >= t2[0] && t2[1] < e2;
            return r2 || console.warn("Distance Expression: Index is out of range"), r2;
          }
          function nn(t2, e2) {
            if (t2[0] > t2[1])
              return [null, null];
            const r2 = en(t2);
            if (e2) {
              if (2 === r2)
                return [t2, null];
              const e3 = Math.floor(r2 / 2);
              return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
            }
            {
              if (1 === r2)
                return [t2, null];
              const e3 = Math.floor(r2 / 2) - 1;
              return [[t2[0], t2[0] + e3], [t2[0] + e3 + 1, t2[1]]];
            }
          }
          function sn(t2, e2) {
            const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            if (!rn(e2, t2.length))
              return r2;
            for (let n2 = e2[0]; n2 <= e2[1]; ++n2)
              Mr(r2, t2[n2]);
            return r2;
          }
          function an(t2) {
            const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let r2 = 0; r2 < t2.length; ++r2)
              for (let n2 = 0; n2 < t2[r2].length; ++n2)
                Mr(e2, t2[r2][n2]);
            return e2;
          }
          function on(t2, e2, r2) {
            if (tn(t2) || tn(e2))
              return NaN;
            let n2 = 0, i2 = 0;
            return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
          }
          function ln(t2) {
            return 360 * t2 - 180;
          }
          function un(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function cn(t2, e2) {
            const r2 = Math.pow(2, e2.z), n2 = (t2.y / Hr + e2.y) / r2;
            return [ln((t2.x / Hr + e2.x) / r2), un(n2)];
          }
          function hn(t2, e2) {
            const r2 = [];
            for (let n2 = 0; n2 < t2.length; ++n2)
              r2.push(cn(t2[n2], e2));
            return r2;
          }
          function pn(t2, e2, r2) {
            const n2 = r2.pointOnLine(e2, t2).point;
            return r2.distance(t2, n2);
          }
          function fn(t2, e2, r2, n2, i2) {
            const s2 = r2.slice(n2[0], n2[1] + 1);
            let a2 = 1 / 0;
            for (let r3 = e2[0]; r3 <= e2[1]; ++r3)
              if (0 === (a2 = Math.min(a2, pn(t2[r3], s2, i2))))
                return 0;
            return a2;
          }
          function dn(t2, e2, r2, n2, i2) {
            const s2 = Math.min(i2.pointToSegmentDistance(t2, r2, n2), i2.pointToSegmentDistance(e2, r2, n2)), a2 = Math.min(i2.pointToSegmentDistance(r2, t2, e2), i2.pointToSegmentDistance(n2, t2, e2));
            return Math.min(s2, a2);
          }
          function mn(t2, e2, r2, n2, i2) {
            if (!rn(e2, t2.length) || !rn(n2, r2.length))
              return NaN;
            let s2 = 1 / 0;
            for (let a2 = e2[0]; a2 < e2[1]; ++a2)
              for (let e3 = n2[0]; e3 < n2[1]; ++e3) {
                if (zr(t2[a2], t2[a2 + 1], r2[e3], r2[e3 + 1]))
                  return 0;
                s2 = Math.min(s2, dn(t2[a2], t2[a2 + 1], r2[e3], r2[e3 + 1], i2));
              }
            return s2;
          }
          function yn(t2, e2, r2, n2, i2) {
            if (!rn(e2, t2.length) || !rn(n2, r2.length))
              return NaN;
            let s2 = 1 / 0;
            for (let a2 = e2[0]; a2 <= e2[1]; ++a2)
              for (let e3 = n2[0]; e3 <= n2[1]; ++e3)
                if (0 === (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3]))))
                  return s2;
            return s2;
          }
          function gn(t2, e2, r2) {
            if (Ir(t2, e2, true))
              return 0;
            let n2 = 1 / 0;
            for (const i2 of e2) {
              const e3 = i2.length;
              if (e3 < 2)
                return console.warn("Distance Expression: Invalid polygon!"), NaN;
              if (i2[0] !== i2[e3 - 1] && 0 === (n2 = Math.min(n2, r2.pointToSegmentDistance(t2, i2[e3 - 1], i2[0]))))
                return n2;
              if (0 === (n2 = Math.min(n2, pn(t2, i2, r2))))
                return n2;
            }
            return n2;
          }
          function xn(t2, e2, r2, n2) {
            if (!rn(e2, t2.length))
              return NaN;
            for (let n3 = e2[0]; n3 <= e2[1]; ++n3)
              if (Ir(t2[n3], r2, true))
                return 0;
            let i2 = 1 / 0;
            for (let s2 = e2[0]; s2 < e2[1]; ++s2)
              for (const e3 of r2)
                for (let r3 = 0, a2 = e3.length, o2 = a2 - 1; r3 < a2; o2 = r3++) {
                  if (zr(t2[s2], t2[s2 + 1], e3[o2], e3[r3]))
                    return 0;
                  i2 = Math.min(i2, dn(t2[s2], t2[s2 + 1], e3[o2], e3[r3], n2));
                }
            return i2;
          }
          function bn(t2, e2) {
            for (const r2 of t2)
              for (let t3 = 0; t3 <= r2.length - 1; ++t3)
                if (Ir(r2[t3], e2, true))
                  return true;
            return false;
          }
          function vn(t2, e2, r2, n2 = 1 / 0) {
            const i2 = an(t2), s2 = an(e2);
            if (n2 !== 1 / 0 && on(i2, s2, r2) >= n2)
              return n2;
            if (Ar(i2, s2)) {
              if (bn(t2, e2))
                return 0;
            } else if (bn(e2, t2))
              return 0;
            let a2 = n2;
            for (const n3 of t2)
              for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++)
                for (const i4 of e2)
                  for (let e3 = 0, o2 = i4.length, l2 = o2 - 1; e3 < o2; l2 = e3++) {
                    if (zr(n3[s3], n3[t3], i4[l2], i4[e3]))
                      return 0;
                    a2 = Math.min(a2, dn(n3[s3], n3[t3], i4[l2], i4[e3], r2));
                  }
            return a2;
          }
          function wn(t2, e2, r2, n2, i2, s2, a2) {
            if (null === s2 || null === a2)
              return;
            const o2 = on(sn(n2, s2), sn(i2, a2), r2);
            o2 < e2 && t2.push({ dist: o2, range1: s2, range2: a2 });
          }
          function _n(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
            if (0 === s2)
              return s2;
            const a2 = new Wr([{ dist: 0, range1: [0, t2.length - 1], range2: [0, 0] }], Kr), o2 = e2 ? Qr : Jr, l2 = an(r2);
            for (; a2.length; ) {
              const i3 = a2.pop();
              if (i3.dist >= s2)
                continue;
              const u2 = i3.range1;
              if (en(u2) <= o2) {
                if (!rn(u2, t2.length))
                  return NaN;
                if (e2) {
                  const e3 = xn(t2, u2, r2, n2);
                  if (0 === (s2 = Math.min(s2, e3)))
                    return s2;
                } else
                  for (let e3 = u2[0]; e3 <= u2[1]; ++e3) {
                    const i4 = gn(t2[e3], r2, n2);
                    if (0 === (s2 = Math.min(s2, i4)))
                      return s2;
                  }
              } else {
                const r3 = nn(u2, e2);
                if (null !== r3[0]) {
                  const e3 = on(sn(t2, r3[0]), l2, n2);
                  e3 < s2 && a2.push({ dist: e3, range1: r3[0], range2: [0, 0] });
                }
                if (null !== r3[1]) {
                  const e3 = on(sn(t2, r3[1]), l2, n2);
                  e3 < s2 && a2.push({ dist: e3, range1: r3[1], range2: [0, 0] });
                }
              }
            }
            return s2;
          }
          function Mn(t2, e2, r2, n2, i2, s2 = 1 / 0) {
            let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
            if (0 === a2)
              return a2;
            const o2 = new Wr([{ dist: 0, range1: [0, t2.length - 1], range2: [0, r2.length - 1] }], Kr), l2 = e2 ? Qr : Jr, u2 = n2 ? Qr : Jr;
            for (; o2.length; ) {
              const s3 = o2.pop();
              if (s3.dist >= a2)
                continue;
              const c2 = s3.range1, h2 = s3.range2;
              if (en(c2) <= l2 && en(h2) <= u2) {
                if (!rn(c2, t2.length) || !rn(h2, r2.length))
                  return NaN;
                if (e2 && n2 ? a2 = Math.min(a2, mn(t2, c2, r2, h2, i2)) : e2 || n2 ? e2 && !n2 ? a2 = Math.min(a2, fn(r2, h2, t2, c2, i2)) : !e2 && n2 && (a2 = Math.min(a2, fn(t2, c2, r2, h2, i2))) : a2 = Math.min(a2, yn(t2, c2, r2, h2, i2)), 0 === a2)
                  return a2;
              } else {
                const s4 = nn(c2, e2), l3 = nn(h2, n2);
                wn(o2, a2, i2, t2, r2, s4[0], l3[0]), wn(o2, a2, i2, t2, r2, s4[0], l3[1]), wn(o2, a2, i2, t2, r2, s4[1], l3[0]), wn(o2, a2, i2, t2, r2, s4[1], l3[1]);
              }
            }
            return a2;
          }
          function An(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = i2;
            const a2 = sn(t2, [0, t2.length - 1]);
            for (const i3 of r2)
              if (!(s2 !== 1 / 0 && on(a2, sn(i3, [0, i3.length - 1]), n2) >= s2) && (s2 = Math.min(s2, Mn(t2, e2, i3, true, n2, s2)), 0 === s2))
                return s2;
            return s2;
          }
          function Sn(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = i2;
            const a2 = sn(t2, [0, t2.length - 1]);
            for (const i3 of r2) {
              if (s2 !== 1 / 0 && on(a2, an(i3), n2) >= s2)
                continue;
              const r3 = _n(t2, e2, i3, n2, s2);
              if (isNaN(r3))
                return r3;
              if (0 === (s2 = Math.min(s2, r3)))
                return s2;
            }
            return s2;
          }
          function In(t2) {
            return "Point" === t2 || "MultiPoint" === t2 || "LineString" === t2 || "MultiLineString" === t2 || "Polygon" === t2 || "MultiPolygon" === t2;
          }
          class Pn {
            constructor(t2, e2) {
              this.type = De, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`'distance' expression requires either one argument, but found ' ${t2.length - 1} instead.`);
              if (rr(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type) {
                  for (let t3 = 0; t3 < e3.features.length; ++t3)
                    if (In(e3.features[t3].geometry.type))
                      return new Pn(e3, e3.features[t3].geometry);
                } else if ("Feature" === e3.type) {
                  if (In(e3.geometry.type))
                    return new Pn(e3, e3.geometry);
                } else if (In(e3.type))
                  return new Pn(e3, e3);
              }
              return e2.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
            }
            evaluate(t2) {
              const e2 = t2.geometry(), r2 = t2.canonicalID();
              if (null != e2 && null != r2) {
                if ("Point" === t2.geometryType())
                  return function(t3, e3, r3) {
                    const n2 = [];
                    for (const r4 of t3)
                      for (const t4 of r4)
                        n2.push(cn(t4, e3));
                    const i2 = new Gr(n2[0][1], "meters");
                    return "Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type ? Mn(n2, false, "Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, i2) : "MultiLineString" === r3.type ? An(n2, false, r3.coordinates, i2) : "Polygon" === r3.type || "MultiPolygon" === r3.type ? Sn(n2, false, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2) : null;
                  }(e2, r2, this.geometries);
                if ("LineString" === t2.geometryType())
                  return function(t3, e3, r3) {
                    const n2 = [];
                    for (const r4 of t3) {
                      const t4 = [];
                      for (const n3 of r4)
                        t4.push(cn(n3, e3));
                      n2.push(t4);
                    }
                    const i2 = new Gr(n2[0][0][1], "meters");
                    if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type)
                      return An("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                    if ("MultiLineString" === r3.type) {
                      let t4 = 1 / 0;
                      for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                        const s2 = An(r3.coordinates[e4], true, n2, i2, t4);
                        if (isNaN(s2))
                          return s2;
                        if (0 === (t4 = Math.min(t4, s2)))
                          return t4;
                      }
                      return t4;
                    }
                    if ("Polygon" === r3.type || "MultiPolygon" === r3.type) {
                      let t4 = 1 / 0;
                      for (let e4 = 0; e4 < n2.length; e4++) {
                        const s2 = Sn(n2[e4], true, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2, t4);
                        if (isNaN(s2))
                          return s2;
                        if (0 === (t4 = Math.min(t4, s2)))
                          return t4;
                      }
                      return t4;
                    }
                    return null;
                  }(e2, r2, this.geometries);
                if ("Polygon" === t2.geometryType())
                  return function(t3, e3, r3) {
                    const n2 = [];
                    for (const r4 of function(t4, e4) {
                      const r5 = t4.length;
                      if (r5 <= 1)
                        return [t4];
                      const n3 = [];
                      let i3, s2;
                      for (let e5 = 0; e5 < r5; e5++) {
                        const r6 = _r(t4[e5]);
                        0 !== r6 && (t4[e5].area = Math.abs(r6), void 0 === s2 && (s2 = r6 < 0), s2 === r6 < 0 ? (i3 && n3.push(i3), i3 = [t4[e5]]) : i3.push(t4[e5]));
                      }
                      return i3 && n3.push(i3), n3;
                    }(t3)) {
                      const t4 = [];
                      for (let n3 = 0; n3 < r4.length; ++n3)
                        t4.push(hn(r4[n3], e3));
                      n2.push(t4);
                    }
                    const i2 = new Gr(n2[0][0][0][1], "meters");
                    if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type)
                      return Sn("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                    if ("MultiLineString" === r3.type) {
                      let t4 = 1 / 0;
                      for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                        const s2 = Sn(r3.coordinates[e4], true, n2, i2, t4);
                        if (isNaN(s2))
                          return s2;
                        if (0 === (t4 = Math.min(t4, s2)))
                          return t4;
                      }
                      return t4;
                    }
                    return "Polygon" === r3.type || "MultiPolygon" === r3.type ? function(t4, e4, r4) {
                      let n3 = 1 / 0;
                      for (const i3 of t4)
                        for (const t5 of e4) {
                          const e5 = vn(i3, t5, r4, n3);
                          if (isNaN(e5))
                            return e5;
                          if (0 === (n3 = Math.min(n3, e5)))
                            return n3;
                        }
                      return n3;
                    }("Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, n2, i2) : null;
                  }(e2, r2, this.geometries);
                console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
              } else
                console.warn("Distance Expression: requirs valid feature and canonical information.");
              return null;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["distance", this.geojson];
            }
          }
          function zn(t2, e2) {
            switch (t2) {
              case "string":
                return ir(e2);
              case "number":
                return +e2;
              case "boolean":
                return !!e2;
              case "color":
                return Pe.parse(e2);
              case "formatted":
                return Qe.fromString(ir(e2));
              case "resolvedImage":
                return tr.fromString(ir(e2));
            }
            return e2;
          }
          function kn(t2, e2, r2, n2) {
            return void 0 !== n2 && (t2 = n2 * Math.round(t2 / n2)), void 0 !== e2 && t2 < e2 && (t2 = e2), void 0 !== r2 && t2 > r2 && (t2 = r2), t2;
          }
          class Tn {
            constructor(t2, e2, r2) {
              this.type = t2, this.key = e2, this.scope = r2;
            }
            static parse(t2, e2) {
              let r2 = e2.expectedType;
              if (null == r2 && (r2 = je), t2.length < 2 || t2.length > 3)
                return e2.error("Invalid number of arguments for 'config' expression.");
              const n2 = e2.parse(t2[1], 1);
              if (!(n2 instanceof sr))
                return e2.error("Key name of 'config' expression must be a string literal.");
              if (t2.length >= 3) {
                const i2 = e2.parse(t2[2], 2);
                return i2 instanceof sr ? new Tn(r2, ir(n2.value), ir(i2.value)) : e2.error("Scope of 'config' expression must be a string literal.");
              }
              return new Tn(r2, ir(n2.value));
            }
            evaluate(t2) {
              const e2 = [this.key, this.scope, t2.scope].filter(Boolean).join(""), r2 = t2.getConfig(e2);
              if (!r2)
                return null;
              const { type: n2, value: i2, values: s2, minValue: a2, maxValue: o2, stepValue: l2 } = r2, u2 = r2.default.evaluate(t2);
              let c2 = u2;
              if (i2) {
                const e3 = t2.scope;
                t2.scope = (e3 || "").split("").slice(1).join(""), c2 = i2.evaluate(t2), t2.scope = e3;
              }
              return n2 && (c2 = zn(n2, c2)), void 0 === c2 || void 0 === a2 && void 0 === o2 && void 0 === l2 || ("number" == typeof c2 ? c2 = kn(c2, a2, o2, l2) : Array.isArray(c2) && (c2 = c2.map((t3) => "number" == typeof t3 ? kn(t3, a2, o2, l2) : t3))), void 0 !== i2 && void 0 !== c2 && s2 && !s2.includes(c2) && (c2 = u2, n2 && (c2 = zn(n2, c2))), (n2 && n2 !== this.type || void 0 !== c2 && nr(c2) !== this.type) && (c2 = zn(this.type.kind, c2)), c2;
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["config", this.key];
              return this.scope && t2.concat(this.key), t2;
            }
          }
          function En(t2) {
            if (t2 instanceof yr) {
              if ("get" === t2.name && 1 === t2.args.length)
                return false;
              if ("feature-state" === t2.name)
                return false;
              if ("has" === t2.name && 1 === t2.args.length)
                return false;
              if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
                return false;
              if (/^filter-/.test(t2.name))
                return false;
            }
            if (t2 instanceof Ur)
              return false;
            if (t2 instanceof Pn)
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !En(t3) && (e2 = false);
            }), e2;
          }
          function Bn(t2) {
            if (t2 instanceof yr && "feature-state" === t2.name)
              return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !Bn(t3) && (e2 = false);
            }), e2;
          }
          function Vn(t2) {
            if (t2 instanceof Tn)
              return /* @__PURE__ */ new Set([t2.key]);
            let e2 = /* @__PURE__ */ new Set();
            return t2.eachChild((t3) => {
              e2 = /* @__PURE__ */ new Set([...e2, ...Vn(t3)]);
            }), e2;
          }
          function Cn(t2, e2) {
            if (t2 instanceof yr && e2.indexOf(t2.name) >= 0)
              return false;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 && !Cn(t3, e2) && (r2 = false);
            }), r2;
          }
          class Rn {
            constructor(t2, e2) {
              this.type = e2.type, this.name = t2, this.boundExpression = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length || "string" != typeof t2[1])
                return e2.error("'var' expression requires exactly one string literal argument.");
              const r2 = t2[1];
              return e2.scope.has(r2) ? new Rn(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["var", this.name];
            }
          }
          class Dn {
            constructor(t2, e2 = [], r2, n2 = new Ce(), i2 = [], s2, a2) {
              this.registry = t2, this.path = e2, this.key = e2.map((t3) => "string" == typeof t3 ? `['${t3}']` : `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2, this._scope = s2, this.options = a2;
            }
            parse(t2, e2, r2, n2, i2 = {}) {
              return e2 || r2 ? this.concat(e2, null, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            parseObjectValue(t2, e2, r2, n2, i2, s2 = {}) {
              return this.concat(e2, r2, n2, i2)._parse(t2, s2);
            }
            _parse(t2, e2) {
              function r2(t3, e3, r3) {
                return "assert" === r3 ? new lr(e3, [t3]) : "coerce" === r3 ? new fr(e3, [t3]) : t3;
              }
              if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (0 === t2.length)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = "string" == typeof t2[0] ? this.registry[t2[0]] : void 0;
                if (n2) {
                  let i2 = n2.parse(t2, this);
                  if (!i2)
                    return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, n3 = i2.type;
                    if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== n3.kind)
                      if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                        if (this.checkSubtype(t3, n3))
                          return null;
                      } else
                        i2 = r2(i2, t3, e2.typeAnnotation || "coerce");
                    else
                      i2 = r2(i2, t3, e2.typeAnnotation || "assert");
                  }
                  if (!(i2 instanceof sr) && "resolvedImage" !== i2.type.kind && Fn(i2)) {
                    const t3 = new mr(this._scope, this.options);
                    try {
                      i2 = new sr(i2.type, i2.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return i2;
                }
                return fr.parse(["to-array", t2], this);
              }
              return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e2, r2, n2) {
              let i2 = "number" == typeof t2 ? this.path.concat(t2) : this.path;
              i2 = "string" == typeof e2 ? i2.concat(e2) : i2;
              const s2 = n2 ? this.scope.concat(n2) : this.scope;
              return new Dn(this.registry, i2, r2 || null, s2, this.errors, this._scope, this.options);
            }
            error(t2, ...e2) {
              const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new Ve(r2, t2));
            }
            checkSubtype(t2, e2) {
              const r2 = Ze(t2, e2);
              return r2 && this.error(r2), r2;
            }
          }
          var Ln = Dn;
          function Fn(t2) {
            if (t2 instanceof Rn)
              return Fn(t2.boundExpression);
            if (t2 instanceof yr && "error" === t2.name)
              return false;
            if (t2 instanceof xr)
              return false;
            if (t2 instanceof Ur)
              return false;
            if (t2 instanceof Pn)
              return false;
            if (t2 instanceof Tn)
              return false;
            const e2 = t2 instanceof fr || t2 instanceof lr;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 = e2 ? r2 && Fn(t3) : r2 && t3 instanceof sr;
            }), !!r2 && En(t2) && Cn(t2, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
          }
          function On(t2, e2) {
            const r2 = t2.length - 1;
            let n2, i2, s2 = 0, a2 = r2, o2 = 0;
            for (; s2 <= a2; )
              if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
                if (o2 === r2 || e2 < i2)
                  return o2;
                s2 = o2 + 1;
              } else {
                if (!(n2 > e2))
                  throw new ar("Input is not a number.");
                a2 = o2 - 1;
              }
            return 0;
          }
          class Un {
            constructor(t2, e2, r2) {
              this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of r2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static parse(t2, e2) {
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              const r2 = e2.parse(t2[1], 1, De);
              if (!r2)
                return null;
              const n2 = [];
              let i2 = null;
              e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
              for (let r3 = 1; r3 < t2.length; r3 += 2) {
                const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
                if ("number" != typeof s2)
                  return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n2.length && n2[n2.length - 1][0] >= s2)
                  return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e2.parse(a2, l2, i2);
                if (!u2)
                  return null;
                i2 = i2 || u2.type, n2.push([s2, u2]);
              }
              return new Un(i2, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r2[0].evaluate(t2);
              const i2 = e2.length;
              return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[On(e2, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["step", this.input.serialize()];
              for (let e2 = 0; e2 < this.labels.length; e2++)
                e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
              return t2;
            }
          }
          const jn = 0.95047, Nn = 1.08883, qn = 4 / 29, $n = 6 / 29, Gn = 3 * $n * $n, Xn = $n * $n * $n, Yn = Math.PI / 180, Zn = 180 / Math.PI;
          function Wn(t2) {
            return t2 > Xn ? Math.pow(t2, 1 / 3) : t2 / Gn + qn;
          }
          function Hn(t2) {
            return t2 > $n ? t2 * t2 * t2 : Gn * (t2 - qn);
          }
          function Kn(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function Jn(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function Qn(t2) {
            const e2 = Jn(t2.r), r2 = Jn(t2.g), n2 = Jn(t2.b), i2 = Wn((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / jn), s2 = Wn((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
            return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Wn((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / Nn)), alpha: t2.a };
          }
          function ti(t2) {
            let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
            return e2 = 1 * Hn(e2), r2 = jn * Hn(r2), n2 = Nn * Hn(n2), new Pe(Kn(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Kn(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Kn(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
          }
          function ei(t2, e2, r2) {
            const n2 = e2 - t2;
            return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          const ri = { forward: Qn, reverse: ti, interpolate: function(t2, e2, r2) {
            return { l: ke(t2.l, e2.l, r2), a: ke(t2.a, e2.a, r2), b: ke(t2.b, e2.b, r2), alpha: ke(t2.alpha, e2.alpha, r2) };
          } }, ni = { forward: function(t2) {
            const { l: e2, a: r2, b: n2 } = Qn(t2), i2 = Math.atan2(n2, r2) * Zn;
            return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
          }, reverse: function(t2) {
            const e2 = t2.h * Yn, r2 = t2.c;
            return ti({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
          }, interpolate: function(t2, e2, r2) {
            return { h: ei(t2.h, e2.h, r2), c: ke(t2.c, e2.c, r2), l: ke(t2.l, e2.l, r2), alpha: ke(t2.alpha, e2.alpha, r2) };
          } };
          var ii = Object.freeze({ __proto__: null, hcl: ni, lab: ri });
          class si {
            constructor(t2, e2, r2, n2, i2) {
              this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of i2)
                this.labels.push(t3), this.outputs.push(e3);
            }
            static interpolationFactor(t2, e2, r2, n2) {
              let i2 = 0;
              if ("exponential" === t2.name)
                i2 = ai(e2, t2.base, r2, n2);
              else if ("linear" === t2.name)
                i2 = ai(e2, 1, r2, n2);
              else if ("cubic-bezier" === t2.name) {
                const s2 = t2.controlPoints;
                i2 = new j(s2[0], s2[1], s2[2], s2[3]).solve(ai(e2, 1, r2, n2));
              }
              return i2;
            }
            static parse(t2, e2) {
              let [r2, n2, i2, ...s2] = t2;
              if (!Array.isArray(n2) || 0 === n2.length)
                return e2.error("Expected an interpolation type expression.", 1);
              if ("linear" === n2[0])
                n2 = { name: "linear" };
              else if ("exponential" === n2[0]) {
                const t3 = n2[1];
                if ("number" != typeof t3)
                  return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if ("cubic-bezier" !== n2[0])
                  return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                    return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e2.error("Expected an even number of arguments.");
              if (i2 = e2.parse(i2, 2, De), !i2)
                return null;
              const a2 = [];
              let o2 = null;
              "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = Oe : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
              for (let t3 = 0; t3 < s2.length; t3 += 2) {
                const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if ("number" != typeof r3)
                  return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (a2.length && a2[a2.length - 1][0] >= r3)
                  return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u2 = e2.parse(n3, l2, o2);
                if (!u2)
                  return null;
                o2 = o2 || u2.type, a2.push([r3, u2]);
              }
              return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new si(o2, r2, n2, i2, a2) : e2.error(`Type ${Xe(o2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0])
                return r2[0].evaluate(t2);
              const i2 = e2.length;
              if (n2 >= e2[i2 - 1])
                return r2[i2 - 1].evaluate(t2);
              const s2 = On(e2, n2), a2 = si.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
              return "interpolate" === this.operator ? Ee[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? ni.reverse(ni.interpolate(ni.forward(o2), ni.forward(l2), a2)) : ri.reverse(ri.interpolate(ri.forward(o2), ri.forward(l2), a2));
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs)
                t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              let t2;
              t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
              const e2 = [this.operator, t2, this.input.serialize()];
              for (let t3 = 0; t3 < this.labels.length; t3++)
                e2.push(this.labels[t3], this.outputs[t3].serialize());
              return e2;
            }
          }
          function ai(t2, e2, r2, n2) {
            const i2 = n2 - r2, s2 = t2 - r2;
            return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
          }
          class oi {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2)
                return e2.error("Expectected at least one argument.");
              let r2 = null;
              const n2 = e2.expectedType;
              n2 && "value" !== n2.kind && (r2 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t3)
                  return null;
                r2 = r2 || t3.type, i2.push(t3);
              }
              const s2 = n2 && i2.some((t3) => Ze(n2, t3.type));
              return new oi(s2 ? je : r2, i2);
            }
            evaluate(t2) {
              let e2, r2 = null, n2 = 0;
              for (const i2 of this.args) {
                if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof tr && !r2.available && (e2 || (e2 = r2), r2 = null, n2 === this.args.length))
                  return e2;
                if (null !== r2)
                  break;
              }
              return r2;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["coalesce"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class li {
            constructor(t2, e2) {
              this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e2 of this.bindings)
                t2(e2[1]);
              t2(this.result);
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r2 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if ("string" != typeof i2)
                  return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2))
                  return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const s2 = e2.parse(t2[n3 + 1], n3 + 1);
                if (!s2)
                  return null;
                r2.push([i2, s2]);
              }
              const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
              return n2 ? new li(r2, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
            serialize() {
              const t2 = ["let"];
              for (const [e2, r2] of this.bindings)
                t2.push(e2, r2.serialize());
              return t2.push(this.result.serialize()), t2;
            }
          }
          class ui {
            constructor(t2, e2, r2) {
              this.type = t2, this.index = e2, this.input = r2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, De), n2 = e2.parse(t2[2], 2, Ge(e2.expectedType || je));
              return r2 && n2 ? new ui(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e2 < 0)
                throw new ar(`Array index out of bounds: ${e2} < 0.`);
              if (e2 >= r2.length)
                throw new ar(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
              if (e2 !== Math.floor(e2))
                throw new ar(`Array index must be an integer, but found ${e2} instead.`);
              return r2[e2];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["at", this.index.serialize(), this.input.serialize()];
            }
          }
          class ci {
            constructor(t2, e2) {
              this.type = Fe, this.needle = t2, this.haystack = e2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length)
                return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, je), n2 = e2.parse(t2[2], 2, je);
              return r2 && n2 ? We(r2.type, [Fe, Le, De, Re, je]) ? new ci(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Xe(r2.type)} instead`) : null;
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (null == r2)
                return false;
              if (!He(e2, ["boolean", "string", "number", "null"]))
                throw new ar(`Expected first argument to be of type boolean, string, number or null, but found ${Xe(nr(e2))} instead.`);
              if (!He(r2, ["string", "array"]))
                throw new ar(`Expected second argument to be of type array or string, but found ${Xe(nr(r2))} instead.`);
              return r2.indexOf(e2) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["in", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class hi {
            constructor(t2, e2, r2) {
              this.type = De, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, je), n2 = e2.parse(t2[2], 2, je);
              if (!r2 || !n2)
                return null;
              if (!We(r2.type, [Fe, Le, De, Re, je]))
                return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Xe(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, De);
                return i2 ? new hi(r2, n2, i2) : null;
              }
              return new hi(r2, n2);
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!He(e2, ["boolean", "string", "number", "null"]))
                throw new ar(`Expected first argument to be of type boolean, string, number or null, but found ${Xe(nr(e2))} instead.`);
              if (!He(r2, ["string", "array"]))
                throw new ar(`Expected second argument to be of type array or string, but found ${Xe(nr(r2))} instead.`);
              if (this.fromIndex) {
                const n2 = this.fromIndex.evaluate(t2);
                return r2.indexOf(e2, n2);
              }
              return r2.indexOf(e2);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (null != this.fromIndex && void 0 !== this.fromIndex) {
                const t2 = this.fromIndex.serialize();
                return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
              }
              return ["index-of", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class pi {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
            }
            static parse(t2, e2) {
              if (t2.length < 5)
                return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1)
                return e2.error("Expected an even number of arguments.");
              let r2, n2;
              e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
              const i2 = {}, s2 = [];
              for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
                let o3 = t2[a3];
                const l2 = t2[a3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e2.concat(a3);
                if (0 === o3.length)
                  return u2.error("Expected at least one branch label.");
                for (const t3 of o3) {
                  if ("number" != typeof t3 && "string" != typeof t3)
                    return u2.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                    return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t3 && Math.floor(t3) !== t3)
                    return u2.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u2.checkSubtype(r2, nr(t3)))
                      return null;
                  } else
                    r2 = nr(t3);
                  if (void 0 !== i2[String(t3)])
                    return u2.error("Branch labels must be unique.");
                  i2[String(t3)] = s2.length;
                }
                const c2 = e2.parse(l2, a3, n2);
                if (!c2)
                  return null;
                n2 = n2 || c2.type, s2.push(c2);
              }
              const a2 = e2.parse(t2[1], 1, je);
              if (!a2)
                return null;
              const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
              return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new pi(r2, n2, a2, i2, s2, o2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              return (nr(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
              for (const t3 of e2) {
                const e3 = n2[this.cases[t3]];
                void 0 === e3 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
              }
              const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
              for (const [e3, n3] of r2)
                t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
              return t2.push(this.otherwise.serialize()), t2;
            }
          }
          class fi {
            constructor(t2, e2, r2) {
              this.type = t2, this.branches = e2, this.otherwise = r2;
            }
            static parse(t2, e2) {
              if (t2.length < 4)
                return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0)
                return e2.error("Expected an odd number of arguments.");
              let r2;
              e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const s2 = e2.parse(t2[i3], i3, Fe);
                if (!s2)
                  return null;
                const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
                if (!a2)
                  return null;
                n2.push([s2, a2]), r2 = r2 || a2.type;
              }
              const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
              return i2 ? new fi(r2, n2, i2) : null;
            }
            evaluate(t2) {
              for (const [e2, r2] of this.branches)
                if (e2.evaluate(t2))
                  return r2.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e2, r2] of this.branches)
                t2(e2), t2(r2);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["case"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class di {
            constructor(t2, e2, r2, n2) {
              this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5)
                return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, je), n2 = e2.parse(t2[2], 2, De);
              if (!r2 || !n2)
                return null;
              if (!We(r2.type, [Ge(je), Le, je]))
                return e2.error(`Expected first argument to be of type array or string, but found ${Xe(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, De);
                return i2 ? new di(r2.type, r2, n2, i2) : null;
              }
              return new di(r2.type, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
              if (!He(e2, ["string", "array"]))
                throw new ar(`Expected first argument to be of type array or string, but found ${Xe(nr(e2))} instead.`);
              if (this.endIndex) {
                const n2 = this.endIndex.evaluate(t2);
                return e2.slice(r2, n2);
              }
              return e2.slice(r2);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (null != this.endIndex && void 0 !== this.endIndex) {
                const t2 = this.endIndex.serialize();
                return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
              }
              return ["slice", this.input.serialize(), this.beginIndex.serialize()];
            }
          }
          function mi(t2, e2) {
            return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
          }
          function yi(t2, e2, r2, n2) {
            return 0 === n2.compare(e2, r2);
          }
          function gi(t2, e2, r2) {
            const n2 = "==" !== t2 && "!=" !== t2;
            return class i2 {
              constructor(t3, e3, r3) {
                this.type = Fe, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
              }
              static parse(t3, e3) {
                if (3 !== t3.length && 4 !== t3.length)
                  return e3.error("Expected two or three arguments.");
                const r3 = t3[0];
                let s2 = e3.parse(t3[1], 1, je);
                if (!s2)
                  return null;
                if (!mi(r3, s2.type))
                  return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Xe(s2.type)}'.`);
                let a2 = e3.parse(t3[2], 2, je);
                if (!a2)
                  return null;
                if (!mi(r3, a2.type))
                  return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Xe(a2.type)}'.`);
                if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                  return e3.error(`Cannot compare types '${Xe(s2.type)}' and '${Xe(a2.type)}'.`);
                n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new lr(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new lr(s2.type, [a2])));
                let o2 = null;
                if (4 === t3.length) {
                  if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                    return e3.error("Cannot use collator to compare non-string types.");
                  if (o2 = e3.parse(t3[3], 3, Ne), !o2)
                    return null;
                }
                return new i2(s2, a2, o2);
              }
              evaluate(i3) {
                const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e3 = nr(s2), r3 = nr(a2);
                  if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                    throw new ar(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = nr(s2), r3 = nr(a2);
                  if ("string" !== t3.kind || "string" !== r3.kind)
                    return e2(i3, s2, a2);
                }
                return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
              serialize() {
                const e3 = [t2];
                return this.eachChild((t3) => {
                  e3.push(t3.serialize());
                }), e3;
              }
            };
          }
          const xi = gi("==", function(t2, e2, r2) {
            return e2 === r2;
          }, yi), bi = gi("!=", function(t2, e2, r2) {
            return e2 !== r2;
          }, function(t2, e2, r2, n2) {
            return !yi(0, e2, r2, n2);
          }), vi = gi("<", function(t2, e2, r2) {
            return e2 < r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) < 0;
          }), wi = gi(">", function(t2, e2, r2) {
            return e2 > r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) > 0;
          }), _i2 = gi("<=", function(t2, e2, r2) {
            return e2 <= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) <= 0;
          }), Mi = gi(">=", function(t2, e2, r2) {
            return e2 >= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) >= 0;
          });
          class Ai {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.type = Le, this.number = t2, this.locale = e2, this.currency = r2, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length)
                return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, De);
              if (!r2)
                return null;
              const n2 = t2[2];
              if ("object" != typeof n2 || Array.isArray(n2))
                return e2.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e2.parseObjectValue(n2.locale, 2, "locale", Le), !i2))
                return null;
              let s2 = null;
              if (n2.currency && (s2 = e2.parseObjectValue(n2.currency, 2, "currency", Le), !s2))
                return null;
              let a2 = null;
              if (n2.unit && (a2 = e2.parseObjectValue(n2.unit, 2, "unit", Le), !a2))
                return null;
              let o2 = null;
              if (n2["min-fraction-digits"] && (o2 = e2.parseObjectValue(n2["min-fraction-digits"], 2, "min-fraction-digits", De), !o2))
                return null;
              let l2 = null;
              return n2["max-fraction-digits"] && (l2 = e2.parseObjectValue(n2["max-fraction-digits"], 2, "max-fraction-digits", De), !l2) ? null : new Ai(r2, i2, s2, a2, o2, l2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
            }
          }
          class Si {
            constructor(t2) {
              this.type = De, this.input = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length)
                return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1);
              return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${Xe(r2.type)} instead.`) : new Si(r2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              if ("string" == typeof e2)
                return e2.length;
              if (Array.isArray(e2))
                return e2.length;
              throw new ar(`Expected value to be of type string or array, but found ${Xe(nr(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["length"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          function Ii(t2) {
            return function() {
              t2 = 1831565813 + (t2 |= 0) | 0;
              let e2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2);
              return e2 = e2 + Math.imul(e2 ^ e2 >>> 7, 61 | e2) ^ e2, ((e2 ^ e2 >>> 14) >>> 0) / 4294967296;
            };
          }
          const Pi = { "==": xi, "!=": bi, ">": wi, "<": vi, ">=": Mi, "<=": _i2, array: lr, at: ui, boolean: lr, case: fi, coalesce: oi, collator: xr, format: ur, image: cr, in: ci, "index-of": hi, interpolate: si, "interpolate-hcl": si, "interpolate-lab": si, length: Si, let: li, literal: sr, match: pi, number: lr, "number-format": Ai, object: lr, slice: di, step: Un, string: lr, "to-boolean": fr, "to-color": fr, "to-number": fr, "to-string": fr, var: Rn, within: Ur, distance: Pn, config: Tn };
          function zi(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, a2 = er(e2, r2, n2, s2);
            if (a2)
              throw new ar(a2);
            return new Pe(e2 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
          }
          function ki(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, a2 = function(t3, e3, r3, n3) {
              return "number" == typeof t3 && t3 >= 0 && t3 <= 360 ? "number" == typeof e3 && e3 >= 0 && e3 <= 100 && "number" == typeof r3 && r3 >= 0 && r3 <= 100 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid hsla value [${[t3, e3, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 'h' must be between 0 and 360.`;
            }(e2, r2, n2, s2);
            if (a2)
              throw new ar(a2);
            const o2 = `hsla(${e2}, ${r2}%, ${n2}%, ${s2})`, l2 = Pe.parse(o2);
            if (!l2)
              throw new ar(`Failed to parse HSLA color: ${o2}`);
            return l2;
          }
          function Ti(t2, e2) {
            return t2 in e2;
          }
          function Ei(t2, e2) {
            const r2 = e2[t2];
            return void 0 === r2 ? null : r2;
          }
          function Bi(t2) {
            return { type: t2 };
          }
          function Vi(t2) {
            return { result: "success", value: t2 };
          }
          function Ci(t2) {
            return { result: "error", value: t2 };
          }
          function Ri(t2, e2) {
            return !!t2 && !!t2.parameters && t2.parameters.indexOf(e2) > -1;
          }
          function Di(t2) {
            return "data-driven" === t2["property-type"];
          }
          function Li(t2) {
            return Ri(t2.expression, "measure-light");
          }
          function Fi(t2) {
            return Ri(t2.expression, "zoom");
          }
          function Oi(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function Ui(t2) {
            return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
          }
          function ji(t2) {
            return t2;
          }
          function Ni(t2, e2) {
            const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Oi(e2) ? "exponential" : "interval");
            if (r2 && ((t2 = Be({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Pe.parse(t3[1])])), t2.default = Pe.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !ii[t2.colorSpace])
              throw new Error(`Unknown color space: ${t2.colorSpace}`);
            let a2, o2, l2;
            if ("exponential" === s2)
              a2 = Xi;
            else if ("interval" === s2)
              a2 = Gi;
            else if ("categorical" === s2) {
              a2 = $i, o2 = /* @__PURE__ */ Object.create(null);
              for (const e3 of t2.stops)
                o2[e3[0]] = e3[1];
              l2 = typeof t2.stops[0][0];
            } else {
              if ("identity" !== s2)
                throw new Error(`Unknown function type "${s2}"`);
              a2 = Yi;
            }
            if (n2) {
              const r3 = {}, n3 = [];
              for (let e3 = 0; e3 < t2.stops.length; e3++) {
                const i4 = t2.stops[e3], s4 = i4[0].zoom;
                void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3)
                i3.push([r3[t3].zoom, Ni(r3[t3], e2)]);
              const s3 = { name: "linear" };
              return { kind: "composite", interpolationType: s3, interpolationFactor: si.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Xi({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
            }
            if (i2) {
              const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: si.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l2) };
            }
            return { kind: "source", evaluate(r3, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return void 0 === i3 ? qi(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
            } };
          }
          function qi(t2, e2, r2) {
            return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
          }
          function $i(t2, e2, r2, n2, i2) {
            return qi(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
          }
          function Gi(t2, e2, r2) {
            if ("number" !== hr(r2))
              return qi(t2.default, e2.default);
            const n2 = t2.stops.length;
            if (1 === n2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0])
              return t2.stops[n2 - 1][1];
            const i2 = On(t2.stops.map((t3) => t3[0]), r2);
            return t2.stops[i2][1];
          }
          function Xi(t2, e2, r2) {
            const n2 = void 0 !== t2.base ? t2.base : 1;
            if ("number" !== hr(r2))
              return qi(t2.default, e2.default);
            const i2 = t2.stops.length;
            if (1 === i2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0])
              return t2.stops[i2 - 1][1];
            const s2 = On(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
              const i3 = n3 - r3, s3 = t3 - r3;
              return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
            }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
            let u2 = Ee[e2.type] || ji;
            if (t2.colorSpace && "rgb" !== t2.colorSpace) {
              const e3 = ii[t2.colorSpace];
              u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
            }
            return "function" == typeof o2.evaluate ? { evaluate(...t3) {
              const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
              if (void 0 !== e3 && void 0 !== r3)
                return u2(e3, r3, a2);
            } } : u2(o2, l2, a2);
          }
          function Yi(t2, e2, r2) {
            return "color" === e2.type ? r2 = Pe.parse(r2) : "formatted" === e2.type ? r2 = Qe.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = tr.fromString(r2.toString()) : hr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), qi(r2, t2.default, e2.default);
          }
          yr.register(Pi, { error: [{ kind: "error" }, [Le], (t2, [e2]) => {
            throw new ar(e2.evaluate(t2));
          }], typeof: [Le, [je], (t2, [e2]) => Xe(nr(e2.evaluate(t2)))], "to-rgba": [Ge(De, 4), [Oe], (t2, [e2]) => e2.evaluate(t2).toRenderColor(null).toArray()], rgb: [Oe, [De, De, De], zi], rgba: [Oe, [De, De, De, De], zi], hsl: [Oe, [De, De, De], ki], hsla: [Oe, [De, De, De, De], ki], has: { type: Fe, overloads: [[[Le], (t2, [e2]) => Ti(e2.evaluate(t2), t2.properties())], [[Le, Ue], (t2, [e2, r2]) => Ti(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: je, overloads: [[[Le], (t2, [e2]) => Ei(e2.evaluate(t2), t2.properties())], [[Le, Ue], (t2, [e2, r2]) => Ei(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [je, [Le], (t2, [e2]) => Ei(e2.evaluate(t2), t2.featureState || {})], properties: [Ue, [], (t2) => t2.properties()], "geometry-type": [Le, [], (t2) => t2.geometryType()], id: [je, [], (t2) => t2.id()], zoom: [De, [], (t2) => t2.globals.zoom], pitch: [De, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [De, [], (t2) => t2.distanceFromCenter()], "measure-light": [De, [Le], (t2, [e2]) => t2.measureLight(e2.evaluate(t2))], "heatmap-density": [De, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [De, [], (t2) => t2.globals.lineProgress || 0], "raster-value": [De, [], (t2) => t2.globals.rasterValue || 0], "raster-particle-speed": [De, [], (t2) => t2.globals.rasterParticleSpeed || 0], "sky-radial-progress": [De, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [je, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [De, Bi(De), (t2, e2) => {
            let r2 = 0;
            for (const n2 of e2)
              r2 += n2.evaluate(t2);
            return r2;
          }], "*": [De, Bi(De), (t2, e2) => {
            let r2 = 1;
            for (const n2 of e2)
              r2 *= n2.evaluate(t2);
            return r2;
          }], "-": { type: De, overloads: [[[De, De], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[De], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [De, [De, De], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [De, [De, De], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [De, [], () => Math.LN2], pi: [De, [], () => Math.PI], e: [De, [], () => Math.E], "^": [De, [De, De], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [De, [De], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [De, [De], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [De, [De], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [De, [De], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [De, [De], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [De, [De], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [De, [De], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [De, [De], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [De, [De], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [De, [De], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [De, Bi(De), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [De, Bi(De), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [De, [De], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [De, [De], (t2, [e2]) => {
            const r2 = e2.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [De, [De], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [De, [De], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [Fe, [Le, je], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [Fe, [je], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [Fe, [Le], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [Fe, [Le, je], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [Fe, [je], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }], "filter->": [Fe, [Le, je], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [Fe, [je], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }], "filter-<=": [Fe, [Le, je], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [Fe, [je], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }], "filter->=": [Fe, [Le, je], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [Fe, [je], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }], "filter-has": [Fe, [je], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [Fe, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [Fe, [Ge(Le)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [Fe, [Ge(je)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [Fe, [Le, Ge(je)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [Fe, [Le, Ge(je)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
            for (; r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e3[i2] === t3)
                return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: Fe, overloads: [[[Fe, Fe], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Bi(Fe), (t2, e2) => {
            for (const r2 of e2)
              if (!r2.evaluate(t2))
                return false;
            return true;
          }]] }, any: { type: Fe, overloads: [[[Fe, Fe], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Bi(Fe), (t2, e2) => {
            for (const r2 of e2)
              if (r2.evaluate(t2))
                return true;
            return false;
          }]] }, "!": [Fe, [Fe], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [Fe, [Le], (t2, [e2]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2.evaluate(t2));
          }], upcase: [Le, [Le], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [Le, [Le], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [Le, Bi(je), (t2, e2) => e2.map((e3) => ir(e3.evaluate(t2))).join("")], "resolved-locale": [Le, [Ne], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()], random: [De, [De, De, je], (t2, e2) => {
            const [r2, n2, i2] = e2.map((e3) => e3.evaluate(t2));
            if (r2 > n2)
              return r2;
            if (r2 === n2)
              return r2;
            let s2;
            if ("string" == typeof i2)
              s2 = function(t3) {
                let e3 = 0;
                if (0 === t3.length)
                  return e3;
                for (let r3 = 0; r3 < t3.length; r3++)
                  e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
                return e3;
              }(i2);
            else {
              if ("number" != typeof i2)
                throw new ar(`Invalid seed input: ${i2}`);
              s2 = i2;
            }
            return r2 + Ii(s2)() * (n2 - r2);
          }] });
          class Zi {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new mr(r2, n2), this._defaultValue = e2 ? function(t3) {
                return "color" === t3.type && (Ui(t3.default) || Array.isArray(t3.default)) ? new Pe(0, 0, 0, 0) : "color" === t3.type ? Pe.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
              }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2, a2, o2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e2, r2, n2, i2, s2, a2, o2) {
              this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (null == t3 || "number" == typeof t3 && t3 != t3)
                  return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues))
                  throw new ar(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${t3.message}`)), this._defaultValue;
              }
            }
          }
          function Wi(t2) {
            return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Pi;
          }
          function Hi(t2, e2, r2, n2) {
            const i2 = new Ln(Pi, [], e2 ? function(t3) {
              const e3 = { color: Oe, string: Le, number: De, enum: Le, boolean: Fe, formatted: qe, resolvedImage: $e };
              return "array" === t3.type ? Ge(e3[t3.value] || je, t3.length) : e3[t3.type];
            }(e2) : void 0, void 0, void 0, r2, n2), s2 = i2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
            return s2 ? Vi(new Zi(s2, e2, r2, n2)) : Ci(i2.errors);
          }
          class Ki {
            constructor(t2, e2, r2) {
              this.kind = t2, this._styleExpression = e2, this.isLightConstant = r2, this.isStateDependent = "constant" !== t2 && !Bn(e2.expression), this.configDependencies = Vn(e2.expression);
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
          }
          class Ji {
            constructor(t2, e2, r2, n2, i2) {
              this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !Bn(e2.expression), this.isLightConstant = i2, this.configDependencies = Vn(e2.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
            interpolationFactor(t2, e2, r2) {
              return this.interpolationType ? si.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
            }
          }
          function Qi(t2, e2, r2, n2) {
            if ("error" === (t2 = Hi(t2, e2, r2, n2)).result)
              return t2;
            const i2 = t2.value.expression, s2 = En(i2);
            if (!s2 && !Di(e2))
              return Ci([new Ve("", "data expressions not supported")]);
            const a2 = Cn(i2, ["zoom", "pitch", "distance-from-center"]);
            if (!a2 && !Fi(e2))
              return Ci([new Ve("", "zoom expressions not supported")]);
            const o2 = Cn(i2, ["measure-light"]);
            if (!o2 && !Li(e2))
              return Ci([new Ve("", "measure-light expression not supported")]);
            const l2 = e2.expression && e2.expression.relaxZoomRestriction, u2 = es(i2);
            return u2 || a2 || l2 ? u2 instanceof Ve ? Ci([u2]) : u2 instanceof si && !Oi(e2) ? Ci([new Ve("", '"interpolate" expressions cannot be used with this property')]) : Vi(u2 ? new Ji(s2 ? "camera" : "composite", t2.value, u2.labels, u2 instanceof si ? u2.interpolation : void 0, o2) : new Ki(s2 ? "constant" : "source", t2.value, o2)) : Ci([new Ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
          }
          class ts {
            constructor(t2, e2) {
              this._parameters = t2, this._specification = e2, Be(this, Ni(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new ts(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function es(t2) {
            let e2 = null;
            if (t2 instanceof li)
              e2 = es(t2.result);
            else if (t2 instanceof oi) {
              for (const r2 of t2.args)
                if (e2 = es(r2), e2)
                  break;
            } else
              (t2 instanceof Un || t2 instanceof si) && t2.input instanceof yr && "zoom" === t2.input.name && (e2 = t2);
            return e2 instanceof Ve || t2.eachChild((t3) => {
              const r2 = es(t3);
              r2 instanceof Ve ? e2 = r2 : e2 && r2 && e2 !== r2 && (e2 = new Ve("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e2;
          }
          var rs, ns, is = function() {
            if (ns)
              return rs;
            ns = 1, rs = e2;
            var t2 = 3;
            function e2(e3, r2, n2) {
              var i2 = this.cells = [];
              if (e3 instanceof ArrayBuffer) {
                this.arrayBuffer = e3;
                var s2 = new Int32Array(this.arrayBuffer);
                e3 = s2[0], this.d = (r2 = s2[1]) + 2 * (n2 = s2[2]);
                for (var a2 = 0; a2 < this.d * this.d; a2++) {
                  var o2 = s2[t2 + a2], l2 = s2[t2 + a2 + 1];
                  i2.push(o2 === l2 ? null : s2.subarray(o2, l2));
                }
                var u2 = s2[t2 + i2.length + 1];
                this.keys = s2.subarray(s2[t2 + i2.length], u2), this.bboxes = s2.subarray(u2), this.insert = this._insertReadonly;
              } else {
                this.d = r2 + 2 * n2;
                for (var c2 = 0; c2 < this.d * this.d; c2++)
                  i2.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = r2, this.extent = e3, this.padding = n2, this.scale = r2 / e3, this.uid = 0;
              var h2 = n2 / r2 * e3;
              this.min = -h2, this.max = e3 + h2;
            }
            return e2.prototype.insert = function(t3, e3, r2, n2, i2) {
              this._forEachCell(e3, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
            }, e2.prototype._insertReadonly = function() {
              throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
            }, e2.prototype._insertCell = function(t3, e3, r2, n2, i2, s2) {
              this.cells[i2].push(s2);
            }, e2.prototype.query = function(t3, e3, r2, n2, i2) {
              var s2 = this.min, a2 = this.max;
              if (t3 <= s2 && e3 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
                return Array.prototype.slice.call(this.keys);
              var o2 = [];
              return this._forEachCell(t3, e3, r2, n2, this._queryCell, o2, {}, i2), o2;
            }, e2.prototype._queryCell = function(t3, e3, r2, n2, i2, s2, a2, o2) {
              var l2 = this.cells[i2];
              if (null !== l2)
                for (var u2 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
                  var p2 = l2[h2];
                  if (void 0 === a2[p2]) {
                    var f2 = 4 * p2;
                    (o2 ? o2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t3 <= c2[f2 + 2] && e3 <= c2[f2 + 3] && r2 >= c2[f2 + 0] && n2 >= c2[f2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
                  }
                }
            }, e2.prototype._forEachCell = function(t3, e3, r2, n2, i2, s2, a2, o2) {
              for (var l2 = this._convertToCellCoord(t3), u2 = this._convertToCellCoord(e3), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
                for (var f2 = u2; f2 <= h2; f2++) {
                  var d2 = this.d * f2 + p2;
                  if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(f2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t3, e3, r2, n2, d2, s2, a2, o2))
                    return;
                }
            }, e2.prototype._convertFromCellCoord = function(t3) {
              return (t3 - this.padding) / this.scale;
            }, e2.prototype._convertToCellCoord = function(t3) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
            }, e2.prototype.toArrayBuffer = function() {
              if (this.arrayBuffer)
                return this.arrayBuffer;
              for (var e3 = this.cells, r2 = t2 + this.cells.length + 1 + 1, n2 = 0, i2 = 0; i2 < this.cells.length; i2++)
                n2 += this.cells[i2].length;
              var s2 = new Int32Array(r2 + n2 + this.keys.length + this.bboxes.length);
              s2[0] = this.extent, s2[1] = this.n, s2[2] = this.padding;
              for (var a2 = r2, o2 = 0; o2 < e3.length; o2++) {
                var l2 = e3[o2];
                s2[t2 + o2] = a2, s2.set(l2, a2), a2 += l2.length;
              }
              return s2[t2 + e3.length] = a2, s2.set(this.keys, a2), s2[t2 + e3.length + 1] = a2 += this.keys.length, s2.set(this.bboxes, a2), a2 += this.bboxes.length, s2.buffer;
            }, rs;
          }(), ss2 = e(is);
          const as = {};
          function os(t2, e2, r2 = {}) {
            Object.defineProperty(t2, "_classRegistryKey", { value: e2, writable: false }), as[e2] = { klass: t2, omit: r2.omit || [] };
          }
          os(Object, "Object"), ss2.serialize = function(t2, e2) {
            const r2 = t2.toArrayBuffer();
            return e2 && e2.add(r2), { buffer: r2 };
          }, ss2.deserialize = function(t2) {
            return new ss2(t2.buffer);
          }, Object.defineProperty(ss2, "name", { value: "Grid" }), os(ss2, "Grid"), os(Pe, "Color"), os(Error, "Error"), os(Qe, "Formatted"), os(Je, "FormattedSection"), os(re, "AJAXError"), os(tr, "ResolvedImage"), os(ts, "StylePropertyFunction"), os(Zi, "StyleExpression", { omit: ["_evaluator"] }), os(Ji, "ZoomDependentExpression"), os(Ki, "ZoomConstantExpression"), os(yr, "CompoundExpression", { omit: ["_evaluate"] });
          for (const t2 in Pi)
            as[Pi[t2]._classRegistryKey] || os(Pi[t2], `Expression${t2}`);
          function ls(t2) {
            return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
          }
          function us(t2) {
            return self.ImageBitmap && t2 instanceof ImageBitmap;
          }
          function cs(t2, e2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
              return t2;
            if (ls(t2) || us(t2))
              return e2 && e2.add(t2), t2;
            if (ArrayBuffer.isView(t2)) {
              const r2 = t2;
              return e2 && e2.add(r2.buffer), r2;
            }
            if (t2 instanceof ImageData)
              return e2 && e2.add(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const r2 = [];
              for (const n2 of t2)
                r2.push(cs(n2, e2));
              return r2;
            }
            if (t2 instanceof Map) {
              const e3 = { $name: "Map" };
              for (const [r2, n2] of t2.entries())
                e3[r2] = cs(n2);
              return e3;
            }
            if (t2 instanceof Set) {
              const e3 = { $name: "Set" };
              let r2 = 0;
              for (const n2 of t2.values())
                e3[++r2] = cs(n2);
              return e3;
            }
            if ("object" == typeof t2) {
              const r2 = t2.constructor, n2 = r2._classRegistryKey;
              if (!n2)
                throw new Error(`can't serialize object of unregistered class ${n2}`);
              const i2 = r2.serialize ? r2.serialize(t2, e2) : {};
              if (!r2.serialize) {
                for (const r3 in t2)
                  t2.hasOwnProperty(r3) && (as[n2].omit.indexOf(r3) >= 0 || (i2[r3] = cs(t2[r3], e2)));
                t2 instanceof Error && (i2.message = t2.message);
              }
              if (i2.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== n2 && (i2.$name = n2), i2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function hs(t2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || ls(t2) || us(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
              return t2;
            if (Array.isArray(t2))
              return t2.map(hs);
            if ("object" == typeof t2) {
              const e2 = t2.$name || "Object";
              if ("Map" === e2) {
                const e3 = /* @__PURE__ */ new Map();
                for (const r3 of Object.keys(t2))
                  "$name" !== r3 && e3.set(r3, hs(t2[r3]));
                return e3;
              }
              if ("Set" === e2) {
                const e3 = /* @__PURE__ */ new Set();
                for (const r3 of Object.keys(t2))
                  "$name" !== r3 && e3.add(hs(t2[r3]));
                return e3;
              }
              const { klass: r2 } = as[e2];
              if (!r2)
                throw new Error(`can't deserialize unregistered class ${e2}`);
              if (r2.deserialize)
                return r2.deserialize(t2);
              const n2 = Object.create(r2.prototype);
              for (const e3 of Object.keys(t2))
                "$name" !== e3 && (n2[e3] = hs(t2[e3]));
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          const ps = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519, "CJK Unified Ideographs Extension B": (t2) => t2 >= 131072 && t2 <= 173791 };
          function fs(t2) {
            for (const e2 of t2)
              if (ys(e2.charCodeAt(0)))
                return true;
            return false;
          }
          function ds(t2) {
            for (const e2 of t2)
              if (!ms(e2.charCodeAt(0)))
                return false;
            return true;
          }
          function ms(t2) {
            return !(ps.Arabic(t2) || ps["Arabic Supplement"](t2) || ps["Arabic Extended-A"](t2) || ps["Arabic Presentation Forms-A"](t2) || ps["Arabic Presentation Forms-B"](t2));
          }
          function ys(t2) {
            return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(ps["Bopomofo Extended"](t2) || ps.Bopomofo(t2) || ps["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || ps["CJK Compatibility Ideographs"](t2) || ps["CJK Compatibility"](t2) || ps["CJK Radicals Supplement"](t2) || ps["CJK Strokes"](t2) || !(!ps["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || ps["CJK Unified Ideographs Extension A"](t2) || ps["CJK Unified Ideographs"](t2) || ps["Enclosed CJK Letters and Months"](t2) || ps["Hangul Compatibility Jamo"](t2) || ps["Hangul Jamo Extended-A"](t2) || ps["Hangul Jamo Extended-B"](t2) || ps["Hangul Jamo"](t2) || ps["Hangul Syllables"](t2) || ps.Hiragana(t2) || ps["Ideographic Description Characters"](t2) || ps.Kanbun(t2) || ps["Kangxi Radicals"](t2) || ps["Katakana Phonetic Extensions"](t2) || ps.Katakana(t2) && 12540 !== t2 || !(!ps["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!ps["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ps["Unified Canadian Aboriginal Syllabics"](t2) || ps["Unified Canadian Aboriginal Syllabics Extended"](t2) || ps["Vertical Forms"](t2) || ps["Yijing Hexagram Symbols"](t2) || ps["Yi Syllables"](t2) || ps["Yi Radicals"](t2))));
          }
          function gs(t2) {
            return !(ys(t2) || function(t3) {
              return !!(ps["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ps["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ps["Letterlike Symbols"](t3) || ps["Number Forms"](t3) || ps["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ps["Control Pictures"](t3) && 9251 !== t3 || ps["Optical Character Recognition"](t3) || ps["Enclosed Alphanumerics"](t3) || ps["Geometric Shapes"](t3) || ps["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || ps["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || ps["CJK Symbols and Punctuation"](t3) || ps.Katakana(t3) || ps["Private Use Area"](t3) || ps["CJK Compatibility Forms"](t3) || ps["Small Form Variants"](t3) || ps["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
            }(t2));
          }
          function xs(t2) {
            return t2 >= 1424 && t2 <= 2303 || ps["Arabic Presentation Forms-A"](t2) || ps["Arabic Presentation Forms-B"](t2);
          }
          function bs(t2, e2) {
            return !(!e2 && xs(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ps.Khmer(t2));
          }
          function vs(t2) {
            for (const e2 of t2)
              if (xs(e2.charCodeAt(0)))
                return true;
            return false;
          }
          const ws = "deferred", _s = "loading", Ms = "loaded";
          let As = null, Ss = "unavailable", Is = null;
          const Ps = function(t2) {
            t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Ss = "error"), As && As(t2);
          };
          function zs() {
            ks.fire(new be("pluginStateChange", { pluginStatus: Ss, pluginURL: Is }));
          }
          const ks = new Me(), Ts = function() {
            return Ss;
          }, Es = function() {
            if (Ss !== ws || !Is)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Ss = _s, zs(), Is && se({ url: Is }, (t2) => {
              t2 ? Ps(t2) : (Ss = Ms, zs());
            });
          }, Bs = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ss === Ms || null != Bs.applyArabicShaping, isLoading: () => Ss === _s, setState(t2) {
            Ss = t2.pluginStatus, Is = t2.pluginURL;
          }, isParsed: () => null != Bs.applyArabicShaping && null != Bs.processBidirectionalText && null != Bs.processStyledBidirectionalText, getPluginURL: () => Is };
          class Vs {
            constructor(t2, e2) {
              this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch, this.brightness = e2.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
            }
            isSupportedScript(t2) {
              return function(t3, e2) {
                for (const r2 of t3)
                  if (!bs(r2.charCodeAt(0), e2))
                    return false;
                return true;
              }(t2, Bs.isLoaded());
            }
          }
          class Cs {
            constructor(t2, e2, r2, n2) {
              this.property = t2, this.value = e2, this.expression = function(t3, e3, r3, n3) {
                if (Ui(t3))
                  return new ts(t3, e3);
                if (Wi(t3) || Array.isArray(t3) && t3.length > 0) {
                  const i2 = Qi(t3, e3, r3, n3);
                  if ("error" === i2.result)
                    throw new Error(i2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return i2.value;
                }
                {
                  let r4 = t3;
                  return "string" == typeof t3 && "color" === e3.type && (r4 = Pe.parse(t3)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => r4 };
                }
              }(void 0 === e2 ? t2.specification.default : e2, t2.specification, r2, n2);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t2, e2, r2) {
              return this.property.possiblyEvaluate(this, t2, e2, r2);
            }
          }
          class Rs {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = new Cs(t2, void 0, e2, r2);
            }
            transitioned(t2, e2) {
              return new Ls(this.property, this.value, e2, nt({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new Ls(this.property, this.value, null, {}, 0);
            }
          }
          class Ds {
            constructor(t2, e2, r2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues), this._scope = e2, this._options = r2, this.configDependencies = /* @__PURE__ */ new Set();
            }
            getValue(t2) {
              return ht(this._values[t2].value.value);
            }
            setValue(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new Rs(this._values[t2].property, this._scope, this._options)), this._values[t2].value = new Cs(this._values[t2].property, null === e2 ? void 0 : ht(e2), this._scope, this._options), this._values[t2].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t2].value.expression.configDependencies]));
            }
            setTransitionOrValue(t2, e2) {
              e2 && (this._options = e2);
              const r2 = this._properties.properties;
              if (t2)
                for (const e3 in t2) {
                  const n2 = t2[e3];
                  if (lt(e3, "-transition")) {
                    const t3 = e3.slice(0, -11);
                    r2[t3] && this.setTransition(t3, n2);
                  } else
                    r2.hasOwnProperty(e3) && this.setValue(e3, n2);
                }
            }
            getTransition(t2) {
              return ht(this._values[t2].transition);
            }
            setTransition(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new Rs(this._values[t2].property)), this._values[t2].transition = ht(e2) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
                const n2 = this.getTransition(e2);
                void 0 !== n2 && (t2[`${e2}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e2) {
              const r2 = new Fs(this._properties);
              for (const n2 of Object.keys(this._values))
                r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
              return r2;
            }
            untransitioned() {
              const t2 = new Fs(this._properties);
              for (const e2 of Object.keys(this._values))
                t2._values[e2] = this._values[e2].untransitioned();
              return t2;
            }
          }
          class Ls {
            constructor(t2, e2, r2, n2, i2) {
              const s2 = n2.delay || 0, a2 = n2.duration || 0;
              i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
              if (s2) {
                if (n2 > this.end)
                  return this.prior = null, i2;
                if (this.value.isDataDriven())
                  return this.prior = null, i2;
                if (n2 < this.begin)
                  return s2.possiblyEvaluate(t2, e2, r2);
                {
                  const a2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, H(a2));
                }
              }
              return i2;
            }
          }
          class Fs {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new js(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values))
                if (this._values[t2].prior)
                  return true;
              return false;
            }
          }
          class Os {
            constructor(t2, e2, r2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues), this._scope = e2, this._options = r2, this.configDependencies = /* @__PURE__ */ new Set();
            }
            getValue(t2) {
              return ht(this._values[t2].value);
            }
            setValue(t2, e2) {
              this._values[t2] = new Cs(this._values[t2].property, null === e2 ? void 0 : ht(e2), this._scope, this._options), this._values[t2].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t2].expression.configDependencies]));
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
              }
              return t2;
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new js(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
          }
          class Us {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = e2, this.parameters = r2;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t2) {
              return "constant" === this.value.kind ? this.value.value : t2;
            }
            evaluate(t2, e2, r2, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
            }
          }
          class js {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class Ns {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return t2.expression.evaluate(e2);
            }
            interpolate(t2, e2, r2) {
              const n2 = Ee[this.specification.type];
              return n2 ? n2(t2, e2, r2) : t2;
            }
          }
          class qs {
            constructor(t2, e2) {
              this.specification = t2, this.overrides = e2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return new Us(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
            }
            interpolate(t2, e2, r2) {
              if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
                return t2;
              if (void 0 === t2.value.value || void 0 === e2.value.value)
                return new Us(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = Ee[this.specification.type];
              return n2 ? new Us(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
            }
          }
          class $s {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return !!t2.expression.evaluate(e2, null, {}, r2, n2);
            }
            interpolate() {
              return false;
            }
          }
          class Gs {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              const e2 = new Vs(0, {});
              for (const r2 in t2) {
                const n2 = t2[r2];
                n2.specification.overridable && this.overridableProperties.push(r2);
                const i2 = this.defaultPropertyValues[r2] = new Cs(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r2] = new Rs(n2);
                this.defaultTransitioningPropertyValues[r2] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e2);
              }
            }
          }
          os(qs, "DataDrivenProperty"), os(Ns, "DataConstantProperty"), os($s, "ColorRampProperty");
          var Xs = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"selectors":{"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"type":"string","required":true},"properties":{"type":"selectorProperty","required":false},"featureNamespace":{"type":"string","required":false}},"selectorProperty":{"experimental":true,"*":{"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{"experimental":true}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant","experimental":true},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant","experimental":true}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
          function Ys(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function Zs(t2) {
            if (Array.isArray(t2))
              return t2.map(Zs);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e2 = {};
              for (const r2 in t2)
                e2[r2] = Zs(t2[r2]);
              return e2;
            }
            return Ys(t2);
          }
          function Ws(t2) {
            if (true === t2 || false === t2)
              return true;
            if (!Array.isArray(t2) || 0 === t2.length)
              return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
              case "in":
                return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e2 of t2.slice(1))
                  if (!Ws(e2) && "boolean" != typeof e2)
                    return false;
                return true;
              default:
                return true;
            }
          }
          function Hs(t2, e2 = "", r2 = null, n2 = "fill") {
            if (null == t2)
              return { filter: () => true, needGeometry: false, needFeature: false };
            Ws(t2) || (t2 = na(t2));
            const i2 = t2;
            let s2 = true;
            try {
              s2 = function(t3) {
                if (!Qs(t3))
                  return t3;
                let e3 = Zs(t3);
                return Js(e3), e3 = Ks(e3), e3;
              }(i2);
            } catch (t3) {
              console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i2, null, 2)}
        `);
            }
            const a2 = Xs[`filter_${n2}`], o2 = Hi(s2, a2, e2, r2);
            let l2 = null;
            if ("error" === o2.result)
              throw new Error(o2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
            l2 = (t3, e3, r3) => o2.value.evaluate(t3, e3, {}, r3);
            let u2 = null, c2 = null;
            if (s2 !== i2) {
              const t3 = Hi(i2, a2, e2, r2);
              if ("error" === t3.result)
                throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              u2 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), c2 = !En(t3.value.expression);
            }
            return { filter: l2, dynamicFilter: u2 || void 0, needGeometry: ra(s2), needFeature: !!c2 };
          }
          function Ks(t2) {
            if (!Array.isArray(t2))
              return t2;
            const e2 = function(t3) {
              if (ta.has(t3[0])) {
                for (let e3 = 1; e3 < t3.length; e3++)
                  if (Qs(t3[e3]))
                    return true;
              }
              return t3;
            }(t2);
            return true === e2 ? e2 : e2.map((t3) => Ks(t3));
          }
          function Js(t2) {
            let e2 = false;
            const r2 = [];
            if ("case" === t2[0]) {
              for (let n2 = 1; n2 < t2.length - 1; n2 += 2)
                e2 = e2 || Qs(t2[n2]), r2.push(t2[n2 + 1]);
              r2.push(t2[t2.length - 1]);
            } else if ("match" === t2[0]) {
              e2 = e2 || Qs(t2[1]);
              for (let e3 = 2; e3 < t2.length - 1; e3 += 2)
                r2.push(t2[e3 + 1]);
              r2.push(t2[t2.length - 1]);
            } else if ("step" === t2[0]) {
              e2 = e2 || Qs(t2[1]);
              for (let e3 = 1; e3 < t2.length - 1; e3 += 2)
                r2.push(t2[e3 + 1]);
            }
            e2 && (t2.length = 0, t2.push("any", ...r2));
            for (let e3 = 1; e3 < t2.length; e3++)
              Js(t2[e3]);
          }
          function Qs(t2) {
            if (!Array.isArray(t2))
              return false;
            if ("pitch" === (e2 = t2[0]) || "distance-from-center" === e2)
              return true;
            var e2;
            for (let e3 = 1; e3 < t2.length; e3++)
              if (Qs(t2[e3]))
                return true;
            return false;
          }
          const ta = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
          function ea(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function ra(t2) {
            if (!Array.isArray(t2))
              return false;
            if ("within" === t2[0] || "distance" === t2[0])
              return true;
            for (let e2 = 1; e2 < t2.length; e2++)
              if (ra(t2[e2]))
                return true;
            return false;
          }
          function na(t2) {
            if (!t2)
              return true;
            const e2 = t2[0];
            return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? ia(t2[1], t2[2], "==") : "!=" === e2 ? oa(ia(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? ia(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(na))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(na)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(na).map(oa)) : "in" === e2 ? sa(t2[1], t2.slice(2)) : "!in" === e2 ? oa(sa(t2[1], t2.slice(2))) : "has" === e2 ? aa(t2[1]) : "!has" !== e2 || oa(aa(t2[1]));
            var r2;
          }
          function ia(t2, e2, r2) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r2}`, e2];
              case "$id":
                return [`filter-id-${r2}`, e2];
              default:
                return [`filter-${r2}`, t2, e2];
            }
          }
          function sa(t2, e2) {
            if (0 === e2.length)
              return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(ea)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function aa(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function oa(t2) {
            return ["!", t2];
          }
          const la = "";
          function ua(t2, e2) {
            return e2 ? `${t2}${la}${e2}` : t2;
          }
          const ca = "-transition", ha = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
          class pa extends Me {
            constructor(t2, e2, r2, n2, i2) {
              if (super(), this.id = t2.id, this.fqid = ua(this.id, r2), this.type = t2.type, this.scope = r2, this.lut = n2, this.options = i2, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.configDependencies = /* @__PURE__ */ new Set(), "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && "sky" !== t2.type && "slot" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), t2.slot && (this.slot = t2.slot), e2.layout && (this._unevaluatedLayout = new Os(e2.layout, this.scope, i2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), e2.paint)) {
                this._transitionablePaint = new Ds(e2.paint, this.scope, i2);
                for (const e3 in t2.paint)
                  this.setPaintProperty(e3, t2.paint[e3]);
                for (const e3 in t2.layout)
                  this.setLayoutProperty(e3, t2.layout[e3]);
                this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new js(e2.paint);
              }
            }
            onAdd(t2) {
            }
            onRemove(t2) {
            }
            isDraped(t2) {
              return !this.is3D() && ha.has(this.type);
            }
            getLayoutProperty(t2) {
              return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e2) {
              if ("custom" === this.type && "visibility" === t2)
                return void (this.visibility = e2);
              const r2 = this._unevaluatedLayout;
              r2._properties.properties[t2] && (r2.setValue(t2, e2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r2.configDependencies]), "visibility" === t2 && this.possiblyEvaluateVisibility());
            }
            possiblyEvaluateVisibility() {
              this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
            }
            getPaintProperty(t2) {
              return lt(t2, ca) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e2) {
              const r2 = this._transitionablePaint, n2 = r2._properties.properties;
              if (lt(t2, ca)) {
                const i3 = t2.slice(0, -11);
                return n2[i3] && r2.setTransition(i3, e2 || void 0), false;
              }
              if (!n2[t2])
                return false;
              const i2 = r2._values[t2], s2 = i2.value.isDataDriven(), a2 = i2.value;
              r2.setValue(t2, e2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r2.configDependencies]), this._handleSpecialPaintPropertyUpdate(t2);
              const o2 = r2._values[t2].value, l2 = o2.isDataDriven(), u2 = lt(t2, "pattern") || "line-dasharray" === t2;
              return l2 || s2 || u2 || this._handleOverridablePaintPropertyUpdate(t2, a2, o2);
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            getProgramIds() {
              return null;
            }
            getDefaultProgramParams(t2, e2, r2) {
              return null;
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e2) {
              this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
            }
            serialize() {
              return ct({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t2, e2) => !(void 0 === t2 || "layout" === e2 && !Object.keys(t2).length || "paint" === e2 && !Object.keys(t2).length));
            }
            is3D() {
              return false;
            }
            isSky() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            hasShadowPass() {
              return false;
            }
            canCastShadows() {
              return false;
            }
            hasLightBeamPass() {
              return false;
            }
            cutoffRange() {
              return 0;
            }
            tileCoverLift() {
              return 0;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e2 = this.paint.get(t2);
                if (e2 instanceof Us && Di(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent)
                  return true;
              }
              return false;
            }
            compileFilter(t2) {
              this._filterCompiled || (this._featureFilter = Hs(this.filter, this.scope, t2), this._filterCompiled = true);
            }
            invalidateCompiledFilter() {
              this._filterCompiled = false;
            }
            dynamicFilter() {
              return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
              return this._featureFilter.needFeature;
            }
            getLayerRenderingStats() {
              return this._stats;
            }
            resetLayerRenderingStats(t2) {
              this._stats && ("shadow" === t2.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
            }
            queryRadius(t2) {
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            }
            queryIntersectsMatchingFeature(t2, e2, r2, n2) {
            }
          }
          const fa = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class da {
            constructor(t2, e2) {
              this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class ma {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e2) {
              return t2._trim(), e2 && (t2.isTransferred = true, e2.add(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e2 = Object.create(this.prototype);
              return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e2 = this.uint8;
                this._refreshViews(), e2 && this.uint8.set(e2);
              }
            }
            _refreshViews() {
              throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
            }
            emplace(...t2) {
              throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
            }
            emplaceBack(...t2) {
              throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
            }
            destroy() {
              this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
          }
          function ya(t2, e2 = 1) {
            let r2 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = fa[t3.type].BYTES_PER_ELEMENT, s2 = r2 = ga(r2, Math.max(e2, i2)), a2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
            }), size: ga(r2, Math.max(n2, e2)), alignment: e2 };
          }
          function ga(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          class xa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
            }
          }
          xa.prototype.bytesPerElement = 4, os(xa, "StructArrayLayout2i4");
          class ba extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          ba.prototype.bytesPerElement = 6, os(ba, "StructArrayLayout3i6");
          class va extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
            }
          }
          va.prototype.bytesPerElement = 8, os(va, "StructArrayLayout4i8");
          class wa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 5 * t2;
              return this.int16[a2 + 0] = e2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, t2;
            }
          }
          wa.prototype.bytesPerElement = 10, os(wa, "StructArrayLayout5i10");
          class _a extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
            }
          }
          _a.prototype.bytesPerElement = 12, os(_a, "StructArrayLayout2i4ub1f12");
          class Ma extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
            }
          }
          Ma.prototype.bytesPerElement = 16, os(Ma, "StructArrayLayout4f16");
          class Aa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          Aa.prototype.bytesPerElement = 12, os(Aa, "StructArrayLayout3f12");
          class Sa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 6 * t2, o2 = 3 * t2;
              return this.uint16[a2 + 0] = e2, this.uint16[a2 + 1] = r2, this.uint16[a2 + 2] = n2, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t2;
            }
          }
          Sa.prototype.bytesPerElement = 12, os(Sa, "StructArrayLayout4ui1f12");
          class Ia extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.uint16[s2 + 0] = e2, this.uint16[s2 + 1] = r2, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
            }
          }
          Ia.prototype.bytesPerElement = 8, os(Ia, "StructArrayLayout4ui8");
          class Pa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          Pa.prototype.bytesPerElement = 12, os(Pa, "StructArrayLayout6i12");
          class za extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const f2 = 12 * t2;
              return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
            }
          }
          za.prototype.bytesPerElement = 24, os(za, "StructArrayLayout4i4ui4i24");
          class ka extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 10 * t2, l2 = 5 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
            }
          }
          ka.prototype.bytesPerElement = 20, os(ka, "StructArrayLayout3i3f20");
          class Ta extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint32[1 * t2 + 0] = e2, t2;
            }
          }
          Ta.prototype.bytesPerElement = 4, os(Ta, "StructArrayLayout1ul4");
          class Ea extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
            }
          }
          Ea.prototype.bytesPerElement = 4, os(Ea, "StructArrayLayout2ui4");
          class Ba extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
              const f2 = this.length;
              return this.resize(f2 + 1), this.emplace(f2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2) {
              const d2 = 20 * t2, m2 = 10 * t2;
              return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r2, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[m2 + 3] = a2, this.float32[m2 + 4] = o2, this.float32[m2 + 5] = l2, this.float32[m2 + 6] = u2, this.int16[d2 + 14] = c2, this.uint32[m2 + 8] = h2, this.uint16[d2 + 18] = p2, this.uint16[d2 + 19] = f2, t2;
            }
          }
          Ba.prototype.bytesPerElement = 40, os(Ba, "StructArrayLayout5i4f1i1ul2ui40");
          class Va extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = 8 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
            }
          }
          Va.prototype.bytesPerElement = 16, os(Va, "StructArrayLayout3i2i2i16");
          class Ca extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 4 * t2, o2 = 8 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
            }
          }
          Ca.prototype.bytesPerElement = 16, os(Ca, "StructArrayLayout2f1f2i16");
          class Ra extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 20 * t2, l2 = 5 * t2;
              return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
            }
          }
          Ra.prototype.bytesPerElement = 20, os(Ra, "StructArrayLayout2ub4f20");
          class Da extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
            }
          }
          Da.prototype.bytesPerElement = 6, os(Da, "StructArrayLayout3ui6");
          class La extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2) {
              const w2 = this.length;
              return this.resize(w2 + 1), this.emplace(w2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2, w2) {
              const _2 = 30 * t2, M2 = 15 * t2, A2 = 60 * t2;
              return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r2, this.int16[_2 + 2] = n2, this.float32[M2 + 2] = i2, this.float32[M2 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[M2 + 5] = l2, this.uint32[M2 + 6] = u2, this.uint32[M2 + 7] = c2, this.uint16[_2 + 16] = h2, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = f2, this.float32[M2 + 10] = d2, this.float32[M2 + 11] = m2, this.uint8[A2 + 48] = y2, this.uint8[A2 + 49] = g2, this.uint8[A2 + 50] = x2, this.uint32[M2 + 13] = b2, this.int16[_2 + 28] = v2, this.uint8[A2 + 58] = w2, t2;
            }
          }
          La.prototype.bytesPerElement = 60, os(La, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
          class Fa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2, w2, _2, M2, A2, S2, I2, P2, z2, k2, T2, E2) {
              const B2 = this.length;
              return this.resize(B2 + 1), this.emplace(B2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2, w2, _2, M2, A2, S2, I2, P2, z2, k2, T2, E2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2, x2, b2, v2, w2, _2, M2, A2, S2, I2, P2, z2, k2, T2, E2, B2) {
              const V2 = 20 * t2, C2 = 40 * t2, R2 = 80 * t2;
              return this.float32[V2 + 0] = e2, this.float32[V2 + 1] = r2, this.int16[C2 + 4] = n2, this.int16[C2 + 5] = i2, this.int16[C2 + 6] = s2, this.int16[C2 + 7] = a2, this.int16[C2 + 8] = o2, this.int16[C2 + 9] = l2, this.int16[C2 + 10] = u2, this.int16[C2 + 11] = c2, this.int16[C2 + 12] = h2, this.uint16[C2 + 13] = p2, this.uint16[C2 + 14] = f2, this.uint16[C2 + 15] = d2, this.uint16[C2 + 16] = m2, this.uint16[C2 + 17] = y2, this.uint16[C2 + 18] = g2, this.uint16[C2 + 19] = x2, this.uint16[C2 + 20] = b2, this.uint16[C2 + 21] = v2, this.uint16[C2 + 22] = w2, this.uint16[C2 + 23] = _2, this.uint16[C2 + 24] = M2, this.uint16[C2 + 25] = A2, this.uint16[C2 + 26] = S2, this.uint16[C2 + 27] = I2, this.uint32[V2 + 14] = P2, this.float32[V2 + 15] = z2, this.float32[V2 + 16] = k2, this.float32[V2 + 17] = T2, this.float32[V2 + 18] = E2, this.uint8[R2 + 76] = B2, t2;
            }
          }
          Fa.prototype.bytesPerElement = 80, os(Fa, "StructArrayLayout2f9i15ui1ul4f1ub80");
          class Oa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.float32[1 * t2 + 0] = e2, t2;
            }
          }
          Oa.prototype.bytesPerElement = 4, os(Oa, "StructArrayLayout1f4");
          class Ua extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 5 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
            }
          }
          Ua.prototype.bytesPerElement = 20, os(Ua, "StructArrayLayout5f20");
          class ja extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = 7 * t2;
              return this.float32[l2 + 0] = e2, this.float32[l2 + 1] = r2, this.float32[l2 + 2] = n2, this.float32[l2 + 3] = i2, this.float32[l2 + 4] = s2, this.float32[l2 + 5] = a2, this.float32[l2 + 6] = o2, t2;
            }
          }
          ja.prototype.bytesPerElement = 28, os(ja, "StructArrayLayout7f28");
          class Na extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 6 * t2;
              return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
            }
          }
          Na.prototype.bytesPerElement = 12, os(Na, "StructArrayLayout1ul3ui12");
          class qa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint16[1 * t2 + 0] = e2, t2;
            }
          }
          qa.prototype.bytesPerElement = 2, os(qa, "StructArrayLayout1ui2");
          class $a extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
            }
          }
          $a.prototype.bytesPerElement = 8, os($a, "StructArrayLayout2f8");
          class Ga extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2) {
              const y2 = this.length;
              return this.resize(y2 + 1), this.emplace(y2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2) {
              const g2 = 16 * t2;
              return this.float32[g2 + 0] = e2, this.float32[g2 + 1] = r2, this.float32[g2 + 2] = n2, this.float32[g2 + 3] = i2, this.float32[g2 + 4] = s2, this.float32[g2 + 5] = a2, this.float32[g2 + 6] = o2, this.float32[g2 + 7] = l2, this.float32[g2 + 8] = u2, this.float32[g2 + 9] = c2, this.float32[g2 + 10] = h2, this.float32[g2 + 11] = p2, this.float32[g2 + 12] = f2, this.float32[g2 + 13] = d2, this.float32[g2 + 14] = m2, this.float32[g2 + 15] = y2, t2;
            }
          }
          Ga.prototype.bytesPerElement = 64, os(Ga, "StructArrayLayout16f64");
          class Xa extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = 10 * t2, u2 = 5 * t2;
              return this.uint16[l2 + 0] = e2, this.uint16[l2 + 1] = r2, this.uint16[l2 + 2] = n2, this.uint16[l2 + 3] = i2, this.float32[u2 + 2] = s2, this.float32[u2 + 3] = a2, this.float32[u2 + 4] = o2, t2;
            }
          }
          Xa.prototype.bytesPerElement = 20, os(Xa, "StructArrayLayout4ui3f20");
          class Ya extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.int16[1 * t2 + 0] = e2, t2;
            }
          }
          Ya.prototype.bytesPerElement = 2, os(Ya, "StructArrayLayout1i2");
          class Za extends ma {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint8[1 * t2 + 0] = e2, t2;
            }
          }
          Za.prototype.bytesPerElement = 1, os(Za, "StructArrayLayout1ub1");
          class Wa extends da {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
              return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
              return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
              return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
              return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
          }
          Wa.prototype.size = 40;
          class Ha extends Ba {
            get(t2) {
              return new Wa(this, t2);
            }
          }
          os(Ha, "CollisionBoxArray");
          class Ka extends da {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 49] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 50] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 13] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
              return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t2) {
              this._structArray.uint8[this._pos1 + 58] = t2;
            }
          }
          Ka.prototype.size = 60;
          class Ja extends La {
            get(t2) {
              return new Ka(this, t2);
            }
          }
          os(Ja, "PlacedSymbolArray");
          class Qa extends da {
            get tileAnchorX() {
              return this._structArray.float32[this._pos4 + 0];
            }
            get tileAnchorY() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 8];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 9];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 10];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 11];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 12];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 23];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 24];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 25];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 26];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 27];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 14];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 14] = t2;
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 15];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 16];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 17];
            }
            get zOffset() {
              return this._structArray.float32[this._pos4 + 18];
            }
            set zOffset(t2) {
              this._structArray.float32[this._pos4 + 18] = t2;
            }
            get hasIconTextFit() {
              return this._structArray.uint8[this._pos1 + 76];
            }
          }
          Qa.prototype.size = 80;
          class to extends Fa {
            get(t2) {
              return new Qa(this, t2);
            }
          }
          os(to, "SymbolInstanceArray");
          class eo extends Oa {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          os(eo, "GlyphOffsetArray");
          class ro extends xa {
            getx(t2) {
              return this.int16[2 * t2 + 0];
            }
            gety(t2) {
              return this.int16[2 * t2 + 1];
            }
          }
          os(ro, "SymbolLineVertexArray");
          class no extends da {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
              return this._structArray.uint16[this._pos2 + 4];
            }
          }
          no.prototype.size = 12;
          class io extends Na {
            get(t2) {
              return new no(this, t2);
            }
          }
          os(io, "FeatureIndexArray");
          class so extends Ea {
            geta_centroid_pos0(t2) {
              return this.uint16[2 * t2 + 0];
            }
            geta_centroid_pos1(t2) {
              return this.uint16[2 * t2 + 1];
            }
          }
          os(so, "FillExtrusionCentroidArray");
          class ao extends da {
            get a_join_normal_inside0() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get a_join_normal_inside1() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get a_join_normal_inside2() {
              return this._structArray.int16[this._pos2 + 2];
            }
          }
          ao.prototype.size = 6;
          class oo extends ba {
            get(t2) {
              return new ao(this, t2);
            }
          }
          os(oo, "FillExtrusionWallArray");
          const lo = ya([{ name: "a_pos", components: 2, type: "Int16" }], 4), uo = ya([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
          class co {
            constructor(t2 = []) {
              this.segments = t2;
            }
            _prepareSegment(t2, e2, r2, n2) {
              let i2 = this.segments[this.segments.length - 1];
              return t2 > co.MAX_VERTEX_ARRAY_LENGTH && ft(`Max vertices per segment is ${co.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > co.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2, primitiveOffset: r2, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
            }
            prepareSegment(t2, e2, r2, n2) {
              return this._prepareSegment(t2, e2.length, r2.length, n2);
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments)
                for (const e2 in t2.vaos)
                  t2.vaos[e2].destroy();
            }
            static simpleSegment(t2, e2, r2, n2) {
              return new co([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          function ho(t2, e2) {
            return 256 * (t2 = Q(Math.floor(t2), 0, 255)) + Q(Math.floor(e2), 0, 255);
          }
          co.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, os(co, "SegmentVector");
          const po = ya([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), fo = ya([{ name: "a_dash", components: 4, type: "Uint16" }]);
          class mo {
            constructor() {
              this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
            }
            add(t2, e2, r2, n2) {
              this.ids.push(yo(t2)), this.positions.push(e2, r2, n2);
            }
            eachPosition(t2, e2) {
              const r2 = yo(t2);
              let n2 = 0, i2 = this.ids.length - 1;
              for (; n2 < i2; ) {
                const t3 = n2 + i2 >> 1;
                this.ids[t3] >= r2 ? i2 = t3 : n2 = t3 + 1;
              }
              for (; this.ids[n2] === r2; )
                e2(this.positions[3 * n2], this.positions[3 * n2 + 1], this.positions[3 * n2 + 2]), n2++;
            }
            static serialize(t2, e2) {
              const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return go(r2, n2, 0, r2.length - 1), e2 && (e2.add(r2.buffer), e2.add(n2.buffer)), { ids: r2, positions: n2 };
            }
            static deserialize(t2) {
              const e2 = new mo();
              let r2;
              e2.ids = t2.ids, e2.positions = t2.positions;
              for (const t3 of e2.ids)
                t3 !== r2 && e2.uniqueIds.push(t3), r2 = t3;
              return e2.indexed = true, e2;
            }
          }
          function yo(t2) {
            const e2 = +t2;
            return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : xe(String(t2));
          }
          function go(t2, e2, r2, n2) {
            for (; r2 < n2; ) {
              const i2 = t2[r2 + n2 >> 1];
              let s2 = r2 - 1, a2 = n2 + 1;
              for (; ; ) {
                do {
                  s2++;
                } while (t2[s2] < i2);
                do {
                  a2--;
                } while (t2[a2] > i2);
                if (s2 >= a2)
                  break;
                xo(t2, s2, a2), xo(e2, 3 * s2, 3 * a2), xo(e2, 3 * s2 + 1, 3 * a2 + 1), xo(e2, 3 * s2 + 2, 3 * a2 + 2);
              }
              a2 - r2 < n2 - a2 ? (go(t2, e2, r2, a2), r2 = a2 + 1) : (go(t2, e2, a2 + 1, n2), n2 = a2);
            }
          }
          function xo(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          os(mo, "FeaturePositionMap");
          class bo {
            constructor(t2) {
              this.gl = t2.gl, this.initialized = false;
            }
            fetchUniformLocation(t2, e2) {
              return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
            }
            set(t2, e2, r2) {
              throw new Error("Uniform#set() must be implemented by each concrete Uniform");
            }
          }
          class vo extends bo {
            constructor(t2) {
              super(t2), this.current = 0;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
            }
          }
          class wo extends bo {
            constructor(t2) {
              super(t2), this.current = 0;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
            }
          }
          class _o extends bo {
            constructor(t2) {
              super(t2), this.current = [0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
            }
          }
          class Mo extends bo {
            constructor(t2) {
              super(t2), this.current = [0, 0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
            }
          }
          class Ao extends bo {
            constructor(t2) {
              super(t2), this.current = [0, 0, 0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
            }
          }
          class So extends bo {
            constructor(t2) {
              super(t2), this.current = Pe.transparent.toRenderColor(null);
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
            }
          }
          const Io = new Float32Array(16);
          class Po extends bo {
            constructor(t2) {
              super(t2), this.current = Io;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                if (r2[12] !== this.current[12] || r2[0] !== this.current[0])
                  return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
                for (let t3 = 1; t3 < 16; t3++)
                  if (r2[t3] !== this.current[t3]) {
                    this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                    break;
                  }
              }
            }
          }
          const zo = new Float32Array(9), ko = new Float32Array(4);
          class To extends bo {
            constructor(t2) {
              super(t2), this.current = ko;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                for (let t3 = 0; t3 < 4; t3++)
                  if (r2[t3] !== this.current[t3]) {
                    this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                    break;
                  }
              }
            }
          }
          function Eo(t2) {
            return [ho(255 * t2.r, 255 * t2.g), ho(255 * t2.b, 255 * t2.a)];
          }
          class Bo {
            constructor(t2, e2, r2, n2) {
              this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2, this.context = n2;
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = n2.constantOr(this.value);
              e2.set(t2, i2, s2 instanceof Pe ? s2.toRenderColor(this.context.lut) : s2);
            }
            getBinding(t2, e2) {
              return "color" === this.type ? new So(t2) : new wo(t2);
            }
          }
          class Vo {
            constructor(t2, e2) {
              this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t2) {
              this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br);
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = "u_pattern" === i2 || "u_dash" === i2 ? this.pattern : "u_pixel_ratio" === i2 ? this.pixelRatio : null;
              s2 && e2.set(t2, i2, s2);
            }
            getBinding(t2, e2) {
              return "u_pattern" === e2 || "u_dash" === e2 ? new Ao(t2) : new wo(t2);
            }
          }
          class Co {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.paintVertexArray.length, l2 = this.expression.evaluate(new Vs(0, { brightness: s2 }), e2, {}, i2, n2, a2);
              this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, l2, this.context);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.expression.evaluate({ zoom: 0, brightness: a2 }, r2, n2, void 0, i2);
              this._setPaintValue(t2, e2, o2, this.context);
            }
            _setPaintValue(t2, e2, r2, n2) {
              if ("color" === this.type) {
                const i2 = Eo(r2.toRenderColor(n2.lut));
                for (let r3 = t2; r3 < e2; r3++)
                  this.paintVertexArray.emplace(r3, i2[0], i2[1]);
              } else {
                for (let n3 = t2; n3 < e2; n3++)
                  this.paintVertexArray.emplace(n3, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class Ro {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.context = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.expression.evaluate(new Vs(this.context.zoom, { brightness: s2 }), e2, {}, i2, n2, a2), l2 = this.expression.evaluate(new Vs(this.context.zoom + 1, { brightness: s2 }), e2, {}, i2, n2, a2), u2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(u2, t2, o2, l2, this.context);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.expression.evaluate({ zoom: this.context.zoom, brightness: a2 }, r2, n2, void 0, i2), l2 = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: a2 }, r2, n2, void 0, i2);
              this._setPaintValue(t2, e2, o2, l2, this.context);
            }
            _setPaintValue(t2, e2, r2, n2, i2) {
              if ("color" === this.type) {
                const n3 = Eo(r2.toRenderColor(i2.lut)), s2 = Eo(r2.toRenderColor(i2.lut));
                for (let r3 = t2; r3 < e2; r3++)
                  this.paintVertexArray.emplace(r3, n3[0], n3[1], s2[0], s2[1]);
              } else {
                for (let i3 = t2; i3 < e2; i3++)
                  this.paintVertexArray.emplace(i3, r2, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, a2 = Q(this.expression.interpolationFactor(s2, this.context.zoom, this.context.zoom + 1), 0, 1);
              e2.set(t2, i2, a2);
            }
            getBinding(t2, e2) {
              return new wo(t2);
            }
          }
          class Do {
            constructor(t2, e2, r2, n2, i2) {
              this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r2 ? fo : po).members;
              for (let t3 = 0; t3 < e2.length; ++t3)
                ;
              this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2, n2) {
              const i2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValues(i2, t2, e2.patterns && e2.patterns[this.layerId], r2);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2, a2) {
              this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], s2);
            }
            _setPaintValues(t2, e2, r2, n2) {
              if (!n2 || !r2)
                return;
              const i2 = n2[r2];
              if (!i2)
                return;
              const { tl: s2, br: a2, pixelRatio: o2 } = i2;
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, s2[0], s2[1], a2[0], a2[1], o2);
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class Lo {
            constructor(t2, e2, r2 = () => true) {
              this.binders = {}, this._buffers = [], this.context = e2;
              const n2 = [];
              for (const i2 in t2.paint._values) {
                const s2 = t2.paint.get(i2);
                if (!r2(i2))
                  continue;
                if (!(s2 instanceof Us && Di(s2.property.specification)))
                  continue;
                const a2 = Uo(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = !!s2.property.useIntegerZoom, c2 = "line-dasharray" === i2 || i2.endsWith("pattern"), h2 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind;
                if ("constant" !== o2.kind || h2)
                  if ("source" === o2.kind || h2 || c2) {
                    const e3 = qo(i2, l2, "source");
                    this.binders[i2] = c2 ? new Do(o2, a2, l2, e3, t2.id) : new Co(o2, a2, l2, e3), n2.push(`/a_${i2}`);
                  } else {
                    const t3 = qo(i2, l2, "composite");
                    this.binders[i2] = new Ro(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
                  }
                else
                  this.binders[i2] = c2 ? new Vo(o2.value, a2) : new Bo(o2.value, a2, l2, e2), n2.push(`/u_${i2}`);
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof Co || e2 instanceof Ro ? e2.maxValue : 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2, a2) {
              for (const o2 in this.binders) {
                const l2 = this.binders[o2];
                l2.context = this.context, (l2 instanceof Co || l2 instanceof Ro || l2 instanceof Do) && l2.populatePaintArray(t2, e2, r2, n2, i2, s2, a2);
              }
            }
            setConstantPatternPositions(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                r2 instanceof Vo && r2.setConstantPatternPositions(t2);
              }
            }
            updatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2) {
              let l2 = false;
              const u2 = Object.keys(t2), c2 = 0 !== u2.length, h2 = c2 ? u2 : e2.uniqueIds;
              this.context.lut = i2.lut;
              for (const u3 in this.binders) {
                const p2 = this.binders[u3];
                if (p2.context = this.context, (p2 instanceof Co || p2 instanceof Ro || p2 instanceof Do) && (true === p2.expression.isStateDependent || false === p2.expression.isLightConstant)) {
                  const f2 = i2.paint.get(u3);
                  p2.expression = f2.value;
                  for (const r3 of h2) {
                    const i3 = t2[r3.toString()];
                    e2.eachPosition(r3, (t3, e3, r4) => {
                      const l3 = n2.feature(t3);
                      p2.updatePaintArray(e3, r4, l3, i3, s2, a2, o2);
                    });
                  }
                  if (!c2)
                    for (const e3 of r2.uniqueIds) {
                      const i3 = t2[e3.toString()];
                      r2.eachPosition(e3, (t3, e4, r3) => {
                        const l3 = n2.feature(t3);
                        p2.updatePaintArray(e4, r3, l3, i3, s2, a2, o2);
                      });
                    }
                  l2 = true;
                }
              }
              return l2;
            }
            defines() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof Bo || r2 instanceof Vo) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof Co || r2 instanceof Ro || r2 instanceof Do)
                  for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                    t2.push(r2.paintVertexAttributes[e3].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof Bo || r2 instanceof Vo || r2 instanceof Ro)
                  for (const e3 of r2.uniformNames)
                    t2.push(e3);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2) {
              const e2 = [];
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                if (n2 instanceof Bo || n2 instanceof Vo || n2 instanceof Ro)
                  for (const i2 of n2.uniformNames)
                    e2.push({ name: i2, property: r2, binding: n2.getBinding(t2, i2) });
              }
              return e2;
            }
            setUniforms(t2, e2, r2, n2, i2) {
              for (const { name: e3, property: s2, binding: a2 } of r2)
                this.binders[s2].setUniform(t2, a2, i2, n2.get(s2), e3);
            }
            updatePaintBuffers() {
              this._buffers = [];
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof Co || e2 instanceof Ro || e2 instanceof Do) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer);
              }
            }
            upload(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof Co || r2 instanceof Ro || r2 instanceof Do) && r2.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof Co || e2 instanceof Ro || e2 instanceof Do) && e2.destroy();
              }
            }
          }
          class Fo {
            constructor(t2, e2, r2 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2)
                this.programConfigurations[n2.id] = new Lo(n2, e2, r2);
              this.needsUpload = false, this._featureMap = new mo(), this._featureMapWithoutIds = new mo(), this._bufferOffset = 0, this._idlessCounter = 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2, a2, o2) {
              for (const r3 in this.programConfigurations)
                this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2, a2, o2);
              void 0 !== e2.id ? this._featureMap.add(e2.id, r2, this._bufferOffset, t2) : (this._featureMapWithoutIds.add(this._idlessCounter, r2, this._bufferOffset, t2), this._idlessCounter += 1), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e2, r2, n2, i2, s2) {
              for (const a2 of r2)
                this.needsUpload = this.programConfigurations[a2.id].updatePaintArrays(t2, this._featureMap, this._featureMapWithoutIds, e2, a2, n2, i2, s2 || 0) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e2 in this.programConfigurations)
                  this.programConfigurations[e2].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations)
                this.programConfigurations[t2].destroy();
            }
          }
          const Oo = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
          function Uo(t2, e2) {
            return Oo[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
          }
          const jo = { "line-pattern": { source: Sa, composite: Sa }, "fill-pattern": { source: Sa, composite: Sa }, "fill-extrusion-pattern": { source: Sa, composite: Sa }, "line-dasharray": { source: Ia, composite: Ia } }, No = { color: { source: $a, composite: Ma }, number: { source: Oa, composite: $a } };
          function qo(t2, e2, r2) {
            const n2 = jo[t2];
            return n2 && n2[r2] || No[e2][r2];
          }
          os(Bo, "ConstantBinder"), os(Vo, "PatternConstantBinder"), os(Co, "SourceExpressionBinder"), os(Do, "PatternCompositeBinder"), os(Ro, "CompositeExpressionBinder"), os(Lo, "ProgramConfiguration", { omit: ["_buffers"] }), os(Fo, "ProgramConfigurationSet");
          const $o = Hr / Math.PI / 2, Go = 5, Xo = 6, Yo = 16383, Zo = 64, Wo = [Zo, 32, 16], Ho = -$o, Ko = $o;
          function Jo(t2, e2, r2, n2 = $o) {
            return r2 = Y(r2), [t2 * Math.sin(r2) * n2, -e2 * n2, t2 * Math.cos(r2) * n2];
          }
          function Qo(t2, e2, r2) {
            return Jo(Math.cos(Y(t2)), Math.sin(Y(t2)), e2, r2);
          }
          const tl = 63710088e-1, el = 2 * Math.PI * tl;
          class rl {
            constructor(t2, e2) {
              if (isNaN(t2) || isNaN(e2))
                throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
              if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new rl(et(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
              return tl * Math.acos(Math.min(i2, 1));
            }
            toBounds(t2 = 0) {
              const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
              return new nl({ lng: this.lng - r2, lat: this.lat - e2 }, { lng: this.lng + r2, lat: this.lat + e2 });
            }
            toEcef(t2) {
              return Qo(this.lat, this.lng, $o + t2 * $o / tl);
            }
            static convert(t2) {
              if (t2 instanceof rl)
                return t2;
              if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
                return new rl(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
                return new rl(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          class nl {
            constructor(t2, e2) {
              if (t2)
                if (e2)
                  this.setSouthWest(t2).setNorthEast(e2);
                else if (4 === t2.length) {
                  const e3 = t2;
                  this.setSouthWest([e3[0], e3[1]]).setNorthEast([e3[2], e3[3]]);
                } else {
                  const e3 = t2;
                  this.setSouthWest(e3[0]).setNorthEast(e3[1]);
                }
            }
            setNorthEast(t2) {
              return this._ne = t2 instanceof rl ? new rl(t2.lng, t2.lat) : rl.convert(t2), this;
            }
            setSouthWest(t2) {
              return this._sw = t2 instanceof rl ? new rl(t2.lng, t2.lat) : rl.convert(t2), this;
            }
            extend(t2) {
              const e2 = this._sw, r2 = this._ne;
              let n2, i2;
              if (t2 instanceof rl)
                n2 = t2, i2 = t2;
              else {
                if (!(t2 instanceof nl))
                  return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(nl.convert(t2)) : this.extend(rl.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend(rl.convert(t2)) : this;
                if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                  return this;
              }
              return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new rl(n2.lng, n2.lat), this._ne = new rl(i2.lng, i2.lat)), this;
            }
            getCenter() {
              return new rl((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new rl(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new rl(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(t2) {
              const { lng: e2, lat: r2 } = rl.convert(t2);
              let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
            }
            static convert(t2) {
              if (t2)
                return t2 instanceof nl ? t2 : new nl(t2);
            }
          }
          const il = 0, sl = 25.5;
          function al(t2) {
            return el * Math.cos(t2 * Math.PI / 180);
          }
          function ol(t2) {
            return (180 + t2) / 360;
          }
          function ll(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function ul(t2, e2) {
            return t2 / al(e2);
          }
          function cl(t2) {
            return 360 * t2 - 180;
          }
          function hl(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function pl(t2, e2) {
            return t2 * al(hl(e2));
          }
          const fl = 85.051129;
          function dl(t2) {
            return Math.cos(Y(Q(t2, -fl, fl)));
          }
          function ml(t2, e2) {
            const r2 = Q(e2, il, sl), n2 = Math.pow(2, r2);
            return dl(t2) * el / (512 * n2);
          }
          function yl(t2) {
            return 1 / Math.cos(t2 * Math.PI / 180);
          }
          function gl(t2, e2 = 0) {
            const r2 = Math.exp(Math.PI * (1 - (t2.y + e2 / Hr) / (1 << t2.z) * 2));
            return 80150034 * r2 / (r2 * r2 + 1) / Hr / (1 << t2.z);
          }
          class xl {
            constructor(t2, e2, r2 = 0) {
              this.x = +t2, this.y = +e2, this.z = +r2;
            }
            static fromLngLat(t2, e2 = 0) {
              const r2 = rl.convert(t2);
              return new xl(ol(r2.lng), ll(r2.lat), ul(e2, r2.lat));
            }
            toLngLat() {
              return new rl(cl(this.x), hl(this.y));
            }
            toAltitude() {
              return pl(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
              return 1 / el * yl(hl(this.y));
            }
          }
          function bl(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = (e2 + n2) / 2, c2 = (r2 + i2) / 2, h2 = new q(u2, c2);
            o2(h2), function(t3, e3, r3, n3, i3, s3) {
              const a3 = r3 - i3, o3 = n3 - s3;
              return Math.abs((n3 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
            }(h2.x, h2.y, s2.x, s2.y, a2.x, a2.y) >= l2 ? (bl(t2, e2, r2, u2, c2, s2, h2, o2, l2), bl(t2, u2, c2, n2, i2, h2, a2, o2, l2)) : t2.push(a2);
          }
          function vl(t2, e2, r2) {
            let n2 = t2[0], i2 = n2.x, s2 = n2.y;
            e2(n2);
            const a2 = [n2];
            for (let o2 = 1; o2 < t2.length; o2++) {
              const l2 = t2[o2], { x: u2, y: c2 } = l2;
              e2(l2), bl(a2, i2, s2, u2, c2, n2, l2, e2, r2), i2 = u2, s2 = c2, n2 = l2;
            }
            return a2;
          }
          function wl(t2, e2, r2, n2) {
            if (n2(e2, r2)) {
              const i2 = e2.add(r2)._mult(0.5);
              wl(t2, e2, i2, n2), wl(t2, i2, r2, n2);
            } else
              t2.push(r2);
          }
          function _l(t2, e2) {
            let r2 = t2[0];
            const n2 = [r2];
            for (let i2 = 1; i2 < t2.length; i2++) {
              const s2 = t2[i2];
              wl(n2, r2, s2, e2), r2 = s2;
            }
            return n2;
          }
          const Ml = Math.pow(2, 14) - 1, Al = -Ml - 1;
          function Sl(t2, e2) {
            const r2 = Math.round(t2.x * e2), n2 = Math.round(t2.y * e2);
            return t2.x = Q(r2, Al, Ml), t2.y = Q(n2, Al, Ml), (r2 < t2.x || r2 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && ft("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
          }
          function Il(t2, e2, r2) {
            const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = Hr / i2;
            if (e2 && r2 && r2.projection.isReprojectedInTileSpace) {
              const s3 = 1 << e2.z, { scale: a2, x: o2, y: l2, projection: u2 } = r2, c2 = (t3) => {
                const r3 = cl((e2.x + t3.x / i2) / s3), n3 = hl((e2.y + t3.y / i2) / s3), c3 = u2.project(r3, n3);
                t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l2) * i2;
              };
              for (let e3 = 0; e3 < n2.length; e3++)
                if (1 !== t2.type)
                  n2[e3] = vl(n2[e3], c2, 1);
                else {
                  const t3 = [];
                  for (const r3 of n2[e3])
                    r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c2(r3), t3.push(r3));
                  n2[e3] = t3;
                }
            }
            for (const t3 of n2)
              for (const e3 of t3)
                Sl(e3, s2);
            return n2;
          }
          function Pl(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Il(t2) : [] };
          }
          function zl(t2, e2, r2, n2, i2) {
            t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
          }
          function kl(t2, e2, r2) {
            const n2 = 16384;
            t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
          }
          class Tl {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new xa(), this.indexArray = new Da(), this.segments = new co(), this.programConfigurations = new Fo(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = [];
              let a2 = null;
              "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
              for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Pl(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), u2, r2))
                  continue;
                const c2 = a2 ? a2.evaluate(u2, {}, r2) : void 0, h2 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o3, geometry: t3 ? u2.geometry : Il(e3, r2, n2), patterns: {}, sortKey: c2 };
                s2.push(h2);
              }
              a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              let o2 = null;
              "globe" === n2.projection.name && (this.globeExtVertexArray = new Pa(), o2 = n2.projection);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l2 = t2[s3].feature;
                this.addFeature(n3, i3, s3, e2.availableImages, r2, o2, e2.brightness), e2.featureIndex.insert(l2, i3, s3, a3, this.index);
              }
            }
            update(t2, e2, r2, n2, i2) {
              const s2 = 0 !== Object.keys(t2).length;
              s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t2, e2, s2 ? this.stateDependentLayers : this.layers, r2, n2, i2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, lo.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, uo.members))), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2, a2) {
              for (const r3 of e2)
                for (const e3 of r3) {
                  const r4 = e3.x, n3 = e3.y;
                  if (r4 < 0 || r4 >= Hr || n3 < 0 || n3 >= Hr)
                    continue;
                  if (s2) {
                    const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3), a4 = this.globeExtVertexArray;
                    kl(a4, t3, e4), kl(a4, t3, e4), kl(a4, t3, e4), kl(a4, t3, e4);
                  }
                  const a3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = a3.vertexLength;
                  zl(this.layoutVertexArray, r4, n3, -1, -1), zl(this.layoutVertexArray, r4, n3, 1, -1), zl(this.layoutVertexArray, r4, n3, 1, 1), zl(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a3.vertexLength += 4, a3.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2, i2, a2);
            }
          }
          function El(t2, e2) {
            for (let r2 = 0; r2 < t2.length; r2++)
              if (Ul(e2, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (Ul(t2, e2[r2]))
                return true;
            return !!Rl(t2, e2);
          }
          function Bl(t2, e2, r2) {
            return !!Ul(t2, e2) || !!Ll(e2, t2, r2);
          }
          function Vl(t2, e2) {
            if (1 === t2.length)
              return Ol(e2, t2[0]);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const n2 = e2[r2];
              for (let e3 = 0; e3 < n2.length; e3++)
                if (Ul(t2, n2[e3]))
                  return true;
            }
            for (let r2 = 0; r2 < t2.length; r2++)
              if (Ol(e2, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e2.length; r2++)
              if (Rl(t2, e2[r2]))
                return true;
            return false;
          }
          function Cl(t2, e2, r2) {
            if (t2.length > 1) {
              if (Rl(t2, e2))
                return true;
              for (let n2 = 0; n2 < e2.length; n2++)
                if (Ll(e2[n2], t2, r2))
                  return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++)
              if (Ll(t2[n2], e2, r2))
                return true;
            return false;
          }
          function Rl(t2, e2) {
            if (0 === t2.length || 0 === e2.length)
              return false;
            for (let r2 = 0; r2 < t2.length - 1; r2++) {
              const n2 = t2[r2], i2 = t2[r2 + 1];
              for (let t3 = 0; t3 < e2.length - 1; t3++)
                if (Dl(n2, i2, e2[t3], e2[t3 + 1]))
                  return true;
            }
            return false;
          }
          function Dl(t2, e2, r2, n2) {
            return dt(t2, r2, n2) !== dt(e2, r2, n2) && dt(t2, e2, r2) !== dt(t2, e2, n2);
          }
          function Ll(t2, e2, r2) {
            const n2 = r2 * r2;
            if (1 === e2.length)
              return t2.distSqr(e2[0]) < n2;
            for (let r3 = 1; r3 < e2.length; r3++)
              if (Fl(t2, e2[r3 - 1], e2[r3]) < n2)
                return true;
            return false;
          }
          function Fl(t2, e2, r2) {
            const n2 = e2.distSqr(r2);
            if (0 === n2)
              return t2.distSqr(e2);
            const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
          }
          function Ol(t2, e2) {
            let r2, n2, i2, s2 = false;
            for (let a2 = 0; a2 < t2.length; a2++) {
              r2 = t2[a2];
              for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
                n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
            }
            return s2;
          }
          function Ul(t2, e2) {
            let r2 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const s2 = t2[n2], a2 = t2[i2];
              s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
            }
            return r2;
          }
          function jl(t2, e2, r2, n2, i2) {
            for (const s3 of t2)
              if (e2 <= s3.x && r2 <= s3.y && n2 >= s3.x && i2 >= s3.y)
                return true;
            const s2 = [new q(e2, r2), new q(e2, i2), new q(n2, i2), new q(n2, r2)];
            if (t2.length > 2) {
              for (const e3 of s2)
                if (Ul(t2, e3))
                  return true;
            }
            for (let e3 = 0; e3 < t2.length - 1; e3++)
              if (Nl(t2[e3], t2[e3 + 1], s2))
                return true;
            return false;
          }
          function Nl(t2, e2, r2) {
            const n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
              return false;
            const s2 = dt(t2, e2, r2[0]);
            return s2 !== dt(t2, e2, r2[1]) || s2 !== dt(t2, e2, r2[2]) || s2 !== dt(t2, e2, r2[3]);
          }
          function ql(t2, e2, r2, n2, i2, s2) {
            let a2 = e2.y - t2.y, o2 = t2.x - e2.x;
            if (s2 = s2 || 0) {
              const t3 = a2 * a2 + o2 * o2;
              if (0 === t3)
                return true;
              const e3 = Math.sqrt(t3);
              a2 /= e3, o2 /= e3;
            }
            return !((r2.x - t2.x) * a2 + (r2.y - t2.y) * o2 - s2 < 0 || (n2.x - t2.x) * a2 + (n2.y - t2.y) * o2 - s2 < 0 || (i2.x - t2.x) * a2 + (i2.y - t2.y) * o2 - s2 < 0);
          }
          function $l(t2, e2, r2, n2, i2, s2, a2) {
            return !(ql(t2, e2, n2, i2, s2, a2) || ql(e2, r2, n2, i2, s2, a2) || ql(r2, t2, n2, i2, s2, a2) || ql(n2, i2, t2, e2, r2, a2) || ql(i2, s2, t2, e2, r2, a2) || ql(s2, n2, t2, e2, r2, a2));
          }
          function Gl(t2, e2, r2) {
            const n2 = e2.paint.get(t2).value;
            return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function Xl(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function Yl(t2, e2, r2, n2, i2) {
            if (!e2[0] && !e2[1])
              return t2;
            const s2 = q.convert(e2)._mult(i2);
            "viewport" === r2 && s2._rotate(-n2);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3++)
              a2.push(t2[e3].sub(s2));
            return a2;
          }
          function Zl(t2, e2, r2, n2) {
            const i2 = q.convert(t2)._mult(n2);
            return "viewport" === e2 && i2._rotate(-r2), i2;
          }
          let Wl, Hl;
          os(Tl, "CircleBucket", { omit: ["layers"] });
          var Kl, Jl = { exports: {} }, Ql = (Kl || (Kl = 1, function(t2, e2) {
            !function(t3) {
              function e3(t4, e4, n2) {
                var i2 = r2(256 * t4, 256 * (e4 = Math.pow(2, n2) - e4 - 1), n2), s2 = r2(256 * (t4 + 1), 256 * (e4 + 1), n2);
                return i2[0] + "," + i2[1] + "," + s2[0] + "," + s2[1];
              }
              function r2(t4, e4, r3) {
                var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
                return [t4 * n2 - 2 * Math.PI * 6378137 / 2, e4 * n2 - 2 * Math.PI * 6378137 / 2];
              }
              t3.getURL = function(t4, r3, n2, i2, s2, a2) {
                return a2 = a2 || {}, t4 + "?" + ["bbox=" + e3(n2, i2, s2), "format=" + (a2.format || "image/png"), "service=" + (a2.service || "WMS"), "version=" + (a2.version || "1.1.1"), "request=" + (a2.request || "GetMap"), "srs=" + (a2.srs || "EPSG:3857"), "width=" + (a2.width || 256), "height=" + (a2.height || 256), "layers=" + r3].join("&");
              }, t3.getTileBBox = e3, t3.getMercCoords = r2, Object.defineProperty(t3, "__esModule", { value: true });
            }(e2);
          }(0, Jl.exports)), Jl.exports);
          class tu {
            constructor(t2, e2, r2) {
              this.z = t2, this.x = e2, this.y = r2, this.key = nu(0, t2, t2, e2, r2);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e2) {
              const r2 = Ql.getTileBBox(this.x, this.y, this.z), n2 = function(t3, e3, r3) {
                let n3, i2 = "";
                for (let s2 = t3; s2 > 0; s2--)
                  n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
                return i2;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r2);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class eu {
            constructor(t2, e2) {
              this.wrap = t2, this.canonical = e2, this.key = nu(t2, e2.z, e2.z, e2.x, e2.y);
            }
          }
          class ru {
            constructor(t2, e2, r2, n2, i2) {
              this.overscaledZ = t2, this.wrap = e2, this.canonical = new tu(r2, +n2, +i2), this.key = 0 === e2 && t2 === r2 ? this.canonical.key : nu(e2, t2, r2, n2, i2);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              const e2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new ru(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ru(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
            }
            calculateScaledKey(t2, e2 = true) {
              if (this.overscaledZ === t2 && e2)
                return this.key;
              if (t2 > this.canonical.z)
                return nu(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
              {
                const r2 = this.canonical.z - t2;
                return nu(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
              }
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap)
                return false;
              const e2 = this.canonical.z - t2.canonical.z;
              return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.z < this.canonical.z && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
            }
            children(t2) {
              if (this.overscaledZ >= t2)
                return [new ru(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new ru(e2, this.wrap, e2, r2, n2), new ru(e2, this.wrap, e2, r2 + 1, n2), new ru(e2, this.wrap, e2, r2, n2 + 1), new ru(e2, this.wrap, e2, r2 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new ru(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new ru(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new eu(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
          }
          function nu(t2, e2, r2, n2, i2) {
            const s2 = 1 << Math.min(r2, 22);
            let a2 = s2 * (i2 % s2) + n2 % s2;
            return t2 && r2 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e2 - r2);
          }
          const iu = [(t2) => {
            let e2 = t2.canonical.x - 1, r2 = t2.wrap;
            return e2 < 0 && (e2 = (1 << t2.canonical.z) - 1, r2--), new ru(t2.overscaledZ, r2, t2.canonical.z, e2, t2.canonical.y);
          }, (t2) => {
            let e2 = t2.canonical.x + 1, r2 = t2.wrap;
            return e2 === 1 << t2.canonical.z && (e2 = 0, r2++), new ru(t2.overscaledZ, r2, t2.canonical.z, e2, t2.canonical.y);
          }, (t2) => new ru(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, (0 === t2.canonical.y ? 1 << t2.canonical.z : t2.canonical.y) - 1), (t2) => new ru(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, t2.canonical.y === (1 << t2.canonical.z) - 1 ? 0 : t2.canonical.y + 1)];
          os(tu, "CanonicalTileID"), os(ru, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
          const su = ya([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: au } = su, ou = ya([{ name: "a_pos_3", components: 3, type: "Int16" }]);
          var lu = ya([{ name: "a_pos", type: "Int16", components: 2 }]);
          class uu {
            constructor(t2, e2) {
              this.pos = t2, this.dir = e2;
            }
            intersectsPlane(t2, e2, r2) {
              const n2 = O.vec3.dot(e2, this.dir);
              if (Math.abs(n2) < 1e-6)
                return false;
              const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n2;
              return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, r2[2] = this.pos[2] + this.dir[2] * i2, true;
            }
            closestPointOnSphere(t2, e2, r2) {
              if (O.vec3.equals(this.pos, t2) || 0 === e2)
                return r2[0] = r2[1] = r2[2] = 0, false;
              const [n2, i2, s2] = this.dir, a2 = this.pos[0] - t2[0], o2 = this.pos[1] - t2[1], l2 = this.pos[2] - t2[2], u2 = n2 * n2 + i2 * i2 + s2 * s2, c2 = 2 * (a2 * n2 + o2 * i2 + l2 * s2), h2 = c2 * c2 - 4 * u2 * (a2 * a2 + o2 * o2 + l2 * l2 - e2 * e2);
              if (h2 < 0) {
                const t3 = Math.max(-c2 / 2, 0), u3 = a2 + n2 * t3, h3 = o2 + i2 * t3, p2 = l2 + s2 * t3, f2 = Math.hypot(u3, h3, p2);
                return r2[0] = u3 * e2 / f2, r2[1] = h3 * e2 / f2, r2[2] = p2 * e2 / f2, false;
              }
              {
                const t3 = (-c2 - Math.sqrt(h2)) / (2 * u2);
                if (t3 < 0) {
                  const t4 = Math.hypot(a2, o2, l2);
                  return r2[0] = a2 * e2 / t4, r2[1] = o2 * e2 / t4, r2[2] = l2 * e2 / t4, false;
                }
                return r2[0] = a2 + n2 * t3, r2[1] = o2 + i2 * t3, r2[2] = l2 + s2 * t3, true;
              }
            }
          }
          class cu {
            constructor(t2, e2, r2, n2, i2) {
              this.TL = t2, this.TR = e2, this.BR = r2, this.BL = n2, this.horizon = i2;
            }
            static fromInvProjectionMatrix(t2, e2, r2) {
              const n2 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], a2 = [-1, -1, 1], o2 = O.vec3.transformMat4(n2, n2, t2), l2 = O.vec3.transformMat4(i2, i2, t2), u2 = O.vec3.transformMat4(s2, s2, t2), c2 = O.vec3.transformMat4(a2, a2, t2);
              return new cu(o2, l2, u2, c2, e2 / r2);
            }
          }
          function hu(t2, e2, r2) {
            let n2 = 1 / 0, i2 = -1 / 0;
            const s2 = [];
            for (const a2 of t2) {
              O.vec3.sub(s2, a2, e2);
              const t3 = O.vec3.dot(s2, r2);
              n2 = Math.min(n2, t3), i2 = Math.max(i2, t3);
            }
            return [n2, i2];
          }
          function pu(t2, e2) {
            let r2 = true;
            for (let n2 = 0; n2 < t2.planes.length; n2++) {
              const i2 = t2.planes[n2];
              let s2 = 0;
              for (let t3 = 0; t3 < e2.length; t3++)
                s2 += O.vec3.dot(i2, e2[t3]) + i2[3] >= 0;
              if (0 === s2)
                return 0;
              s2 !== e2.length && (r2 = false);
            }
            return r2 ? 2 : 1;
          }
          function fu(t2, e2) {
            for (const r2 of t2.projections) {
              const n2 = hu(e2, t2.points[0], r2.axis);
              if (r2.projection[1] < n2[0] || r2.projection[0] > n2[1])
                return 0;
            }
            return 1;
          }
          function du(t2, e2) {
            let r2 = 0;
            const n2 = [0, 0, 0, 0];
            for (let i2 = 0; i2 < t2.length; i2++)
              n2[0] = t2[i2][0], n2[1] = t2[i2][1], n2[2] = t2[i2][2], n2[3] = 1, O.vec4.dot(n2, e2) >= 0 && r2++;
            return r2;
          }
          class mu {
            constructor(t2, e2) {
              this.points = t2 || new Array(8).fill([0, 0, 0]), this.planes = e2 || new Array(6).fill([0, 0, 0, 0]), this.bounds = yu.fromPoints(this.points), this.projections = [], this.frustumEdges = [O.vec3.sub([], this.points[2], this.points[3]), O.vec3.sub([], this.points[0], this.points[3]), O.vec3.sub([], this.points[4], this.points[0]), O.vec3.sub([], this.points[5], this.points[1]), O.vec3.sub([], this.points[6], this.points[2]), O.vec3.sub([], this.points[7], this.points[3])];
              for (const t3 of this.frustumEdges) {
                const e3 = [0, -t3[2], t3[1]], r2 = [t3[2], 0, -t3[0]];
                this.projections.push({ axis: e3, projection: hu(this.points, this.points[0], e3) }), this.projections.push({ axis: r2, projection: hu(this.points, this.points[0], r2) });
              }
            }
            static fromInvProjectionMatrix(t2, e2, r2, n2) {
              const i2 = Math.pow(2, r2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
                const s3 = O.vec4.transformMat4([], r3, t2), a3 = 1 / s3[3] / e2 * i2;
                return O.vec4.mul(s3, s3, [a3, a3, n2 ? 1 / s3[3] : a3, a3]);
              }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
                const e3 = O.vec3.sub([], s2[t3[0]], s2[t3[1]]), r3 = O.vec3.sub([], s2[t3[2]], s2[t3[1]]), n3 = O.vec3.normalize([], O.vec3.cross([], e3, r3)), i3 = -O.vec3.dot(n3, s2[t3[1]]);
                return n3.concat(i3);
              }), o2 = [];
              for (let t3 = 0; t3 < s2.length; t3++)
                o2.push([s2[t3][0], s2[t3][1], s2[t3][2]]);
              return new mu(o2, a2);
            }
            intersectsPrecise(t2, e2, r2) {
              for (let r3 = 0; r3 < e2.length; r3++)
                if (!du(t2, e2[r3]))
                  return 0;
              for (let e3 = 0; e3 < this.planes.length; e3++)
                if (!du(t2, this.planes[e3]))
                  return 0;
              for (const e3 of r2)
                for (const r3 of this.frustumEdges) {
                  const n2 = O.vec3.cross([], e3, r3), i2 = O.vec3.length(n2);
                  if (0 === i2)
                    continue;
                  O.vec3.scale(n2, n2, 1 / i2);
                  const s2 = hu(this.points, this.points[0], n2), a2 = hu(t2, this.points[0], n2);
                  if (s2[0] > a2[1] || a2[0] > s2[1])
                    return 0;
                }
              return 1;
            }
            containsPoint(t2) {
              for (const e2 of this.planes) {
                const r2 = e2[3];
                if (O.vec3.dot([e2[0], e2[1], e2[2]], t2) + r2 < 0)
                  return false;
              }
              return true;
            }
          }
          class yu {
            static fromPoints(t2) {
              const e2 = [1 / 0, 1 / 0, 1 / 0], r2 = [-1 / 0, -1 / 0, -1 / 0];
              for (const n2 of t2)
                O.vec3.min(e2, e2, n2), O.vec3.max(r2, r2, n2);
              return new yu(e2, r2);
            }
            static fromTileIdAndHeight(t2, e2, r2) {
              const n2 = 1 << t2.canonical.z, i2 = t2.canonical.x, s2 = t2.canonical.y;
              return new yu([i2 / n2, s2 / n2, e2], [(i2 + 1) / n2, (s2 + 1) / n2, r2]);
            }
            static applyTransform(t2, e2) {
              const r2 = t2.getCorners();
              for (let t3 = 0; t3 < r2.length; ++t3)
                O.vec3.transformMat4(r2[t3], r2[t3], e2);
              return yu.fromPoints(r2);
            }
            static applyTransformFast(t2, e2) {
              const r2 = [e2[12], e2[13], e2[14]], n2 = [...r2];
              for (let i2 = 0; i2 < 3; i2++)
                for (let s2 = 0; s2 < 3; s2++) {
                  const a2 = e2[4 * s2 + i2], o2 = a2 * t2.min[s2], l2 = a2 * t2.max[s2];
                  r2[i2] += Math.min(o2, l2), n2[i2] += Math.max(o2, l2);
                }
              return new yu(r2, n2);
            }
            static projectAabbCorners(t2, e2) {
              const r2 = t2.getCorners();
              for (let t3 = 0; t3 < r2.length; ++t3)
                O.vec3.transformMat4(r2[t3], r2[t3], e2);
              return r2;
            }
            constructor(t2, e2) {
              this.min = t2, this.max = e2, this.center = O.vec3.scale([], O.vec3.add([], this.min, this.max), 0.5);
            }
            quadrant(t2) {
              const e2 = [t2 % 2 == 0, t2 < 2], r2 = O.vec3.clone(this.min), n2 = O.vec3.clone(this.max);
              for (let t3 = 0; t3 < e2.length; t3++)
                r2[t3] = e2[t3] ? this.min[t3] : this.center[t3], n2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
              return n2[2] = this.max[2], new yu(r2, n2);
            }
            distanceX(t2) {
              return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
            }
            distanceY(t2) {
              return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
            }
            distanceZ(t2) {
              return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
            }
            getCorners() {
              const t2 = this.min, e2 = this.max;
              return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
            }
            intersects(t2) {
              return this.intersectsAabb(t2.bounds) ? pu(t2, this.getCorners()) : 0;
            }
            intersectsFlat(t2) {
              return this.intersectsAabb(t2.bounds) ? pu(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
            }
            intersectsPrecise(t2, e2) {
              return e2 || this.intersects(t2) ? fu(t2, this.getCorners()) : 0;
            }
            intersectsPreciseFlat(t2, e2) {
              return e2 || this.intersectsFlat(t2) ? fu(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
            }
            intersectsAabb(t2) {
              for (let e2 = 0; e2 < 3; ++e2)
                if (this.min[e2] > t2.max[e2] || t2.min[e2] > this.max[e2])
                  return false;
              return true;
            }
            intersectsAabbXY(t2) {
              return !(this.min[0] > t2.max[0] || t2.min[0] > this.max[0] || this.min[1] > t2.max[1] || t2.min[1] > this.max[1]);
            }
            encapsulate(t2) {
              for (let e2 = 0; e2 < 3; e2++)
                this.min[e2] = Math.min(this.min[e2], t2.min[e2]), this.max[e2] = Math.max(this.max[e2], t2.max[e2]);
            }
            encapsulatePoint(t2) {
              for (let e2 = 0; e2 < 3; e2++)
                this.min[e2] = Math.min(this.min[e2], t2[e2]), this.max[e2] = Math.max(this.max[e2], t2[e2]);
            }
            closestPoint(t2) {
              return [Math.max(Math.min(this.max[0], t2[0]), this.min[0]), Math.max(Math.min(this.max[1], t2[1]), this.min[1]), Math.max(Math.min(this.max[2], t2[2]), this.min[2])];
            }
          }
          function gu(t2) {
            return t2 * $o / tl;
          }
          os(yu, "Aabb");
          const xu = [new yu([Ho, Ho, Ho], [Ko, Ko, Ko]), new yu([Ho, Ho, Ho], [0, 0, Ko]), new yu([0, Ho, Ho], [Ko, 0, Ko]), new yu([Ho, 0, Ho], [0, Ko, Ko]), new yu([0, 0, Ho], [Ko, Ko, Ko])];
          function bu(t2, e2, r2, n2 = true) {
            const i2 = O.vec3.scale([], t2._camera.position, t2.worldSize), s2 = [e2, r2, 1, 1];
            O.vec4.transformMat4(s2, s2, t2.pixelMatrixInverse), O.vec4.scale(s2, s2, 1 / s2[3]);
            const a2 = O.vec3.sub([], s2, i2), o2 = O.vec3.normalize([], a2), l2 = t2.globeMatrix, u2 = [l2[12], l2[13], l2[14]], c2 = O.vec3.sub([], u2, i2), h2 = O.vec3.length(c2), p2 = O.vec3.normalize([], c2), f2 = t2.worldSize / (2 * Math.PI), d2 = O.vec3.dot(p2, o2), m2 = Math.asin(f2 / h2);
            if (m2 < Math.acos(d2)) {
              if (!n2)
                return null;
              const t3 = [], e3 = [];
              O.vec3.scale(t3, o2, h2 / d2), O.vec3.normalize(e3, O.vec3.sub(e3, t3, c2)), O.vec3.normalize(o2, O.vec3.add(o2, c2, O.vec3.scale(o2, e3, Math.tan(m2) * h2)));
            }
            const y2 = [];
            new uu(i2, o2).closestPointOnSphere(u2, f2, y2);
            const g2 = O.vec3.normalize([], wt(l2, 0)), x2 = O.vec3.normalize([], wt(l2, 1)), b2 = O.vec3.normalize([], wt(l2, 2)), v2 = O.vec3.dot(g2, y2), w2 = O.vec3.dot(x2, y2), _2 = O.vec3.dot(b2, y2), M2 = Z(Math.asin(-w2 / f2));
            let A2 = Z(Math.atan2(v2, _2));
            A2 = t2.center.lng + function(t3, e3) {
              const r3 = (e3 - t3 + 180) % 360 - 180;
              return r3 < -180 ? r3 + 360 : r3;
            }(t2.center.lng, A2);
            const S2 = ol(A2), I2 = Q(ll(M2), 0, 1);
            return new xl(S2, I2);
          }
          class vu {
            constructor(t2, e2, r2) {
              this.a = O.vec3.sub([], t2, r2), this.b = O.vec3.sub([], e2, r2), this.center = r2;
              const n2 = O.vec3.normalize([], this.a), i2 = O.vec3.normalize([], this.b);
              this.angle = Math.acos(O.vec3.dot(n2, i2));
            }
          }
          function wu(t2, e2) {
            if (0 === t2.angle)
              return null;
            let r2;
            return r2 = 0 === t2.a[e2] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n2) {
              const i2 = Math.sin(r3);
              return t3 * (Math.sin((1 - n2) * r3) / i2) + e3 * (Math.sin(n2 * r3) / i2);
            }(t2.a[e2], t2.b[e2], t2.angle, Q(r2, 0, 1)) + t2.center[e2];
          }
          function _u(t2) {
            if (t2.z <= 1)
              return xu[t2.z + 2 * t2.y + t2.x];
            const e2 = Pu(Iu(t2));
            return yu.fromPoints(e2);
          }
          function Mu(t2, e2, r2) {
            return O.vec3.scale(t2, t2, 1 - r2), O.vec3.scaleAndAdd(t2, t2, e2, r2);
          }
          function Au(t2, e2, r2) {
            for (const n2 of t2)
              O.vec3.transformMat4(n2, n2, e2), O.vec3.scale(n2, n2, r2);
          }
          function Su(t2, e2, r2, n2) {
            const i2 = e2 / t2.worldSize, s2 = t2.globeMatrix;
            if (r2.z <= 1) {
              const t3 = _u(r2).getCorners();
              return Au(t3, s2, i2), yu.fromPoints(t3);
            }
            const a2 = Iu(r2, n2), o2 = Pu(a2, $o + gu(t2._tileCoverLift));
            Au(o2, s2, i2);
            const l2 = Number.MAX_VALUE, u2 = [-l2, -l2, -l2], c2 = [l2, l2, l2];
            if (a2.contains(t2.center)) {
              for (const t3 of o2)
                O.vec3.min(c2, c2, t3), O.vec3.max(u2, u2, t3);
              u2[2] = 0;
              const e3 = t2.point, r3 = [e3.x * i2, e3.y * i2, 0];
              return O.vec3.min(c2, c2, r3), O.vec3.max(u2, u2, r3), new yu(c2, u2);
            }
            if (t2._tileCoverLift > 0) {
              for (const t3 of o2)
                O.vec3.min(c2, c2, t3), O.vec3.max(u2, u2, t3);
              return new yu(c2, u2);
            }
            const h2 = [s2[12] * i2, s2[13] * i2, s2[14] * i2], p2 = a2.getCenter(), f2 = Q(t2.center.lat, -fl, fl), d2 = Q(p2.lat, -fl, fl), m2 = ol(t2.center.lng), y2 = ll(f2);
            let g2 = m2 - ol(p2.lng);
            const x2 = y2 - ll(d2);
            g2 > 0.5 ? g2 -= 1 : g2 < -0.5 && (g2 += 1);
            let b2 = 0;
            if (Math.abs(g2) > Math.abs(x2))
              b2 = g2 >= 0 ? 1 : 3;
            else {
              b2 = x2 >= 0 ? 0 : 2;
              const t3 = [s2[4] * i2, s2[5] * i2, s2[6] * i2], e3 = -Math.sin(Y(x2 >= 0 ? a2.getSouth() : a2.getNorth())) * $o;
              O.vec3.scaleAndAdd(h2, h2, t3, e3);
            }
            const v2 = o2[b2], w2 = o2[(b2 + 1) % 4], _2 = new vu(v2, w2, h2), M2 = [wu(_2, 0) || v2[0], wu(_2, 1) || v2[1], wu(_2, 2) || v2[2]], A2 = Du(t2.zoom);
            if (A2 > 0) {
              const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, a3) {
                const o3 = 1 / (1 << r3);
                let l3 = t3 * o3, u3 = l3 + o3, c3 = e3 * o3, h3 = c3 + o3, p3 = 0;
                const f3 = (l3 + u3) / 2 - s3;
                return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u3 = ((u3 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (a3 *= n4)) * i4 + a3, h3 = (h3 * n4 - a3) * i4 + a3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
              }(r2, e2, t2._pixelsPerMercatorPixel, m2, y2);
              for (let t3 = 0; t3 < o2.length; t3++)
                Mu(o2[t3], n3[t3], A2);
              const i3 = O.vec3.add([], n3[b2], n3[(b2 + 1) % 4]);
              O.vec3.scale(i3, i3, 0.5), Mu(M2, i3, A2);
            }
            for (const t3 of o2)
              O.vec3.min(c2, c2, t3), O.vec3.max(u2, u2, t3);
            return c2[2] = Math.min(v2[2], w2[2]), O.vec3.min(c2, c2, M2), O.vec3.max(u2, u2, M2), new yu(c2, u2);
          }
          function Iu({ x: t2, y: e2, z: r2 }, n2 = false) {
            const i2 = 1 / (1 << r2), s2 = new rl(cl(t2 * i2), e2 === (1 << r2) - 1 && n2 ? -90 : hl((e2 + 1) * i2)), a2 = new rl(cl((t2 + 1) * i2), 0 === e2 && n2 ? 90 : hl(e2 * i2));
            return new nl(s2, a2);
          }
          function Pu(t2, e2 = $o) {
            const r2 = Y(t2.getNorth()), n2 = Y(t2.getSouth()), i2 = Math.cos(r2), s2 = Math.cos(n2), a2 = Math.sin(r2), o2 = Math.sin(n2), l2 = t2.getWest(), u2 = t2.getEast();
            return [Jo(s2, o2, l2, e2), Jo(s2, o2, u2, e2), Jo(i2, a2, u2, e2), Jo(i2, a2, l2, e2)];
          }
          function zu(t2, e2, r2, n2) {
            const i2 = 1 << r2.z, s2 = (t2 / Hr + r2.x) / i2;
            return Qo(hl((e2 / Hr + r2.y) / i2), cl(s2), n2);
          }
          function ku({ min: t2, max: e2 }) {
            return Yo / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
          }
          const Tu = new Float64Array(16);
          function Eu(t2) {
            const e2 = ku(t2), r2 = O.mat4.fromScaling(Tu, [e2, e2, e2]);
            return O.mat4.translate(r2, r2, O.vec3.negate([], t2.min));
          }
          function Bu(t2) {
            const e2 = O.mat4.fromTranslation(Tu, t2.min), r2 = 1 / ku(t2);
            return O.mat4.scale(e2, e2, [r2, r2, r2]);
          }
          function Vu(t2) {
            const e2 = Hr / (2 * Math.PI);
            return t2 / (2 * Math.PI) / e2;
          }
          function Cu(t2, e2) {
            return Hr / (512 * Math.pow(2, t2)) * ku(_u(e2));
          }
          function Ru(t2, e2, r2, n2, i2) {
            const s2 = Vu(r2), a2 = [t2, e2, -r2 / (2 * Math.PI)], o2 = O.mat4.identity(new Float64Array(16));
            return O.mat4.translate(o2, o2, a2), O.mat4.scale(o2, o2, [s2, s2, s2]), O.mat4.rotateX(o2, o2, Y(-i2)), O.mat4.rotateY(o2, o2, Y(-n2)), o2;
          }
          function Du(t2) {
            return tt(Go, Xo, t2);
          }
          function Lu(t2, e2) {
            const r2 = Qo(e2.lat, e2.lng), n2 = function(t3) {
              const e3 = Qo(t3._center.lat, t3._center.lng), r3 = O.vec3.fromValues(0, 1, 0);
              let n3 = O.vec3.cross([], r3, e3);
              const i3 = O.mat4.fromRotation([], -t3.angle, e3);
              n3 = O.vec3.transformMat4(n3, n3, i3), O.mat4.fromRotation(i3, -t3._pitch, n3);
              const s2 = O.vec3.normalize([], e3);
              return O.vec3.scale(s2, s2, gu(t3.cameraToCenterDistance / t3.pixelsPerMeter)), O.vec3.transformMat4(s2, s2, i3), O.vec3.add([], e3, s2);
            }(t2), i2 = O.vec3.subtract([], n2, r2);
            return O.vec3.angle(i2, r2);
          }
          function Fu(t2, e2) {
            return Lu(t2, e2) > Math.PI / 2 * 1.01;
          }
          const Ou = Y(85), Uu = Math.cos(Ou), ju = Math.sin(Ou), Nu = O.mat4.create(), qu = (t2) => {
            const e2 = [];
            return "map" === t2.paint.get("circle-pitch-alignment") && e2.push("PITCH_WITH_MAP"), "map" === t2.paint.get("circle-pitch-scale") && e2.push("SCALE_WITH_MAP"), e2;
          };
          function $u(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            if (s2 && t2.queryGeometry.isAboveHorizon)
              return false;
            s2 && (l2 *= t2.pixelToTileUnitsFactor);
            const u2 = t2.tileID.canonical, c2 = r2.projection.upVectorScale(u2, r2.center.lat, r2.worldSize).metersToTile;
            for (const h2 of e2)
              for (const e3 of h2) {
                const h3 = e3.add(o2), p2 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(h3.x, h3.y, true) : 0, f2 = r2.projection.projectTilePoint(h3.x, h3.y, u2);
                if (p2 > 0) {
                  const t3 = r2.projection.upVector(u2, h3.x, h3.y);
                  f2.x += t3[0] * c2 * p2, f2.y += t3[1] * c2 * p2, f2.z += t3[2] * c2 * p2;
                }
                const d2 = s2 ? h3 : Gu(f2.x, f2.y, f2.z, n2), m2 = s2 ? t2.tilespaceRays.map((t3) => Zu(t3, p2)) : t2.queryGeometry.screenGeometry, y2 = O.vec4.transformMat4([], [f2.x, f2.y, f2.z, 1], n2);
                if (!a2 && s2 ? l2 *= y2[3] / r2.cameraToCenterDistance : a2 && !s2 && (l2 *= r2.cameraToCenterDistance / y2[3]), s2) {
                  const t3 = hl((e3.y / Hr + u2.y) / (1 << u2.z));
                  l2 /= r2.projection.pixelsPerMeter(t3, 1) / ul(1, t3);
                }
                if (Bl(m2, d2, l2))
                  return true;
              }
            return false;
          }
          function Gu(t2, e2, r2, n2) {
            const i2 = O.vec4.transformMat4([], [t2, e2, r2, 1], n2);
            return new q(i2[0] / i2[3], i2[1] / i2[3]);
          }
          const Xu = O.vec3.fromValues(0, 0, 0), Yu = O.vec3.fromValues(0, 0, 1);
          function Zu(t2, e2) {
            const r2 = O.vec3.create();
            return Xu[2] = e2, t2.intersectsPlane(Xu, Yu, r2), new q(r2[0], r2[1]);
          }
          class Wu extends Tl {
          }
          let Hu, Ku, Ju, Qu;
          function tc(t2, { width: e2, height: r2 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray)
                i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e2 * r2 * n2)
                throw new RangeError("mismatched image size");
            } else
              i2 = new Uint8Array(e2 * r2 * n2);
            return t2.width = e2, t2.height = r2, t2.data = i2, t2;
          }
          function ec(t2, e2, r2) {
            const { width: n2, height: i2 } = e2;
            n2 === t2.width && i2 === t2.height || (rc(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2, null), t2.width = n2, t2.height = i2, t2.data = e2.data);
          }
          function rc(t2, e2, r2, n2, i2, s2, a2, o2) {
            if (0 === i2.width || 0 === i2.height)
              return e2;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const l2 = t2.data, u2 = e2.data, c2 = 4 === s2 && o2;
            for (let o3 = 0; o3 < i2.height; o3++) {
              const h2 = ((r2.y + o3) * t2.width + r2.x) * s2, p2 = ((n2.y + o3) * e2.width + n2.x) * s2;
              if (c2)
                for (let t3 = 0; t3 < i2.width; t3++) {
                  const e3 = h2 + t3 * s2 + 3, r3 = p2 + t3 * s2;
                  u2[r3 + 0] = 255, u2[r3 + 1] = 255, u2[r3 + 2] = 255, u2[r3 + 3] = l2[e3];
                }
              else if (a2)
                for (let t3 = 0; t3 < i2.width; t3++) {
                  const e3 = h2 + t3 * s2, r3 = p2 + t3 * s2, n3 = l2[e3 + 3], i3 = new Pe(l2[e3 + 0] / 255 * n3, l2[e3 + 1] / 255 * n3, l2[e3 + 2] / 255 * n3, n3).toRenderColor(a2).toArray();
                  u2[r3 + 0] = i3[0], u2[r3 + 1] = i3[1], u2[r3 + 2] = i3[2], u2[r3 + 3] = i3[3];
                }
              else
                for (let t3 = 0; t3 < i2.width * s2; t3++)
                  u2[p2 + t3] = l2[h2 + t3];
            }
            return e2;
          }
          os(Wu, "HeatmapBucket", { omit: ["layers"] });
          class nc {
            constructor(t2, e2) {
              tc(this, t2, 1, e2);
            }
            resize(t2) {
              ec(this, new nc(t2), 1);
            }
            clone() {
              return new nc({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              rc(t2, e2, r2, n2, i2, 1, null);
            }
          }
          class ic {
            constructor(t2, e2) {
              tc(this, t2, 4, e2);
            }
            resize(t2) {
              ec(this, new ic(t2), 4);
            }
            replace(t2, e2) {
              e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new ic({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2, s2, a2) {
              rc(t2, e2, r2, n2, i2, 4, s2, a2);
            }
          }
          class sc {
            constructor(t2, e2) {
              this.width = t2.width, this.height = t2.height, this.data = e2 instanceof Uint8Array ? new Float32Array(e2.buffer) : e2;
            }
          }
          function ac(t2) {
            const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new ic({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
              e2[t2.evaluationKey] = s3;
              const a2 = t2.expression.evaluate(e2);
              a2 && (i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a));
            };
            if (t2.clips)
              for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
                for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
                  const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
                  s2(i3, a2, l2 * (1 - o2) + u2 * o2);
                }
            else
              for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
                s2(0, e3, t3 / (r2 - 1));
            return i2;
          }
          os(nc, "AlphaImage"), os(ic, "RGBAImage");
          const oc = ya([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: lc } = oc;
          function uc(t2, e2, r2 = 2) {
            const n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
            let s2 = cc(t2, 0, i2, r2, true);
            const a2 = [];
            if (!s2 || s2.next === s2.prev)
              return a2;
            let o2, l2, u2;
            if (n2 && (s2 = function(t3, e3, r3, n3) {
              const i3 = [];
              for (let r4 = 0, s3 = e3.length; r4 < s3; r4++) {
                const a3 = cc(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
                a3 === a3.next && (a3.steiner = true), i3.push(wc(a3));
              }
              i3.sort(gc);
              for (let t4 = 0; t4 < i3.length; t4++)
                r3 = xc(i3[t4], r3);
              return r3;
            }(t2, e2, s2, r2)), t2.length > 80 * r2) {
              o2 = 1 / 0, l2 = 1 / 0;
              let e3 = -1 / 0, n3 = -1 / 0;
              for (let s3 = r2; s3 < i2; s3 += r2) {
                const r3 = t2[s3], i3 = t2[s3 + 1];
                r3 < o2 && (o2 = r3), i3 < l2 && (l2 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
              }
              u2 = Math.max(e3 - o2, n3 - l2), u2 = 0 !== u2 ? 32767 / u2 : 0;
            }
            return pc(s2, a2, r2, o2, l2, u2, 0), a2;
          }
          function cc(t2, e2, r2, n2, i2) {
            let s2;
            if (i2 === function(t3, e3, r3, n3) {
              let i3 = 0;
              for (let s3 = e3, a2 = r3 - n3; s3 < r3; s3 += n3)
                i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
              return i3;
            }(t2, e2, r2, n2) > 0)
              for (let i3 = e2; i3 < r2; i3 += n2)
                s2 = Ec(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
            else
              for (let i3 = r2 - n2; i3 >= e2; i3 -= n2)
                s2 = Ec(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
            return s2 && Sc(s2, s2.next) && (Bc(s2), s2 = s2.next), s2;
          }
          function hc(t2, e2) {
            if (!t2)
              return t2;
            e2 || (e2 = t2);
            let r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !Sc(n2, n2.next) && 0 !== Ac(n2.prev, n2, n2.next))
                n2 = n2.next;
              else {
                if (Bc(n2), n2 = e2 = n2.prev, n2 === n2.next)
                  break;
                r2 = true;
              }
            } while (r2 || n2 !== e2);
            return e2;
          }
          function pc(t2, e2, r2, n2, i2, s2, a2) {
            if (!t2)
              return;
            !a2 && s2 && function(t3, e3, r3, n3) {
              let i3 = t3;
              do {
                0 === i3.z && (i3.z = vc(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                let e4, r4 = 1;
                do {
                  let n4, i4 = t4;
                  t4 = null;
                  let s3 = null;
                  for (e4 = 0; i4; ) {
                    e4++;
                    let a3 = i4, o3 = 0;
                    for (let t5 = 0; t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++)
                      ;
                    let l2 = r4;
                    for (; o3 > 0 || l2 > 0 && a3; )
                      0 !== o3 && (0 === l2 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                    i4 = a3;
                  }
                  s3.nextZ = null, r4 *= 2;
                } while (e4 > 1);
              }(i3);
            }(t2, n2, i2, s2);
            let o2 = t2;
            for (; t2.prev !== t2.next; ) {
              const l2 = t2.prev, u2 = t2.next;
              if (s2 ? dc(t2, n2, i2, s2) : fc(t2))
                e2.push(l2.i, t2.i, u2.i), Bc(t2), t2 = u2.next, o2 = u2.next;
              else if ((t2 = u2) === o2) {
                a2 ? 1 === a2 ? pc(t2 = mc(hc(t2), e2), e2, r2, n2, i2, s2, 2) : 2 === a2 && yc(t2, e2, r2, n2, i2, s2) : pc(hc(t2), e2, r2, n2, i2, s2, 1);
                break;
              }
            }
          }
          function fc(t2) {
            const e2 = t2.prev, r2 = t2, n2 = t2.next;
            if (Ac(e2, r2, n2) >= 0)
              return false;
            const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2;
            let d2 = n2.next;
            for (; d2 !== e2; ) {
              if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && _c(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && Ac(d2.prev, d2, d2.next) >= 0)
                return false;
              d2 = d2.next;
            }
            return true;
          }
          function dc(t2, e2, r2, n2) {
            const i2 = t2.prev, s2 = t2, a2 = t2.next;
            if (Ac(i2, s2, a2) >= 0)
              return false;
            const o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, m2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, y2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = vc(f2, d2, e2, r2, n2), x2 = vc(m2, y2, e2, r2, n2);
            let b2 = t2.prevZ, v2 = t2.nextZ;
            for (; b2 && b2.z >= g2 && v2 && v2.z <= x2; ) {
              if (b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y2 && b2 !== i2 && b2 !== a2 && _c(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ac(b2.prev, b2, b2.next) >= 0)
                return false;
              if (b2 = b2.prevZ, v2.x >= f2 && v2.x <= m2 && v2.y >= d2 && v2.y <= y2 && v2 !== i2 && v2 !== a2 && _c(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ac(v2.prev, v2, v2.next) >= 0)
                return false;
              v2 = v2.nextZ;
            }
            for (; b2 && b2.z >= g2; ) {
              if (b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y2 && b2 !== i2 && b2 !== a2 && _c(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ac(b2.prev, b2, b2.next) >= 0)
                return false;
              b2 = b2.prevZ;
            }
            for (; v2 && v2.z <= x2; ) {
              if (v2.x >= f2 && v2.x <= m2 && v2.y >= d2 && v2.y <= y2 && v2 !== i2 && v2 !== a2 && _c(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ac(v2.prev, v2, v2.next) >= 0)
                return false;
              v2 = v2.nextZ;
            }
            return true;
          }
          function mc(t2, e2) {
            let r2 = t2;
            do {
              const n2 = r2.prev, i2 = r2.next.next;
              !Sc(n2, i2) && Ic(n2, r2, r2.next, i2) && kc(n2, i2) && kc(i2, n2) && (e2.push(n2.i, r2.i, i2.i), Bc(r2), Bc(r2.next), r2 = t2 = i2), r2 = r2.next;
            } while (r2 !== t2);
            return hc(r2);
          }
          function yc(t2, e2, r2, n2, i2, s2) {
            let a2 = t2;
            do {
              let t3 = a2.next.next;
              for (; t3 !== a2.prev; ) {
                if (a2.i !== t3.i && Mc(a2, t3)) {
                  let o2 = Tc(a2, t3);
                  return a2 = hc(a2, a2.next), o2 = hc(o2, o2.next), pc(a2, e2, r2, n2, i2, s2, 0), void pc(o2, e2, r2, n2, i2, s2, 0);
                }
                t3 = t3.next;
              }
              a2 = a2.next;
            } while (a2 !== t2);
          }
          function gc(t2, e2) {
            return t2.x - e2.x;
          }
          function xc(t2, e2) {
            const r2 = function(t3, e3) {
              let r3 = e3;
              const n3 = t3.x, i2 = t3.y;
              let s2, a2 = -1 / 0;
              do {
                if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
                  const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
                  if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3))
                    return s2;
                }
                r3 = r3.next;
              } while (r3 !== e3);
              if (!s2)
                return null;
              const o2 = s2, l2 = s2.x, u2 = s2.y;
              let c2 = 1 / 0;
              r3 = s2;
              do {
                if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && _c(i2 < u2 ? n3 : a2, i2, l2, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
                  const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
                  kc(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && bc(s2, r3))) && (s2 = r3, c2 = e4);
                }
                r3 = r3.next;
              } while (r3 !== o2);
              return s2;
            }(t2, e2);
            if (!r2)
              return e2;
            const n2 = Tc(r2, t2);
            return hc(n2, n2.next), hc(r2, r2.next);
          }
          function bc(t2, e2) {
            return Ac(t2.prev, t2, e2.prev) < 0 && Ac(e2.next, t2, t2.next) < 0;
          }
          function vc(t2, e2, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function wc(t2) {
            let e2 = t2, r2 = t2;
            do {
              (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r2;
          }
          function _c(t2, e2, r2, n2, i2, s2, a2, o2) {
            return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
          }
          function Mc(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              let r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ic(r2, r2.next, t3, e3))
                  return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e2) && (kc(t2, e2) && kc(e2, t2) && function(t3, e3) {
              let r2 = t3, n2 = false;
              const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
              do {
                r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e2) && (Ac(t2.prev, t2, e2.prev) || Ac(t2, e2.prev, e2)) || Sc(t2, e2) && Ac(t2.prev, t2, t2.next) > 0 && Ac(e2.prev, e2, e2.next) > 0);
          }
          function Ac(t2, e2, r2) {
            return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
          }
          function Sc(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function Ic(t2, e2, r2, n2) {
            const i2 = zc(Ac(t2, e2, r2)), s2 = zc(Ac(t2, e2, n2)), a2 = zc(Ac(r2, n2, t2)), o2 = zc(Ac(r2, n2, e2));
            return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Pc(t2, r2, e2)) || !(0 !== s2 || !Pc(t2, n2, e2)) || !(0 !== a2 || !Pc(r2, t2, n2)) || !(0 !== o2 || !Pc(r2, e2, n2));
          }
          function Pc(t2, e2, r2) {
            return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
          }
          function zc(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function kc(t2, e2) {
            return Ac(t2.prev, t2, t2.next) < 0 ? Ac(t2, e2, t2.next) >= 0 && Ac(t2, t2.prev, e2) >= 0 : Ac(t2, e2, t2.prev) < 0 || Ac(t2, t2.next, e2) < 0;
          }
          function Tc(t2, e2) {
            const r2 = Vc(t2.i, t2.x, t2.y), n2 = Vc(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
          }
          function Ec(t2, e2, r2, n2) {
            const i2 = Vc(t2, e2, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function Bc(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function Vc(t2, e2, r2) {
            return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
          }
          function Cc(t2, e2) {
            const r2 = t2.length;
            if (r2 <= 1)
              return [t2];
            const n2 = [];
            let i2, s2;
            for (let e3 = 0; e3 < r2; e3++) {
              const r3 = mt(t2[e3]);
              0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
            }
            if (i2 && n2.push(i2), e2 > 1)
              for (let t3 = 0; t3 < n2.length; t3++)
                n2[t3].length <= e2 || (br(n2[t3], e2, 1, n2[t3].length - 1, Rc), n2[t3] = n2[t3].slice(0, e2));
            return n2;
          }
          function Rc(t2, e2) {
            return e2.area - t2.area;
          }
          function Dc(t2, e2, r2) {
            const n2 = r2.patternDependencies;
            let i2 = false;
            for (const r3 of e2) {
              const e3 = r3.paint.get(`${t2}-pattern`);
              e3.isConstant() || (i2 = true);
              const s2 = e3.constantOr(null);
              s2 && (i2 = true, n2[s2] = true);
            }
            return i2;
          }
          function Lc(t2, e2, r2, n2, i2) {
            const s2 = i2.patternDependencies;
            for (const a2 of e2) {
              const e3 = a2.paint.get(`${t2}-pattern`).value;
              if ("constant" !== e3.kind) {
                let t3 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3, s2[t3] = true, r2.patterns[a2.id] = t3;
              }
            }
            return r2;
          }
          class Fc {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new xa(), this.indexArray = new Da(), this.indexArray2 = new Ea(), this.programConfigurations = new Fo(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.segments = new co(), this.segments2 = new co(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection;
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.hasPattern = Dc("fill", this.layers, e2);
              const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
              for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, c2 = Pl(a2, t3);
                if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), c2, r2))
                  continue;
                const h2 = i2 ? i2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Il(a2, r2, n2), patterns: {}, sortKey: h2 };
                s2.push(p2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = Lc("fill", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s3, r2, {}, e2.availableImages, e2.brightness);
                e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r2, n2, i2) {
              const s2 = 0 !== Object.keys(t2).length;
              s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t2, e2, s2 ? this.stateDependentLayers : this.layers, r2, n2, i2);
            }
            addFeatures(t2, e2, r2, n2, i2, s2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2, s2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, lc), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2 = [], a2) {
              for (const t3 of Cc(e2, 500)) {
                let e3 = 0;
                for (const r4 of t3)
                  e3 += r4.length;
                const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s3 = [];
                for (const e4 of t3) {
                  if (0 === e4.length)
                    continue;
                  e4 !== t3[0] && s3.push(i3.length / 2);
                  const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                  this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                  for (let t4 = 1; t4 < e4.length; t4++)
                    this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                  r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
                }
                const a3 = uc(i3, s3);
                for (let t4 = 0; t4 < a3.length; t4 += 3)
                  this.indexArray.emplaceBack(n3 + a3[t4], n3 + a3[t4 + 1], n3 + a3[t4 + 2]);
                r3.vertexLength += e3, r3.primitiveLength += a3.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, a2);
            }
          }
          let Oc, Uc, jc, Nc;
          os(Fc, "FillBucket", { omit: ["layers", "patternFeatures"] });
          class qc {
            constructor(t2, e2, r2, n2) {
              if (this.triangleCount = e2.length / 3, this.min = new q(0, 0), this.max = new q(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t2.length)
                return;
              const [i2, s2] = [t2[0].clone(), t2[0].clone()];
              for (let e3 = 1; e3 < t2.length; ++e3) {
                const r3 = t2[e3];
                i2.x = Math.min(i2.x, r3.x), i2.y = Math.min(i2.y, r3.y), s2.x = Math.max(s2.x, r3.x), s2.y = Math.max(s2.y, r3.y);
              }
              if (n2) {
                const t3 = Math.ceil(Math.max(s2.x - i2.x, s2.y - i2.y) / n2);
                r2 = Math.max(r2, t3);
              }
              if (0 === r2)
                return;
              this.min = i2, this.max = s2;
              const a2 = this.max.sub(this.min);
              a2.x = Math.max(a2.x, 1), a2.y = Math.max(a2.y, 1);
              const o2 = Math.max(a2.x, a2.y) / r2;
              this.cellsX = Math.max(1, Math.ceil(a2.x / o2)), this.cellsY = Math.max(1, Math.ceil(a2.y / o2)), this.xScale = 1 / o2, this.yScale = 1 / o2;
              const l2 = [];
              for (let r3 = 0; r3 < this.triangleCount; r3++) {
                const n3 = t2[e2[3 * r3 + 0]].sub(this.min), i3 = t2[e2[3 * r3 + 1]].sub(this.min), s3 = t2[e2[3 * r3 + 2]].sub(this.min), a3 = $c(Math.floor(Math.min(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), u3 = $c(Math.floor(Math.max(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), c2 = $c(Math.floor(Math.min(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), h2 = $c(Math.floor(Math.max(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), p2 = new q(0, 0), f2 = new q(0, 0), d2 = new q(0, 0), m2 = new q(0, 0);
                for (let t3 = c2; t3 <= h2; ++t3) {
                  p2.y = f2.y = t3 * o2, d2.y = m2.y = (t3 + 1) * o2;
                  for (let e3 = a3; e3 <= u3; ++e3)
                    p2.x = d2.x = e3 * o2, f2.x = m2.x = (e3 + 1) * o2, ($l(n3, i3, s3, p2, f2, m2) || $l(n3, i3, s3, p2, m2, d2)) && l2.push({ cellIdx: t3 * this.cellsX + e3, triIdx: r3 });
                }
              }
              if (0 === l2.length)
                return;
              l2.sort((t3, e3) => t3.cellIdx - e3.cellIdx || t3.triIdx - e3.triIdx);
              let u2 = 0;
              for (; u2 < l2.length; ) {
                const t3 = l2[u2].cellIdx, e3 = { start: this.payload.length, len: 0 };
                for (; u2 < l2.length && l2[u2].cellIdx === t3; )
                  ++e3.len, this.payload.push(l2[u2++].triIdx);
                this.cells[t3] = e3;
              }
            }
            _lazyInitLookup() {
              this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
            }
            queryPoint(t2, e2) {
              if (0 === this.triangleCount || 0 === this.cells.length)
                return;
              if (t2.x > this.max.x || this.min.x > t2.x || t2.y > this.max.y || this.min.y > t2.y)
                return;
              const r2 = $c(t2.x - this.min.x, this.xScale, this.cellsX), n2 = $c(t2.y - this.min.y, this.yScale, this.cellsY), i2 = this.cells[n2 * this.cellsX + r2];
              if (i2) {
                this._lazyInitLookup();
                for (let t3 = 0; t3 < i2.len; t3++) {
                  const r3 = this.payload[i2.start + t3], n3 = Math.floor(r3 / 8), s2 = 1 << r3 % 8;
                  if (!(this.lookup[n3] & s2) && (this.lookup[n3] |= s2, e2.push(r3), e2.length === this.triangleCount))
                    return;
                }
              }
            }
            query(t2, e2, r2) {
              if (0 === this.triangleCount || 0 === this.cells.length)
                return;
              if (t2.x > this.max.x || this.min.x > e2.x)
                return;
              if (t2.y > this.max.y || this.min.y > e2.y)
                return;
              this._lazyInitLookup();
              const n2 = $c(t2.x - this.min.x, this.xScale, this.cellsX), i2 = $c(e2.x - this.min.x, this.xScale, this.cellsX), s2 = $c(t2.y - this.min.y, this.yScale, this.cellsY), a2 = $c(e2.y - this.min.y, this.yScale, this.cellsY);
              for (let t3 = s2; t3 <= a2; t3++)
                for (let e3 = n2; e3 <= i2; e3++) {
                  const n3 = this.cells[t3 * this.cellsX + e3];
                  if (n3)
                    for (let t4 = 0; t4 < n3.len; t4++) {
                      const e4 = this.payload[n3.start + t4], i3 = Math.floor(e4 / 8), s3 = 1 << e4 % 8;
                      if (!(this.lookup[i3] & s3) && (this.lookup[i3] |= s3, r2.push(e4), r2.length === this.triangleCount))
                        return;
                    }
                }
            }
          }
          function $c(t2, e2, r2) {
            return Math.max(0, Math.min(r2 - 1, Math.floor(t2 * e2)));
          }
          os(qc, "TriangleGridIndex");
          class Gc {
            constructor(t2) {
              this.zoom = t2.zoom, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.footprints = [];
            }
            updateFootprints(t2, e2) {
              for (const r2 of this.footprints)
                e2.push({ footprint: r2, id: t2 });
            }
            populate(t2, e2, r2, n2) {
              const i2 = [];
              for (const { feature: e3, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Pl(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), l2, r2))
                  continue;
                const u2 = { id: s2, properties: e3.properties, type: e3.type, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : Il(e3, r2, n2), patterns: {} };
                i2.push(u2);
              }
              for (const n3 of i2) {
                const { geometry: i3, index: s2, sourceLayerIndex: a2 } = n3;
                this.addFeature(n3, i3, s2, r2, {}, e2.availableImages, e2.brightness), e2.featureIndex.insert(t2[s2].feature, i3, s2, a2, this.index);
              }
            }
            isEmpty() {
              return 0 === this.footprints.length;
            }
            uploadPending() {
              return false;
            }
            upload(t2) {
            }
            update(t2, e2, r2, n2, i2) {
            }
            destroy() {
            }
            addFeature(t2, e2, r2, n2, i2, s2 = [], a2) {
              for (const t3 of Cc(e2, 2)) {
                const e3 = [], r3 = [], n3 = [], i3 = new q(1 / 0, 1 / 0), s3 = new q(-1 / 0, -1 / 0);
                for (const a4 of t3)
                  if (0 !== a4.length) {
                    a4 !== t3[0] && n3.push(r3.length / 2);
                    for (let t4 = 0; t4 < a4.length; t4++)
                      r3.push(a4[t4].x), r3.push(a4[t4].y), e3.push(a4[t4]), i3.x = Math.min(i3.x, a4[t4].x), i3.y = Math.min(i3.y, a4[t4].y), s3.x = Math.max(s3.x, a4[t4].x), s3.y = Math.max(s3.y, a4[t4].y);
                  }
                const a3 = uc(r3, n3), o2 = new qc(e3, a3, 8, 256);
                this.footprints.push({ vertices: e3, indices: a3, grid: o2, min: i3, max: s3 });
              }
            }
          }
          os(Gc, "ClipBucket", { omit: ["layers"] });
          const Xc = ya([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Yc = ya([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Zc = ya([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Wc = ya([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Hc = ya([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Kc = ya([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Jc } = Xc;
          var Qc, th, eh, rh, nh, ih, sh, ah = {};
          function oh() {
            if (th)
              return Qc;
            th = 1;
            var t2 = N();
            function e2(t3, e3, n3, i2, s2) {
              this.properties = {}, this.extent = n3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = i2, this._values = s2, t3.readFields(r2, this, e3);
            }
            function r2(t3, e3, r3) {
              1 == t3 ? e3.id = r3.readVarint() : 2 == t3 ? function(t4, e4) {
                for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
                  var n3 = e4._keys[t4.readVarint()], i2 = e4._values[t4.readVarint()];
                  e4.properties[n3] = i2;
                }
              }(r3, e3) : 3 == t3 ? e3.type = r3.readVarint() : 4 == t3 && (e3._geometry = r3.pos);
            }
            function n2(t3) {
              for (var e3, r3, n3 = 0, i2 = 0, s2 = t3.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
                n3 += ((r3 = t3[a2]).x - (e3 = t3[i2]).x) * (e3.y + r3.y);
              return n3;
            }
            return Qc = e2, e2.types = ["Unknown", "Point", "LineString", "Polygon"], e2.prototype.loadGeometry = function() {
              var e3 = this._pbf;
              e3.pos = this._geometry;
              for (var r3, n3 = e3.readVarint() + e3.pos, i2 = 1, s2 = 0, a2 = 0, o2 = 0, l2 = []; e3.pos < n3; ) {
                if (s2 <= 0) {
                  var u2 = e3.readVarint();
                  i2 = 7 & u2, s2 = u2 >> 3;
                }
                if (s2--, 1 === i2 || 2 === i2)
                  a2 += e3.readSVarint(), o2 += e3.readSVarint(), 1 === i2 && (r3 && l2.push(r3), r3 = []), r3.push(new t2(a2, o2));
                else {
                  if (7 !== i2)
                    throw new Error("unknown command " + i2);
                  r3 && r3.push(r3[0].clone());
                }
              }
              return r3 && l2.push(r3), l2;
            }, e2.prototype.bbox = function() {
              var t3 = this._pbf;
              t3.pos = this._geometry;
              for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t3.pos < e3; ) {
                if (n3 <= 0) {
                  var c2 = t3.readVarint();
                  r3 = 7 & c2, n3 = c2 >> 3;
                }
                if (n3--, 1 === r3 || 2 === r3)
                  (i2 += t3.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t3.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
                else if (7 !== r3)
                  throw new Error("unknown command " + r3);
              }
              return [a2, l2, o2, u2];
            }, e2.prototype.toGeoJSON = function(t3, r3, i2) {
              var s2, a2, o2 = this.extent * Math.pow(2, i2), l2 = this.extent * t3, u2 = this.extent * r3, c2 = this.loadGeometry(), h2 = e2.types[this.type];
              function p2(t4) {
                for (var e3 = 0; e3 < t4.length; e3++) {
                  var r4 = t4[e3];
                  t4[e3] = [360 * (r4.x + l2) / o2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + u2) / o2) * Math.PI / 180)) - 90];
                }
              }
              switch (this.type) {
                case 1:
                  var f2 = [];
                  for (s2 = 0; s2 < c2.length; s2++)
                    f2[s2] = c2[s2][0];
                  p2(c2 = f2);
                  break;
                case 2:
                  for (s2 = 0; s2 < c2.length; s2++)
                    p2(c2[s2]);
                  break;
                case 3:
                  for (c2 = function(t4) {
                    var e3 = t4.length;
                    if (e3 <= 1)
                      return [t4];
                    for (var r4, i3, s3 = [], a3 = 0; a3 < e3; a3++) {
                      var o3 = n2(t4[a3]);
                      0 !== o3 && (void 0 === i3 && (i3 = o3 < 0), i3 === o3 < 0 ? (r4 && s3.push(r4), r4 = [t4[a3]]) : r4.push(t4[a3]));
                    }
                    return r4 && s3.push(r4), s3;
                  }(c2), s2 = 0; s2 < c2.length; s2++)
                    for (a2 = 0; a2 < c2[s2].length; a2++)
                      p2(c2[s2][a2]);
              }
              1 === c2.length ? c2 = c2[0] : h2 = "Multi" + h2;
              var d2 = { type: "Feature", geometry: { type: h2, coordinates: c2 }, properties: this.properties };
              return "id" in this && (d2.id = this.id), d2;
            }, Qc;
          }
          function lh() {
            if (rh)
              return eh;
            rh = 1;
            var t2 = oh();
            function e2(t3, e3) {
              this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(r2, this, e3), this.length = this._features.length;
            }
            function r2(t3, e3, r3) {
              15 === t3 ? e3.version = r3.readVarint() : 1 === t3 ? e3.name = r3.readString() : 5 === t3 ? e3.extent = r3.readVarint() : 2 === t3 ? e3._features.push(r3.pos) : 3 === t3 ? e3._keys.push(r3.readString()) : 4 === t3 && e3._values.push(function(t4) {
                for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
                  var n2 = t4.readVarint() >> 3;
                  e4 = 1 === n2 ? t4.readString() : 2 === n2 ? t4.readFloat() : 3 === n2 ? t4.readDouble() : 4 === n2 ? t4.readVarint64() : 5 === n2 ? t4.readVarint() : 6 === n2 ? t4.readSVarint() : 7 === n2 ? t4.readBoolean() : null;
                }
                return e4;
              }(r3));
            }
            return eh = e2, e2.prototype.feature = function(e3) {
              if (e3 < 0 || e3 >= this._features.length)
                throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[e3];
              var r3 = this._pbf.readVarint() + this._pbf.pos;
              return new t2(this._pbf, r3, this.extent, this._keys, this._values);
            }, eh;
          }
          function uh() {
            return sh || (sh = 1, ah.VectorTile = function() {
              if (ih)
                return nh;
              ih = 1;
              var t2 = lh();
              function e2(e3, r2, n2) {
                if (3 === e3) {
                  var i2 = new t2(n2, n2.readVarint() + n2.pos);
                  i2.length && (r2[i2.name] = i2);
                }
              }
              return nh = function(t3, r2) {
                this.layers = t3.readFields(e2, {}, r2);
              }, nh;
            }(), ah.VectorTileFeature = oh(), ah.VectorTileLayer = lh()), ah;
          }
          var ch = uh();
          class hh extends q {
            constructor(t2, e2, r2) {
              super(t2, e2), this.z = r2;
            }
          }
          class ph extends hh {
            constructor(t2, e2, r2, n2) {
              super(t2, e2, r2), this.w = n2;
            }
          }
          function fh(t2, e2, r2, n2) {
            const i2 = [], s2 = 0 === n2 ? (t3, e3, r3, n3, i3, s3) => {
              t3.push(new q(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
            } : (t3, e3, r3, n3, i3, s3) => {
              t3.push(new q(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
            };
            for (const a2 of t2) {
              const t3 = [];
              for (const i3 of a2) {
                if (i3.length <= 2)
                  continue;
                const a3 = [];
                for (let t4 = 0; t4 < i3.length - 1; t4++) {
                  const o3 = i3[t4].x, l3 = i3[t4].y, u2 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h2 = 0 === n2 ? o3 : l3, p2 = 0 === n2 ? u2 : c2;
                  h2 < e2 ? p2 > e2 && s2(a3, o3, l3, u2, c2, e2) : h2 > r2 ? p2 < r2 && s2(a3, o3, l3, u2, c2, r2) : a3.push(i3[t4]), p2 < e2 && h2 >= e2 && s2(a3, o3, l3, u2, c2, e2), p2 > r2 && h2 <= r2 && s2(a3, o3, l3, u2, c2, r2);
                }
                let o2 = i3[i3.length - 1];
                const l2 = 0 === n2 ? o2.x : o2.y;
                l2 >= e2 && l2 <= r2 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
              }
              t3.length && i2.push(t3);
            }
            return i2;
          }
          function dh(t2, e2, r2, n2) {
            const i2 = "x" === r2 ? "y" : "x", s2 = (n2 - t2[r2]) / (e2[r2] - t2[r2]);
            t2[i2] = t2[i2] + (e2[i2] - t2[i2]) * s2, t2[r2] = n2, t2.hasOwnProperty("z") && (t2.z = ke(t2.z, e2.z, s2)), t2.hasOwnProperty("w") && (t2.w = ke(t2.w, e2.w, s2));
          }
          function mh(t2, e2, r2, n2) {
            const i2 = r2, s2 = n2;
            for (const r3 of ["x", "y"]) {
              let n3 = t2, a2 = e2;
              n3[r3] >= a2[r3] && (n3 = e2, a2 = t2), n3[r3] < i2 && a2[r3] > i2 && dh(n3, a2, r3, i2), n3[r3] < s2 && a2[r3] > s2 && dh(a2, n3, r3, s2);
            }
          }
          const yh = Number.MAX_SAFE_INTEGER;
          function gh(t2, e2, r2, n2) {
            return t2.order < e2 || t2.order === yh || !(t2.clipMask & r2) || function(t3, e3) {
              return 0 !== e3.length && void 0 === e3.find((e4) => e4 === t3);
            }(n2, t2.clipScope);
          }
          function xh(t2, e2) {
            return t2.x - e2.x || t2.y - e2.y;
          }
          function bh(t2, e2) {
            return 0 === xh(t2.min, e2.min) && 0 === xh(t2.max, e2.max);
          }
          function vh(t2, e2) {
            return !(t2.min.x > e2.max.x || t2.max.x < e2.min.x || t2.min.y > e2.max.y || t2.max.y < e2.min.y);
          }
          function wh(t2, e2) {
            if (t2.length !== e2.length)
              return false;
            for (let r2 = 0; r2 < t2.length; r2++)
              if (t2[r2].sourceId !== e2[r2].sourceId || !bh(t2[r2], e2[r2]) || t2[r2].order !== e2[r2].order || t2[r2].clipMask !== e2[r2].clipMask || !$(t2[r2].clipScope, e2[r2].clipScope))
                return false;
            return true;
          }
          function _h(t2, e2, r2) {
            const n2 = 1 / Hr, i2 = 1 / (1 << r2.canonical.z), s2 = (e2.x * n2 + r2.canonical.x) * i2 + r2.wrap, a2 = (e2.y * n2 + r2.canonical.y) * i2;
            return { min: new q((t2.x * n2 + r2.canonical.x) * i2 + r2.wrap, (t2.y * n2 + r2.canonical.y) * i2), max: new q(s2, a2) };
          }
          function Mh(t2, e2, r2) {
            const n2 = 1 << r2.canonical.z, i2 = ((e2.x - r2.wrap) * n2 - r2.canonical.x) * Hr, s2 = (e2.y * n2 - r2.canonical.y) * Hr;
            return { min: new q(((t2.x - r2.wrap) * n2 - r2.canonical.x) * Hr, (t2.y * n2 - r2.canonical.y) * Hr), max: new q(i2, s2) };
          }
          function Ah(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = t2.indices, l2 = t2.vertices, u2 = [];
            for (let c2 = n2; c2 < n2 + i2; c2 += 3) {
              const n3 = e2[r2[c2 + 0] + s2], i3 = e2[r2[c2 + 1] + s2], h2 = e2[r2[c2 + 2] + s2], p2 = Math.min(n3.x, i3.x, h2.x), f2 = Math.max(n3.x, i3.x, h2.x), d2 = Math.min(n3.y, i3.y, h2.y), m2 = Math.max(n3.y, i3.y, h2.y);
              u2.length = 0, t2.grid.query(new q(p2, d2), new q(f2, m2), u2);
              for (let t3 = 0; t3 < u2.length; t3++) {
                const e3 = u2[t3];
                if ($l(l2[o2[3 * e3 + 0]], l2[o2[3 * e3 + 1]], l2[o2[3 * e3 + 2]], n3, i3, h2, a2))
                  return true;
              }
            }
            return false;
          }
          function Sh(t2, e2, r2, n2) {
            if (!t2 || !r2)
              return false;
            let i2 = t2.vertices;
            if (!e2.canonical.equals(n2.canonical) || e2.wrap !== n2.wrap) {
              if (r2.vertices.length < t2.vertices.length)
                return Sh(r2, n2, t2, e2);
              const s2 = e2.canonical, a2 = n2.canonical, o2 = Math.pow(2, a2.z - s2.z);
              i2 = t2.vertices.map((t3) => new q((t3.x + s2.x * Hr) * o2 - a2.x * Hr, (t3.y + s2.y * Hr) * o2 - a2.y * Hr));
            }
            return Ah(r2, i2, t2.indices, 0, t2.indices.length, 0, 0);
          }
          function Ih(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z - r2.z);
            return new q((t2 + r2.x * Hr) * i2 - n2.x * Hr, (e2 + r2.y * Hr) * i2 - n2.y * Hr);
          }
          function Ph(t2, e2) {
            const r2 = [];
            e2.grid.queryPoint(t2, r2);
            const n2 = e2.indices, i2 = e2.vertices;
            for (let e3 = 0; e3 < r2.length; e3++) {
              const s2 = r2[e3];
              if (Ul([i2[n2[3 * s2 + 0]], i2[n2[3 * s2 + 1]], i2[n2[3 * s2 + 2]]], t2))
                return true;
            }
            return false;
          }
          const zh = [new q(0, 0), new q(Hr, 0), new q(Hr, Hr), new q(0, Hr)];
          function kh(t2, e2) {
            const r2 = [];
            let n2 = [];
            if (!e2 || t2.length < 2)
              return [t2];
            if (2 === t2.length)
              return Nl(t2[0], t2[1], zh) ? [t2] : [];
            for (let e3 = 0; e3 < t2.length + 2; e3++) {
              const i2 = t2[e3 % t2.length], s2 = t2[(e3 + 1) % t2.length], a2 = Nl(0 === e3 ? t2[t2.length - 1] : t2[(e3 - 1) % t2.length], i2, zh), o2 = Nl(i2, s2, zh), l2 = a2 || o2;
              l2 && n2.push(i2), l2 && o2 || n2.length > 0 && (n2.length > 1 && r2.push(n2), n2 = []);
            }
            return n2.length > 1 && r2.push(n2), r2;
          }
          const Th = ch.VectorTileFeature.types, Eh = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], Bh = ["fill-extrusion-flood-light-ground-radius"], Vh = Math.pow(2, 13), Ch = Math.pow(2, 15) - 1, Rh = new q(0, 1), Dh = 2147483648;
          function Lh(t2, e2, r2, n2, i2, s2, a2, o2) {
            t2.emplaceBack((e2 << 1) + a2, (r2 << 1) + s2, (Math.floor(n2 * Vh) << 1) + i2, Math.round(o2));
          }
          function Fh(t2, e2, r2) {
            t2.emplaceBack(e2.x * Hr, e2.y * Hr, r2 ? 1 : 0);
          }
          function Oh(t2, e2, r2, n2, i2, s2) {
            t2.emplaceBack(e2.x, e2.y, (r2.x << 1) + n2, (r2.y << 1) + i2, s2);
          }
          function Uh(t2, e2, r2) {
            const n2 = 16384;
            t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
          }
          class jh {
            constructor() {
              this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
            }
          }
          class Nh {
            constructor() {
              this.centroidXY = new q(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new q(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new q(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
            }
            span() {
              return new q(this.max.x - this.min.x, this.max.y - this.min.y);
            }
          }
          class qh {
            constructor() {
              this.acc = new q(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
            }
            startRing(t2, e2) {
              t2.min.x === Number.MAX_VALUE && (t2.min.x = t2.max.x = e2.x, t2.min.y = t2.max.y = e2.y);
            }
            appendEdge(t2, e2, r2) {
              this.accCount++, this.acc._add(e2);
              let n2 = !!this.borders;
              e2.x < t2.min.x ? (t2.min.x = e2.x, n2 = true) : e2.x > t2.max.x && (t2.max.x = e2.x, n2 = true), e2.y < t2.min.y ? (t2.min.y = e2.y, n2 = true) : e2.y > t2.max.y && (t2.max.y = e2.y, n2 = true), ((0 === e2.x || e2.x === Hr) && e2.x === r2.x) != ((0 === e2.y || e2.y === Hr) && e2.y === r2.y) && this.processBorderOverlap(e2, r2), n2 && this.checkBorderIntersection(e2, r2);
            }
            checkBorderIntersection(t2, e2) {
              e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, ke(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > Hr != t2.x > Hr && this.addBorderIntersection(1, ke(e2.y, t2.y, (Hr - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, ke(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > Hr != t2.y > Hr && this.addBorderIntersection(3, ke(e2.x, t2.x, (Hr - e2.y) / (t2.y - e2.y)));
            }
            addBorderIntersection(t2, e2) {
              this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
              const r2 = this.borders[t2];
              e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
            }
            processBorderOverlap(t2, e2) {
              if (t2.x === e2.x) {
                if (t2.y === e2.y)
                  return;
                const r2 = 0 === t2.x ? 0 : 1;
                this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
              } else {
                const r2 = 0 === t2.y ? 2 : 3;
                this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
              }
            }
            centroid() {
              return 0 === this.accCount ? new q(0, 0) : new q(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
            }
            intersectsCount() {
              return this.borders ? this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0) : 0;
            }
          }
          function $h(t2, e2) {
            const r2 = t2.add(e2)._unit(), n2 = Q(t2.x * r2.x + t2.y * r2.y, -1, 1);
            var i2, s2, a2;
            return a2 = Math.acos(n2), Math.min(4, Math.max(-4, Math.tan(a2))) / 4 * Ch * ((i2 = t2).x * (s2 = e2).y - i2.y * s2.x < 0 ? -1 : 1);
          }
          const Gh = [(t2) => t2.x < 0, (t2) => t2.x > Hr, (t2) => t2.y < 0, (t2) => t2.y > Hr];
          function Xh(t2, e2, r2, n2) {
            const i2 = [4];
            if (0 === n2)
              return i2;
            r2._mult(n2);
            const s2 = t2.sub(r2), a2 = e2.sub(r2), o2 = [t2, e2, s2, a2];
            for (let t3 = 0; t3 < 4; t3++)
              for (const e3 of o2)
                if (Gh[t3](e3)) {
                  i2.push(t3);
                  break;
                }
            return i2;
          }
          class Yh {
            constructor(t2) {
              this.vertexArray = new wa(), this.indexArray = new Da(), this.programConfigurations = new Fo(t2.layers, { zoom: t2.zoom, lut: t2.lut }, (t3) => Bh.includes(t3)), this._segments = new co(), this.hiddenByLandmarkVertexArray = new Za(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new co();
            }
            getDefaultSegment() {
              return this.regionSegments[4];
            }
            hasData() {
              return 0 !== this.vertexArray.length;
            }
            addData(t2, e2, r2, n2 = false) {
              const i2 = t2.length;
              if (i2 > 2) {
                let s2 = Math.max(0, this._segments.get().length - 1);
                const a2 = this._segments._prepareSegment(4 * i2, this.vertexArray.length, 2 * this._segmentToGroundQuads[s2].length);
                let o2;
                s2 !== this._segments.get().length - 1 && (s2++, this._segmentToGroundQuads[s2] = [], this._segmentToRegionTriCounts[s2] = [0, 0, 0, 0, 0]);
                {
                  const e3 = t2[0], r3 = t2[1];
                  o2 = $h(e3.sub(t2[i2 - 1])._perp()._unit(), r3.sub(e3)._perp()._unit());
                }
                for (let l2 = 0; l2 < i2; l2++) {
                  const u2 = l2 === i2 - 1 ? 0 : l2 + 1, c2 = t2[l2], h2 = t2[u2], p2 = t2[u2 === i2 - 1 ? 0 : u2 + 1], f2 = h2.sub(c2)._perp()._unit(), d2 = $h(f2, p2.sub(h2)._perp()._unit()), m2 = o2, y2 = d2;
                  if (Jh(c2, h2, e2) || n2 && Qh(c2, e2) && Qh(h2, e2)) {
                    o2 = d2;
                    continue;
                  }
                  const g2 = a2.vertexLength;
                  Oh(this.vertexArray, c2, h2, 1, 1, m2), Oh(this.vertexArray, c2, h2, 1, 0, m2), Oh(this.vertexArray, c2, h2, 0, 1, y2), Oh(this.vertexArray, c2, h2, 0, 0, y2), a2.vertexLength += 4;
                  const x2 = Xh(c2, h2, f2, r2);
                  for (const t3 of x2)
                    this._segmentToGroundQuads[s2].push({ id: g2, region: t3 }), this._segmentToRegionTriCounts[s2][t3] += 2, a2.primitiveLength += 2;
                  o2 = d2;
                }
              }
            }
            prepareBorderSegments() {
              if (!this.hasData())
                return;
              const t2 = this._segments.get(), e2 = t2.length;
              for (let t3 = 0; t3 < e2; t3++)
                this._segmentToGroundQuads[t3].sort((t4, e3) => t4.region - e3.region);
              for (let r2 = 0; r2 < e2; r2++) {
                const e3 = this._segmentToGroundQuads[r2], n2 = t2[r2], i2 = this._segmentToRegionTriCounts[r2];
                i2.reduce((t3, e4) => t3 + e4, 0);
                let s2 = 0;
                for (let t3 = 0; t3 <= 4; t3++) {
                  const e4 = i2[t3];
                  if (0 !== e4) {
                    let r3 = this.regionSegments[t3];
                    r3 || (r3 = this.regionSegments[t3] = new co());
                    const i3 = { vertexOffset: n2.vertexOffset, primitiveOffset: n2.primitiveOffset + s2, vertexLength: n2.vertexLength, primitiveLength: e4 };
                    r3.get().push(i3);
                  }
                  s2 += e4;
                }
                for (let t3 = 0; t3 < e3.length; t3++) {
                  const r3 = e3[t3].id;
                  this.indexArray.emplaceBack(r3, r3 + 1, r3 + 3), this.indexArray.emplaceBack(r3, r3 + 3, r3 + 2);
                }
              }
              this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
            }
            addPaintPropertiesData(t2, e2, r2, n2, i2, s2) {
              this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t2, e2, r2, n2, i2, s2);
            }
            upload(t2) {
              this.hasData() && (this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Yc.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray));
            }
            uploadPaintProperties(t2) {
              this.hasData() && this.programConfigurations.upload(t2);
            }
            update(t2, e2, r2, n2, i2, s2) {
              this.hasData() && this.programConfigurations.updatePaintArrays(t2, e2, r2, n2, i2, s2);
            }
            updateHiddenByLandmark(t2) {
              if (!this.hasData())
                return;
              const e2 = t2.groundVertexCount + t2.groundVertexArrayOffset;
              if (0 === t2.groundVertexCount)
                return;
              const r2 = t2.flags & Dh ? 1 : 0;
              for (let n2 = t2.groundVertexArrayOffset; n2 < e2; ++n2)
                this.hiddenByLandmarkVertexArray.emplace(n2, r2);
              this._needsHiddenByLandmarkUpdate = true;
            }
            uploadHiddenByLandmark(t2) {
              this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t2.createVertexBuffer(this.hiddenByLandmarkVertexArray, Hc.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
            }
            destroy() {
              if (this.vertexBuffer) {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                for (let t2 = 0; t2 <= 4; t2++) {
                  const e2 = this.regionSegments[t2];
                  e2 && e2.destroy();
                }
              }
            }
          }
          class Zh {
            constructor(t2) {
              this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Da(), this.footprintVertices = new xa(), this.footprintSegments = [], this.layoutVertexArray = new va(), this.centroidVertexArray = new so(), this.wallVertexArray = new oo(), this.indexArray = new Da(), this.programConfigurations = new Fo(t2.layers, { zoom: t2.zoom, lut: t2.lut }, (t3) => Eh.includes(t3)), this.segments = new co(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.groundEffect = new Yh(t2), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.features = [], this.hasPattern = Dc("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = gl(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
              for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Pl(i2, t3);
                if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), l2, r2))
                  continue;
                const u2 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : Il(i2, r2, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length, h2 = "Polygon" === Th[u2.type];
                if (this.hasPattern)
                  this.features.push(Lc("fill-extrusion", this.layers, u2, this.zoom, e2));
                else if (this.wallMode)
                  for (const t4 of u2.geometry)
                    for (const i3 of kh(t4, h2))
                      this.addFeature(u2, [i3], a2, r2, {}, e2.availableImages, n2, e2.brightness);
                else
                  this.addFeature(u2, u2.geometry, a2, r2, {}, e2.availableImages, n2, e2.brightness);
                e2.featureIndex.insert(i2, u2.geometry, a2, o2, this.index, c2);
              }
              this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
            }
            addFeatures(t2, e2, r2, n2, i2, s2) {
              for (const t3 of this.features) {
                const a2 = "Polygon" === Th[t3.type], { geometry: o2 } = t3;
                if (this.wallMode)
                  for (const l2 of o2)
                    for (const o3 of kh(l2, a2))
                      this.addFeature(t3, [o3], t3.index, e2, r2, n2, i2, s2);
                else
                  this.addFeature(t3, o2, t3.index, e2, r2, n2, i2, s2);
              }
              this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
            }
            update(t2, e2, r2, n2, i2) {
              const s2 = 0 !== Object.keys(t2).length;
              if (s2 && !this.stateDependentLayers.length)
                return;
              const a2 = s2 ? this.stateDependentLayers : this.layers;
              this.programConfigurations.updatePaintArrays(t2, e2, a2, r2, n2, i2), this.groundEffect.update(t2, e2, a2, r2, n2, i2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Jc), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t2.createVertexBuffer(this.wallVertexArray, Wc.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Kc.members, true)), this.groundEffect.upload(t2)), this.groundEffect.uploadPaintProperties(t2), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            uploadCentroid(t2) {
              this.groundEffect.uploadHiddenByLandmark(t2), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Zc.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t2, {}) / this.tileToMeter, u2 = [new q(0, 0), new q(Hr, Hr)], c2 = a2.projection, h2 = "globe" === c2.name, p2 = this.wallMode || "Polygon" === Th[t2.type], f2 = new qh();
              f2.centroidDataIndex = this.centroidData.length;
              const d2 = new Nh(), m2 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t2, {}, n2) <= 0, y2 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t2, {}, n2);
              let g2;
              if (d2.height = y2, d2.vertexArrayOffset = this.layoutVertexArray.length, d2.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Pa()), this.wallMode) {
                if (h2)
                  return void ft("Non zero fill-extrusion-line-width is not yet supported on globe.");
                if (1 !== e2.length)
                  return;
                g2 = function(t3) {
                  const e3 = t3[0].x === t3[t3.length - 1].x && t3[0].y === t3[t3.length - 1].y, r3 = function(t4) {
                    let e4 = 0;
                    const r4 = t4.length;
                    for (let n4 = 0; n4 < r4; n4++)
                      e4 += (t4[(n4 + 1) % r4].x - t4[n4].x) * (t4[(n4 + 1) % r4].y + t4[n4].y);
                    return e4 >= 0;
                  }(t3);
                  r3 || (t3 = t3.reverse());
                  const n3 = { geometry: [], joinNormals: [], indices: [] }, i3 = [], s3 = [], a3 = [];
                  let o3 = t3.length;
                  if (o3 < (e3 ? 3 : 2))
                    return n3;
                  for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); )
                    o3--;
                  let l3, u3, c3, h3, p3, f3 = 0;
                  for (; f3 < o3 - 1 && t3[f3].equals(t3[f3 + 1]); )
                    f3++;
                  e3 && (l3 = t3[o3 - 2], p3 = t3[f3].sub(l3)._unit()._perp());
                  for (let r4 = f3; r4 < o3; r4++) {
                    if (c3 = r4 === o3 - 1 ? e3 ? t3[f3 + 1] : void 0 : t3[r4 + 1], c3 && t3[r4].equals(c3))
                      continue;
                    p3 && (h3 = p3), l3 && (u3 = l3), l3 = t3[r4], p3 = c3 ? c3.sub(l3)._unit()._perp() : h3, h3 = h3 || p3;
                    let n4 = h3.add(p3);
                    0 === n4.x && 0 === n4.y || n4._unit();
                    const d4 = n4.x * p3.x + n4.y * p3.y, m3 = 0 !== d4 ? 1 / d4 : 1 / 0, y3 = h3.x * p3.y - h3.y * p3.x > 0;
                    let g3 = "miter";
                    const x3 = 2;
                    "miter" === g3 && m3 > x3 && (g3 = "bevel"), "bevel" === g3 && (m3 > 100 && (g3 = "flipbevel"), m3 < x3 && (g3 = "miter"));
                    const b3 = (t4, e4, r5, n5) => {
                      const o4 = new q(t4.x, t4.y), l4 = new q(t4.x, t4.y);
                      o4.x += e4.x * n5, o4.y += e4.y * n5, l4.x -= e4.x * Math.max(r5, 1), l4.y -= e4.y * Math.max(r5, 1), a3.push(e4), i3.push(o4), s3.push(l4);
                    };
                    if ("miter" === g3)
                      n4._mult(m3), b3(l3, n4, 0, 0);
                    else if ("flipbevel" === g3)
                      n4 = p3.mult(-1), b3(l3, n4, 0, 0), b3(l3, n4.mult(-1), 0, 0);
                    else {
                      const t4 = -Math.sqrt(m3 * m3 - 1), e4 = y3 ? t4 : 0, r5 = y3 ? 0 : t4;
                      u3 && b3(l3, h3, e4, r5), c3 && b3(l3, p3, e4, r5);
                    }
                  }
                  n3.geometry = [...i3, ...s3.reverse(), i3[0]], n3.joinNormals = [...a3, ...a3.reverse(), a3[a3.length - 1]];
                  const d3 = n3.geometry.length - 1;
                  for (let t4 = 0; t4 < d3 / 2; t4++)
                    if (t4 + 1 < d3 / 2) {
                      let e4 = t4, r4 = t4 + 1, i4 = d3 - 1 - t4, s4 = d3 - 2 - t4;
                      e4 = 0 === e4 ? d3 - 1 : e4 - 1, r4 = 0 === r4 ? d3 - 1 : r4 - 1, i4 = 0 === i4 ? d3 - 1 : i4 - 1, s4 = 0 === s4 ? d3 - 1 : s4 - 1, n3.indices.push(i4), n3.indices.push(r4), n3.indices.push(e4), n3.indices.push(i4), n3.indices.push(s4), n3.indices.push(r4);
                    }
                  return n3;
                }(e2[0]), e2 = [g2.geometry];
              }
              const x2 = (t3, e3) => t3 < (e3.length - 1) / 2 || t3 === e3.length - 1, b2 = this.wallMode ? [e2] : Cc(e2, 500);
              for (let t3 = b2.length - 1; t3 >= 0; t3--) {
                const e3 = b2[t3];
                (0 === e3.length || (v2 = e3[0]).every((t4) => t4.x <= 0) || v2.every((t4) => t4.x >= Hr) || v2.every((t4) => t4.y <= 0) || v2.every((t4) => t4.y >= Hr)) && b2.splice(t3, 1);
              }
              var v2;
              let w2;
              if (h2)
                w2 = np(b2, u2, n2);
              else {
                w2 = [];
                for (const t3 of b2)
                  w2.push({ polygon: t3, bounds: u2 });
              }
              const _2 = p2 ? this.edgeRadius : 0, M2 = _2 > 0 && this.zoom < 17, A2 = (t3, e3) => {
                if (0 === t3.length)
                  return false;
                const r3 = t3[t3.length - 1];
                return e3.x === r3.x && e3.y === r3.y;
              };
              for (const { polygon: t3, bounds: e3 } of w2) {
                let r3 = 0, i3 = 0;
                for (const e4 of t3)
                  p2 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += p2 ? e4.length - 1 : e4.length;
                const s3 = this.segments.prepareSegment((p2 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
                d2.footprintSegIdx < 0 && (d2.footprintSegIdx = this.footprintSegments.length), d2.polygonSegIdx < 0 && (d2.polygonSegIdx = this.polygonSegments.length);
                const a3 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, o3 = new jh();
                if (o3.vertexOffset = this.footprintVertices.length, o3.indexOffset = 3 * this.footprintIndices.length, o3.ringIndices = [], p2) {
                  const i4 = [], a4 = [];
                  r3 = s3.vertexLength;
                  for (let r4 = 0; r4 < t3.length; r4++) {
                    const u4 = t3[r4];
                    u4.length && 0 !== r4 && a4.push(i4.length / 2);
                    const p3 = [];
                    let f3, d3;
                    f3 = u4[1].sub(u4[0])._perp()._unit(), o3.ringIndices.push(u4.length - 1);
                    for (let t4 = 1; t4 < u4.length; t4++) {
                      const e4 = u4[t4], r5 = u4[t4 === u4.length - 1 ? 1 : t4 + 1], a5 = e4.clone();
                      if (_2) {
                        d3 = r5.sub(e4)._perp()._unit();
                        const t5 = f3.add(d3)._unit(), n3 = _2 * Math.min(4, 1 / (f3.x * t5.x + f3.y * t5.y));
                        a5.x += n3 * t5.x, a5.y += n3 * t5.y, a5.x = Math.round(a5.x), a5.y = Math.round(a5.y), f3 = d3;
                      }
                      if (!m2 || 0 !== _2 && !M2 || A2(p3, a5) || p3.push(a5), Lh(this.layoutVertexArray, a5.x, a5.y, 0, 0, 1, 1, 0), this.wallMode) {
                        const e5 = x2(t4, u4);
                        Fh(this.wallVertexArray, g2.joinNormals[t4], !e5);
                      }
                      s3.vertexLength++, this.footprintVertices.emplaceBack(e4.x, e4.y), i4.push(e4.x, e4.y), h2 && Uh(this.layoutVertexExtArray, c2.projectTilePoint(a5.x, a5.y, n2), c2.upVector(n2, a5.x, a5.y));
                    }
                    m2 && (0 === _2 || M2) && (0 !== p3.length && A2(p3, p3[0]) && p3.pop(), this.groundEffect.addData(p3, e3, l2));
                  }
                  const u3 = this.wallMode ? g2.indices : uc(i4, a4);
                  for (let t4 = 0; t4 < u3.length; t4 += 3)
                    this.footprintIndices.emplaceBack(o3.vertexOffset + u3[t4 + 0], o3.vertexOffset + u3[t4 + 1], o3.vertexOffset + u3[t4 + 2]), this.indexArray.emplaceBack(r3 + u3[t4], r3 + u3[t4 + 2], r3 + u3[t4 + 1]), s3.primitiveLength++;
                  o3.indexCount += u3.length, o3.vertexCount += this.footprintVertices.length - o3.vertexOffset;
                }
                for (let i4 = 0; i4 < t3.length; i4++) {
                  const a4 = t3[i4];
                  f2.startRing(d2, a4[0]);
                  let o4 = a4.length > 4 && tp(a4[a4.length - 2], a4[0], a4[1]), u3 = _2 ? Hh(a4[a4.length - 2], a4[0], a4[1], _2) : 0;
                  const y3 = [];
                  let b3, v3, w3;
                  v3 = a4[1].sub(a4[0])._perp()._unit();
                  let M3 = true;
                  for (let t4 = 1, i5 = 0; t4 < a4.length; t4++) {
                    let l3 = a4[t4 - 1], p3 = a4[t4];
                    const S2 = a4[t4 === a4.length - 1 ? 1 : t4 + 1];
                    if (f2.appendEdge(d2, p3, l3), Jh(p3, l3, e3)) {
                      _2 && (v3 = S2.sub(p3)._perp()._unit(), M3 = !M3);
                      continue;
                    }
                    const I2 = p3.sub(l3)._perp(), P2 = I2.x / (Math.abs(I2.x) + Math.abs(I2.y)), z2 = I2.y > 0 ? 1 : 0, k2 = l3.dist(p3);
                    if (i5 + k2 > 32768 && (i5 = 0), _2) {
                      w3 = S2.sub(p3)._perp()._unit();
                      let t5 = Kh(l3, p3, S2, Wh(v3, w3), _2);
                      isNaN(t5) && (t5 = 0);
                      const e4 = p3.sub(l3)._unit();
                      l3 = l3.add(e4.mult(u3))._round(), p3 = p3.add(e4.mult(-t5))._round(), u3 = t5, v3 = w3, m2 && this.zoom >= 17 && (A2(y3, l3) || y3.push(l3), A2(y3, p3) || y3.push(p3));
                    }
                    const T2 = s3.vertexLength, E2 = a4.length > 4 && tp(l3, p3, S2);
                    let B2 = ep(i5, o4, M3);
                    if (Lh(this.layoutVertexArray, l3.x, l3.y, P2, z2, 0, 0, B2), Lh(this.layoutVertexArray, l3.x, l3.y, P2, z2, 0, 1, B2), this.wallMode) {
                      const e4 = x2(t4 - 1, a4), r4 = g2.joinNormals[t4 - 1];
                      Fh(this.wallVertexArray, r4, e4), Fh(this.wallVertexArray, r4, e4);
                    }
                    if (i5 += k2, B2 = ep(i5, E2, !M3), o4 = E2, Lh(this.layoutVertexArray, p3.x, p3.y, P2, z2, 0, 0, B2), Lh(this.layoutVertexArray, p3.x, p3.y, P2, z2, 0, 1, B2), this.wallMode) {
                      const e4 = x2(t4, a4), r4 = g2.joinNormals[t4];
                      Fh(this.wallVertexArray, r4, e4), Fh(this.wallVertexArray, r4, e4);
                    }
                    if (s3.vertexLength += 4, this.indexArray.emplaceBack(T2 + 0, T2 + 1, T2 + 2), this.indexArray.emplaceBack(T2 + 1, T2 + 3, T2 + 2), s3.primitiveLength += 2, _2) {
                      const n3 = r3 + (1 === t4 ? a4.length - 2 : t4 - 2), i6 = 1 === t4 ? r3 : n3 + 1;
                      if (this.indexArray.emplaceBack(T2 + 1, n3, T2 + 3), this.indexArray.emplaceBack(n3, i6, T2 + 3), s3.primitiveLength += 2, void 0 === b3 && (b3 = T2), !Jh(S2, a4[t4], e3)) {
                        const e4 = t4 === a4.length - 1 ? b3 : s3.vertexLength;
                        this.indexArray.emplaceBack(T2 + 2, T2 + 3, e4), this.indexArray.emplaceBack(T2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(T2 + 3, i6, e4 + 1), s3.primitiveLength += 3;
                      }
                      M3 = !M3;
                    }
                    if (h2) {
                      const t5 = this.layoutVertexExtArray, e4 = c2.projectTilePoint(l3.x, l3.y, n2), r4 = c2.projectTilePoint(p3.x, p3.y, n2), i6 = c2.upVector(n2, l3.x, l3.y), s4 = c2.upVector(n2, p3.x, p3.y);
                      Uh(t5, e4, i6), Uh(t5, e4, i6), Uh(t5, r4, s4), Uh(t5, r4, s4);
                    }
                  }
                  p2 && (r3 += a4.length - 1), m2 && _2 && this.zoom >= 17 && (0 !== y3.length && A2(y3, y3[0]) && y3.pop(), this.groundEffect.addData(y3, e3, l2, _2 > 0));
                }
                this.footprintSegments.push(o3), a3.triangleCount = this.indexArray.length - a3.triangleArrayOffset, this.polygonSegments.push(a3), ++d2.footprintSegLen, ++d2.polygonSegLen;
              }
              if (d2.vertexCount = this.layoutVertexArray.length - d2.vertexArrayOffset, d2.groundVertexCount = this.groundEffect.vertexArray.length - d2.groundVertexArrayOffset, 0 !== d2.vertexCount) {
                if (d2.centroidXY = f2.borders ? Rh : this.encodeCentroid(f2, d2), this.centroidData.push(d2), f2.borders) {
                  this.featuresOnBorder.push(f2);
                  const t3 = this.featuresOnBorder.length - 1;
                  for (let e3 = 0; e3 < f2.borders.length; e3++)
                    f2.borders[e3][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e3].push(t3);
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, o2), this.groundEffect.addPaintPropertiesData(t2, r2, i2, s2, n2, o2), this.maxHeight = Math.max(this.maxHeight, y2);
              }
            }
            sortBorders() {
              for (let t2 = 0; t2 < this.borderFeatureIndices.length; t2++)
                this.borderFeatureIndices[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
            }
            splitToSubtiles() {
              const t2 = [];
              for (let e3 = 0; e3 < this.centroidData.length; e3++) {
                const r3 = this.centroidData[e3], n3 = +(r3.min.y + r3.max.y > Hr), i3 = 2 * n3 + (+(r3.min.x + r3.max.x > Hr) ^ n3);
                for (let n4 = 0; n4 < r3.polygonSegLen; n4++) {
                  const s3 = r3.polygonSegIdx + n4;
                  t2.push({ centroidIdx: e3, subtile: i3, polygonSegmentIdx: s3, triangleSegmentIdx: this.polygonSegments[s3].triangleSegIdx });
                }
              }
              const e2 = new Da();
              t2.sort((t3, e3) => t3.triangleSegmentIdx === e3.triangleSegmentIdx ? t3.subtile - e3.subtile : t3.triangleSegmentIdx - e3.triangleSegmentIdx);
              let r2 = 0, n2 = 0, i2 = 0;
              for (const e3 of t2) {
                if (e3.triangleSegmentIdx !== r2)
                  break;
                i2++;
              }
              const s2 = t2.length;
              for (; n2 !== t2.length; ) {
                r2 = t2[n2].triangleSegmentIdx;
                let a2 = 0, o2 = n2, l2 = n2;
                for (let e3 = o2; e3 < i2 && t2[e3].subtile === a2; e3++)
                  l2++;
                for (; o2 !== i2; ) {
                  const n3 = t2[o2];
                  a2 = n3.subtile;
                  const s3 = this.centroidData[n3.centroidIdx].min.clone(), u2 = this.centroidData[n3.centroidIdx].max.clone(), c2 = { vertexOffset: this.segments.segments[r2].vertexOffset, primitiveOffset: e2.length, vertexLength: this.segments.segments[r2].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                  for (let r3 = o2; r3 < l2; r3++) {
                    const n4 = t2[r3], i3 = this.polygonSegments[n4.polygonSegmentIdx], a3 = this.centroidData[n4.centroidIdx].min, o3 = this.centroidData[n4.centroidIdx].max, l3 = this.indexArray.uint16;
                    for (let t3 = i3.triangleArrayOffset; t3 < i3.triangleArrayOffset + i3.triangleCount; t3++)
                      e2.emplaceBack(l3[3 * t3], l3[3 * t3 + 1], l3[3 * t3 + 2]);
                    c2.primitiveLength += i3.triangleCount, s3.x = Math.min(s3.x, a3.x), s3.y = Math.min(s3.y, a3.y), u2.x = Math.max(u2.x, o3.x), u2.y = Math.max(u2.y, o3.y);
                  }
                  c2.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c2, min: s3, max: u2 }), o2 = l2;
                  for (let e3 = o2; e3 < i2 && t2[e3].subtile === t2[o2].subtile; e3++)
                    l2++;
                }
                n2 = i2;
                for (let e3 = n2; e3 < s2 && t2[e3].triangleSegmentIdx === t2[n2].triangleSegmentIdx; e3++)
                  i2++;
              }
              e2._trim(), this.indexArray = e2;
            }
            getVisibleSegments(t2, e2, r2) {
              const n2 = new co();
              if (this.wallMode) {
                for (const t3 of this.triangleSubSegments)
                  n2.segments.push(t3.segment);
                return n2;
              }
              let i2 = 0, s2 = 0;
              const a2 = 1 << t2.canonical.z;
              if (e2) {
                const r3 = e2.getMinMaxForTile(t2);
                r3 && (i2 = r3.min, s2 = r3.max);
              }
              s2 += this.maxHeight;
              const o2 = t2.toUnwrapped();
              let l2;
              const u2 = [o2.canonical.x / a2 + o2.wrap, o2.canonical.y / a2], c2 = [(o2.canonical.x + 1) / a2 + o2.wrap, (o2.canonical.y + 1) / a2], h2 = (t3, e3, r3) => [t3[0] * (1 - r3[0]) + e3[0] * r3[0], t3[1] * (1 - r3[1]) + e3[1] * r3[1]], p2 = [], f2 = [];
              for (const t3 of this.triangleSubSegments) {
                p2[0] = t3.min.x / Hr, p2[1] = t3.min.y / Hr, f2[0] = t3.max.x / Hr, f2[1] = t3.max.y / Hr;
                const e3 = h2(u2, c2, p2), a3 = h2(u2, c2, f2);
                if (0 === new yu([e3[0], e3[1], i2], [a3[0], a3[1], s2]).intersectsPrecise(r2)) {
                  l2 && (n2.segments.push(l2), l2 = void 0);
                  continue;
                }
                const o3 = t3.segment;
                l2 && l2.vertexOffset !== o3.vertexOffset && (n2.segments.push(l2), l2 = void 0), l2 ? (l2.vertexLength += o3.vertexLength, l2.primitiveLength += o3.primitiveLength) : l2 = { vertexOffset: o3.vertexOffset, primitiveLength: o3.primitiveLength, vertexLength: o3.vertexLength, primitiveOffset: o3.primitiveOffset, sortKey: void 0, vaos: {} };
              }
              return l2 && n2.segments.push(l2), n2;
            }
            encodeCentroid(t2, e2) {
              const r2 = t2.centroid(), n2 = e2.span(), i2 = Math.min(7, Math.round(n2.x * this.tileToMeter / 10)), s2 = Math.min(7, Math.round(n2.y * this.tileToMeter / 10));
              return new q(Q(r2.x, 1, Hr - 1) << 3 | i2, Q(r2.y, 1, Hr - 1) << 3 | s2);
            }
            encodeBorderCentroid(t2) {
              if (!t2.borders)
                return new q(0, 0);
              const e2 = t2.borders, r2 = Number.MAX_VALUE;
              if (e2[0][0] !== r2 || e2[1][0] !== r2) {
                const t3 = e2[0][0] !== r2 ? 0 : 1;
                return new q(6 | (e2[0][0] !== r2 ? 0 : 65528), (e2[t3][0] + e2[t3][1]) / 2 << 3 | 6);
              }
              {
                const t3 = e2[2][0] !== r2 ? 2 : 3;
                return new q((e2[t3][0] + e2[t3][1]) / 2 << 3 | 6, 6 | (e2[2][0] !== r2 ? 0 : 65528));
              }
            }
            showCentroid(t2) {
              const e2 = this.centroidData[t2.centroidDataIndex];
              e2.flags &= Dh, e2.centroidXY.x = 0, e2.centroidXY.y = 0, this.writeCentroidToBuffer(e2);
            }
            writeCentroidToBuffer(t2) {
              this.groundEffect.updateHiddenByLandmark(t2);
              const e2 = t2.vertexArrayOffset, r2 = t2.vertexCount + t2.vertexArrayOffset, n2 = t2.flags & Dh ? Rh : t2.centroidXY, i2 = this.centroidVertexArray.geta_centroid_pos0(e2);
              if (this.centroidVertexArray.geta_centroid_pos1(e2) !== n2.y || i2 !== n2.x) {
                for (let t3 = e2; t3 < r2; ++t3)
                  this.centroidVertexArray.emplace(t3, n2.x, n2.y);
                this.needsCentroidUpdate = true;
              }
            }
            createCentroidsBuffer() {
              this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
              for (const t2 of this.centroidData)
                this.writeCentroidToBuffer(t2);
            }
            updateReplacement(t2, e2, r2) {
              if (e2.updateTime === this.replacementUpdateTime)
                return;
              this.replacementUpdateTime = e2.updateTime;
              const n2 = e2.getReplacementRegionsForTile(t2.toUnwrapped());
              if (wh(this.activeReplacements, n2))
                return;
              if (this.activeReplacements = n2, 0 === this.centroidVertexArray.length)
                this.createCentroidsBuffer();
              else
                for (const t3 of this.centroidData)
                  t3.flags &= 2147483647;
              const i2 = [];
              for (const e3 of this.activeReplacements) {
                if (e3.order < r2)
                  continue;
                const n3 = Math.pow(2, e3.footprintTileId.canonical.z - t2.canonical.z);
                for (const r3 of this.centroidData)
                  if (!(r3.flags & Dh || e3.min.x > r3.max.x || r3.min.x > e3.max.x || e3.min.y > r3.max.y || r3.min.y > e3.max.y))
                    for (let s2 = 0; s2 < r3.footprintSegLen; s2++) {
                      const a2 = this.footprintSegments[r3.footprintSegIdx + s2];
                      if (i2.length = 0, ip(this.footprintVertices, a2.vertexOffset, a2.vertexCount, e3.footprintTileId.canonical, t2.canonical, i2), Ah(e3.footprint, i2, this.footprintIndices.uint16, a2.indexOffset, a2.indexCount, -a2.vertexOffset, -n3)) {
                        r3.flags |= Dh;
                        break;
                      }
                    }
              }
              for (const t3 of this.centroidData)
                this.writeCentroidToBuffer(t3);
              this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
            }
            footprintContainsPoint(t2, e2, r2) {
              let n2 = false;
              for (let i2 = 0; i2 < r2.footprintSegLen; i2++) {
                const s2 = this.footprintSegments[r2.footprintSegIdx + i2];
                let a2 = 0;
                for (const r3 of s2.ringIndices) {
                  for (let i3 = a2, o2 = r3 + a2 - 1; i3 < r3 + a2; o2 = i3++) {
                    const r4 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 0], a3 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 1], l2 = this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 1];
                    a3 > e2 != l2 > e2 && t2 < (this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 0] - r4) * (e2 - a3) / (l2 - a3) + r4 && (n2 = !n2);
                  }
                  a2 = r3;
                }
              }
              return n2;
            }
            getHeightAtTileCoord(t2, e2) {
              let r2 = Number.NEGATIVE_INFINITY, n2 = true;
              const i2 = 4 * (t2 + Hr) * Hr + (e2 + Hr);
              if (this.partLookup.hasOwnProperty(i2)) {
                const t3 = this.partLookup[i2];
                return t3 ? { height: t3.height, hidden: !!(t3.flags & Dh) } : void 0;
              }
              for (const s2 of this.centroidData)
                t2 > s2.max.x || s2.min.x > t2 || e2 > s2.max.y || s2.min.y > e2 || this.footprintContainsPoint(t2, e2, s2) && s2 && s2.height > r2 && (r2 = s2.height, this.partLookup[i2] = s2, n2 = !!(s2.flags & Dh));
              if (r2 !== Number.NEGATIVE_INFINITY)
                return { height: r2, hidden: n2 };
              this.partLookup[i2] = void 0;
            }
          }
          function Wh(t2, e2) {
            const r2 = t2.add(e2)._unit();
            return t2.x * r2.x + t2.y * r2.y;
          }
          function Hh(t2, e2, r2, n2) {
            const i2 = e2.sub(t2)._perp()._unit(), s2 = r2.sub(e2)._perp()._unit();
            return Kh(t2, e2, r2, Wh(i2, s2), n2);
          }
          function Kh(t2, e2, r2, n2, i2) {
            const s2 = Math.sqrt(1 - n2 * n2);
            return Math.min(t2.dist(e2) / 3, e2.dist(r2) / 3, i2 * s2 / n2);
          }
          function Jh(t2, e2, r2) {
            return t2.x < r2[0].x && e2.x < r2[0].x || t2.x > r2[1].x && e2.x > r2[1].x || t2.y < r2[0].y && e2.y < r2[0].y || t2.y > r2[1].y && e2.y > r2[1].y;
          }
          function Qh(t2, e2) {
            return t2.x < e2[0].x || t2.x > e2[1].x || t2.y < e2[0].y || t2.y > e2[1].y;
          }
          function tp(t2, e2, r2) {
            if (t2.x < 0 || t2.x >= Hr || e2.x < 0 || e2.x >= Hr || r2.x < 0 || r2.x >= Hr)
              return false;
            const n2 = r2.sub(e2), i2 = n2.perp(), s2 = t2.sub(e2);
            return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
          }
          function ep(t2, e2, r2) {
            const n2 = e2 ? 2 | t2 : -3 & t2;
            return r2 ? 1 | n2 : -2 & n2;
          }
          function rp() {
            const t2 = Math.PI / 32, e2 = Math.tan(t2), r2 = tl;
            return r2 * Math.sqrt(1 + 2 * e2 * e2) - r2;
          }
          function np(t2, e2, r2) {
            const n2 = 1 << r2.z, i2 = cl(r2.x / n2), s2 = cl((r2.x + 1) / n2), a2 = hl(r2.y / n2), o2 = hl((r2.y + 1) / n2);
            return function(t3, e3, r3, n3, i3 = 0, s3) {
              const a3 = [];
              if (!t3.length || !r3 || !n3)
                return a3;
              const o3 = (t4, e4) => {
                for (const r4 of t4)
                  a3.push({ polygon: r4, bounds: e4 });
              }, l2 = Math.ceil(Math.log2(r3)), u2 = Math.ceil(Math.log2(n3)), c2 = l2 - u2, h2 = [];
              for (let t4 = 0; t4 < Math.abs(c2); t4++)
                h2.push(c2 > 0 ? 0 : 1);
              for (let t4 = 0; t4 < Math.min(l2, u2); t4++)
                h2.push(0), h2.push(1);
              let p2 = t3;
              if (p2 = fh(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = fh(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length)
                return a3;
              const f2 = [];
              for (h2.length ? f2.push({ polygons: p2, bounds: e3, depth: 0 }) : o3(p2, e3); f2.length; ) {
                const t4 = f2.pop(), e4 = t4.depth, r4 = h2[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u3 = 0 === r4 ? a4.x : a4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = fh(t4.polygons, l3 - i3, c3 + i3, r4), d2 = fh(t4.polygons, c3 - i3, u3 + i3, r4);
                if (p3.length) {
                  const t5 = [n4, new q(0 === r4 ? c3 : a4.x, 1 === r4 ? c3 : a4.y)];
                  h2.length > e4 + 1 ? f2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
                }
                if (d2.length) {
                  const t5 = [new q(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), a4];
                  h2.length > e4 + 1 ? f2.push({ polygons: d2, bounds: t5, depth: e4 + 1 }) : o3(d2, t5);
                }
              }
              return a3;
            }(t2, e2, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
              if (0 === t3)
                return 0.5 * (e3 + i3);
              {
                const t4 = hl((r2.y + e3 / Hr) / n2);
                return (ll(0.5 * (hl((r2.y + i3 / Hr) / n2) + t4)) * n2 - r2.y) * Hr;
              }
            });
          }
          function ip(t2, e2, r2, n2, i2, s2) {
            const a2 = Math.pow(2, n2.z - i2.z);
            for (let o2 = 0; o2 < r2; o2++) {
              let r3 = t2.int16[2 * (o2 + e2) + 0], l2 = t2.int16[2 * (o2 + e2) + 1];
              r3 = (r3 + i2.x * Hr) * a2 - n2.x * Hr, l2 = (l2 + i2.y * Hr) * a2 - n2.y * Hr, s2.push(new q(r3, l2));
            }
          }
          let sp, ap;
          function op(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function lp(t2, e2) {
            if (1 === t2.length) {
              let r2 = 0;
              const n2 = e2[r2++];
              let i2;
              for (; !i2 || n2.equals(i2); )
                if (i2 = e2[r2++], !i2)
                  return 1 / 0;
              for (; r2 < e2.length; r2++) {
                const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = op(o2, o2), h2 = op(o2, l2), p2 = op(l2, l2), f2 = op(u2, o2), d2 = op(u2, l2), m2 = c2 * p2 - h2 * h2, y2 = (p2 * f2 - h2 * d2) / m2, g2 = (c2 * d2 - h2 * f2) / m2, x2 = n2.z * (1 - y2 - g2) + i2.z * y2 + s2.z * g2;
                if (isFinite(x2))
                  return x2;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r2 of e2)
                t3 = Math.min(t3, r2.z);
              return t3;
            }
          }
          function up(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = 0 !== s2[0], c2 = u2 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
              const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, f2 = 2 * c3 + 1, d2 = function(t4, e4, r4, n4, i4) {
                return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
              }(t3, h2.x - u3, h2.y - c3, p2, f2), m2 = Math.abs(d2[0] - d2[1]), y2 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x2 = Math.min(0.25, 0.5 * l3 * (m2 + y2) / p2), b2 = Math.min(0.25, 0.5 * l3 * g2 / f2);
              return o3 + Math.max(x2 * s3, b2 * a3);
            }(i2, s2, o2) : l2;
            return { base: l2 + (0 === r2) ? -1 : r2, top: u2 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
          }
          os(Zh, "FillExtrusionBucket", { omit: ["layers", "features"] }), os(Nh, "PartData"), os(jh, "FootprintSegment"), os(qh, "BorderCentroidData"), os(Yh, "GroundEffect");
          const cp = ya([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), hp = ya([{ name: "a_z_offset", components: 1, type: "Float32" }], 4), { members: pp } = cp, fp = ya([{ name: "a_packed", components: 4, type: "Float32" }]), { members: dp } = fp, mp = ya([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: yp } = mp;
          class gp {
            constructor(t2, e2) {
              this.width = t2, this.height = e2, this.nextRow = 0, this.image = new nc({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
            }
            getDash(t2, e2) {
              const r2 = this.getKey(t2, e2);
              return this.positions[r2];
            }
            trim() {
              const t2 = this.width, e2 = this.height = at(this.nextRow);
              this.image.resize({ width: t2, height: e2 });
            }
            getKey(t2, e2) {
              return t2.join(",") + e2;
            }
            getDashRanges(t2, e2, r2) {
              const n2 = [];
              let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, a2 = true;
              n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t2[0] });
              let o2 = t2[0];
              for (let e3 = 1; e3 < t2.length; e3++) {
                a2 = !a2;
                const l2 = t2[e3];
                i2 = o2 * r2, o2 += l2, s2 = o2 * r2, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l2 });
              }
              return n2;
            }
            addRoundDash(t2, e2, r2) {
              const n2 = e2 / 2;
              for (let e3 = -r2; e3 <= r2; e3++) {
                const i2 = this.width * (this.nextRow + r2 + e3);
                let s2 = 0, a2 = t2[s2];
                for (let o2 = 0; o2 < this.width; o2++) {
                  o2 / a2.right > 1 && (a2 = t2[++s2]);
                  const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
                  let h2;
                  const p2 = e3 / r2 * (n2 + 1);
                  if (a2.isDash) {
                    const t3 = n2 - Math.abs(p2);
                    h2 = Math.sqrt(c2 * c2 + t3 * t3);
                  } else
                    h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                  this.image.data[i2 + o2] = Math.max(0, Math.min(255, h2 + 128));
                }
              }
            }
            addRegularDash(t2, e2) {
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                const r3 = t2[e3], n3 = t2[e3 + 1];
                r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
              }
              const r2 = t2[0], n2 = t2[t2.length - 1];
              r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
              const i2 = this.width * this.nextRow;
              let s2 = 0, a2 = t2[s2];
              for (let r3 = 0; r3 < this.width; r3++) {
                r3 / a2.right > 1 && (a2 = t2[++s2]);
                const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l2 = Math.min(n3, o2);
                this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
              }
            }
            addDash(t2, e2) {
              const r2 = this.getKey(t2, e2);
              if (this.positions[r2])
                return this.positions[r2];
              const n2 = "round" === e2, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
              if (this.nextRow + s2 > this.height)
                return ft("LineAtlas out of space"), null;
              0 === t2.length && t2.push(1);
              let a2 = 0;
              for (let e3 = 0; e3 < t2.length; e3++)
                t2[e3] < 0 && (ft("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
              if (0 !== a2) {
                const r3 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r3);
                n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e2 ? 0.5 * r3 : 0);
              }
              const o2 = this.nextRow + i2;
              this.nextRow += s2;
              const l2 = { tl: [o2, i2], br: [a2, 0] };
              return this.positions[r2] = l2, l2;
            }
          }
          os(gp, "LineAtlas");
          const xp = ch.VectorTileFeature.types, bp = Math.cos(Math.PI / 180 * 37.5), vp = Math.cos(Math.PI / 180 * 5);
          class wp {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.hasZOffset = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new _a(), this.layoutVertexArray2 = new Ma(), this.patternVertexArray = new Aa(), this.indexArray = new Da(), this.programConfigurations = new Fo(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.segments = new co(), this.maxLineLength = 0, this.zOffsetVertexArray = new Oa(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.tessellationStep = t2.tessellationStep ? t2.tessellationStep : Hr / 64;
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.hasPattern = Dc("line", this.layers, e2);
              const i2 = this.layers[0].layout.get("line-sort-key"), s2 = this.layers[0].layout.get("line-z-offset");
              this.hasZOffset = !s2.isConstant() || !!s2.constantOr(0);
              const a2 = [];
              for (const { feature: e3, id: s3, index: o3, sourceLayerIndex: l3 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u3 = Pl(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), u3, r2))
                  continue;
                const c2 = i2 ? i2.evaluate(u3, {}, r2) : void 0, h2 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u3.geometry : Il(e3, r2, n2), patterns: {}, sortKey: c2 };
                a2.push(h2);
              }
              i2 && a2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              const { lineAtlas: o2, featureIndex: l2 } = e2, u2 = this.addConstantDashes(o2);
              for (const n3 of a2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3;
                if (u2 && this.addFeatureDashes(n3, o2), this.hasPattern) {
                  const t3 = Lc("line", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, s3, r2, o2.positions, e2.availableImages, e2.brightness);
                l2.insert(t2[s3].feature, i3, s3, a3, this.index);
              }
            }
            addConstantDashes(t2) {
              let e2 = false;
              for (const r2 of this.layers) {
                const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
                if ("constant" !== n2.kind || "constant" !== i2.kind)
                  e2 = true;
                else {
                  const e3 = i2.value, r3 = n2.value;
                  if (!r3)
                    continue;
                  t2.addDash(r3, e3);
                }
              }
              return e2;
            }
            addFeatureDashes(t2, e2) {
              const r2 = this.zoom;
              for (const n2 of this.layers) {
                const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
                if ("constant" === i2.kind && "constant" === s2.kind)
                  continue;
                let a2, o2;
                if ("constant" === i2.kind) {
                  if (a2 = i2.value, !a2)
                    continue;
                } else
                  a2 = i2.evaluate({ zoom: r2 }, t2);
                o2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r2 }, t2), e2.addDash(a2, o2), t2.patterns[n2.id] = e2.getKey(a2, o2);
              }
            }
            update(t2, e2, r2, n2, i2) {
              const s2 = 0 !== Object.keys(t2).length;
              s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t2, e2, s2 ? this.stateDependentLayers : this.layers, r2, n2, i2);
            }
            addFeatures(t2, e2, r2, n2, i2, s2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2, s2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, dp)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t2.createVertexBuffer(this.patternVertexArray, yp)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, hp.members, true)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, pp), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
                return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = this.layers[0].layout, l2 = o2.get("line-join").evaluate(t2, {}), u2 = o2.get("line-cap").evaluate(t2, {}), c2 = o2.get("line-miter-limit"), h2 = o2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2);
              for (const r3 of e2)
                this.addLine(r3, t2, n2, l2, u2, c2, h2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, a2);
            }
            addLine(t2, e2, r2, n2, i2, s2, a2) {
              this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.currentVertex = void 0;
              const o2 = { zoom: this.zoom, lineProgress: void 0 }, l2 = this.layers[0].layout, u2 = "none" === n2;
              if (this.patternJoinNone = this.hasPattern && u2, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e3 = 0; e3 < t2.length - 1; e3++)
                  this.totalDistance += t2[e3].dist(t2[e3 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const c2 = "Polygon" === xp[e2.type];
              let h2 = t2.length;
              for (; h2 >= 2 && t2[h2 - 1].equals(t2[h2 - 2]); )
                h2--;
              let p2 = 0;
              for (; p2 < h2 - 1 && t2[p2].equals(t2[p2 + 1]); )
                p2++;
              if (h2 < (c2 ? 3 : 2))
                return;
              "bevel" === n2 && (s2 = 1.05);
              const f2 = this.overscaling <= 16 ? 15 * Hr / (512 * this.overscaling) : 0, d2 = this.segments.prepareSegment(10 * h2, this.layoutVertexArray, this.indexArray);
              let m2, y2, g2, x2, b2, v2;
              this.e1 = this.e2 = -1, c2 && (m2 = t2[h2 - 2], b2 = t2[p2].sub(m2)._unit()._perp());
              for (let r3 = p2; r3 < h2; r3++) {
                if (g2 = r3 === h2 - 1 ? c2 ? t2[p2 + 1] : void 0 : t2[r3 + 1], g2 && t2[r3].equals(g2))
                  continue;
                if (b2 && (x2 = b2), m2 && (y2 = m2), m2 = t2[r3], this.hasZOffset) {
                  const t3 = l2.get("line-z-offset").value;
                  if ("constant" === t3.kind)
                    v2 = t3.value;
                  else {
                    if (this.lineClips) {
                      const t4 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                      o2.lineProgress = (t4 * this.lineClips.start + this.distance + (y2 ? y2.dist(m2) : 0)) / t4;
                    } else
                      ft(`line-z-offset evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`), o2.lineProgress = 0;
                    v2 = t3.evaluate(o2, e2);
                  }
                  v2 = v2 || 0;
                }
                b2 = g2 ? g2.sub(m2)._unit()._perp() : x2, x2 = x2 || b2;
                const w2 = y2 && g2;
                let _2 = w2 ? n2 : c2 || u2 ? "butt" : i2;
                const M2 = x2.x * b2.x + x2.y * b2.y;
                if (u2) {
                  const t3 = function(t4) {
                    if (t4.patternJoinNone) {
                      const e3 = t4.segmentPoints.length / 2, r4 = t4.lineSoFar - t4.segmentStart;
                      for (let n3 = 0; n3 < e3; ++n3) {
                        const e4 = t4.segmentPoints[2 * n3 + 1], i3 = Math.round(t4.segmentPoints[2 * n3]) + 0.5 + 0.25 * e4;
                        t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart), t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart);
                      }
                      t4.segmentPoints.length = 0;
                    }
                    t4.e1 = t4.e2 = -1;
                  };
                  if (w2 && M2 < vp) {
                    this.updateDistance(y2, m2), this.addCurrentVertex(m2, x2, 1, 1, d2, v2), t3(this), this.addCurrentVertex(m2, b2, -1, -1, d2, v2);
                    continue;
                  }
                  if (y2) {
                    if (!g2) {
                      this.updateDistance(y2, m2), this.addCurrentVertex(m2, x2, 1, 1, d2, v2), t3(this);
                      continue;
                    }
                    _2 = "miter";
                  }
                }
                let A2 = x2.add(b2);
                0 === A2.x && 0 === A2.y || A2._unit();
                const S2 = A2.x * b2.x + A2.y * b2.y, I2 = 0 !== S2 ? 1 / S2 : 1 / 0, P2 = 2 * Math.sqrt(2 - 2 * S2), z2 = S2 < bp && y2 && g2, k2 = x2.x * b2.y - x2.y * b2.x > 0;
                if (z2 && r3 > p2) {
                  const t3 = m2.dist(y2);
                  if (t3 > 2 * f2) {
                    const e3 = m2.sub(m2.sub(y2)._mult(f2 / t3)._round());
                    this.updateDistance(y2, e3), this.addCurrentVertex(e3, x2, 0, 0, d2, v2), y2 = e3;
                  }
                }
                if (w2 && "round" === _2 && (I2 < a2 ? _2 = "miter" : I2 <= 2 && (_2 = "fakeround")), "miter" === _2 && I2 > s2 && (_2 = "bevel"), "bevel" === _2 && (I2 > 2 && (_2 = "flipbevel"), I2 < s2 && (_2 = "miter")), y2 && this.updateDistance(y2, m2), "miter" === _2)
                  A2._mult(I2), this.addCurrentVertex(m2, A2, 0, 0, d2, v2);
                else if ("flipbevel" === _2) {
                  if (I2 > 100)
                    A2 = b2.mult(-1);
                  else {
                    const t3 = I2 * x2.add(b2).mag() / x2.sub(b2).mag();
                    A2._perp()._mult(t3 * (k2 ? -1 : 1));
                  }
                  this.addCurrentVertex(m2, A2, 0, 0, d2, v2), this.addCurrentVertex(m2, A2.mult(-1), 0, 0, d2, v2);
                } else if ("bevel" === _2 || "fakeround" === _2) {
                  const t3 = -Math.sqrt(I2 * I2 - 1), e3 = k2 ? t3 : 0, r4 = k2 ? 0 : t3;
                  if (y2 && this.addCurrentVertex(m2, x2, e3, r4, d2, v2), "fakeround" === _2) {
                    const t4 = Math.round(180 * P2 / Math.PI / 20);
                    for (let e4 = 1; e4 < t4; e4++) {
                      let r5 = e4 / t4;
                      if (0.5 !== r5) {
                        const t5 = r5 - 0.5;
                        r5 += r5 * t5 * (r5 - 1) * ((1.0904 + M2 * (M2 * (3.55645 - 1.43519 * M2) - 3.2452)) * t5 * t5 + (0.848013 + M2 * (0.215638 * M2 - 1.06021)));
                      }
                      const n3 = b2.sub(x2)._mult(r5)._add(x2)._unit()._mult(k2 ? -1 : 1);
                      this.addHalfVertex(m2, n3.x, n3.y, false, k2, 0, d2, v2);
                    }
                  }
                  g2 && this.addCurrentVertex(m2, b2, -e3, -r4, d2, v2);
                } else
                  "butt" === _2 ? this.addCurrentVertex(m2, A2, 0, 0, d2, v2) : "square" === _2 ? (y2 || this.addCurrentVertex(m2, A2, -1, -1, d2, v2), this.addCurrentVertex(m2, A2, 0, 0, d2, v2), y2 && this.addCurrentVertex(m2, A2, 1, 1, d2, v2)) : "round" === _2 && (y2 && (this.addCurrentVertex(m2, x2, 0, 0, d2, v2), this.addCurrentVertex(m2, x2, 1, 1, d2, v2, true)), g2 && (this.addCurrentVertex(m2, b2, -1, -1, d2, v2, true), this.addCurrentVertex(m2, b2, 0, 0, d2, v2)));
                if (z2 && r3 < h2 - 1) {
                  const t3 = m2.dist(g2);
                  if (t3 > 2 * f2) {
                    const e3 = m2.add(g2.sub(m2)._mult(f2 / t3)._round());
                    this.updateDistance(m2, e3), this.addCurrentVertex(e3, b2, 0, 0, d2, v2), m2 = e3;
                  }
                }
              }
            }
            addVerticesTo(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = (e2.w - t2.w) / this.tessellationStep | 0;
              if (c2 > 1) {
                this.lineSoFar = t2.w;
                const h2 = (e2.x - t2.x) / c2, p2 = (e2.y - t2.y) / c2, f2 = (e2.z - t2.z) / c2, d2 = (e2.w - t2.w) / c2;
                for (let e3 = 1; e3 < c2; ++e3)
                  t2.x += h2, t2.y += p2, t2.z += f2, this.lineSoFar += d2, this.addHalfVertex(t2, r2, n2, u2, false, a2, l2, t2.z), this.addHalfVertex(t2, i2, s2, u2, true, -o2, l2, t2.z);
              }
              this.lineSoFar = e2.w, this.addHalfVertex(e2, r2, n2, u2, false, a2, l2, e2.z), this.addHalfVertex(e2, i2, s2, u2, true, -o2, l2, e2.z);
            }
            addCurrentVertex(t2, e2, r2, n2, i2, s2, a2 = false) {
              const o2 = e2.x + e2.y * r2, l2 = e2.y - e2.x * r2, u2 = e2.y * n2 - e2.x, c2 = -e2.y - e2.x * n2;
              if (null != s2) {
                const e3 = -10, h2 = Hr + 10, p2 = s2, f2 = new ph(t2.x, t2.y, p2, this.lineSoFar), d2 = _p(t2, e3, h2), m2 = this.lineSoFar;
                if (this.currentVertex)
                  if (d2) {
                    const s3 = this.currentVertexIsOutside, f3 = this.currentVertex, d3 = new ph(t2.x, t2.y, p2, this.lineSoFar);
                    mh(f3, d3, e3, h2), _p(d3, e3, h2) || (s3 && (this.e1 = this.e2 = -1, this.lineSoFar = f3.w, this.addHalfVertex(f3, o2, l2, a2, false, r2, i2, f3.z), this.addHalfVertex(f3, u2, c2, a2, true, -n2, i2, f3.z)), this.addVerticesTo(f3, d3, o2, l2, u2, c2, r2, n2, i2, a2));
                  } else {
                    const t3 = this.currentVertex;
                    this.currentVertexIsOutside && (mh(t3, f2, e3, h2), this.e1 = this.e2 = -1, this.lineSoFar = t3.w, this.addHalfVertex(t3, o2, l2, a2, false, r2, i2, t3.z), this.addHalfVertex(t3, u2, c2, a2, true, -n2, i2, t3.z)), this.addVerticesTo(t3, f2, o2, l2, u2, c2, r2, n2, i2, a2);
                  }
                else
                  d2 || (this.addHalfVertex(t2, o2, l2, a2, false, r2, i2, s2), this.addHalfVertex(t2, u2, c2, a2, true, -n2, i2, s2));
                this.currentVertex = f2, this.currentVertexIsOutside = d2, this.lineSoFar = m2;
              } else
                this.addHalfVertex(t2, o2, l2, a2, false, r2, i2, s2), this.addHalfVertex(t2, u2, c2, a2, true, -n2, i2, s2);
            }
            addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2, l2) {
              this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s2 || this.segmentPoints.push(this.lineSoFar - this.segmentStart, a2)), this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
              const u2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2, null != l2 && this.zOffsetVertexArray.emplaceBack(l2);
            }
            updateScaledDistance() {
              if (this.lineClips) {
                const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
              } else
                this.lineSoFar = this.distance;
            }
            updateDistance(t2, e2) {
              this.distance += t2.dist(e2), this.updateScaledDistance();
            }
          }
          function _p(t2, e2, r2) {
            return t2.x < e2 || t2.x > r2 || t2.y < e2 || t2.y > r2;
          }
          let Mp, Ap;
          function Sp(t2, e2, r2) {
            return e2 * (Hr / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
          }
          function Ip(t2, e2) {
            return 1 / Sp(t2, 1, e2.tileZoom);
          }
          function Pp(t2, e2, r2, n2) {
            return t2.translatePosMatrix(n2 || e2.tileID.projMatrix, e2, r2.paint.get("line-translate"), r2.paint.get("line-translate-anchor"));
          }
          os(wp, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
          const zp = (t2) => {
            const e2 = [];
            kp(t2) && e2.push("RENDER_LINE_DASH"), t2.paint.get("line-gradient") && e2.push("RENDER_LINE_GRADIENT");
            const r2 = t2.paint.get("line-trim-offset");
            0 === r2[0] && 0 === r2[1] || e2.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t2.paint.get("line-border-width").constantOr(1) && e2.push("RENDER_LINE_BORDER");
            const n2 = "none" === t2.layout.get("line-join").constantOr("miter"), i2 = !!t2.paint.get("line-pattern").constantOr(1);
            return n2 && i2 && e2.push("LINE_JOIN_NONE"), e2;
          };
          function kp(t2) {
            const e2 = t2.paint.get("line-dasharray").value;
            return e2.value || "constant" !== e2.kind;
          }
          let Tp;
          const Ep = () => Tp || (Tp = { layout: Mp || (Mp = new Gs({ "line-cap": new qs(Xs.layout_line["line-cap"]), "line-join": new qs(Xs.layout_line["line-join"]), "line-miter-limit": new Ns(Xs.layout_line["line-miter-limit"]), "line-round-limit": new Ns(Xs.layout_line["line-round-limit"]), "line-sort-key": new qs(Xs.layout_line["line-sort-key"]), "line-z-offset": new qs(Xs.layout_line["line-z-offset"]), visibility: new Ns(Xs.layout_line.visibility) })), paint: Ap || (Ap = new Gs({ "line-opacity": new qs(Xs.paint_line["line-opacity"]), "line-color": new qs(Xs.paint_line["line-color"]), "line-translate": new Ns(Xs.paint_line["line-translate"]), "line-translate-anchor": new Ns(Xs.paint_line["line-translate-anchor"]), "line-width": new qs(Xs.paint_line["line-width"]), "line-gap-width": new qs(Xs.paint_line["line-gap-width"]), "line-offset": new qs(Xs.paint_line["line-offset"]), "line-blur": new qs(Xs.paint_line["line-blur"]), "line-dasharray": new qs(Xs.paint_line["line-dasharray"]), "line-pattern": new qs(Xs.paint_line["line-pattern"]), "line-gradient": new $s(Xs.paint_line["line-gradient"]), "line-trim-offset": new Ns(Xs.paint_line["line-trim-offset"]), "line-trim-fade-range": new Ns(Xs.paint_line["line-trim-fade-range"]), "line-trim-color": new Ns(Xs.paint_line["line-trim-color"]), "line-emissive-strength": new Ns(Xs.paint_line["line-emissive-strength"]), "line-border-width": new qs(Xs.paint_line["line-border-width"]), "line-border-color": new qs(Xs.paint_line["line-border-color"]), "line-occlusion-opacity": new Ns(Xs.paint_line["line-occlusion-opacity"]) })) }, Tp);
          class Bp extends qs {
            possiblyEvaluate(t2, e2) {
              return e2 = new Vs(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
            }
            evaluate(t2, e2, r2, n2) {
              return e2 = nt({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
            }
          }
          let Vp;
          function Cp(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          const Rp = ya([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Dp = ya([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Lp = ya([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
          ya([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const Fp = ya([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), Op = ya([{ name: "a_texb", components: 2, type: "Uint16" }]), Up = ya([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), jp = ya([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
          ya([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const Np = ya([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), qp = ya([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          ya([{ name: "triangle", components: 3, type: "Uint16" }]), ya([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), ya([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), ya([{ type: "Float32", name: "offsetX" }]), ya([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
          var $p = 24;
          const Gp = 128;
          function Xp(t2, e2) {
            const { expression: r2 } = e2;
            if ("constant" === r2.kind)
              return { kind: "constant", layoutSize: r2.evaluate(new Vs(t2 + 1)) };
            if ("source" === r2.kind)
              return { kind: "source" };
            {
              const { zoomStops: e3, interpolationType: n2 } = r2;
              let i2 = 0;
              for (; i2 < e3.length && e3[i2] <= t2; )
                i2++;
              i2 = Math.max(0, i2 - 1);
              let s2 = i2;
              for (; s2 < e3.length && e3[s2] < t2 + 1; )
                s2++;
              s2 = Math.min(e3.length - 1, s2);
              const a2 = e3[i2], o2 = e3[s2];
              return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Vs(a2)), maxSize: r2.evaluate(new Vs(o2)), interpolationType: n2 };
            }
          }
          function Yp(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
            return "source" === t2.kind ? n2 / Gp : "composite" === t2.kind ? ke(n2 / Gp, i2 / Gp, r2) : e2;
          }
          function Zp(t2, e2) {
            let r2 = 0, n2 = 0;
            if ("constant" === t2.kind)
              n2 = t2.layoutSize;
            else if ("source" !== t2.kind) {
              const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? Q(si.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
              "camera" === t2.kind ? n2 = ke(t2.minSize, t2.maxSize, o2) : r2 = o2;
            }
            return { uSizeT: r2, uSize: n2 };
          }
          var Wp = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Gp, evaluateSizeForFeature: Yp, evaluateSizeForZoom: Zp, getSizeData: Xp });
          function Hp(t2, e2, r2) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e3, r3) {
                const n2 = e3.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Bs.applyArabicShaping && (t4 = Bs.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r2);
            }), t2;
          }
          const Kp = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
          function Jp(t2) {
            return "\uFE36" === t2 || "\uFE48" === t2 || "\uFE38" === t2 || "\uFE44" === t2 || "\uFE42" === t2 || "\uFE3E" === t2 || "\uFE3C" === t2 || "\uFE3A" === t2 || "\uFE18" === t2 || "\uFE40" === t2 || "\uFE10" === t2 || "\uFE13" === t2 || "\uFE14" === t2 || "\uFF40" === t2 || "\uFFE3" === t2 || "\uFE11" === t2 || "\uFE12" === t2;
          }
          function Qp(t2) {
            return "\uFE35" === t2 || "\uFE47" === t2 || "\uFE37" === t2 || "\uFE43" === t2 || "\uFE41" === t2 || "\uFE3D" === t2 || "\uFE3B" === t2 || "\uFE39" === t2 || "\uFE17" === t2 || "\uFE3F" === t2;
          }
          var tf, ef, rf, nf = {};
          function sf() {
            return tf || (tf = 1, nf.read = function(t2, e2, r2, n2, i2) {
              var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
              for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
                ;
              for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
                ;
              if (0 === s2)
                s2 = 1 - u2;
              else {
                if (s2 === l2)
                  return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
                a2 += Math.pow(2, n2), s2 -= u2;
              }
              return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
            }, nf.write = function(t2, e2, r2, n2, i2, s2) {
              var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, m2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
              for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
                ;
              for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
                ;
              t2[r2 + f2 - d2] |= 128 * m2;
            }), nf;
          }
          function af() {
            if (rf)
              return ef;
            rf = 1, ef = e2;
            var t2 = sf();
            function e2(t3) {
              this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            e2.Varint = 0, e2.Fixed64 = 1, e2.Bytes = 2, e2.Fixed32 = 5;
            var r2 = 4294967296, n2 = 1 / r2, i2 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
            function s2(t3) {
              return t3.type === e2.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
            }
            function a2(t3, e3, r3) {
              return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
            }
            function o2(t3, e3, r3) {
              var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
              r3.realloc(n3);
              for (var i3 = r3.pos - 1; i3 >= t3; i3--)
                r3.buf[i3 + n3] = r3.buf[i3];
            }
            function l2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeVarint(t3[r3]);
            }
            function u2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeSVarint(t3[r3]);
            }
            function c2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeFloat(t3[r3]);
            }
            function h2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeDouble(t3[r3]);
            }
            function p2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeBoolean(t3[r3]);
            }
            function f2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeFixed32(t3[r3]);
            }
            function d2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeSFixed32(t3[r3]);
            }
            function m2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeFixed64(t3[r3]);
            }
            function y2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                e3.writeSFixed64(t3[r3]);
            }
            function g2(t3, e3) {
              return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
            }
            function x2(t3, e3, r3) {
              t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
            }
            function b2(t3, e3) {
              return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
            }
            return e2.prototype = { destroy: function() {
              this.buf = null;
            }, readFields: function(t3, e3, r3) {
              for (r3 = r3 || this.length; this.pos < r3; ) {
                var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
                this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
              }
              return e3;
            }, readMessage: function(t3, e3) {
              return this.readFields(t3, e3, this.readVarint() + this.pos);
            }, readFixed32: function() {
              var t3 = g2(this.buf, this.pos);
              return this.pos += 4, t3;
            }, readSFixed32: function() {
              var t3 = b2(this.buf, this.pos);
              return this.pos += 4, t3;
            }, readFixed64: function() {
              var t3 = g2(this.buf, this.pos) + g2(this.buf, this.pos + 4) * r2;
              return this.pos += 8, t3;
            }, readSFixed64: function() {
              var t3 = g2(this.buf, this.pos) + b2(this.buf, this.pos + 4) * r2;
              return this.pos += 8, t3;
            }, readFloat: function() {
              var e3 = t2.read(this.buf, this.pos, true, 23, 4);
              return this.pos += 4, e3;
            }, readDouble: function() {
              var e3 = t2.read(this.buf, this.pos, true, 52, 8);
              return this.pos += 8, e3;
            }, readVarint: function(t3) {
              var e3, r3, n3 = this.buf;
              return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
                var n4, i3, s3 = r4.buf;
                if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128)
                  return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128)
                  return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128)
                  return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128)
                  return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128)
                  return a2(t4, n4, e4);
                if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128)
                  return a2(t4, n4, e4);
                throw new Error("Expected varint not more than 10 bytes");
              }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
            }, readVarint64: function() {
              return this.readVarint(true);
            }, readSVarint: function() {
              var t3 = this.readVarint();
              return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
            }, readBoolean: function() {
              return Boolean(this.readVarint());
            }, readString: function() {
              var t3 = this.readVarint() + this.pos, e3 = this.pos;
              return this.pos = t3, t3 - e3 >= 12 && i2 ? function(t4, e4, r3) {
                return i2.decode(t4.subarray(e4, r3));
              }(this.buf, e3, t3) : function(t4, e4, r3) {
                for (var n3 = "", i3 = e4; i3 < r3; ) {
                  var s3, a3, o3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
                  if (i3 + c3 > r3)
                    break;
                  1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (s3 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & s3) <= 127 && (u3 = null) : 3 === c3 ? (a3 = t4[i3 + 2], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && ((u3 = (15 & l3) << 12 | (63 & s3) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (a3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && 128 == (192 & o3) && ((u3 = (15 & l3) << 18 | (63 & s3) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
                }
                return n3;
              }(this.buf, e3, t3);
            }, readBytes: function() {
              var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
              return this.pos = t3, e3;
            }, readPackedVarint: function(t3, r3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readVarint(r3));
              var n3 = s2(this);
              for (t3 = t3 || []; this.pos < n3; )
                t3.push(this.readVarint(r3));
              return t3;
            }, readPackedSVarint: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readSVarint());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readSVarint());
              return t3;
            }, readPackedBoolean: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readBoolean());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readBoolean());
              return t3;
            }, readPackedFloat: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readFloat());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readFloat());
              return t3;
            }, readPackedDouble: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readDouble());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readDouble());
              return t3;
            }, readPackedFixed32: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readFixed32());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readFixed32());
              return t3;
            }, readPackedSFixed32: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readSFixed32());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readSFixed32());
              return t3;
            }, readPackedFixed64: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readFixed64());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readFixed64());
              return t3;
            }, readPackedSFixed64: function(t3) {
              if (this.type !== e2.Bytes)
                return t3.push(this.readSFixed64());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; )
                t3.push(this.readSFixed64());
              return t3;
            }, skip: function(t3) {
              var r3 = 7 & t3;
              if (r3 === e2.Varint)
                for (; this.buf[this.pos++] > 127; )
                  ;
              else if (r3 === e2.Bytes)
                this.pos = this.readVarint() + this.pos;
              else if (r3 === e2.Fixed32)
                this.pos += 4;
              else {
                if (r3 !== e2.Fixed64)
                  throw new Error("Unimplemented type: " + r3);
                this.pos += 8;
              }
            }, writeTag: function(t3, e3) {
              this.writeVarint(t3 << 3 | e3);
            }, realloc: function(t3) {
              for (var e3 = this.length || 16; e3 < this.pos + t3; )
                e3 *= 2;
              if (e3 !== this.length) {
                var r3 = new Uint8Array(e3);
                r3.set(this.buf), this.buf = r3, this.length = e3;
              }
            }, finish: function() {
              return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }, writeFixed32: function(t3) {
              this.realloc(4), x2(this.buf, t3, this.pos), this.pos += 4;
            }, writeSFixed32: function(t3) {
              this.realloc(4), x2(this.buf, t3, this.pos), this.pos += 4;
            }, writeFixed64: function(t3) {
              this.realloc(8), x2(this.buf, -1 & t3, this.pos), x2(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
            }, writeSFixed64: function(t3) {
              this.realloc(8), x2(this.buf, -1 & t3, this.pos), x2(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
            }, writeVarint: function(t3) {
              (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
                var r3, n3;
                if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
                  throw new Error("Given varint doesn't fit into 10 bytes");
                e3.realloc(10), function(t5, e4, r4) {
                  r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
                }(r3, 0, e3), function(t5, e4) {
                  var r4 = (7 & t5) << 4;
                  e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
                }(n3, e3);
              }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
            }, writeSVarint: function(t3) {
              this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
            }, writeBoolean: function(t3) {
              this.writeVarint(Boolean(t3));
            }, writeString: function(t3) {
              t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
              var e3 = this.pos;
              this.pos = function(t4, e4, r4) {
                for (var n3, i3, s3 = 0; s3 < e4.length; s3++) {
                  if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                    if (!i3) {
                      n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                      continue;
                    }
                    if (n3 < 56320) {
                      t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                      continue;
                    }
                    n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
                  } else
                    i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
                  n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
                }
                return r4;
              }(this.buf, t3, this.pos);
              var r3 = this.pos - e3;
              r3 >= 128 && o2(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
            }, writeFloat: function(e3) {
              this.realloc(4), t2.write(this.buf, e3, this.pos, true, 23, 4), this.pos += 4;
            }, writeDouble: function(e3) {
              this.realloc(8), t2.write(this.buf, e3, this.pos, true, 52, 8), this.pos += 8;
            }, writeBytes: function(t3) {
              var e3 = t3.length;
              this.writeVarint(e3), this.realloc(e3);
              for (var r3 = 0; r3 < e3; r3++)
                this.buf[this.pos++] = t3[r3];
            }, writeRawMessage: function(t3, e3) {
              this.pos++;
              var r3 = this.pos;
              t3(e3, this);
              var n3 = this.pos - r3;
              n3 >= 128 && o2(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
            }, writeMessage: function(t3, r3, n3) {
              this.writeTag(t3, e2.Bytes), this.writeRawMessage(r3, n3);
            }, writePackedVarint: function(t3, e3) {
              e3.length && this.writeMessage(t3, l2, e3);
            }, writePackedSVarint: function(t3, e3) {
              e3.length && this.writeMessage(t3, u2, e3);
            }, writePackedBoolean: function(t3, e3) {
              e3.length && this.writeMessage(t3, p2, e3);
            }, writePackedFloat: function(t3, e3) {
              e3.length && this.writeMessage(t3, c2, e3);
            }, writePackedDouble: function(t3, e3) {
              e3.length && this.writeMessage(t3, h2, e3);
            }, writePackedFixed32: function(t3, e3) {
              e3.length && this.writeMessage(t3, f2, e3);
            }, writePackedSFixed32: function(t3, e3) {
              e3.length && this.writeMessage(t3, d2, e3);
            }, writePackedFixed64: function(t3, e3) {
              e3.length && this.writeMessage(t3, m2, e3);
            }, writePackedSFixed64: function(t3, e3) {
              e3.length && this.writeMessage(t3, y2, e3);
            }, writeBytesField: function(t3, r3) {
              this.writeTag(t3, e2.Bytes), this.writeBytes(r3);
            }, writeFixed32Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeFixed32(r3);
            }, writeSFixed32Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeSFixed32(r3);
            }, writeFixed64Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeFixed64(r3);
            }, writeSFixed64Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeSFixed64(r3);
            }, writeVarintField: function(t3, r3) {
              this.writeTag(t3, e2.Varint), this.writeVarint(r3);
            }, writeSVarintField: function(t3, r3) {
              this.writeTag(t3, e2.Varint), this.writeSVarint(r3);
            }, writeStringField: function(t3, r3) {
              this.writeTag(t3, e2.Bytes), this.writeString(r3);
            }, writeFloatField: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeFloat(r3);
            }, writeDoubleField: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeDouble(r3);
            }, writeBooleanField: function(t3, e3) {
              this.writeVarintField(t3, Boolean(e3));
            } }, ef;
          }
          var of = e(af());
          const lf = 3;
          function uf(t2, e2, r2) {
            e2.glyphs = [], 1 === t2 && r2.readMessage(cf, e2);
          }
          function cf(t2, e2, r2) {
            if (3 === t2) {
              const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(hf, {});
              e2.glyphs.push({ id: t3, bitmap: new nc({ width: i2 + 2 * lf, height: s2 + 2 * lf }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
            } else
              4 === t2 ? e2.ascender = r2.readSVarint() : 5 === t2 && (e2.descender = r2.readSVarint());
          }
          function hf(t2, e2, r2) {
            1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
          }
          const pf = lf, ff = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
          class df {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t2, e2) {
              const r2 = new df();
              return r2.scale = t2 || 1, r2.fontStack = e2, r2;
            }
            static forImage(t2) {
              const e2 = new df();
              return e2.imageName = t2, e2;
            }
          }
          class mf {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e2) {
              const r2 = new mf();
              for (let n2 = 0; n2 < t2.sections.length; n2++) {
                const i2 = t2.sections[n2];
                i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
              }
              return r2;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSections() {
              return this.sections;
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCodePoint(t2) {
              return this.text.codePointAt(t2);
            }
            verticalizePunctuation(t2) {
              this.text = function(t3, e2) {
                let r2 = "";
                for (let n2 = 0; n2 < t3.length; n2++) {
                  const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
                  r2 += !e2 && (i2 && gs(i2) && !Kp[t3[n2 + 1]] || s2 && gs(s2) && !Kp[t3[n2 - 1]]) || !Kp[t3[n2]] ? t3[n2] : Kp[t3[n2]];
                }
                return r2;
              }(this.text, t2);
            }
            trim() {
              let t2 = 0;
              for (let e3 = 0; e3 < this.text.length && gf[this.text.charCodeAt(e3)]; e3++)
                t2++;
              let e2 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && gf[this.text.charCodeAt(r2)]; r2--)
                e2--;
              this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
            }
            substring(t2, e2) {
              const r2 = new mf();
              return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
            }
            addTextSection(t2, e2) {
              this.text += t2.text, this.sections.push(df.forText(t2.scale, t2.fontStack || e2));
              const r2 = this.sections.length - 1;
              for (let e3 = 0; e3 < t2.text.length; ++e3)
                this.sectionIndex.push(r2);
            }
            addImageSection(t2) {
              const e2 = t2.image ? t2.image.namePrimary : "";
              if (0 === e2.length)
                return void ft("Can't add FormattedSection with an empty image.");
              const r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCodePoint(r2), this.sections.push(df.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : ft("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function yf(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2) {
            const m2 = mf.fromFeature(t2, i2);
            h2 === ff.vertical && m2.verticalizePunctuation(p2);
            let y2 = [];
            const g2 = function(t3, e3, r3, n3, i3, s3) {
              if (!t3)
                return [];
              const a3 = [], o3 = function(t4, e4, r4, n4, i4, s4) {
                let a4 = 0;
                for (let r5 = 0; r5 < t4.length(); r5++) {
                  const o4 = t4.getSection(r5);
                  a4 += bf(t4.getCodePoint(r5), o4, n4, i4, e4, s4);
                }
                return a4 / Math.max(1, Math.ceil(a4 / r4));
              }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("\u200B") >= 0;
              let u3 = 0;
              for (let r4 = 0; r4 < t3.length(); r4++) {
                const h3 = t3.getSection(r4), p3 = t3.getCodePoint(r4);
                if (gf[p3] || (u3 += bf(p3, h3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
                  const e4 = !((c3 = p3) < 11904 || !(ps["Bopomofo Extended"](c3) || ps.Bopomofo(c3) || ps["CJK Compatibility Forms"](c3) || ps["CJK Compatibility Ideographs"](c3) || ps["CJK Compatibility"](c3) || ps["CJK Radicals Supplement"](c3) || ps["CJK Strokes"](c3) || ps["CJK Symbols and Punctuation"](c3) || ps["CJK Unified Ideographs Extension A"](c3) || ps["CJK Unified Ideographs"](c3) || ps["Enclosed CJK Letters and Months"](c3) || ps["Halfwidth and Fullwidth Forms"](c3) || ps.Hiragana(c3) || ps["Ideographic Description Characters"](c3) || ps["Kangxi Radicals"](c3) || ps["Katakana Phonetic Extensions"](c3) || ps.Katakana(c3) || ps["Vertical Forms"](c3) || ps["Yi Radicals"](c3) || ps["Yi Syllables"](c3)));
                  (xf[p3] || e4 || h3.imageName) && a3.push(_f(r4 + 1, u3, o3, a3, wf(p3, t3.getCodePoint(r4 + 1), e4 && l3), false));
                }
              }
              var c3;
              return Mf(_f(t3.length(), u3, o3, a3, 0, true));
            }(m2, u2, s2, e2, n2, f2), { processBidirectionalText: x2, processStyledBidirectionalText: b2 } = Bs;
            if (x2 && 1 === m2.sections.length) {
              const t3 = x2(m2.toString(), g2);
              for (const e3 of t3) {
                const t4 = new mf();
                t4.text = e3, t4.sections = m2.sections;
                for (let r3 = 0; r3 < e3.length; r3++)
                  t4.sectionIndex.push(0);
                y2.push(t4);
              }
            } else if (b2) {
              const t3 = b2(m2.text, m2.sectionIndex, g2);
              for (const e3 of t3) {
                const t4 = new mf();
                t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = m2.sections, y2.push(t4);
              }
            } else
              y2 = function(t3, e3) {
                const r3 = [], n3 = t3.text;
                let i3 = 0;
                for (const n4 of e3)
                  r3.push(t3.substring(i3, n4)), i3 = n4;
                return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
              }(m2, g2);
            const v2 = [], w2 = { positionedLines: v2, text: m2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
            return function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
              let p3 = 0, f3 = 0, d3 = 0;
              const m3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
              let y3 = false;
              for (const t4 of i3) {
                const r4 = t4.getSections();
                for (const t5 of r4) {
                  if (t5.imageName)
                    continue;
                  const r5 = e3[t5.fontStack];
                  if (r5 && (y3 = void 0 !== r5.ascender && void 0 !== r5.descender, !y3))
                    break;
                }
                if (!y3)
                  break;
              }
              let g3 = 0;
              for (const a4 of i3) {
                a4.trim();
                const i4 = a4.getMaxScale(), o4 = (i4 - 1) * $p, b4 = { positionedGlyphs: [], lineOffset: 0 };
                t3.positionedLines[g3] = b4;
                const v4 = b4.positionedGlyphs;
                let w4 = 0;
                if (!a4.length()) {
                  f3 += s3, ++g3;
                  continue;
                }
                let _2 = 0, M2 = 0;
                for (let s4 = 0; s4 < a4.length(); s4++) {
                  const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), m4 = a4.getCodePoint(s4);
                  let g4 = o5.scale, b5 = null, A3 = null, S2 = null, I2 = $p, P2 = 0;
                  const z2 = !(l3 === ff.horizontal || !c3 && !ys(m4) || c3 && (gf[m4] || (x3 = m4, ps.Arabic(x3) || ps["Arabic Supplement"](x3) || ps["Arabic Extended-A"](x3) || ps["Arabic Presentation Forms-A"](x3) || ps["Arabic Presentation Forms-B"](x3))));
                  if (o5.imageName) {
                    const e4 = n3[o5.imageName];
                    if (!e4)
                      continue;
                    S2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, A3 = e4.paddedRect;
                    const r4 = e4.displaySize;
                    g4 = g4 * $p / h3, b5 = { width: r4[0], height: r4[1], left: 0, top: -pf, advance: z2 ? r4[1] : r4[0], localGlyph: false }, P2 = y3 ? -b5.height * g4 : i4 * $p - 17 - r4[1] * g4, I2 = b5.advance;
                    const s5 = (z2 ? r4[0] : r4[1]) * g4 - $p * i4;
                    s5 > 0 && s5 > w4 && (w4 = s5);
                  } else {
                    const t4 = r3[o5.fontStack];
                    if (!t4)
                      continue;
                    t4[m4] && (A3 = t4[m4]);
                    const n4 = e3[o5.fontStack];
                    if (!n4)
                      continue;
                    const s5 = n4.glyphs[m4];
                    if (!s5)
                      continue;
                    if (b5 = s5.metrics, I2 = 8203 !== m4 ? $p : 0, y3) {
                      const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                      _2 < r4 && (_2 = r4, M2 = (t5 - e4) / 2 * g4), P2 = -t5 * g4;
                    } else
                      P2 = (i4 - g4) * $p - 17;
                  }
                  z2 ? (t3.verticalizable = true, v4.push({ glyph: m4, imageName: S2, x: p3, y: f3 + P2, vertical: z2, scale: g4, localGlyph: b5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: b5, rect: A3 }), p3 += I2 * g4 + u3) : (v4.push({ glyph: m4, imageName: S2, x: p3, y: f3 + P2, vertical: z2, scale: g4, localGlyph: b5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: b5, rect: A3 }), p3 += b5.advance * g4 + u3);
                }
                0 !== v4.length && (d3 = Math.max(p3 - u3, d3), y3 ? Sf(v4, m3, w4, M2, s3 * i4 / 2) : Sf(v4, m3, w4, 0, s3 / 2)), p3 = 0;
                const A2 = s3 * i4 + w4;
                b4.lineOffset = Math.max(w4, o4), f3 += A2, ++g3;
              }
              var x3;
              const b3 = f3, { horizontalAlign: v3, verticalAlign: w3 } = Af(a3);
              (function(t4, e4, r4, n4, i4, s4) {
                const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
                for (const e5 of t4)
                  for (const t5 of e5.positionedGlyphs)
                    t5.x += a4, t5.y += o4;
              })(t3.positionedLines, m3, v3, w3, d3, b3), t3.top += -w3 * b3, t3.bottom = t3.top + b3, t3.left += -v3 * d3, t3.right = t3.left + d3, t3.hasBaseline = y3;
            }(w2, e2, r2, n2, y2, a2, o2, l2, h2, u2, p2, d2), !function(t3) {
              for (const e3 of t3)
                if (0 !== e3.positionedGlyphs.length)
                  return false;
              return true;
            }(v2) && w2;
          }
          const gf = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, xf = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function bf(t2, e2, r2, n2, i2, s2) {
            if (e2.imageName) {
              const t3 = n2[e2.imageName];
              return t3 ? t3.displaySize[0] * e2.scale * $p / s2 + i2 : 0;
            }
            {
              const n3 = r2[e2.fontStack], s3 = n3 && n3.glyphs[t2];
              return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
            }
          }
          function vf(t2, e2, r2, n2) {
            const i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function wf(t2, e2, r2) {
            let n2 = 0;
            return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
          }
          function _f(t2, e2, r2, n2, i2, s2) {
            let a2 = null, o2 = vf(e2, r2, i2, s2);
            for (const t3 of n2) {
              const n3 = vf(e2 - t3.x, r2, i2, s2) + t3.badness;
              n3 <= o2 && (a2 = t3, o2 = n3);
            }
            return { index: t2, x: e2, priorBreak: a2, badness: o2 };
          }
          function Mf(t2) {
            return t2 ? Mf(t2.priorBreak).concat(t2.index) : [];
          }
          function Af(t2) {
            let e2 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r2 };
          }
          function Sf(t2, e2, r2, n2, i2) {
            if (!(e2 || r2 || n2 || i2))
              return;
            const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
            for (let e3 = 0; e3 <= s2; e3++)
              t2[e3].x -= o2, t2[e3].y += r2 + n2 + i2;
          }
          function If(t2, e2, r2, n2) {
            const { horizontalAlign: i2, verticalAlign: s2 } = Af(n2), a2 = r2[0] - t2.displaySize[0] * i2, o2 = r2[1] - t2.displaySize[1] * s2;
            return { imagePrimary: t2, imageSecondary: e2, top: o2, bottom: o2 + t2.displaySize[1], left: a2, right: a2 + t2.displaySize[0] };
          }
          function Pf(t2, e2, r2, n2, i2, s2) {
            const a2 = t2.imagePrimary;
            let o2;
            if (a2.content) {
              const t3 = a2.content, e3 = a2.pixelRatio || 1;
              o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
            }
            const l2 = e2.left * s2, u2 = e2.right * s2;
            let c2, h2, p2, f2;
            "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
            const d2 = e2.top * s2, m2 = e2.bottom * s2;
            return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + m2 + n2[2]) : (c2 = i2[1] + (d2 + m2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { imagePrimary: a2, imageSecondary: void 0, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
          }
          class zf extends q {
            constructor(t2, e2, r2, n2, i2) {
              super(t2, e2), this.angle = n2, this.z = r2, void 0 !== i2 && (this.segment = i2);
            }
            clone() {
              return new zf(this.x, this.y, this.z, this.angle, this.segment);
            }
          }
          function kf(t2, e2, r2, n2, i2) {
            if (void 0 === e2.segment)
              return true;
            let s2 = e2, a2 = e2.segment + 1, o2 = 0;
            for (; o2 > -r2 / 2; ) {
              if (a2--, a2 < 0)
                return false;
              o2 -= t2[a2].dist(s2), s2 = t2[a2];
            }
            o2 += t2[a2].dist(t2[a2 + 1]), a2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r2 / 2; ) {
              const e3 = t2[a2], r3 = t2[a2 + 1];
              if (!r3)
                return false;
              let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
              for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
                u2 -= l2.shift().angleDelta;
              if (u2 > i2)
                return false;
              a2++, o2 += e3.dist(r3);
            }
            return true;
          }
          function Tf(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++)
              e2 += t2[r2].dist(t2[r2 + 1]);
            return e2;
          }
          function Ef(t2, e2, r2) {
            return t2 ? 0.6 * e2 * r2 : 0;
          }
          function Bf(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function Vf(t2, e2, r2, n2, i2, s2) {
            const a2 = Ef(r2, i2, s2), o2 = Bf(r2, n2) * s2;
            let l2 = 0;
            const u2 = Tf(t2) / 2;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
              if (l2 + s3 > u2) {
                const c2 = (u2 - l2) / s3, h2 = ke(n3.x, i3.x, c2), p2 = ke(n3.y, i3.y, c2), f2 = new zf(h2, p2, 0, i3.angleTo(n3), r3);
                return !a2 || kf(t2, f2, o2, a2, e2) ? f2 : void 0;
              }
              l2 += s3;
            }
          }
          function Cf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = Ef(n2, s2, a2), c2 = Bf(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
            return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), Rf(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
          }
          function Rf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = s2 / 2, c2 = Tf(t2);
            let h2 = 0, p2 = e2 - r2, f2 = [];
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), m2 = o3.angleTo(a3);
              for (; p2 + r2 < h2 + d2; ) {
                p2 += r2;
                const y2 = (p2 - h2) / d2, g2 = ke(a3.x, o3.x, y2), x2 = ke(a3.y, o3.y, y2);
                if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                  const r3 = new zf(g2, x2, 0, m2, e3);
                  n2 && !kf(t2, r3, s2, n2, i2) || f2.push(r3);
                }
              }
              h2 += d2;
            }
            return o2 || f2.length || a2 || (f2 = Rf(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
          }
          function Df(t2, e2, r2, n2, i2) {
            const s2 = [];
            for (let a2 = 0; a2 < t2.length; a2++) {
              const o2 = t2[a2];
              let l2;
              for (let t3 = 0; t3 < o2.length - 1; t3++) {
                let a3 = o2[t3], u2 = o2[t3 + 1];
                a3.x < e2 && u2.x < e2 || (a3.x < e2 ? a3 = new q(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e2 && (u2 = new q(e2, a3.y + (e2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r2 && u2.y < r2 || (a3.y < r2 ? a3 = new q(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round() : u2.y < r2 && (u2 = new q(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new q(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new q(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new q(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new q(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
              }
            }
            return s2;
          }
          function Lf(t2) {
            let e2 = 0, r2 = 0;
            for (const n3 of t2)
              e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
            t2.sort((t3, e3) => e3.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
            let i2 = 0, s2 = 0;
            for (const e3 of t2)
              for (let t3 = n2.length - 1; t3 >= 0; t3--) {
                const r3 = n2[t3];
                if (!(e3.w > r3.w || e3.h > r3.h)) {
                  if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                    const e4 = n2.pop();
                    t3 < n2.length && (n2[t3] = e4);
                  } else
                    e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                  break;
                }
              }
            return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
          }
          os(zf, "Anchor");
          const Ff = 1;
          class Of {
            constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2 }, a2) {
              this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.padding = a2;
            }
            get tl() {
              return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
            }
            get displaySize() {
              return [(this.paddedRect.w - 2 * this.padding) / this.pixelRatio, (this.paddedRect.h - 2 * this.padding) / this.pixelRatio];
            }
          }
          class Uf {
            constructor(t2, e2, r2) {
              const n2 = {}, i2 = {};
              this.haveRenderCallbacks = [];
              const s2 = [];
              this.addImages(t2, n2, Ff, s2), this.addImages(e2, i2, 2, s2);
              const { w: a2, h: o2 } = Lf(s2), l2 = new ic({ width: a2 || 1, height: o2 || 1 });
              for (const e3 in t2) {
                const i3 = t2[e3], s3 = n2[e3].paddedRect;
                ic.copy(i3.data, l2, { x: 0, y: 0 }, { x: s3.x + Ff, y: s3.y + Ff }, i3.data, r2, i3.sdf);
              }
              for (const t3 in e2) {
                const n3 = e2[t3], s3 = i2[t3].paddedRect;
                let a3 = i2[t3].padding;
                const o3 = s3.x + a3, u2 = s3.y + a3, c2 = n3.data.width, h2 = n3.data.height;
                a3 = a3 > 1 ? a3 - 1 : a3, ic.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3, y: u2 }, n3.data, r2), ic.copy(n3.data, l2, { x: 0, y: h2 - a3 }, { x: o3, y: u2 - a3 }, { width: c2, height: a3 }, r2), ic.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3, y: u2 + h2 }, { width: c2, height: a3 }, r2), ic.copy(n3.data, l2, { x: c2 - a3, y: 0 }, { x: o3 - a3, y: u2 }, { width: a3, height: h2 }, r2), ic.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3 + c2, y: u2 }, { width: a3, height: h2 }, r2), ic.copy(n3.data, l2, { x: c2 - a3, y: h2 - a3 }, { x: o3 - a3, y: u2 - a3 }, { width: a3, height: a3 }, r2), ic.copy(n3.data, l2, { x: 0, y: h2 - a3 }, { x: o3 + c2, y: u2 - a3 }, { width: a3, height: a3 }, r2), ic.copy(n3.data, l2, { x: 0, y: 0 }, { x: o3 + c2, y: u2 + h2 }, { width: a3, height: a3 }, r2), ic.copy(n3.data, l2, { x: c2 - a3, y: 0 }, { x: o3 - a3, y: u2 + h2 }, { width: a3, height: a3 }, r2);
              }
              this.image = l2, this.iconPositions = n2, this.patternPositions = i2;
            }
            addImages(t2, e2, r2, n2) {
              for (const i2 in t2) {
                const s2 = t2[i2], a2 = { x: 0, y: 0, w: s2.data.width + 2 * r2, h: s2.data.height + 2 * r2 };
                n2.push(a2), e2[i2] = new Of(a2, s2, r2), s2.hasRenderCallback && this.haveRenderCallbacks.push(i2);
              }
            }
            patchUpdatedImages(t2, e2, r2) {
              this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3, r2)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks, r2);
              for (const n2 in t2.getUpdatedImages(r2))
                this.patchUpdatedImage(this.iconPositions[n2], t2.getImage(n2, r2), e2), this.patchUpdatedImage(this.patternPositions[n2], t2.getImage(n2, r2), e2);
            }
            patchUpdatedImage(t2, e2, r2) {
              if (!t2 || !e2)
                return;
              if (t2.version === e2.version)
                return;
              t2.version = e2.version;
              const [n2, i2] = t2.tl;
              r2.update(e2.data, { position: { x: n2, y: i2 } });
            }
          }
          os(Of, "ImagePosition"), os(Uf, "ImageAtlas");
          const jf = 1e20;
          function Nf(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            for (let u2 = e2; u2 < e2 + n2; u2++)
              qf(t2, r2 * s2 + u2, s2, i2, a2, o2, l2);
            for (let u2 = r2; u2 < r2 + i2; u2++)
              qf(t2, u2 * s2 + e2, 1, n2, a2, o2, l2);
          }
          function qf(t2, e2, r2, n2, i2, s2, a2) {
            s2[0] = 0, a2[0] = -jf, a2[1] = jf, i2[0] = t2[e2];
            for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
              i2[o2] = t2[e2 + o2 * r2];
              const n3 = o2 * o2;
              do {
                const t3 = s2[l2];
                u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
              } while (u2 <= a2[l2] && --l2 > -1);
              l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = jf;
            }
            for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
              for (; a2[l2 + 1] < o2; )
                l2++;
              const n3 = s2[l2], u2 = o2 - n3;
              t2[e2 + o2 * r2] = i2[n3] + u2 * u2;
            }
          }
          const $f = 2, Gf = { none: 0, ideographs: 1, all: 2 };
          class Xf {
            constructor(t2, e2, r2) {
              this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
            }
            setURL(t2, e2) {
              this.urls[e2] = t2;
            }
            getGlyphs(t2, e2, r2) {
              const n2 = [], i2 = this.urls[e2] || It.GLYPHS_URL;
              for (const e3 in t2)
                for (const r3 of t2[e3])
                  n2.push({ stack: e3, id: r3 });
              rt(n2, ({ stack: t3, id: e3 }, r3) => {
                let n3 = this.entries[t3];
                n3 || (n3 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
                let s2 = n3.glyphs[e3];
                if (void 0 !== s2)
                  return void r3(null, { stack: t3, id: e3, glyph: s2 });
                if (s2 = this._tinySDF(n3, t3, e3), s2)
                  return n3.glyphs[e3] = s2, void r3(null, { stack: t3, id: e3, glyph: s2 });
                const a2 = Math.floor(e3 / 256);
                if (256 * a2 > 65535)
                  return void r3(new Error("glyphs > 65535 not supported"));
                if (n3.ranges[a2])
                  return void r3(null, { stack: t3, id: e3, glyph: s2 });
                let o2 = n3.requests[a2];
                o2 || (o2 = n3.requests[a2] = [], Xf.loadGlyphRange(t3, a2, i2, this.requestManager, (t4, e4) => {
                  if (e4) {
                    n3.ascender = e4.ascender, n3.descender = e4.descender;
                    for (const t5 in e4.glyphs)
                      this._doesCharSupportLocalGlyph(+t5) || (n3.glyphs[+t5] = e4.glyphs[+t5]);
                    n3.ranges[a2] = true;
                  }
                  for (const r4 of o2)
                    r4(t4, e4);
                  delete n3.requests[a2];
                })), o2.push((n4, i3) => {
                  n4 ? r3(n4) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
                });
              }, (t3, e3) => {
                if (t3)
                  r2(t3);
                else if (e3) {
                  const t4 = {};
                  for (const { stack: r3, id: n3, glyph: i3 } of e3)
                    void 0 === t4[r3] && (t4[r3] = {}), void 0 === t4[r3].glyphs && (t4[r3].glyphs = {}), t4[r3].glyphs[n3] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t4[r3].ascender = this.entries[r3].ascender, t4[r3].descender = this.entries[r3].descender;
                  r2(null, t4);
                }
              });
            }
            _doesCharSupportLocalGlyph(t2) {
              return this.localGlyphMode !== Gf.none && (this.localGlyphMode === Gf.all ? !!this.localFontFamily : !!this.localFontFamily && (ps["CJK Unified Ideographs"](t2) || ps["Hangul Syllables"](t2) || ps.Hiragana(t2) || ps.Katakana(t2) || ps["CJK Symbols and Punctuation"](t2) || ps["CJK Unified Ideographs Extension A"](t2) || ps["CJK Unified Ideographs Extension B"](t2)));
            }
            _tinySDF(t2, e2, r2) {
              const n2 = this.localFontFamily;
              if (!n2 || !this._doesCharSupportLocalGlyph(r2))
                return;
              let i2 = t2.tinySDF;
              if (!i2) {
                let r3 = "400";
                /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new Xf.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 24 * $f, buffer: 3 * $f, radius: 8 * $f }), i2.fontWeight = r3;
              }
              if (this.localGlyphs[i2.fontWeight][r2])
                return this.localGlyphs[i2.fontWeight][r2];
              const s2 = String.fromCodePoint(r2), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h2, glyphTop: p2, glyphAdvance: f2 } = i2.draw(s2);
              return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new nc({ width: o2, height: l2 }, a2), metrics: { width: u2 / $f, height: c2 / $f, left: h2 / $f, top: p2 / $f - 27, advance: f2 / $f, localGlyph: true } };
            }
          }
          Xf.loadGlyphRange = function(t2, e2, r2, n2, i2) {
            const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), ee.Glyphs);
            se(o2, (t3, e3) => {
              if (t3)
                i2(t3);
              else if (e3) {
                const t4 = {}, r3 = function(t5) {
                  return new of(t5).readFields(uf, {});
                }(e3);
                for (const e4 of r3.glyphs)
                  t4[e4.id] = e4;
                i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
              }
            });
          }, Xf.TinySDF = class {
            constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
              this.buffer = e2, this.cutoff = n2, this.radius = r2;
              const o2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              u2.font = `${a2} ${s2} ${t2}px ${i2}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
            }
            _createCanvas(t2) {
              const e2 = document.createElement("canvas");
              return e2.width = e2.height = t2, e2;
            }
            draw(t2) {
              const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.ceil(r2), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, a2 + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h2 = Math.max(u2 * c2, 0), p2 = new Uint8ClampedArray(h2), f2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
              if (0 === o2 || 0 === l2)
                return f2;
              const { ctx: d2, buffer: m2, gridInner: y2, gridOuter: g2 } = this;
              d2.clearRect(m2, m2, o2, l2), d2.fillText(t2, m2, m2 + a2);
              const x2 = d2.getImageData(m2, m2, o2, l2);
              g2.fill(jf, 0, h2), y2.fill(0, 0, h2);
              for (let t3 = 0; t3 < l2; t3++)
                for (let e3 = 0; e3 < o2; e3++) {
                  const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
                  if (0 === r3)
                    continue;
                  const n3 = (t3 + m2) * u2 + e3 + m2;
                  if (1 === r3)
                    g2[n3] = 0, y2[n3] = jf;
                  else {
                    const t4 = 0.5 - r3;
                    g2[n3] = t4 > 0 ? t4 * t4 : 0, y2[n3] = t4 < 0 ? t4 * t4 : 0;
                  }
                }
              Nf(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), Nf(y2, m2, m2, o2, l2, u2, this.f, this.v, this.z);
              for (let t3 = 0; t3 < h2; t3++) {
                const e3 = Math.sqrt(g2[t3]) - Math.sqrt(y2[t3]);
                p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
              }
              return f2;
            }
          };
          const Yf = Ff;
          function Zf(t2, e2, r2, n2) {
            const i2 = [], s2 = t2.imagePrimary, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2 * Yf, l2 = s2.paddedRect.h - 2 * Yf, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), m2 = p2.reduce(f2, 0), y2 = o2 - d2, g2 = l2 - m2;
            let x2 = 0, b2 = d2, v2 = 0, w2 = m2, _2 = 0, M2 = y2, A2 = 0, S2 = g2;
            if (s2.content && n2) {
              const t3 = s2.content;
              x2 = Wf(h2, 0, t3[0]), v2 = Wf(p2, 0, t3[1]), b2 = Wf(h2, t3[0], t3[2]), w2 = Wf(p2, t3[1], t3[3]), _2 = t3[0] - x2, A2 = t3[1] - v2, M2 = t3[2] - t3[0] - b2, S2 = t3[3] - t3[1] - w2;
            }
            const I2 = (n3, i3, o3, l3) => {
              const h3 = Kf(n3.stretch - x2, b2, u2, t2.left), p3 = Jf(n3.fixed - _2, M2, n3.stretch, d2), f3 = Kf(i3.stretch - v2, w2, c2, t2.top), y3 = Jf(i3.fixed - A2, S2, i3.stretch, m2), g3 = Kf(o3.stretch - x2, b2, u2, t2.left), I3 = Jf(o3.fixed - _2, M2, o3.stretch, d2), P2 = Kf(l3.stretch - v2, w2, c2, t2.top), z2 = Jf(l3.fixed - A2, S2, l3.stretch, m2), k2 = new q(h3, f3), T2 = new q(g3, f3), E2 = new q(g3, P2), B2 = new q(h3, P2), V2 = new q(p3 / a2, y3 / a2), C2 = new q(I3 / a2, z2 / a2), R2 = e2 * Math.PI / 180;
              if (R2) {
                const t3 = Math.sin(R2), e3 = Math.cos(R2), r3 = [e3, -t3, t3, e3];
                k2._matMult(r3), T2._matMult(r3), B2._matMult(r3), E2._matMult(r3);
              }
              const D2 = n3.stretch + n3.fixed, L2 = o3.stretch + o3.fixed, F2 = i3.stretch + i3.fixed, O2 = l3.stretch + l3.fixed, U2 = t2.imageSecondary;
              return { tl: k2, tr: T2, bl: B2, br: E2, texPrimary: { x: s2.paddedRect.x + Yf + D2, y: s2.paddedRect.y + Yf + F2, w: L2 - D2, h: O2 - F2 }, texSecondary: U2 ? { x: U2.paddedRect.x + Yf + D2, y: U2.paddedRect.y + Yf + F2, w: L2 - D2, h: O2 - F2 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V2, pixelOffsetBR: C2, minFontScaleX: M2 / a2 / u2, minFontScaleY: S2 / a2 / c2, isSDF: r2 };
            };
            if (n2 && (s2.stretchX || s2.stretchY)) {
              const t3 = Hf(h2, y2, d2), e3 = Hf(p2, g2, m2);
              for (let r3 = 0; r3 < t3.length - 1; r3++) {
                const n3 = t3[r3], s3 = t3[r3 + 1];
                for (let t4 = 0; t4 < e3.length - 1; t4++)
                  i2.push(I2(n3, e3[t4], s3, e3[t4 + 1]));
              }
            } else
              i2.push(I2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
            return i2;
          }
          function Wf(t2, e2, r2) {
            let n2 = 0;
            for (const i2 of t2)
              n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
            return n2;
          }
          function Hf(t2, e2, r2) {
            const n2 = [{ fixed: -Yf, stretch: 0 }];
            for (const [e3, r3] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
            }
            return n2.push({ fixed: e2 + Yf, stretch: r2 }), n2;
          }
          function Kf(t2, e2, r2, n2) {
            return t2 / e2 * r2 + n2;
          }
          function Jf(t2, e2, r2, n2) {
            return t2 - e2 * r2 / n2;
          }
          function Qf(t2, e2, r2, n2) {
            const i2 = e2 + t2.positionedLines[n2].lineOffset;
            return 0 === n2 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
          }
          function td(t2, e2 = 1, r2 = false) {
            let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
            const o2 = t2[0];
            for (let t3 = 0; t3 < o2.length; t3++) {
              const e3 = o2[t3];
              (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
            }
            const l2 = Math.min(s2 - n2, a2 - i2);
            let u2 = l2 / 2;
            const c2 = new Wr([], ed);
            if (0 === l2)
              return new q(n2, i2);
            for (let e3 = n2; e3 < s2; e3 += l2)
              for (let r3 = i2; r3 < a2; r3 += l2)
                c2.push(new rd(e3 + u2, r3 + u2, u2, t2));
            let h2 = function(t3) {
              let e3 = 0, r3 = 0, n3 = 0;
              const i3 = t3[0];
              for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
                const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
                r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
              }
              return new rd(r3 / e3, n3 / e3, 0, t3);
            }(t2), p2 = c2.length;
            for (; c2.length; ) {
              const n3 = c2.pop();
              (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u2 = n3.h / 2, c2.push(new rd(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new rd(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new rd(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new rd(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
            }
            return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
          }
          function ed(t2, e2) {
            return e2.max - t2.max;
          }
          class rd {
            constructor(t2, e2, r2, n2) {
              this.p = new q(t2, e2), this.h = r2, this.d = function(t3, e3) {
                let r3 = false, n3 = 1 / 0;
                for (let i2 = 0; i2 < e3.length; i2++) {
                  const s2 = e3[i2];
                  for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                    const i4 = s2[e4], o2 = s2[a2];
                    i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Fl(t3, i4, o2));
                  }
                }
                return (r3 ? 1 : -1) * Math.sqrt(n3);
              }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
            }
          }
          const nd = Number.POSITIVE_INFINITY, id = Math.sqrt(2);
          function sd(t2, [e2, r2]) {
            let n2 = 0, i2 = 0;
            if (r2 === nd) {
              e2 < 0 && (e2 = 0);
              const r3 = e2 / id;
              switch (t2) {
                case "top-right":
                case "top-left":
                  i2 = r3 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  i2 = 7 - r3;
                  break;
                case "bottom":
                  i2 = 7 - e2;
                  break;
                case "top":
                  i2 = e2 - 7;
              }
              switch (t2) {
                case "top-right":
                case "bottom-right":
                  n2 = -r3;
                  break;
                case "top-left":
                case "bottom-left":
                  n2 = r3;
                  break;
                case "left":
                  n2 = e2;
                  break;
                case "right":
                  n2 = -e2;
              }
            } else {
              switch (e2 = Math.abs(e2), r2 = Math.abs(r2), t2) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r2;
              }
              switch (t2) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e2;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e2;
              }
            }
            return [n2, i2];
          }
          function ad(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function od(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2) {
            let m2 = s2.textMaxSize.evaluate(e2, {}, h2);
            void 0 === m2 && (m2 = a2);
            const y2 = t2.layers[0].layout, g2 = y2.get("icon-offset").evaluate(e2, {}, h2), x2 = hd(r2.horizontal) || r2.vertical, b2 = "globe" === p2.name, v2 = $p, w2 = a2 / v2, _2 = t2.tilePixelRatio * m2 / v2, M2 = (E2 = t2.overscaling, t2.zoom > 18 && E2 > 2 && (E2 >>= 1), Math.max(Hr / (512 * E2), 1) * y2.get("symbol-spacing")), A2 = y2.get("text-padding") * t2.tilePixelRatio, S2 = y2.get("icon-padding") * t2.tilePixelRatio, I2 = Y(y2.get("text-max-angle")), P2 = "map" === y2.get("text-rotation-alignment") && "point" !== y2.get("symbol-placement"), z2 = "map" === y2.get("icon-rotation-alignment") && "point" !== y2.get("symbol-placement"), k2 = y2.get("symbol-placement"), T2 = M2 / 2;
            var E2;
            const B2 = y2.get("icon-text-fit").evaluate(e2, {}, h2), V2 = y2.get("icon-text-fit-padding").evaluate(e2, {}, h2), C2 = "none" !== B2;
            let R2;
            false === t2.hasAnyIconTextFit && C2 && (t2.hasAnyIconTextFit = true), n2 && C2 && (t2.allowVerticalPlacement && r2.vertical && (R2 = Pf(n2, r2.vertical, B2, V2, g2, w2)), x2 && (n2 = Pf(n2, x2, B2, V2, g2, w2)));
            const D2 = (a3, o3, m3) => {
              if (o3.x < 0 || o3.x >= Hr || o3.y < 0 || o3.y >= Hr)
                return;
              let y3 = null;
              if (b2) {
                const { x: t3, y: e3, z: r3 } = p2.projectTilePoint(o3.x, o3.y, m3);
                y3 = { anchor: new zf(t3, e3, r3, 0, void 0), up: p2.upVector(m3, o3.x, o3.y) };
              }
              !function(t3, e3, r3, n3, i3, s3, a4, o4, l3, u3, c3, h3, p3, f3, d3, m4, y4, g3, x3, b3, v3, w3, _3, M3, A3, S3, I3) {
                const P3 = t3.addToLineVertexArray(e3, n3);
                let z3, k3, T3, E3, B3, V3, C3, R3 = 0, D3 = 0, L2 = 0, F2 = 0, O2 = -1, U2 = -1;
                const j2 = {};
                let N2 = xe("");
                const q2 = r3 ? r3.anchor : e3, $2 = "none" !== l3.layout.get("icon-text-fit").evaluate(v3, {}, A3);
                let G2 = 0, X2 = 0;
                if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [G2, X2] = l3.layout.get("text-offset").evaluate(v3, {}, A3).map((t4) => t4 * $p) : (G2 = l3.layout.get("text-radial-offset").evaluate(v3, {}, A3) * $p, X2 = nd), t3.allowVerticalPlacement && i3.vertical) {
                  const t4 = i3.vertical;
                  if (d3)
                    V3 = fd(t4), o4 && (C3 = fd(o4));
                  else {
                    const r4 = l3.layout.get("text-rotate").evaluate(v3, {}, A3) + 90;
                    T3 = pd(u3, q2, e3, c3, h3, p3, t4, f3, r4, m4), o4 && (E3 = pd(u3, q2, e3, c3, h3, p3, o4, g3, r4));
                  }
                }
                if (s3) {
                  const n4 = l3.layout.get("icon-rotate").evaluate(v3, {}, A3), i4 = Zf(s3, n4, _3, $2), a5 = o4 ? Zf(o4, n4, _3, $2) : void 0;
                  k3 = pd(u3, q2, e3, c3, h3, p3, s3, g3, n4), R3 = 4 * i4.length;
                  const f4 = t3.iconSizeData;
                  let d4 = null;
                  "source" === f4.kind ? (d4 = [Gp * l3.layout.get("icon-size").evaluate(v3, {}, A3)], d4[0] > ud && ft(`${t3.layerIds[0]}: Value for "icon-size" is >= ${ld}. Reduce your "icon-size".`)) : "composite" === f4.kind && (d4 = [Gp * w3.compositeIconSizes[0].evaluate(v3, {}, A3), Gp * w3.compositeIconSizes[1].evaluate(v3, {}, A3)], (d4[0] > ud || d4[1] > ud) && ft(`${t3.layerIds[0]}: Value for "icon-size" is >= ${ld}. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, i4, d4, b3, x3, v3, false, r3, e3, P3.lineStartIndex, P3.lineLength, -1, M3, A3, S3, I3), O2 = t3.icon.placedSymbolArray.length - 1, a5 && (D3 = 4 * a5.length, t3.addSymbols(t3.icon, a5, d4, b3, x3, v3, ff.vertical, r3, e3, P3.lineStartIndex, P3.lineLength, -1, M3, A3, S3, I3), U2 = t3.icon.placedSymbolArray.length - 1);
                }
                for (const n4 in i3.horizontal) {
                  const s4 = i3.horizontal[n4];
                  z3 || (N2 = xe(s4.text), d3 ? B3 = fd(s4) : z3 = pd(u3, q2, e3, c3, h3, p3, s4, f3, l3.layout.get("text-rotate").evaluate(v3, {}, A3), m4));
                  const o5 = 1 === s4.positionedLines.length;
                  if (L2 += cd(t3, r3, e3, s4, a4, l3, d3, v3, m4, P3, i3.vertical ? ff.horizontal : ff.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], j2, O2, w3, M3, A3, S3), o5)
                    break;
                }
                i3.vertical && (F2 += cd(t3, r3, e3, i3.vertical, a4, l3, d3, v3, m4, P3, ff.vertical, ["vertical"], j2, U2, w3, M3, A3, S3));
                let Y2 = -1;
                const Z2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
                Y2 = Z2(B3, Y2), Y2 = Z2(V3, Y2), Y2 = Z2(C3, Y2);
                const W2 = Y2 > -1 ? 1 : 0;
                t3.glyphOffsetArray.length >= 65535 && ft("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== v3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, v3.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, q2.x, q2.y, q2.z, j2.right >= 0 ? j2.right : -1, j2.center >= 0 ? j2.center : -1, j2.left >= 0 ? j2.left : -1, j2.vertical >= 0 ? j2.vertical : -1, O2, U2, N2, void 0 !== z3 ? z3 : t3.collisionBoxArray.length, void 0 !== z3 ? z3 + 1 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, void 0 !== k3 ? k3 : t3.collisionBoxArray.length, void 0 !== k3 ? k3 + 1 : t3.collisionBoxArray.length, E3 || t3.collisionBoxArray.length, E3 ? E3 + 1 : t3.collisionBoxArray.length, c3, L2, F2, R3, D3, W2, 0, G2, X2, Y2, 0, $2 ? 1 : 0);
              }(t2, o3, y3, a3, r2, n2, i2, R2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, A2, P2, l2, 0, S2, z2, g2, e2, s2, u2, c2, h2, f2, d2);
            };
            if ("line" === k2)
              for (const i3 of Df(e2.geometry, 0, 0, Hr, Hr)) {
                const e3 = Cf(i3, M2, I2, r2.vertical || x2, n2, v2, _2, t2.overscaling, Hr);
                for (const r3 of e3)
                  x2 && dd(t2, x2.text, T2, r3) || D2(i3, r3, h2);
              }
            else if ("line-center" === k2) {
              for (const t3 of e2.geometry)
                if (t3.length > 1) {
                  const e3 = Vf(t3, I2, r2.vertical || x2, n2, v2, _2);
                  e3 && D2(t3, e3, h2);
                }
            } else if ("Polygon" === e2.type)
              for (const t3 of Cc(e2.geometry, 0)) {
                const e3 = td(t3, 16);
                D2(t3[0], new zf(e3.x, e3.y, 0, 0, void 0), h2);
              }
            else if ("LineString" === e2.type)
              for (const t3 of e2.geometry)
                D2(t3, new zf(t3[0].x, t3[0].y, 0, 0, void 0), h2);
            else if ("Point" === e2.type)
              for (const t3 of e2.geometry)
                for (const e3 of t3)
                  D2([e3], new zf(e3.x, e3.y, 0, 0, void 0), h2);
          }
          const ld = 255, ud = ld * Gp;
          function cd(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2, y2, g2) {
            const x2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
              const l3 = [];
              if (0 === e3.positionedLines.length)
                return l3;
              const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
                const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
                return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
              }(r3);
              let h3 = Math.abs(e3.top - e3.bottom);
              for (const t4 of e3.positionedLines)
                h3 -= t4.lineOffset;
              const p3 = e3.positionedLines.length, f3 = h3 / p3;
              let d3 = e3.top - r3[1];
              for (let t4 = 0; t4 < p3; ++t4) {
                const n4 = e3.positionedLines[t4];
                d3 = Qf(e3, f3, d3, t4);
                for (const t5 of n4.positionedGlyphs) {
                  if (!t5.rect)
                    continue;
                  const n5 = t5.rect || {};
                  let s4 = pf + 1, h4 = true, p4 = 1, f4 = 0;
                  if (t5.imageName) {
                    const e4 = a3[t5.imageName];
                    if (!e4)
                      continue;
                    if (e4.sdf) {
                      ft("SDF images are not supported in formatted text and will be ignored.");
                      continue;
                    }
                    h4 = false, p4 = e4.pixelRatio, s4 = Ff / p4;
                  }
                  const m3 = (i3 || o3) && t5.vertical, y3 = t5.metrics.advance * t5.scale / 2, g3 = t5.metrics, x3 = t5.rect;
                  if (null === x3)
                    continue;
                  o3 && e3.verticalizable && (f4 = t5.imageName ? y3 - t5.metrics.width * t5.scale / 2 : 0);
                  const b3 = i3 ? [t5.x + y3, t5.y] : [0, 0];
                  let v3 = [0, 0], w2 = [0, 0], _2 = false;
                  i3 || (m3 ? (w2 = [t5.x + y3 + c3[0], t5.y + c3[1] - f4], _2 = true) : v3 = [t5.x + y3 + r3[0], t5.y + r3[1] - f4]);
                  const M2 = x3.w * t5.scale / (p4 * (t5.localGlyph ? $f : 1)), A2 = x3.h * t5.scale / (p4 * (t5.localGlyph ? $f : 1));
                  let S2, I2, P2, z2;
                  if (m3) {
                    const e4 = t5.y - d3, r4 = new q(-y3, y3 - e4), n6 = -Math.PI / 2, i4 = new q(...w2);
                    S2 = new q(-y3 + v3[0], v3[1]), S2._rotateAround(n6, r4)._add(i4), S2.x += -e4 + y3, S2.y -= (g3.left - s4) * t5.scale;
                    const a4 = t5.imageName ? g3.advance * t5.scale : $p * t5.scale, o4 = String.fromCodePoint(t5.glyph);
                    Jp(o4) ? S2.x += (1 - s4) * t5.scale : Qp(o4) ? S2.x += a4 - g3.height * t5.scale + (-s4 - 1) * t5.scale : S2.x += t5.imageName || g3.width + 2 * s4 === x3.w && g3.height + 2 * s4 === x3.h ? (a4 - A2) / 2 : (a4 - (g3.height + 2 * s4) * t5.scale) / 2, I2 = new q(S2.x, S2.y - M2), P2 = new q(S2.x + A2, S2.y), z2 = new q(S2.x + A2, S2.y - M2);
                  } else {
                    const e4 = (g3.left - s4) * t5.scale - y3 + v3[0], r4 = (-g3.top - s4) * t5.scale + v3[1], n6 = e4 + M2, i4 = r4 + A2;
                    S2 = new q(e4, r4), I2 = new q(n6, r4), P2 = new q(e4, i4), z2 = new q(n6, i4);
                  }
                  if (u3) {
                    let t6;
                    t6 = i3 ? new q(0, 0) : _2 ? new q(c3[0], c3[1]) : new q(r3[0], r3[1]), S2._rotateAround(u3, t6), I2._rotateAround(u3, t6), P2._rotateAround(u3, t6), z2._rotateAround(u3, t6);
                  }
                  const k2 = new q(0, 0), T2 = new q(0, 0);
                  l3.push({ tl: S2, tr: I2, bl: P2, br: z2, texPrimary: n5, texSecondary: void 0, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: k2, pixelOffsetBR: T2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              }
              return l3;
            }(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement), b2 = t2.textSizeData;
            let v2 = null;
            "source" === b2.kind ? (v2 = [Gp * s2.layout.get("text-size").evaluate(o2, {}, y2)], v2[0] > ud && ft(`${t2.layerIds[0]}: Value for "text-size" is >= ${ld}. Reduce your "text-size".`)) : "composite" === b2.kind && (v2 = [Gp * d2.compositeTextSizes[0].evaluate(o2, {}, y2), Gp * d2.compositeTextSizes[1].evaluate(o2, {}, y2)], (v2[0] > ud || v2[1] > ud) && ft(`${t2.layerIds[0]}: Value for "text-size" is >= ${ld}. Reduce your "text-size".`)), t2.addSymbols(t2.text, x2, v2, l2, a2, o2, c2, e2, r2, u2.lineStartIndex, u2.lineLength, f2, m2, y2, g2, false);
            for (const e3 of h2)
              p2[e3] = t2.text.placedSymbolArray.length - 1;
            return 4 * x2.length;
          }
          function hd(t2) {
            for (const e2 in t2)
              return t2[e2];
            return null;
          }
          function pd(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            let c2 = a2.top, h2 = a2.bottom, p2 = a2.left, f2 = a2.right;
            const d2 = a2.collisionPadding;
            if (d2 && (p2 -= d2[0], c2 -= d2[1], f2 += d2[2], h2 += d2[3]), l2) {
              const t3 = new q(p2, c2), e3 = new q(f2, c2), r3 = new q(p2, h2), n3 = new q(f2, h2), i3 = Y(l2);
              let s3 = new q(0, 0);
              u2 && (s3 = new q(u2[0], u2[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), c2 = Math.min(t3.y, e3.y, r3.y, n3.y), h2 = Math.max(t3.y, e3.y, r3.y, n3.y);
            }
            return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, p2, c2, f2, h2, o2, n2, i2, s2), t2.length - 1;
          }
          function fd(t2) {
            t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
            const e2 = t2.bottom - t2.top;
            return e2 > 0 ? Math.max(10, e2) : null;
          }
          function dd(t2, e2, r2, n2) {
            const i2 = t2.compareText;
            if (e2 in i2) {
              const t3 = i2[e2];
              for (let e3 = t3.length - 1; e3 >= 0; e3--)
                if (n2.dist(t3[e3]) < r2)
                  return true;
            } else
              i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          function md(t2, e2) {
            const r2 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01));
            let a2 = Math.sin(t2._pitch) * s2 + i2;
            const o2 = i2 * (1 / t2._horizonShift);
            return t2.elevation && 0 !== t2.elevation.exaggeration() || (a2 *= 1 + Math.max(t2.zoom - 17, 0)), Math.min(1.01 * a2, o2);
          }
          function yd(t2, e2) {
            if (!e2.isReprojectedInTileSpace)
              return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
            const r2 = Math.pow(2, -t2.z), n2 = t2.x * r2, i2 = (t2.x + 1) * r2, s2 = t2.y * r2, a2 = (t2.y + 1) * r2, o2 = cl(n2), l2 = cl(i2), u2 = hl(s2), c2 = hl(a2), h2 = e2.project(o2, u2), p2 = e2.project(l2, u2), f2 = e2.project(l2, c2), d2 = e2.project(o2, c2);
            let m2 = Math.min(h2.x, p2.x, f2.x, d2.x), y2 = Math.min(h2.y, p2.y, f2.y, d2.y), g2 = Math.max(h2.x, p2.x, f2.x, d2.x), x2 = Math.max(h2.y, p2.y, f2.y, d2.y);
            const b2 = r2 / 16;
            function v2(t3, r3, n3, i3, s3, a3) {
              const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e2.project(cl(o3), hl(l3)), c3 = Math.max(0, m2 - u3.x, y2 - u3.y, u3.x - g2, u3.y - x2);
              m2 = Math.min(m2, u3.x), g2 = Math.max(g2, u3.x), y2 = Math.min(y2, u3.y), x2 = Math.max(x2, u3.y), c3 > b2 && (v2(t3, u3, n3, i3, o3, l3), v2(u3, r3, o3, l3, s3, a3));
            }
            v2(h2, p2, n2, s2, i2, s2), v2(p2, f2, i2, s2, i2, a2), v2(f2, d2, i2, a2, n2, a2), v2(d2, h2, n2, a2, n2, s2), m2 -= b2, y2 -= b2, g2 += b2, x2 += b2;
            const w2 = 1 / Math.max(g2 - m2, x2 - y2);
            return { scale: w2, x: m2 * w2, y: y2 * w2, x2: g2 * w2, y2: x2 * w2, projection: e2 };
          }
          function gd(t2, { x: e2, y: r2 }, n2 = 0) {
            return new q(((e2 - n2) * t2.scale - t2.x) * Hr, (r2 * t2.scale - t2.y) * Hr);
          }
          const xd = O.mat4.identity(new Float32Array(16));
          class bd {
            constructor(t2) {
              this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
            }
            project(t2, e2) {
              return { x: 0, y: 0, z: 0 };
            }
            unproject(t2, e2) {
              return new rl(0, 0);
            }
            projectTilePoint(t2, e2, r2) {
              return { x: t2, y: e2, z: 0 };
            }
            locationPoint(t2, e2, r2 = true) {
              return t2._coordinatePoint(t2.locationCoordinate(e2), r2);
            }
            pixelsPerMeter(t2, e2) {
              return ul(1, t2) * e2;
            }
            pixelSpaceConversion(t2, e2, r2) {
              return 1;
            }
            farthestPixelDistance(t2) {
              return md(t2, t2.pixelsPerMeter);
            }
            pointCoordinate(t2, e2, r2, n2) {
              const i2 = t2.horizonLineFromTop(false), s2 = new q(e2, Math.max(i2, r2));
              return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
            }
            pointCoordinate3D(t2, e2, r2) {
              const n2 = new q(e2, r2);
              if (t2.elevation)
                return t2.elevation.pointCoordinate(n2);
              {
                const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
                return [e3.x, e3.y, e3.z];
              }
            }
            isPointAboveHorizon(t2, e2) {
              if (t2.elevation && t2.elevation.visibleDemTiles.length)
                return !this.pointCoordinate3D(t2, e2.x, e2.y);
              const r2 = t2.horizonLineFromTop();
              return e2.y < r2;
            }
            createInversionMatrix(t2, e2) {
              return xd;
            }
            createTileMatrix(t2, e2, r2) {
              let n2, i2, s2;
              const a2 = r2.canonical, o2 = O.mat4.identity(new Float64Array(16));
              if (this.isReprojectedInTileSpace) {
                const l2 = yd(a2, this);
                n2 = 1, i2 = l2.x + r2.wrap * l2.scale, s2 = l2.y, O.mat4.scale(o2, o2, [n2 / l2.scale, n2 / l2.scale, t2.pixelsPerMeter / e2]);
              } else
                n2 = e2 / t2.zoomScale(a2.z), i2 = (a2.x + Math.pow(2, a2.z) * r2.wrap) * n2, s2 = a2.y * n2;
              return O.mat4.translate(o2, o2, [i2, s2, 0]), O.mat4.scale(o2, o2, [n2 / Hr, n2 / Hr, 1]), o2;
            }
            upVector(t2, e2, r2) {
              return [0, 0, 1];
            }
            upVectorScale(t2, e2, r2) {
              return { metersToTile: 1 };
            }
          }
          class vd extends bd {
            constructor(t2) {
              super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
              const [e2, r2] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(Y(e2));
              this.n = (n2 + Math.sin(Y(r2))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t2, e2) {
              const { n: r2, c: n2, r0: i2 } = this, s2 = Y(t2 - this.center[0]), a2 = Y(e2), o2 = Math.sqrt(n2 - 2 * r2 * Math.sin(a2)) / r2;
              return { x: o2 * Math.sin(s2 * r2), y: o2 * Math.cos(s2 * r2) - i2, z: 0 };
            }
            unproject(t2, e2) {
              const { n: r2, c: n2, r0: i2 } = this, s2 = i2 + e2;
              let a2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
              s2 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
              const o2 = Y(this.center[0]) * r2;
              a2 = et(a2, -Math.PI - o2, Math.PI - o2);
              const l2 = Q(Z(a2 / r2) + this.center[0], -180, 180), u2 = Math.asin(Q((n2 - (t2 * t2 + s2 * s2) * r2 * r2) / (2 * r2), -1, 1)), c2 = Q(Z(u2), -fl, fl);
              return new rl(l2, c2);
            }
          }
          const wd = 1.340264, _d = -0.081106, Md = 893e-6, Ad = 3796e-6, Sd = Math.sqrt(3) / 2;
          class Id extends bd {
            project(t2, e2) {
              e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
              const r2 = Math.asin(Sd * Math.sin(e2)), n2 = r2 * r2, i2 = n2 * n2 * n2;
              return { x: 0.5 * (t2 * Math.cos(r2) / (Sd * (wd + 3 * _d * n2 + i2 * (7 * Md + 9 * Ad * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (wd + _d * n2 + i2 * (Md + Ad * n2)) / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI;
              let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = r2 * r2, i2 = n2 * n2 * n2;
              for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r2 * (wd + _d * n2 + i2 * (Md + Ad * n2)) - e2, a3 = wd + 3 * _d * n2 + i2 * (7 * Md + 9 * Ad * n2), t3 = s3 / a3, r2 = Q(r2 - t3, -Math.PI / 3, Math.PI / 3), n2 = r2 * r2, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++o3)
                ;
              const s2 = Sd * t2 * (wd + 3 * _d * n2 + i2 * (7 * Md + 9 * Ad * n2)) / Math.cos(r2), a2 = Math.asin(Math.sin(r2) / Sd), o2 = Q(180 * s2 / Math.PI, -180, 180), l2 = Q(180 * a2 / Math.PI, -fl, fl);
              return new rl(o2, l2);
            }
          }
          class Pd extends bd {
            constructor(t2) {
              super(t2), this.wrap = true, this.supportsWorldCopies = true;
            }
            project(t2, e2) {
              return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
            }
            unproject(t2, e2) {
              const r2 = 360 * (t2 - 0.5), n2 = Q(360 * (0.5 - e2), -fl, fl);
              return new rl(r2, n2);
            }
          }
          const zd = Math.PI / 2;
          function kd(t2) {
            return Math.tan((zd + t2) / 2);
          }
          class Td extends bd {
            constructor(t2) {
              super(t2), this.center = t2.center || [0, 30];
              const [e2, r2] = this.parallels = t2.parallels || [30, 30];
              let n2 = Y(e2), i2 = Y(r2);
              this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
              const s2 = Math.cos(n2), a2 = kd(n2);
              this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log(kd(i2) / a2), this.f = s2 * Math.pow(kd(n2), this.n) / this.n;
            }
            project(t2, e2) {
              e2 = Y(e2), this.southernCenter && (e2 = -e2), t2 = Y(t2 - this.center[0]);
              const r2 = 1e-6, { n: n2, f: i2 } = this;
              i2 > 0 ? e2 < -zd + r2 && (e2 = -zd + r2) : e2 > zd - r2 && (e2 = zd - r2);
              const s2 = i2 / Math.pow(kd(e2), n2);
              let a2 = s2 * Math.sin(n2 * t2), o2 = i2 - s2 * Math.cos(n2 * t2);
              return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
              const { n: r2, f: n2 } = this, i2 = n2 - e2, s2 = Math.sign(i2), a2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
              let o2 = Math.atan2(t2, Math.abs(i2)) * s2;
              i2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * s2);
              const l2 = Q(Z(o2 / r2) + this.center[0], -180, 180), u2 = Q(Z(2 * Math.atan(Math.pow(n2 / a2, 1 / r2)) - zd), -fl, fl);
              return new rl(l2, this.southernCenter ? -u2 : u2);
            }
          }
          class Ed extends bd {
            constructor(t2) {
              super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
            }
            project(t2, e2) {
              return { x: ol(t2), y: ll(e2), z: 0 };
            }
            unproject(t2, e2) {
              const r2 = cl(t2), n2 = hl(e2);
              return new rl(r2, n2);
            }
          }
          const Bd = Y(fl);
          class Vd extends bd {
            project(t2, e2) {
              const r2 = (e2 = Y(e2)) * e2, n2 = r2 * r2;
              return { x: 0.5 * ((t2 = Y(t2)) * (0.8707 - 0.131979 * r2 + n2 * (n2 * (3971e-6 * r2 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r2 * (0.015085 + n2 * (0.028874 * r2 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI;
              let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r2 * r2;
              do {
                s2 = r2 * r2;
                const t3 = s2 * s2;
                i2 = (r2 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r2 = Q(r2 - i2, -Bd, Bd);
              } while (Math.abs(i2) > 1e-6 && --n2 > 0);
              s2 = r2 * r2;
              const a2 = Q(Z(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = Z(r2);
              return new rl(a2, o2);
            }
          }
          const Cd = Y(fl);
          class Rd extends bd {
            project(t2, e2) {
              e2 = Y(e2), t2 = Y(t2);
              const r2 = Math.cos(e2), n2 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n2 + 2 * r2 * Math.sin(t2 / 2) / s2) || 0, o2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
              return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
              const s2 = 1e-6;
              let a2 = 0, o2 = 0;
              do {
                const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u2 = s3 * s3, c2 = i3 * i3, h2 = Math.cos(r2 / 2), p2 = Math.sin(r2 / 2), f2 = 2 * h2 * p2, d2 = p2 * p2, m2 = 1 - c2 * h2 * h2, y2 = m2 ? 1 / m2 : 0, g2 = m2 ? Math.acos(i3 * h2) * Math.sqrt(1 / m2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r2 / Math.PI) - t2, b2 = 0.5 * (g2 * s3 + n2) - e2, v2 = 0.5 * y2 * (c2 * d2 + g2 * i3 * h2 * u2) + 1 / Math.PI, w2 = y2 * (f2 * l2 / 4 - g2 * s3 * p2), _2 = 0.125 * y2 * (l2 * p2 - g2 * s3 * c2 * f2), M2 = 0.5 * y2 * (u2 * h2 + g2 * d2 * i3) + 0.5, A2 = w2 * _2 - M2 * v2;
                a2 = (b2 * w2 - x2 * M2) / A2, o2 = (x2 * _2 - b2 * v2) / A2, r2 = Q(r2 - a2, -Math.PI, Math.PI), n2 = Q(n2 - o2, -Cd, Cd);
              } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
              return new rl(Z(r2), Z(n2));
            }
          }
          class Dd extends bd {
            constructor(t2) {
              super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Y(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
            }
            project(t2, e2) {
              const { scale: r2, cosPhi: n2 } = this;
              return { x: Y(t2) * n2 * r2 + 0.5, y: -Math.sin(Y(e2)) / n2 * r2 + 0.5, z: 0 };
            }
            unproject(t2, e2) {
              const { scale: r2, cosPhi: n2 } = this, i2 = -(e2 - 0.5) / r2, s2 = Q(Z((t2 - 0.5) / r2) / n2, -180, 180), a2 = Math.asin(Q(i2 * n2, -1, 1)), o2 = Q(Z(a2), -fl, fl);
              return new rl(s2, o2);
            }
          }
          class Ld extends Ed {
            constructor(t2) {
              super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
            }
            projectTilePoint(t2, e2, r2) {
              const n2 = zu(t2, e2, r2), i2 = Eu(_u(r2));
              return O.vec3.transformMat4(n2, n2, i2), { x: n2[0], y: n2[1], z: n2[2] };
            }
            locationPoint(t2, e2) {
              const r2 = Qo(e2.lat, e2.lng), n2 = O.vec3.normalize([], r2), i2 = t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude, s2 = ul(1, 0) * Hr * i2;
              O.vec3.scaleAndAdd(r2, r2, n2, s2);
              const a2 = O.mat4.identity(new Float64Array(16));
              return O.mat4.multiply(a2, t2.pixelMatrix, t2.globeMatrix), O.vec3.transformMat4(r2, r2, a2), new q(r2[0], r2[1]);
            }
            pixelsPerMeter(t2, e2) {
              return ul(1, 0) * e2;
            }
            pixelSpaceConversion(t2, e2, r2) {
              const n2 = ul(1, t2) * e2, i2 = ke(ul(1, 45) * e2, n2, r2);
              return this.pixelsPerMeter(t2, e2) / i2;
            }
            createTileMatrix(t2, e2, r2) {
              const n2 = Bu(_u(r2.canonical));
              return O.mat4.multiply(new Float64Array(16), t2.globeMatrix, n2);
            }
            createInversionMatrix(t2, e2) {
              const { center: r2 } = t2, n2 = Eu(_u(e2));
              return O.mat4.rotateY(n2, n2, Y(r2.lng)), O.mat4.rotateX(n2, n2, Y(r2.lat)), O.mat4.scale(n2, n2, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n2);
            }
            pointCoordinate(t2, e2, r2, n2) {
              return bu(t2, e2, r2, true) || new xl(0, 0);
            }
            pointCoordinate3D(t2, e2, r2) {
              const n2 = this.pointCoordinate(t2, e2, r2, 0);
              return [n2.x, n2.y, n2.z];
            }
            isPointAboveHorizon(t2, e2) {
              return !bu(t2, e2.x, e2.y, false);
            }
            farthestPixelDistance(t2) {
              const e2 = function(t3, e3) {
                const r3 = t3.cameraToCenterDistance, n2 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), a2 = O.vec3.add([], O.vec3.scale([], s2, -r3), [0, 0, n2]), o2 = t3.worldSize / (2 * Math.PI), l2 = [0, 0, -o2], u2 = t3.width / t3.height, c2 = Math.tan(t3.fovAboveCenter), h2 = O.vec3.scale([], i2.up(), c2), p2 = O.vec3.scale([], i2.right(), c2 * u2), f2 = O.vec3.normalize([], O.vec3.add([], O.vec3.add([], s2, h2), p2)), d2 = [];
                let m2;
                if (new uu(a2, f2).closestPointOnSphere(l2, o2, d2)) {
                  const e4 = O.vec3.add([], d2, l2), r4 = O.vec3.sub([], e4, a2);
                  m2 = Math.cos(t3.fovAboveCenter) * O.vec3.length(r4);
                } else {
                  const t4 = O.vec3.sub([], a2, l2), e4 = O.vec3.sub([], l2, a2);
                  O.vec3.normalize(e4, e4);
                  const r4 = O.vec3.length(t4) - o2;
                  m2 = Math.sqrt(r4 * (r4 + 2 * o2));
                  const n3 = Math.acos(m2 / (o2 + r4)) - Math.acos(O.vec3.dot(s2, e4));
                  m2 *= Math.cos(n3);
                }
                return 1.01 * m2;
              }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r2 = Du(t2.zoom);
              if (r2 > 0) {
                const n2 = md(t2, ul(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s2 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
                return ke(e2, n2 + i2 * (1 - Math.cos(s2)), Math.pow(r2, 10));
              }
              return e2;
            }
            upVector(t2, e2, r2) {
              return zu(e2, r2, t2, 1);
            }
            upVectorScale(t2) {
              return { metersToTile: gu(ku(_u(t2))) };
            }
          }
          function Fd(t2) {
            const e2 = t2.parallels, r2 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
            switch (t2.name) {
              case "mercator":
                return new Ed(t2);
              case "equirectangular":
                return new Pd(t2);
              case "naturalEarth":
                return new Vd(t2);
              case "equalEarth":
                return new Id(t2);
              case "winkelTripel":
                return new Rd(t2);
              case "albers":
                return r2 ? new Dd(t2) : new vd(t2);
              case "lambertConformalConic":
                return r2 ? new Dd(t2) : new Td(t2);
              case "globe":
                return new Ld(t2);
            }
            throw new Error(`Invalid projection name: ${t2.name}`);
          }
          const Od = ch.VectorTileFeature.types, Ud = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function jd(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = o2 ? Math.min(ud, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(ud, Math.round(o2[1])) : 0;
            t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
          }
          function Nd(t2, e2, r2) {
            t2.emplaceBack(e2, r2);
          }
          function qd(t2, e2, r2, n2, i2, s2, a2) {
            t2.emplaceBack(e2, r2, n2, i2, s2, a2);
          }
          function $d(t2, e2, r2, n2, i2) {
            t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2);
          }
          function Gd(t2) {
            for (const e2 of t2.sections)
              if (vs(e2.text))
                return true;
            return false;
          }
          class Xd {
            constructor(t2) {
              this.layoutVertexArray = new za(), this.indexArray = new Da(), this.programConfigurations = t2, this.segments = new co(), this.dynamicLayoutVertexArray = new Ma(), this.opacityVertexArray = new Ta(), this.placedSymbolArray = new Ja(), this.iconTransitioningVertexArray = new Ea(), this.globeExtVertexArray = new ka(), this.zOffsetVertexArray = new Oa();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
            }
            upload(t2, e2, r2, n2, i2) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Rp.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Lp.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Ud, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t2.createVertexBuffer(this.iconTransitioningVertexArray, Op.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Dp.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i2) && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, Fp.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
            }
          }
          os(Xd, "SymbolBuffers");
          class Yd {
            constructor(t2, e2, r2) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new co(), this.collisionVertexArray = new Ra(), this.collisionVertexArrayExt = new Ma();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Up.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, jp.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
          }
          os(Yd, "CollisionBuffers");
          class Zd {
            constructor(t2) {
              this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.lut = t2.lut, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = O.mat4.identity([]), this.placementViewportMatrix = O.mat4.identity([]);
              const e2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = Xp(this.zoom, e2["text-size"]), this.iconSizeData = Xp(this.zoom, e2["icon-size"]);
              const r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
              this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => ff[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = r2.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            createArrays() {
              this.text = new Xd(new Fo(this.layers, { zoom: this.zoom, lut: this.lut }, (t2) => t2.startsWith("text") || t2.startsWith("symbol"))), this.icon = new Xd(new Fo(this.layers, { zoom: this.zoom, lut: this.lut }, (t2) => t2.startsWith("icon") || t2.startsWith("symbol"))), this.glyphOffsetArray = new eo(), this.lineVertexArray = new ro(), this.symbolInstances = new to();
            }
            calculateGlyphDependencies(t2, e2, r2, n2, i2) {
              for (let r3 = 0; r3 < t2.length; r3++) {
                const s2 = t2.codePointAt(r3);
                if (void 0 === s2)
                  break;
                if (e2[s2] = true, n2 && i2 && s2 <= 65535) {
                  const n3 = Kp[t2.charAt(r3)];
                  n3 && (e2[n3.charCodeAt(0)] = true);
                }
              }
            }
            updateFootprints(t2, e2) {
            }
            updateReplacement(t2, e2) {
              if (e2.updateTime === this.replacementUpdateTime)
                return false;
              this.replacementUpdateTime = e2.updateTime;
              const r2 = e2.getReplacementRegionsForTile(t2.toUnwrapped(), true);
              return !wh(this.activeReplacements, r2) && (this.activeReplacements = r2, true);
            }
            populate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = i2.layout, a2 = "globe" === this.projection.name, o2 = s2.get("text-font"), l2 = s2.get("text-field"), u2 = s2.get("icon-image"), c2 = ("constant" !== l2.value.kind || l2.value.value instanceof Qe && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== o2.value.kind || o2.value.value.length > 0), h2 = "constant" !== u2.value.kind || !!u2.value.value || Object.keys(u2.parameters).length > 0, p2 = s2.get("symbol-sort-key");
              if (this.features = [], !c2 && !h2)
                return;
              const f2 = e2.iconDependencies, d2 = e2.glyphDependencies, m2 = e2.availableImages, y2 = new Vs(this.zoom);
              for (const { feature: e3, id: l3, index: u3, sourceLayerIndex: g2 } of t2) {
                const t3 = i2._featureFilter.needGeometry, x2 = Pl(e3, t3);
                if (!i2._featureFilter.filter(y2, x2, r2))
                  continue;
                if (t3 || (x2.geometry = Il(e3, r2, n2)), a2 && 1 !== e3.type && r2.z <= 5) {
                  const t4 = x2.geometry, e4 = 0.98078528056, n3 = (t5, n4) => {
                    const i3 = zu(t5.x, t5.y, r2, 1), s3 = zu(n4.x, n4.y, r2, 1);
                    return O.vec3.dot(i3, s3) < e4;
                  };
                  for (let e5 = 0; e5 < t4.length; e5++)
                    t4[e5] = _l(t4[e5], n3);
                }
                let b2, v2;
                if (c2) {
                  const t4 = i2.getValueAndResolveTokens("text-field", x2, r2, m2), e4 = Qe.factory(t4);
                  Gd(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Ts() || this.hasRTLText && Bs.isParsed()) && (b2 = Hp(e4, i2, x2));
                }
                if (h2) {
                  const t4 = i2.getValueAndResolveTokens("icon-image", x2, r2, m2);
                  v2 = t4 instanceof tr ? t4 : tr.fromString(t4);
                }
                if (!b2 && !v2)
                  continue;
                const w2 = this.sortFeaturesByKey ? p2.evaluate(x2, {}, r2) : void 0;
                if (this.features.push({ id: l3, text: b2, icon: v2, index: u3, sourceLayerIndex: g2, geometry: x2.geometry, properties: e3.properties, type: Od[e3.type], sortKey: w2 }), v2 && (f2[v2.namePrimary] = true, v2.nameSecondary && (f2[v2.nameSecondary] = true)), b2) {
                  const t4 = o2.evaluate(x2, {}, r2).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ff.vertical) >= 0;
                  for (const r3 of b2.sections)
                    if (r3.image)
                      f2[r3.image.namePrimary] = true;
                    else {
                      const n3 = fs(b2.toString()), i3 = r3.fontStack || t4, s3 = d2[i3] = d2[i3] || {};
                      this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                    }
                }
              }
              "line" === s2.get("symbol-placement") && (this.features = function(t3) {
                const e3 = {}, r3 = {}, n3 = [];
                let i3 = 0;
                function s3(e4) {
                  n3.push(t3[e4]), i3++;
                }
                function a3(t4, e4, i4) {
                  const s4 = r3[t4];
                  return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
                }
                function o3(t4, r4, i4) {
                  const s4 = e3[r4];
                  return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
                }
                function l3(t4, e4, r4) {
                  const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return `${t4}:${n4.x}:${n4.y}`;
                }
                for (let u3 = 0; u3 < t3.length; u3++) {
                  const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    s3(u3);
                    continue;
                  }
                  const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                  if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                    const t4 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t4].geometry);
                    delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
                  } else
                    f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
                }
                return n3.filter((t4) => t4.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
            }
            update(t2, e2, r2, n2, i2) {
              const s2 = 0 !== Object.keys(t2).length;
              if (s2 && !this.stateDependentLayers.length)
                return;
              const a2 = s2 ? this.stateDependentLayers : this.layers;
              this.text.programConfigurations.updatePaintArrays(t2, e2, a2, r2, n2, i2), this.icon.programConfigurations.updatePaintArrays(t2, e2, a2, r2, n2, i2);
            }
            updateZOffset() {
              const t2 = (t3, e3, n3) => {
                r2 += e3, r2 > t3.length && t3.resize(r2);
                for (let i2 = -e3; i2 < 0; i2++)
                  t3.emplace(i2 + r2, n3);
              }, e2 = (t3, e3, r3) => {
                n2 += e3, n2 > t3.length && t3.resize(n2);
                for (let i2 = -e3; i2 < 0; i2++)
                  t3.emplace(i2 + n2, r3);
              };
              if (!this.zOffsetBuffersNeedUpload)
                return;
              this.zOffsetBuffersNeedUpload = false;
              let r2 = 0, n2 = 0;
              for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
                const n3 = this.symbolInstances.get(r3), { numHorizontalGlyphVertices: i2, numVerticalGlyphVertices: s2, numIconVertices: a2 } = n3, o2 = n3.zOffset, l2 = a2 > 0;
                if ((i2 > 0 || s2 > 0) && (t2(this.text.zOffsetVertexArray, i2, o2), t2(this.text.zOffsetVertexArray, s2, o2)), l2) {
                  const { placedIconSymbolIndex: t3, verticalPlacedIconSymbolIndex: r4 } = n3;
                  t3 >= 0 && e2(this.icon.zOffsetVertexArray, a2, o2), r4 >= 0 && e2(this.icon.zOffsetVertexArray, n3.numVerticalIconVertices, o2);
                }
              }
              this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
              return this.projectionInstance || (this.projectionInstance = Fd(this.projection)), this.projectionInstance;
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e2) {
              const r2 = this.lineVertexArray.length;
              if (void 0 !== t2.segment)
                for (const { x: t3, y: r3 } of e2)
                  this.lineVertexArray.emplaceBack(t3, r3);
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, m2) {
              const y2 = t2.indexArray, g2 = t2.layoutVertexArray, x2 = t2.globeExtVertexArray, b2 = t2.segments.prepareSegment(4 * e2.length, g2, y2, this.canOverlap ? s2.sortKey : void 0), v2 = this.glyphOffsetArray.length, w2 = b2.vertexLength, _2 = this.allowVerticalPlacement && a2 === ff.vertical ? Math.PI / 2 : 0, M2 = s2.text && s2.text.sections;
              for (let n3 = 0; n3 < e2.length; n3++) {
                const { tl: i3, tr: a3, bl: u3, br: c3, texPrimary: h3, texSecondary: v3, pixelOffsetTL: w3, pixelOffsetBR: A3, minFontScaleX: S2, minFontScaleY: I2, glyphOffset: P2, isSDF: z2, sectionIndex: k2 } = e2[n3], T2 = b2.vertexLength, E2 = P2[1];
                if (jd(g2, l2.x, l2.y, i3.x, E2 + i3.y, h3.x, h3.y, r2, z2, w3.x, w3.y, S2, I2), jd(g2, l2.x, l2.y, a3.x, E2 + a3.y, h3.x + h3.w, h3.y, r2, z2, A3.x, w3.y, S2, I2), jd(g2, l2.x, l2.y, u3.x, E2 + u3.y, h3.x, h3.y + h3.h, r2, z2, w3.x, A3.y, S2, I2), jd(g2, l2.x, l2.y, c3.x, E2 + c3.y, h3.x + h3.w, h3.y + h3.h, r2, z2, A3.x, A3.y, S2, I2), o2) {
                  const { x: e3, y: r3, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
                  qd(x2, e3, r3, n4, i4, s3, a4), qd(x2, e3, r3, n4, i4, s3, a4), qd(x2, e3, r3, n4, i4, s3, a4), qd(x2, e3, r3, n4, i4, s3, a4), $d(t2.dynamicLayoutVertexArray, e3, r3, n4, _2);
                } else
                  $d(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, _2);
                if (m2) {
                  const e3 = v3 || h3;
                  Nd(t2.iconTransitioningVertexArray, e3.x, e3.y), Nd(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y), Nd(t2.iconTransitioningVertexArray, e3.x, e3.y + e3.h), Nd(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y + e3.h);
                }
                y2.emplaceBack(T2, T2 + 1, T2 + 2), y2.emplaceBack(T2 + 1, T2 + 2, T2 + 3), b2.vertexLength += 4, b2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P2[0]), n3 !== e2.length - 1 && k2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(g2.length, s2, s2.index, {}, p2, f2, d2, M2 && M2[k2]);
              }
              const A2 = o2 ? o2.anchor : l2;
              t2.placedSymbolArray.emplaceBack(A2.x, A2.y, A2.z, l2.x, l2.y, v2, this.glyphOffsetArray.length - v2, w2, u2, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], a2, 0, false, 0, h2, 0);
            }
            _commitLayoutVertex(t2, e2, r2, n2, i2, s2, a2) {
              t2.emplaceBack(e2, r2, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
            }
            _addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l2 = o2.vertexLength, u2 = a2.tileAnchorX, c2 = a2.tileAnchorY;
              for (let t3 = 0; t3 < 4; t3++)
                r2.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
              this._commitDebugCollisionVertexUpdate(r2.collisionVertexArrayExt, e2, t2.padding, a2.zOffset), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new q(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new q(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new q(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new q(t2.x1, t2.y2)), o2.vertexLength += 4;
              const h2 = r2.indexArray;
              h2.emplaceBack(l2, l2 + 1), h2.emplaceBack(l2 + 1, l2 + 2), h2.emplaceBack(l2 + 2, l2 + 3), h2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
                this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
              }
            }
            _addIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
                this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
              }
            }
            generateCollisionDebugBuffers(t2, e2) {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Yd(Va, Np.members, Ea), this.iconCollisionBox = new Yd(Va, Np.members, Ea);
              const r2 = Zp(this.iconSizeData, t2), n2 = Zp(this.textSizeData, t2);
              for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
                const s2 = this.symbolInstances.get(i2);
                this._addTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
              }
            }
            getSymbolInstanceTextSize(t2, e2, r2, n2) {
              const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = Yp(this.textSizeData, t2, i2) / $p;
              return this.tilePixelRatio * s2;
            }
            getSymbolInstanceIconSize(t2, e2, r2) {
              const n2 = this.icon.placedSymbolArray.get(r2), i2 = Yp(this.iconSizeData, t2, n2);
              return this.tilePixelRatio * i2;
            }
            _commitDebugCollisionVertexUpdate(t2, e2, r2, n2) {
              t2.emplaceBack(e2, -r2, -r2, n2), t2.emplaceBack(e2, r2, -r2, n2), t2.emplaceBack(e2, r2, r2, n2), t2.emplaceBack(e2, -r2, r2, n2);
            }
            _updateTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
                this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
              }
            }
            _updateIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let a2 = n2; a2 < i2; a2++) {
                const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
                this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
              }
            }
            updateCollisionDebugBuffers(t2, e2) {
              if (!this.hasDebugData())
                return;
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
              const r2 = Zp(this.iconSizeData, t2), n2 = Zp(this.textSizeData, t2);
              for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
                const s2 = this.symbolInstances.get(i2);
                this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
              }
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = {};
              if (e2 < r2) {
                const { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(e2);
                u2.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.textFeatureIndex = f2;
              }
              if (n2 < i2) {
                const { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(n2);
                u2.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalTextFeatureIndex = f2;
              }
              if (s2 < a2) {
                const { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(s2);
                u2.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.iconFeatureIndex = f2;
              }
              if (o2 < l2) {
                const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(o2);
                u2.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u2.verticalIconFeatureIndex = f2;
              }
              return u2;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r2 = this.symbolInstances.get(e2);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            hasIconTextFit() {
              return this.hasAnyIconTextFit;
            }
            addIndicesForPlacedSymbol(t2, e2) {
              const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
                t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
                return this.symbolInstanceIndexes;
              const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                s2.push(t3);
                const a2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e2 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
              }
              return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
            }
            getSortedIndexesByZOffset() {
              if (!this.zOffsetSortDirty)
                return this.symbolInstanceIndexesSortedZOffset;
              if (!this.symbolInstanceIndexesSortedZOffset) {
                this.symbolInstanceIndexesSortedZOffset = [];
                for (let t2 = 0; t2 < this.symbolInstances.length; ++t2)
                  this.symbolInstanceIndexesSortedZOffset.push(t2);
              }
              return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t2, e2) => this.symbolInstances.get(e2).zOffset - this.symbolInstances.get(t2).zOffset);
            }
            addToSortKeyRanges(t2, e2) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e2 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e2.featureIndex);
                  const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e2;
                  r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          let Wd, Hd, Kd;
          os(Zd, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Zd.addDynamicAttributes = $d;
          class Jd {
            constructor(t2) {
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Re, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e2 = this.defaultValue.property.overrides;
                if (e2 && e2.hasOverride(t2.formattedSection))
                  return e2.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          os(Jd, "FormatSectionOverride", { omit: ["defaultValue"] });
          const Qd = () => Kd || (Kd = { layout: Wd || (Wd = new Gs({ "symbol-placement": new Ns(Xs.layout_symbol["symbol-placement"]), "symbol-spacing": new Ns(Xs.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ns(Xs.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new qs(Xs.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ns(Xs.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Ns(Xs.layout_symbol["symbol-z-elevate"]), "icon-allow-overlap": new Ns(Xs.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ns(Xs.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ns(Xs.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ns(Xs.layout_symbol["icon-rotation-alignment"]), "icon-size": new qs(Xs.layout_symbol["icon-size"]), "icon-text-fit": new qs(Xs.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new qs(Xs.layout_symbol["icon-text-fit-padding"]), "icon-image": new qs(Xs.layout_symbol["icon-image"]), "icon-rotate": new qs(Xs.layout_symbol["icon-rotate"]), "icon-padding": new Ns(Xs.layout_symbol["icon-padding"]), "icon-keep-upright": new Ns(Xs.layout_symbol["icon-keep-upright"]), "icon-offset": new qs(Xs.layout_symbol["icon-offset"]), "icon-anchor": new qs(Xs.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ns(Xs.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ns(Xs.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ns(Xs.layout_symbol["text-rotation-alignment"]), "text-field": new qs(Xs.layout_symbol["text-field"]), "text-font": new qs(Xs.layout_symbol["text-font"]), "text-size": new qs(Xs.layout_symbol["text-size"]), "text-max-width": new qs(Xs.layout_symbol["text-max-width"]), "text-line-height": new qs(Xs.layout_symbol["text-line-height"]), "text-letter-spacing": new qs(Xs.layout_symbol["text-letter-spacing"]), "text-justify": new qs(Xs.layout_symbol["text-justify"]), "text-radial-offset": new qs(Xs.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ns(Xs.layout_symbol["text-variable-anchor"]), "text-anchor": new qs(Xs.layout_symbol["text-anchor"]), "text-max-angle": new Ns(Xs.layout_symbol["text-max-angle"]), "text-writing-mode": new Ns(Xs.layout_symbol["text-writing-mode"]), "text-rotate": new qs(Xs.layout_symbol["text-rotate"]), "text-padding": new Ns(Xs.layout_symbol["text-padding"]), "text-keep-upright": new Ns(Xs.layout_symbol["text-keep-upright"]), "text-transform": new qs(Xs.layout_symbol["text-transform"]), "text-offset": new qs(Xs.layout_symbol["text-offset"]), "text-allow-overlap": new Ns(Xs.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ns(Xs.layout_symbol["text-ignore-placement"]), "text-optional": new Ns(Xs.layout_symbol["text-optional"]), visibility: new Ns(Xs.layout_symbol.visibility) })), paint: Hd || (Hd = new Gs({ "icon-opacity": new qs(Xs.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new qs(Xs.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new qs(Xs.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new qs(Xs.paint_symbol["text-emissive-strength"]), "icon-color": new qs(Xs.paint_symbol["icon-color"]), "icon-halo-color": new qs(Xs.paint_symbol["icon-halo-color"]), "icon-halo-width": new qs(Xs.paint_symbol["icon-halo-width"]), "icon-halo-blur": new qs(Xs.paint_symbol["icon-halo-blur"]), "icon-translate": new Ns(Xs.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ns(Xs.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new qs(Xs.paint_symbol["icon-image-cross-fade"]), "text-opacity": new qs(Xs.paint_symbol["text-opacity"]), "text-occlusion-opacity": new qs(Xs.paint_symbol["text-occlusion-opacity"]), "text-color": new qs(Xs.paint_symbol["text-color"], { runtimeType: Oe, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new qs(Xs.paint_symbol["text-halo-color"]), "text-halo-width": new qs(Xs.paint_symbol["text-halo-width"]), "text-halo-blur": new qs(Xs.paint_symbol["text-halo-blur"]), "text-translate": new Ns(Xs.paint_symbol["text-translate"]), "text-translate-anchor": new Ns(Xs.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Ns(Xs.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Ns(Xs.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Ns(Xs.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Ns(Xs.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new qs(Xs.paint_symbol["symbol-z-offset"]), "symbol-elevation-reference": new Ns(Xs.paint_symbol["symbol-elevation-reference"]) })) }, Kd);
          class tm extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, Qd(), e2, r2, n2), this._colorAdjustmentMatrix = O.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t2.paint && ("icon-occlusion-opacity" in t2.paint || "text-occlusion-opacity" in t2.paint);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
              const r2 = this.layout.get("text-writing-mode");
              if (r2) {
                const t3 = [];
                for (const e3 of r2)
                  t3.indexOf(e3) < 0 && t3.push(e3);
                this.layout._values["text-writing-mode"] = t3;
              } else
                this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
              this._setPaintOverrides();
            }
            getColorAdjustmentMatrix(t2, e2, r2, n2) {
              return this._saturation === t2 && this._contrast === e2 && this._brightnessMin === r2 && this._brightnessMax === n2 || (this._colorAdjustmentMatrix = function(t3, e3, r3, n3) {
                t3 = St(t3), e3 = At(e3);
                const i2 = O.mat4.create(), s2 = t3 / 3, a2 = 1 - 2 * s2, o2 = [a2, s2, s2, 0, s2, a2, s2, 0, s2, s2, a2, 0, 0, 0, 0, 1], l2 = 0.5 - 0.5 * e3, u2 = n3 - r3;
                return O.mat4.multiply(i2, [u2, 0, 0, 0, 0, u2, 0, 0, 0, 0, u2, 0, r3, r3, r3, 1], [e3, 0, 0, 0, 0, e3, 0, 0, 0, 0, e3, 0, l2, l2, l2, 1]), O.mat4.multiply(i2, i2, o2), i2;
              }(t2, e2, r2, n2), this._saturation = t2, this._contrast = e2, this._brightnessMin = r2, this._brightnessMax = n2), this._colorAdjustmentMatrix;
            }
            getValueAndResolveTokens(t2, e2, r2, n2) {
              const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
              return s2.isDataDriven() || Wi(s2.value) || !i2 ? i2 : function(t3, e3) {
                return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
              }(e2.properties, i2);
            }
            createBucket(t2) {
              return new Zd(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            _setPaintOverrides() {
              for (const t2 of Qd().paint.overridableProperties) {
                if (!tm.hasPaintOverride(this.layout, t2))
                  continue;
                const e2 = this.paint.get(t2), r2 = new Jd(e2), n2 = new Zi(r2, e2.property.specification, this.scope, this.options);
                let i2 = null;
                i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Ki("source", n2) : new Ji("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new Us(e2.property, i2, e2.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && tm.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e2) {
              const r2 = t2.get("text-field"), n2 = Qd().paint.properties[e2];
              let i2 = false;
              const s2 = (t3) => {
                for (const e3 of t3)
                  if (n2.overrides && n2.overrides.hasOverride(e3))
                    return void (i2 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof Qe)
                s2(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                const t3 = (e4) => {
                  i2 || (e4 instanceof sr && nr(e4.value) === qe ? s2(e4.value.sections) : e4 instanceof ur ? s2(e4.sections) : e4.eachChild(t3));
                }, e3 = r2.value;
                e3._styleExpression && t3(e3._styleExpression.expression);
              }
              return i2;
            }
            getProgramIds() {
              return ["symbol"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { config: new Lo(this, { zoom: e2, lut: r2 }), overrideFog: false };
            }
          }
          let em, rm, nm, im;
          var sm = ya([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          function am(t2) {
            switch (t2) {
              case WebGL2RenderingContext.RGBA8:
                return WebGL2RenderingContext.RGBA;
              case WebGL2RenderingContext.DEPTH_COMPONENT16:
                return WebGL2RenderingContext.DEPTH_COMPONENT;
              case WebGL2RenderingContext.DEPTH24_STENCIL8:
                return WebGL2RenderingContext.DEPTH_STENCIL;
              case WebGL2RenderingContext.R8:
              case WebGL2RenderingContext.R32F:
                return WebGL2RenderingContext.RED;
            }
          }
          function om(t2) {
            switch (t2) {
              case WebGL2RenderingContext.RGBA8:
                return WebGL2RenderingContext.UNSIGNED_BYTE;
              case WebGL2RenderingContext.DEPTH_COMPONENT16:
                return WebGL2RenderingContext.UNSIGNED_SHORT;
              case WebGL2RenderingContext.DEPTH24_STENCIL8:
                return WebGL2RenderingContext.UNSIGNED_INT_24_8;
              case WebGL2RenderingContext.R8:
                return WebGL2RenderingContext.UNSIGNED_BYTE;
              case WebGL2RenderingContext.R32F:
                return WebGL2RenderingContext.FLOAT;
            }
          }
          class lm {
            constructor(t2, e2, r2, n2) {
              this.context = t2, this.format = r2, this.useMipmap = n2 && n2.useMipmap, this.texture = t2.gl.createTexture(), this.update(e2, { premultiply: n2 && n2.premultiply });
            }
            update(t2, e2) {
              const r2 = t2 && t2 instanceof HTMLVideoElement && 0 === t2.width ? t2.videoWidth : t2.width, n2 = t2 && t2 instanceof HTMLVideoElement && 0 === t2.height ? t2.videoHeight : t2.height, { context: i2 } = this, { gl: s2 } = i2, { x: a2, y: o2 } = e2 && e2.position ? e2.position : { x: 0, y: 0 }, l2 = Math.max(a2 + r2, this.size ? this.size[0] : 0), u2 = Math.max(o2 + n2, this.size ? this.size[1] : 0);
              !this.size || this.size[0] === l2 && this.size[1] === u2 || (s2.bindTexture(s2.TEXTURE_2D, null), s2.deleteTexture(this.texture), this.texture = s2.createTexture(), this.size = null), s2.bindTexture(s2.TEXTURE_2D, this.texture), i2.pixelStoreUnpackFlipY.set(false), i2.pixelStoreUnpack.set(1), i2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA8 && (!e2 || false !== e2.premultiply));
              const c2 = t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || ImageBitmap && t2 instanceof ImageBitmap;
              if (!this.size && l2 > 0 && u2 > 0) {
                const t3 = this.useMipmap ? Math.floor(Math.log2(Math.max(l2, u2))) + 1 : 1;
                s2.texStorage2D(s2.TEXTURE_2D, t3, this.format, l2, u2), this.size = [l2, u2];
              }
              if (this.size)
                if (c2)
                  s2.texSubImage2D(s2.TEXTURE_2D, 0, a2, o2, am(this.format), om(this.format), t2);
                else {
                  const e3 = t2.data;
                  e3 && s2.texSubImage2D(s2.TEXTURE_2D, 0, a2, o2, r2, n2, am(this.format), om(this.format), e3);
                }
              this.useMipmap && s2.generateMipmap(s2.TEXTURE_2D);
            }
            bind(t2, e2, r2 = false) {
              const { context: n2 } = this, { gl: i2 } = n2;
              i2.bindTexture(i2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, this.useMipmap && !r2 ? t2 === i2.NEAREST ? i2.NEAREST_MIPMAP_NEAREST : i2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), e2 !== this.wrapS && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
            }
            bindExtraParam(t2, e2, r2, n2) {
              const { context: i2 } = this, { gl: s2 } = i2;
              s2.bindTexture(s2.TEXTURE_2D, this.texture), e2 !== this.magFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, e2), this.magFilter = e2), t2 !== this.minFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === s2.NEAREST ? s2.NEAREST_MIPMAP_NEAREST : s2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), r2 !== this.wrapS && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, r2), this.wrapS = r2), n2 !== this.wrapT && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, n2), this.wrapT = n2);
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }
          class um {
            constructor(t2, e2) {
              this.context = t2, this.texture = e2;
            }
            bind(t2, e2) {
              const { context: r2 } = this, { gl: n2 } = r2;
              n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e2 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
            }
          }
          function cm(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = [t2, e2, 1, r2, n2, 1, i2, s2, 1], u2 = [a2, o2, 1], c2 = O.mat3.adjoint([], l2), [h2, p2, f2] = O.vec3.transformMat3(u2, u2, c2);
            return O.mat3.multiply(l2, l2, [h2, 0, 0, 0, p2, 0, 0, 0, f2]);
          }
          function hm(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
              const l3 = cm(0, 0, 1, 0, 1, 1, 0, 1), u2 = cm(t3, e3, r3, n3, i3, s3, a3, o3), c2 = O.mat3.adjoint([], l3);
              return O.mat3.multiply(u2, u2, c2);
            }(t2, e2, r2, n2, i2, s2, a2, o2);
            return [l2[2] / l2[8] / Hr, l2[5] / l2[8] / Hr];
          }
          function pm(t2) {
            return [t2[0], Math.min(Math.max(t2[1], -fl), fl)];
          }
          class fm extends Me {
            constructor(t2, e2, r2, n2) {
              super(), this.id = t2, this.dispatcher = r2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n2), this.options = e2, this._dirty = false;
            }
            load(t2, e2) {
              if (this._loaded = e2 || false, this.fire(new be("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
                return t2 && (this.coordinates = t2), this._loaded = true, void this._finishLoading();
              this._imageRequest = ce(this.map._requestManager.transformRequest(this.url, ee.Image), (e3, r2) => {
                this._imageRequest = null, this._loaded = true, e3 ? this.fire(new ve(e3)) : r2 && (this.image = r2 instanceof HTMLImageElement ? Dt.getImageData(r2) : r2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading());
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t2) {
              return t2.url ? (this._imageRequest && t2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t2.url, this.load(t2.coordinates, this._loaded), this) : this;
            }
            setTexture(t2) {
              if (!(t2.handle instanceof WebGLTexture))
                throw new Error("The provided handle is not a WebGLTexture instance");
              return this.texture = new um(this.map.painter.context, t2.handle), this.width = t2.dimensions[0], this.height = t2.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new be("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            onRemove(t2) {
              this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof um || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
            }
            setCoordinates(t2) {
              if (this.coordinates = t2, this._boundsArray = void 0, this._unsupportedCoords = false, !t2.length)
                return this;
              this.onNorthPole = false, this.onSouthPole = false;
              let e2 = t2[0][1], r2 = t2[0][1];
              for (const n3 of t2)
                n3[1] > r2 && (r2 = n3[1]), n3[1] < e2 && (e2 = n3[1]);
              const n2 = (r2 + e2) / 2;
              if (n2 > fl ? this.onNorthPole = true : n2 < -fl && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
                const e3 = t2.map(xl.fromLngLat);
                this.tileID = function(t3) {
                  let e4 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i2 = -1 / 0;
                  for (const s3 of t3)
                    e4 = Math.min(e4, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i2 = Math.max(i2, s3.y);
                  const s2 = Math.max(n3 - e4, i2 - r3), a2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), o2 = Math.pow(2, a2);
                  let l2 = Math.floor((e4 + n3) / 2 * o2);
                  return l2 > 1 && (l2 -= 1), new tu(a2, l2, Math.floor((r3 + i2) / 2 * o2));
                }(e3), this.minzoom = this.maxzoom = this.tileID.z;
              }
              return this.fire(new be("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            _clear() {
              this._boundsArray = void 0, this._unsupportedCoords = false;
            }
            _prepareData(t2) {
              for (const t3 in this.tiles) {
                const e3 = this.tiles[t3];
                "loaded" !== e3.state && (e3.state = "loaded", e3.texture = this.texture);
              }
              if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
                return;
              const e2 = yd(new tu(0, 0, 0), this.map.transform.projection), r2 = [e2.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e2.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e2.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e2.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
              if (!function(t3) {
                const e3 = t3[1].x - t3[0].x, r3 = t3[1].y - t3[0].y, n3 = t3[2].x - t3[1].x, i3 = t3[2].y - t3[1].y, s3 = t3[3].x - t3[2].x, a3 = t3[3].y - t3[2].y, o3 = t3[0].x - t3[3].x, l3 = t3[0].y - t3[3].y, u3 = e3 * i3 - n3 * r3, c3 = n3 * a3 - s3 * i3, h3 = s3 * l3 - o3 * a3, p3 = o3 * r3 - e3 * l3;
                return u3 > 0 && c3 > 0 && h3 > 0 && p3 > 0 || u3 < 0 && c3 < 0 && h3 < 0 && p3 < 0;
              }(r2))
                return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
              const n2 = yd(this.tileID, this.map.transform.projection), [i2, s2, a2, o2] = this.coordinates.map((t3) => {
                const e3 = n2.projection.project(t3[0], t3[1]);
                return gd(n2, e3)._round();
              });
              this.perspectiveTransform = hm(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, o2.x, o2.y);
              const l2 = this._boundsArray = new va();
              l2.emplaceBack(i2.x, i2.y, 0, 0), l2.emplaceBack(s2.x, s2.y, Hr, 0), l2.emplaceBack(o2.x, o2.y, 0, Hr), l2.emplaceBack(a2.x, a2.y, Hr, Hr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t2.createVertexBuffer(l2, sm.members), this.boundsSegments = co.simpleSegment(0, 0, 4, 2);
              const u2 = [], c2 = [pm((h2 = this.coordinates)[0]), pm(h2[1]), pm(h2[2]), pm(h2[3])];
              var h2;
              const [p2, f2, d2, m2] = function(t3) {
                let e3 = t3[0][0], r3 = e3, n3 = t3[0][1], i3 = n3;
                for (let s3 = 1; s3 < t3.length; s3++)
                  t3[s3][0] < e3 ? e3 = t3[s3][0] : t3[s3][0] > r3 && (r3 = t3[s3][0]), t3[s3][1] < n3 ? n3 = t3[s3][1] : t3[s3][1] > i3 && (i3 = t3[s3][1]);
                return [e3, n3, r3 - e3, i3 - n3];
              }(c2);
              {
                const n3 = new va(), [i3, s3, a3, o3] = function(t3) {
                  let e3 = t3[0].x, r3 = e3, n4 = t3[0].y, i4 = n4;
                  for (let s4 = 1; s4 < t3.length; s4++)
                    t3[s4].x < e3 ? e3 = t3[s4].x : t3[s4].x > r3 && (r3 = t3[s4].x), t3[s4].y < n4 ? n4 = t3[s4].y : t3[s4].y > i4 && (i4 = t3[s4].y);
                  return [e3, n4, r3 - e3, i4 - n4];
                }(r2), l3 = (t3) => [(t3.x - i3) / a3, (t3.y - s3) / o3], [c3, h3, y2, g2] = r2.map(l3), x2 = function(t3, e3, r3, n4, i4, s4, a4, o4) {
                  const l4 = cm(0, 0, 1, 0, 1, 1, 0, 1), u3 = cm(t3, e3, r3, n4, i4, s4, a4, o4), c4 = O.mat3.adjoint([], u3);
                  return O.mat3.multiply(l4, l4, c4);
                }(c3[0], c3[1], h3[0], h3[1], y2[0], y2[1], g2[0], g2[1]);
                this.elevatedGlobePerspectiveTransform = hm(c3[0], c3[1], h3[0], h3[1], y2[0], y2[1], g2[0], g2[1]);
                const b2 = (t3, e3) => {
                  u2.push(t3.lng);
                  const r3 = Math.round((t3.lng - p2) / d2 * Hr), i4 = Math.round((t3.lat - f2) / m2 * Hr), s4 = l3(e3), a4 = O.vec3.transformMat3([], [s4[0], s4[1], 1], x2), o4 = Math.round(a4[0] / a4[2] * Hr), c4 = Math.round(a4[1] / a4[2] * Hr);
                  n3.emplaceBack(r3, i4, o4, c4);
                }, v2 = r2[3].x - r2[0].x, w2 = r2[3].y - r2[0].y, _2 = r2[2].x - r2[1].x, M2 = r2[2].y - r2[1].y;
                for (let t3 = 0; t3 < 65; t3++) {
                  const n4 = t3 / 64, i4 = [r2[0].x + n4 * v2, r2[0].y + n4 * w2], s4 = [r2[1].x + n4 * _2, r2[1].y + n4 * M2], a4 = s4[0] - i4[0], o4 = s4[1] - i4[1];
                  for (let t4 = 0; t4 < 65; t4++) {
                    const r3 = t4 / 64, n5 = { x: i4[0] + a4 * r3, y: i4[1] + o4 * r3, z: 0 };
                    b2(e2.projection.unproject(n5.x, n5.y), n5);
                  }
                }
                this.elevatedGlobeVertexBuffer = t2.createVertexBuffer(n3, sm.members);
              }
              {
                this.maxLongitudeTriangleSize = 0;
                let e3 = [], r3 = new Da();
                const n3 = (t3, n4, i3) => {
                  r3.emplaceBack(t3, n4, i3);
                  const s3 = u2[t3], a3 = u2[n4], o3 = u2[i3], l3 = Math.min(Math.min(s3, a3), o3), c3 = Math.max(Math.max(s3, a3), o3) - l3;
                  c3 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = c3), e3.push(l3 + c3 / 2);
                };
                for (let t3 = 0; t3 < 64; t3++)
                  for (let e4 = 0; e4 < 64; e4++) {
                    const r4 = 65 * t3 + e4, i3 = r4 + 1, s3 = r4 + 65, a3 = s3 + 1;
                    n3(r4, s3, i3), n3(i3, s3, a3);
                  }
                [e3, r3] = function(t3, e4) {
                  const r4 = Array.from({ length: t3.length }, (t4, e5) => e5);
                  r4.sort((e5, r5) => t3[e5] - t3[r5]);
                  const n4 = [], i3 = new Da();
                  for (let s3 = 0; s3 < r4.length; s3++) {
                    const a3 = r4[s3];
                    n4.push(t3[a3]);
                    const o3 = 3 * a3, l3 = o3 + 1;
                    i3.emplaceBack(e4.uint16[o3], e4.uint16[l3], e4.uint16[l3 + 1]);
                  }
                  return [n4, i3];
                }(e3, r3), this.elevatedGlobeTrianglesCenterLongitudes = e3, this.elevatedGlobeIndexBuffer = t2.createIndexBuffer(r3);
              }
              this.elevatedGlobeSegments = co.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, d2 / Hr, 0, m2 / Hr, 0, 0, f2, p2, 0]);
            }
            prepare() {
              const t2 = 0 !== Object.keys(this.tiles).length;
              if (this.tileID && !t2)
                return;
              const e2 = this.map.painter.context, r2 = e2.gl;
              !this._dirty || this.texture instanceof um || (this.texture ? this.texture.update(this.image) : (this.texture = new lm(e2, this.image, r2.RGBA8), this.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE)), this._dirty = false), t2 && this._prepareData(e2);
            }
            loadTile(t2, e2) {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e2(null)) : (t2.state = "errored", e2(null));
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
            getSegmentsForLongitude(t2) {
              const e2 = this.elevatedGlobeSegments;
              if (!this.elevatedGlobeTrianglesCenterLongitudes || !e2)
                return null;
              const r2 = this.elevatedGlobeTrianglesCenterLongitudes;
              let n2 = (i2 = t2 + 180) + 360 * Math.round((r2[0] - i2) / 360);
              var i2;
              const s2 = new co(), a2 = (t3, r3) => {
                s2.segments.push({ vertexOffset: 0, primitiveOffset: t3, vertexLength: e2.segments[0].vertexLength, primitiveLength: r3, sortKey: void 0, vaos: {} });
              }, o2 = 0.51 * this.maxLongitudeTriangleSize;
              if (Math.abs(r2[0] - n2) <= o2) {
                const t3 = Mt(r2, 0, r2.length, n2 + o2);
                return t3 === r2.length || a2(t3, _t(r2, t3 + 1, r2.length, n2 + 360 - o2) - t3), s2;
              }
              n2 < r2[0] && (n2 += 360);
              const l2 = _t(r2, 0, r2.length, n2 - o2);
              if (l2 === r2.length)
                return a2(0, r2.length), s2;
              a2(0, l2 - 0);
              const u2 = Mt(r2, l2 + 1, r2.length, n2 + o2);
              return u2 !== r2.length && a2(u2, r2.length - u2), s2;
            }
          }
          const dm = (Math.pow(256, 2) - 1) / 16907520;
          class mm extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: nm || (nm = new Gs({ visibility: new Ns(Xs.layout_raster.visibility) })), paint: im || (im = new Gs({ "raster-opacity": new Ns(Xs.paint_raster["raster-opacity"]), "raster-color": new $s(Xs.paint_raster["raster-color"]), "raster-color-mix": new Ns(Xs.paint_raster["raster-color-mix"]), "raster-color-range": new Ns(Xs.paint_raster["raster-color-range"]), "raster-hue-rotate": new Ns(Xs.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ns(Xs.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ns(Xs.paint_raster["raster-brightness-max"]), "raster-saturation": new Ns(Xs.paint_raster["raster-saturation"]), "raster-contrast": new Ns(Xs.paint_raster["raster-contrast"]), "raster-resampling": new Ns(Xs.paint_raster["raster-resampling"]), "raster-fade-duration": new Ns(Xs.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Ns(Xs.paint_raster["raster-emissive-strength"]), "raster-array-band": new Ns(Xs.paint_raster["raster-array-band"]), "raster-elevation": new Ns(Xs.paint_raster["raster-elevation"]) })) }, e2, r2, n2), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
            }
            getProgramIds() {
              return ["raster"];
            }
            hasColorMap() {
              return !!this._transitionablePaint._values["raster-color"].value.value;
            }
            tileCoverLift() {
              return this.paint.get("raster-elevation");
            }
            isDraped(t2) {
              return !(t2 && t2._source instanceof fm && (t2._source.onNorthPole || t2._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "raster-color" !== t2 && "raster-color-range" !== t2 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
            }
            updateColorRamp(t2) {
              if (!this.hasColorMap())
                return;
              if (!this._curRampRange)
                return;
              const e2 = this._transitionablePaint._values["raster-color"].value.expression, [r2, n2] = t2 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
              isNaN(r2) && isNaN(n2) || r2 === this._curRampRange[0] && n2 === this._curRampRange[1] || (this.colorRamp = ac({ expression: e2, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r2, end: n2 }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [r2, n2]);
            }
          }
          let ym, gm, xm, bm, vm;
          class wm extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: ym || (ym = new Gs({ visibility: new Ns(Xs["layout_raster-particle"].visibility) })), paint: gm || (gm = new Gs({ "raster-particle-array-band": new Ns(Xs["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Ns(Xs["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new $s(Xs["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Ns(Xs["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Ns(Xs["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Ns(Xs["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Ns(Xs["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new Ns(Xs["paint_raster-particle"]["raster-particle-elevation"]) })) }, e2, r2, n2), this._updateColorRamp(), this.lastInvalidatedAt = Dt.now();
            }
            onRemove(t2) {
              this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
            }
            hasColorMap() {
              return !!this._transitionablePaint._values["raster-particle-color"].value.value;
            }
            getProgramIds() {
              return ["rasterParticle"];
            }
            hasOffscreenPass() {
              return "none" !== this.visibility;
            }
            isDraped(t2) {
              return false;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "raster-particle-color" !== t2 && "raster-particle-max-speed" !== t2 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t2 && this._invalidateAnimationState();
            }
            _updateColorRamp() {
              if (!this.hasColorMap())
                return;
              const t2 = this._transitionablePaint._values["raster-particle-color"].value.expression, e2 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
              this.colorRamp = ac({ expression: t2, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e2 }], resolution: 256 }), this.colorRampTexture = null;
            }
            _invalidateAnimationState() {
              this.lastInvalidatedAt = Dt.now();
            }
            tileCoverLift() {
              return this.paint.get("raster-particle-elevation");
            }
          }
          class _m extends pa {
            constructor(t2, e2) {
              super(t2, {}, e2, null), this.implementation = t2, t2.slot && (this.slot = t2.slot);
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            isDraped(t2) {
              return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
              return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
            }
            onAdd(t2) {
              this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
            }
            onRemove(t2) {
              this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
            }
          }
          function Mm(t2, e2, r2) {
            const n2 = [0, 0, 1], i2 = O.quat.identity([]);
            return O.quat.rotateY(i2, i2, r2 ? -Y(t2) + Math.PI : Y(t2)), O.quat.rotateX(i2, i2, -Y(e2)), O.vec3.transformQuat(n2, n2, i2), O.vec3.normalize(n2, n2);
          }
          function Am(t2, e2) {
            const r2 = Im(t2.projection, t2.zoom, t2.width, t2.height), n2 = function(t3, e3, r3, n3, i3) {
              const s2 = new rl(r3.lng - 180 * Pm, r3.lat), a2 = new rl(r3.lng + 180 * Pm, r3.lat), o2 = t3.project(s2.lng, s2.lat), l2 = t3.project(a2.lng, a2.lat), u2 = -Math.atan2(l2.y - o2.y, l2.x - o2.x), c2 = xl.fromLngLat(r3);
              c2.y = Q(c2.y, -1 + Pm, 1 - Pm);
              const h2 = c2.toLngLat(), p2 = t3.project(h2.lng, h2.lat), f2 = xl.fromLngLat(h2);
              f2.x += Pm;
              const d2 = f2.toLngLat(), m2 = t3.project(d2.lng, d2.lat), y2 = km(m2.x - p2.x, m2.y - p2.y, u2), g2 = xl.fromLngLat(h2);
              g2.y += Pm;
              const x2 = g2.toLngLat(), b2 = t3.project(x2.lng, x2.lat), v2 = km(b2.x - p2.x, b2.y - p2.y, u2), w2 = Math.abs(y2.x) / Math.abs(v2.y), _2 = O.mat4.identity([]);
              O.mat4.rotateZ(_2, _2, -u2 * (1 - (i3 ? 0 : n3)));
              const M2 = O.mat4.identity([]);
              return O.mat4.scale(M2, M2, [1, 1 - (1 - w2) * n3, 1]), M2[4] = -v2.x / v2.y * n3, O.mat4.rotateZ(M2, M2, u2), O.mat4.multiply(M2, _2, M2), M2;
            }(t2.projection, 0, t2.center, r2, e2), i2 = Sm(t2);
            return O.mat4.scale(n2, n2, [i2, i2, 1]), n2;
          }
          function Sm(t2) {
            const e2 = t2.projection, r2 = Im(t2.projection, t2.zoom, t2.width, t2.height), n2 = zm(e2, t2.center), i2 = zm(e2, rl.convert(e2.center));
            return Math.pow(2, n2 * r2 + (1 - r2) * i2);
          }
          function Im(t2, e2, r2, n2, i2 = 1 / 0) {
            const s2 = t2.range;
            if (!s2)
              return 0;
            const a2 = Math.min(i2, Math.max(r2, n2)), o2 = Math.log(a2 / 1024) / Math.LN2;
            return tt(s2[0] + o2, s2[1] + o2, e2);
          }
          const Pm = 1 / 4e4;
          function zm(t2, e2) {
            const r2 = Q(e2.lat, -fl, fl), n2 = new rl(e2.lng - 180 * Pm, r2), i2 = new rl(e2.lng + 180 * Pm, r2), s2 = t2.project(n2.lng, r2), a2 = t2.project(i2.lng, r2), o2 = xl.fromLngLat(n2), l2 = xl.fromLngLat(i2), u2 = a2.x - s2.x, c2 = a2.y - s2.y, h2 = l2.x - o2.x, p2 = l2.y - o2.y, f2 = Math.sqrt((h2 * h2 + p2 * p2) / (u2 * u2 + c2 * c2));
            return Math.log(f2) / Math.LN2;
          }
          function km(t2, e2, r2) {
            const n2 = Math.cos(r2), i2 = Math.sin(r2);
            return { x: t2 * n2 - e2 * i2, y: t2 * i2 + e2 * n2 };
          }
          function Tm(t2, e2, r2) {
            O.mat4.identity(t2), O.mat4.rotateZ(t2, t2, Y(e2[2])), O.mat4.rotateX(t2, t2, Y(e2[0])), O.mat4.rotateY(t2, t2, Y(e2[1])), O.mat4.scale(t2, t2, r2), O.mat4.multiply(t2, t2, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
          }
          function Em(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = [r2[0] - e2[0], r2[1] - e2[1], 0], u2 = [n2[0] - e2[0], n2[1] - e2[1], 0];
            if (O.vec3.length(l2) < 1e-12 || O.vec3.length(u2) < 1e-12)
              return O.quat.identity(t2);
            const c2 = O.vec3.cross([], l2, u2);
            O.vec3.normalize(c2, c2), O.vec3.subtract(u2, n2, e2), l2[2] = (s2 - i2) * o2, u2[2] = (a2 - i2) * o2;
            const h2 = l2;
            return O.vec3.cross(h2, l2, u2), O.vec3.normalize(h2, h2), O.quat.rotationTo(t2, c2, h2);
          }
          function Bm(t2, e2, r2 = false) {
            const n2 = Du(e2.zoom), i2 = function(t3, e3, r3) {
              const n3 = e3.worldSize, i3 = [t3[12], t3[13], t3[14]], s2 = hl(i3[1] / n3), a2 = cl(i3[0] / n3), o2 = O.mat4.identity([]), l2 = ul(1, s2) * n3, u2 = ul(1, 0) * n3 * ml(s2, e3.zoom), c2 = 1 / Vu(n3);
              let h2 = u2 * c2;
              if (r3) {
                const t4 = Im(e3.projection, e3.zoom, e3.width, e3.height, 1024);
                h2 = c2 * e3.projection.pixelSpaceConversion(e3.center.lat, n3, t4);
              }
              const p2 = Qo(s2, a2);
              O.vec3.add(p2, p2, O.vec3.scale([], O.vec3.normalize([], p2), l2 * h2 * i3[2]));
              const f2 = function(t4) {
                const e4 = [t4[0], t4[1], t4[2]];
                let r4 = [0, 1, 0];
                const n4 = O.vec3.cross([], r4, e4);
                return O.vec3.cross(r4, e4, n4), 0 === O.vec3.squaredLength(r4) && (r4 = [0, 1, 0], O.vec3.cross(n4, e4, r4)), O.vec3.normalize(n4, n4), O.vec3.normalize(r4, r4), O.vec3.normalize(e4, e4), [n4[0], n4[1], n4[2], 0, r4[0], r4[1], r4[2], 0, e4[0], e4[1], e4[2], 0, t4[0], t4[1], t4[2], 1];
              }(p2);
              O.mat4.scale(o2, o2, [h2, h2, h2 * l2]), O.mat4.translate(o2, o2, [-i3[0], -i3[1], -i3[2]]);
              const d2 = O.mat4.multiply([], e3.globeMatrix, f2);
              return O.mat4.multiply(d2, d2, o2), O.mat4.multiply(d2, d2, t3), d2;
            }(t2, e2, r2);
            if (n2 > 0) {
              const r3 = function(t3, e3) {
                const r4 = e3.worldSize, n3 = ul(1, 0) * r4 * ml(e3.center.lat, e3.zoom) / Vu(r4), i3 = ul(1, e3.center.lat) * r4, s2 = O.mat4.identity([]);
                return O.mat4.rotateY(s2, s2, Y(e3.center.lng)), O.mat4.rotateX(s2, s2, Y(e3.center.lat)), O.mat4.translate(s2, s2, [0, 0, $o]), O.mat4.scale(s2, s2, [n3, n3, n3 * i3]), O.mat4.translate(s2, s2, [e3.point.x - 0.5 * r4, e3.point.y - 0.5 * r4, 0]), O.mat4.multiply(s2, s2, t3), O.mat4.multiply(s2, e3.globeMatrix, s2);
              }(t2, e2);
              return function(t3, e3, r4) {
                const n3 = (t4, e4, r5) => {
                  const n4 = O.vec3.length(t4), i4 = O.vec3.length(e4), s3 = Mu(t4, e4, r5);
                  return O.vec3.scale(s3, s3, 1 / O.vec3.length(s3) * ke(n4, i4, r5));
                }, i3 = n3([t3[0], t3[1], t3[2]], [e3[0], e3[1], e3[2]], r4), s2 = n3([t3[4], t3[5], t3[6]], [e3[4], e3[5], e3[6]], r4), a2 = n3([t3[8], t3[9], t3[10]], [e3[8], e3[9], e3[10]], r4), o2 = Mu([t3[12], t3[13], t3[14]], [e3[12], e3[13], e3[14]], r4);
                return [i3[0], i3[1], i3[2], 0, s2[0], s2[1], s2[2], 0, a2[0], a2[1], a2[2], 0, o2[0], o2[1], o2[2], 1];
              }(i2, r3, n2);
            }
            return i2;
          }
          function Vm(t2, e2, r2, n2) {
            const i2 = yu.projectAabbCorners(n2, r2);
            let s2 = Number.MAX_VALUE, a2 = -1;
            for (let t3 = 0; t3 < i2.length; ++t3) {
              const r3 = i2[t3];
              r3[0] = (0.5 * r3[0] + 0.5) * e2.width, r3[1] = (0.5 - 0.5 * r3[1]) * e2.height, r3[2] < s2 && (a2 = t3, s2 = r3[2]);
            }
            const o2 = (t3) => new q(i2[t3][0], i2[t3][1]);
            let l2;
            switch (a2) {
              case 0:
              case 6:
                l2 = [o2(1), o2(5), o2(4), o2(7), o2(3), o2(2), o2(1)];
                break;
              case 1:
              case 7:
                l2 = [o2(0), o2(4), o2(5), o2(6), o2(2), o2(3), o2(0)];
                break;
              case 3:
              case 5:
                l2 = [o2(1), o2(0), o2(4), o2(7), o2(6), o2(2), o2(1)];
                break;
              default:
                l2 = [o2(1), o2(5), o2(6), o2(7), o2(3), o2(0), o2(1)];
            }
            if (El(t2, l2))
              return s2;
          }
          const Cm = ya([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Rm = ya([{ name: "a_color_3f", components: 3, type: "Float32" }]), Dm = ya([{ name: "a_color_4f", components: 4, type: "Float32" }]), Lm = ya([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Fm = ya([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Om = ya([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), Um = ya([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), jm = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
          class Nm {
            constructor(t2, e2, r2, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
            }
          }
          function qm(t2, e2) {
            const r2 = -1 === t2.indexOf("://");
            try {
              return new URL(t2, r2 && e2 ? "http://example.com" : void 0), true;
            } catch (t3) {
              return false;
            }
          }
          class $m {
            constructor(t2, e2) {
              this.feature = t2, this.instancedDataOffset = e2, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
            }
          }
          class Gm {
            constructor() {
              this.instancedDataArray = new Ga(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
            }
          }
          class Xm {
            constructor(t2) {
              this.zoom = t2.zoom, this.canonical = t2.canonical, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.projection = t2.projection, this.index = t2.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false, this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.tileToMeter = gl(r2);
              const i2 = this.layers[0]._featureFilter.needGeometry;
              this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
              for (const { feature: s2, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = null != a2 ? a2 : s2.properties && s2.properties.hasOwnProperty("id") ? s2.properties.id : void 0, u2 = Pl(s2, i2);
                if (!this.layers[0]._featureFilter.filter(new Vs(this.zoom), u2, r2))
                  continue;
                const c2 = { id: t3, sourceLayerIndex: l2, index: o2, geometry: i2 ? u2.geometry : Il(s2, r2, n2), properties: s2.properties, type: s2.type, patterns: {} }, h2 = this.addFeature(c2, c2.geometry, u2);
                h2 && e2.featureIndex.insert(s2, c2.geometry, o2, l2, this.index, this.instancesPerModel[h2].instancedDataArray.length, Hr / 32);
              }
              this.lookup = null;
            }
            update(t2, e2, r2, n2) {
              for (const e3 in this.instancesPerModel) {
                const r3 = this.instancesPerModel[e3];
                for (const e4 in t2)
                  r3.idToFeaturesIndex.hasOwnProperty(e4) && (this.evaluate(r3.features[r3.idToFeaturesIndex[e4]], t2[e4], r3, true), this.uploaded = false);
              }
              this.maxHeight = 0;
            }
            updateZoomBasedPaintProperties() {
              if (!this.hasZoomDependentProperties)
                return false;
              let t2 = false;
              for (const e2 in this.instancesPerModel) {
                const r2 = this.instancesPerModel[e2];
                for (const e3 of r2.features) {
                  const n2 = this.layers[0], i2 = e3.feature, s2 = this.canonical, a2 = n2.paint.get("model-rotation").evaluate(i2, {}, s2), o2 = n2.paint.get("model-scale").evaluate(i2, {}, s2), l2 = n2.paint.get("model-translation").evaluate(i2, {}, s2);
                  O.vec3.exactEquals(e3.rotation, a2) && O.vec3.exactEquals(e3.scale, o2) && O.vec3.exactEquals(e3.translation, l2) || (this.evaluate(e3, e3.featureStates, r2, true), t2 = true);
                }
              }
              return t2;
            }
            updateReplacement(t2, e2, r2, n2) {
              if (e2.updateTime === this.replacementUpdateTime)
                return false;
              this.replacementUpdateTime = e2.updateTime;
              const i2 = e2.getReplacementRegionsForTile(t2.toUnwrapped(), true);
              if (wh(this.activeReplacements, i2))
                return false;
              this.activeReplacements = i2;
              let s2 = false;
              for (const e3 in this.instancesPerModel) {
                const i3 = this.instancesPerModel[e3], a2 = i3.instancedDataArray;
                for (const e4 of i3.features) {
                  const i4 = e4.instancedDataOffset, o2 = e4.instancedDataCount;
                  for (let e5 = 0; e5 < o2; e5++) {
                    const o3 = 16 * (e5 + i4);
                    let l2 = a2.float32[o3 + 0];
                    const u2 = l2 > Hr;
                    l2 = u2 ? l2 - Hr : l2;
                    const c2 = Math.floor(l2), h2 = a2.float32[o3 + 1];
                    let p2 = false;
                    for (const e6 of this.activeReplacements)
                      if (!gh(e6, r2, jm.Model, n2) && !(e6.min.x > c2 || c2 > e6.max.x || e6.min.y > h2 || h2 > e6.max.y) && (p2 = Ph(Ih(c2, h2, t2.canonical, e6.footprintTileId.canonical), e6.footprint), p2))
                        break;
                    a2.float32[o3] = p2 ? l2 + Hr : l2, s2 = s2 || p2 !== u2;
                  }
                }
              }
              return s2;
            }
            isEmpty() {
              for (const t2 in this.instancesPerModel)
                if (0 !== this.instancesPerModel[t2].instancedDataArray.length)
                  return false;
              return true;
            }
            uploadPending() {
              return !this.uploaded;
            }
            upload(t2) {
              if (!this.uploaded)
                for (const e2 in this.instancesPerModel) {
                  const r2 = this.instancesPerModel[e2];
                  r2.instancedDataArray.length < 0 || 0 === r2.instancedDataArray.length || (r2.instancedDataBuffer ? r2.instancedDataBuffer.updateData(r2.instancedDataArray) : r2.instancedDataBuffer = t2.createVertexBuffer(r2.instancedDataArray, Om.members, true, void 0, this.instanceCount));
                }
              this.uploaded = true;
            }
            destroy() {
              for (const t3 in this.instancesPerModel) {
                const e2 = this.instancesPerModel[t3];
                0 !== e2.instancedDataArray.length && e2.instancedDataBuffer && e2.instancedDataBuffer.destroy();
              }
              const t2 = this.layers[0].modelManager;
              if (t2 && this.modelUris)
                for (const e2 of this.modelUris)
                  t2.removeModel(e2, "");
            }
            addFeature(t2, e2, r2) {
              const n2 = this.layers[0], i2 = n2.layout.get("model-id").evaluate(r2, {}, this.canonical);
              if (!i2)
                return ft(`modelId is not evaluated for layer ${n2.id} and it is not going to get rendered.`), i2;
              qm(i2, false) && (this.modelUris.includes(i2) || this.modelUris.push(i2)), this.instancesPerModel[i2] || (this.instancesPerModel[i2] = new Gm());
              const s2 = this.instancesPerModel[i2], a2 = s2.instancedDataArray, o2 = new $m(r2, a2.length);
              for (const t3 of e2)
                for (const e3 of t3) {
                  if (e3.x < 0 || e3.x >= Hr || e3.y < 0 || e3.y >= Hr)
                    continue;
                  const t4 = (this.lookupDim - 1) / Hr, r3 = this.lookupDim * (e3.y * t4 | 0) + e3.x * t4 | 0;
                  if (this.lookup) {
                    if (0 !== this.lookup[r3])
                      continue;
                    this.lookup[r3] = 1;
                  }
                  this.instanceCount++;
                  const n3 = a2.length;
                  a2.resize(n3 + 1), s2.instancesEvaluatedElevation.push(0), a2.float32[16 * n3] = e3.x, a2.float32[16 * n3 + 1] = e3.y;
                }
              return o2.instancedDataCount = s2.instancedDataArray.length - o2.instancedDataOffset, o2.instancedDataCount > 0 && (t2.id && (s2.idToFeaturesIndex[t2.id] = s2.features.length), s2.features.push(o2), this.evaluate(o2, {}, s2, false)), i2;
            }
            getModelUris() {
              return this.modelUris;
            }
            evaluate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = t2.feature, a2 = this.canonical, o2 = t2.rotation = i2.paint.get("model-rotation").evaluate(s2, e2, a2), l2 = t2.scale = i2.paint.get("model-scale").evaluate(s2, e2, a2), u2 = t2.translation = i2.paint.get("model-translation").evaluate(s2, e2, a2), c2 = i2.paint.get("model-color").evaluate(s2, e2, a2);
              c2.a = i2.paint.get("model-color-mix-intensity").evaluate(s2, e2, a2);
              const h2 = [];
              this.maxVerticalOffset < u2[2] && (this.maxVerticalOffset = u2[2]), this.maxScale = Math.max(Math.max(this.maxScale, l2[0]), Math.max(l2[1], l2[2])), Tm(h2, o2, l2);
              const p2 = Math.round(100 * c2.a) + c2.b / 1.05;
              for (let e3 = 0; e3 < t2.instancedDataCount; ++e3) {
                const i3 = t2.instancedDataOffset + e3, s3 = 16 * i3, o3 = r2.instancedDataArray.float32;
                let l3 = 0;
                n2 && (l3 = o3[s3 + 6] - r2.instancesEvaluatedElevation[i3]);
                const f2 = 0 | o3[s3 + 1];
                o3[s3] = (0 | o3[s3]) + c2.r / 1.05, o3[s3 + 1] = f2 + c2.g / 1.05, o3[s3 + 2] = p2, o3[s3 + 3] = 1 / (a2.z > 10 ? this.tileToMeter : gl(a2, f2)), o3[s3 + 4] = u2[0], o3[s3 + 5] = u2[1], o3[s3 + 6] = u2[2] + l3, o3[s3 + 7] = h2[0], o3[s3 + 8] = h2[1], o3[s3 + 9] = h2[2], o3[s3 + 10] = h2[4], o3[s3 + 11] = h2[5], o3[s3 + 12] = h2[6], o3[s3 + 13] = h2[8], o3[s3 + 14] = h2[9], o3[s3 + 15] = h2[10], r2.instancesEvaluatedElevation[i3] = u2[2];
              }
            }
          }
          let Ym, Zm;
          os(Xm, "ModelBucket", { omit: ["layers"] }), os(Gm, "PerModelAttributes"), os($m, "ModelFeature");
          const Wm = 64, Hm = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
          function Km(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2 = false) {
            const c2 = r2.zoom, h2 = r2.project(n2), p2 = ml(n2.lat, c2), f2 = 1 / p2;
            O.mat4.identity(t2), O.mat4.translate(t2, t2, [h2.x + a2[0] * f2, h2.y + a2[1] * f2, a2[2]]);
            let d2 = 1, m2 = 1;
            const y2 = r2.worldSize;
            if (u2) {
              if ("mercator" === r2.projection.name) {
                let t3 = 0;
                r2.elevation && (t3 = r2.elevation.getAtPointOrZero(new xl(h2.x / y2, h2.y / y2), 0));
                const e3 = O.vec4.transformMat4([], [h2.x, h2.y, t3, 1], r2.projMatrix)[3] / r2.cameraToCenterDistance;
                d2 = e3, m2 = e3 * ml(r2.center.lat, c2);
              } else if ("globe" === r2.projection.name) {
                const e3 = Bm(t2, r2), i3 = O.mat4.multiply([], r2.projMatrix, e3), s3 = [0, 0, 0, 1];
                O.vec4.transformMat4(s3, s3, i3);
                const a3 = s3[3] / r2.cameraToCenterDistance, o3 = Du(c2), l3 = r2.projection.pixelsPerMeter(n2.lat, y2) * ml(n2.lat, c2), u3 = r2.projection.pixelsPerMeter(r2.center.lat, y2) * ml(r2.center.lat, c2);
                d2 = a3 / ke(l3, dl(r2.center.lat), o3), m2 = a3 * p2 / l3, d2 *= u3, m2 *= u3;
              }
            } else
              d2 = f2;
            O.mat4.scale(t2, t2, [d2, d2, m2]);
            const g2 = [...t2], x2 = e2.orientation, b2 = [];
            if (Tm(b2, [x2[0] + i2[0], x2[1] + i2[1], x2[2] + i2[2]], s2), O.mat4.multiply(t2, g2, b2), o2 && r2.elevation) {
              let i3 = 0;
              const s3 = [];
              if (l2 && r2.elevation) {
                i3 = function(t3, e3, r3, n3, i4) {
                  const s4 = e3.elevation;
                  if (!s4)
                    return 0;
                  const a4 = yu.projectAabbCorners(r3, n3), o4 = ul(1, i4.lat) * e3.worldSize, l3 = function(t4, e4) {
                    const r4 = [0, 0, 1], n4 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                    for (const i5 of n4) {
                      const n5 = t4[i5.corners[0]], s5 = t4[i5.corners[1]], a5 = t4[i5.corners[2]], o5 = [s5[0] - n5[0], s5[1] - n5[1], e4 * (s5[2] - n5[2])], l4 = O.vec3.cross(o5, o5, [a5[0] - n5[0], a5[1] - n5[1], e4 * (a5[2] - n5[2])]);
                      O.vec3.normalize(l4, l4), i5.dotProductWithUp = O.vec3.dot(l4, r4);
                    }
                    return n4.sort((t5, e5) => t5.dotProductWithUp - e5.dotProductWithUp), n4[0].corners;
                  }(a4, o4), u3 = a4[l3[0]], c3 = a4[l3[1]], h3 = a4[l3[2]], p3 = a4[l3[3]], f3 = s4.getAtPointOrZero(new xl(u3[0] / e3.worldSize, u3[1] / e3.worldSize), 0), d3 = s4.getAtPointOrZero(new xl(c3[0] / e3.worldSize, c3[1] / e3.worldSize), 0), m3 = s4.getAtPointOrZero(new xl(h3[0] / e3.worldSize, h3[1] / e3.worldSize), 0), y3 = s4.getAtPointOrZero(new xl(p3[0] / e3.worldSize, p3[1] / e3.worldSize), 0), g3 = (f3 + y3) / 2, x3 = (d3 + m3) / 2;
                  return g3 > x3 ? d3 < m3 ? Em(t3, c3, p3, u3, d3, y3, f3, o4) : Em(t3, h3, u3, p3, m3, f3, y3, o4) : f3 < y3 ? Em(t3, u3, c3, h3, f3, d3, m3, o4) : Em(t3, p3, h3, c3, y3, m3, d3, o4), Math.max(g3, x3);
                }(s3, r2, e2.aabb, t2, n2);
                const a3 = O.mat4.fromQuat([], s3), o3 = O.mat4.multiply([], a3, b2);
                O.mat4.multiply(t2, g2, o3);
              } else
                i3 = r2.elevation.getAtPointOrZero(new xl(h2.x / y2, h2.y / y2), 0);
              0 !== i3 && (t2[14] += i3);
            }
          }
          function Jm(t2, e2, r2 = false) {
            t2.uploaded || (t2.gfxTexture = new lm(e2, t2.image, r2 ? e2.gl.R8 : e2.gl.RGBA8, { useMipmap: t2.sampler.minFilter >= e2.gl.NEAREST_MIPMAP_NEAREST }), t2.uploaded = true, t2.image = null);
          }
          function Qm(t2, e2, r2) {
            t2.indexBuffer = e2.createIndexBuffer(t2.indexArray, false, true), t2.vertexBuffer = e2.createVertexBuffer(t2.vertexArray, Cm.members, false, true), t2.normalArray && (t2.normalBuffer = e2.createVertexBuffer(t2.normalArray, Fm.members, false, true)), t2.texcoordArray && (t2.texcoordBuffer = e2.createVertexBuffer(t2.texcoordArray, Lm.members, false, true)), t2.colorArray && (t2.colorBuffer = e2.createVertexBuffer(t2.colorArray, (12 === t2.colorArray.bytesPerElement ? Rm : Dm).members, false, true)), t2.featureArray && (t2.pbrBuffer = e2.createVertexBuffer(t2.featureArray, Um.members, true)), t2.segments = co.simpleSegment(0, 0, t2.vertexArray.length, t2.indexArray.length);
            const n2 = t2.material;
            n2.pbrMetallicRoughness.baseColorTexture && Jm(n2.pbrMetallicRoughness.baseColorTexture, e2), n2.pbrMetallicRoughness.metallicRoughnessTexture && Jm(n2.pbrMetallicRoughness.metallicRoughnessTexture, e2), n2.normalTexture && Jm(n2.normalTexture, e2), n2.occlusionTexture && Jm(n2.occlusionTexture, e2, r2), n2.emissionTexture && Jm(n2.emissionTexture, e2);
          }
          function ty(t2, e2, r2) {
            if (t2.meshes)
              for (const n2 of t2.meshes)
                Qm(n2, e2, r2);
            if (t2.children)
              for (const n2 of t2.children)
                ty(n2, e2, r2);
          }
          function ey(t2) {
            if (t2.meshes)
              for (const e2 of t2.meshes)
                e2.indexArray.destroy(), e2.vertexArray.destroy(), e2.colorArray && e2.colorArray.destroy(), e2.normalArray && e2.normalArray.destroy(), e2.texcoordArray && e2.texcoordArray.destroy(), e2.featureArray && e2.featureArray.destroy();
            if (t2.children)
              for (const e2 of t2.children)
                ey(e2);
          }
          function ry(t2) {
            if (t2.meshes)
              for (const r2 of t2.meshes)
                r2.vertexBuffer && (r2.vertexBuffer.destroy(), r2.indexBuffer.destroy(), r2.normalBuffer && r2.normalBuffer.destroy(), r2.texcoordBuffer && r2.texcoordBuffer.destroy(), r2.colorBuffer && r2.colorBuffer.destroy(), r2.pbrBuffer && r2.pbrBuffer.destroy(), r2.segments.destroy(), r2.material && ((e2 = r2.material).pbrMetallicRoughness.baseColorTexture && e2.pbrMetallicRoughness.baseColorTexture.gfxTexture && e2.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e2.pbrMetallicRoughness.metallicRoughnessTexture && e2.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e2.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e2.normalTexture && e2.normalTexture.gfxTexture && e2.normalTexture.gfxTexture.destroy(), e2.emissionTexture && e2.emissionTexture.gfxTexture && e2.emissionTexture.gfxTexture.destroy(), e2.occlusionTexture && e2.occlusionTexture.gfxTexture && e2.occlusionTexture.gfxTexture.destroy()));
            var e2;
            if (t2.children)
              for (const e3 of t2.children)
                ry(e3);
          }
          class ny {
            constructor(t2, e2, r2) {
              this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
            }
            static create(t2, e2, r2) {
              const n2 = r2 || t2.findDEMTileFor(e2);
              if (!n2 || !n2.dem)
                return;
              const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
              return new ny(n2, i2.dim / Hr / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
            }
            tileCoordToPixel(t2, e2) {
              const r2 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r2);
              return new q(n2, i2);
            }
            getElevationAt(t2, e2, r2, n2) {
              const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
              return n2 = !!n2, r2 ? ke(ke(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), ke(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
            }
            getElevationAtPixel(t2, e2, r2) {
              return this._dem.get(t2, e2, !!r2);
            }
            getMeterToDEM(t2) {
              return (1 << this._demTile.tileID.canonical.z) * ul(1, t2) * this._dem.stride;
            }
          }
          const iy = new Float32Array(262144), sy = new Uint8Array(262144);
          function ay(t2) {
            let e2 = 0;
            if (t2.meshes)
              for (const r2 of t2.meshes)
                e2 = Math.max(e2, r2.aabb.max[2]);
            if (t2.children)
              for (const r2 of t2.children)
                e2 = Math.max(e2, ay(r2));
            return e2;
          }
          function oy(t2, e2, r2) {
            if (t2.meshes)
              for (const n2 of t2.meshes)
                n2.aabb.min[0] !== 1 / 0 && r2.insert(e2, n2.aabb.min[0], n2.aabb.min[1], n2.aabb.max[0], n2.aabb.max[1]);
            if (t2.children)
              for (const n2 of t2.children)
                oy(n2, e2, r2);
          }
          const ly = ["", "wall", "door", "roof", "window", "lamp", "logo"];
          class uy {
            constructor(t2) {
              this.node = t2, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: t2.id, geometry: [], properties: { height: ay(t2) } }, this.aabb = this._getLocalBounds();
            }
            _getLocalBounds() {
              if (!this.node.meshes)
                return new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              if (!this.aabb) {
                let t2 = 0;
                const e2 = new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
                for (const r2 of this.node.meshes)
                  this.node.lightMeshIndex !== t2 && (r2.transformedAabb = yu.applyTransformFast(r2.aabb, this.node.matrix), e2.encapsulate(r2.transformedAabb)), t2++;
                this.aabb = e2;
              }
              return this.aabb;
            }
          }
          class cy {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.id = e2, this.modelTraits |= Hm.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, r2 && (this.modelTraits |= Hm.HasMapboxMeshFeatures), n2 && (this.modelTraits |= Hm.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = i2, this.dirty = true, this.needsUpload = false, this.nodesInfo = [];
              for (const e3 of t2)
                this.nodesInfo.push(new uy(e3)), oy(e3, s2.featureIndexArray.length, s2.grid), s2.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, s2.bucketLayerIDs.length - 1, 0);
            }
            updateFootprints(t2, e2) {
              for (const r2 of this.getNodesInfo()) {
                const n2 = r2.node;
                n2.footprint && e2.push({ footprint: n2.footprint, id: t2 });
              }
            }
            update() {
              console.log("Update 3D model bucket");
            }
            populate() {
              console.log("populate 3D model bucket");
            }
            uploadPending() {
              return !this.uploaded || this.needsUpload;
            }
            upload(t2) {
              if (!this.needsUpload)
                return;
              const e2 = this.getNodesInfo();
              for (const r2 of e2) {
                const e3 = r2.node;
                this.uploaded ? this.updatePbrBuffer(e3) : ty(e3, t2, true);
              }
              for (const t3 of e2)
                ey(t3.node);
              this.uploaded = true, this.needsUpload = false;
            }
            updatePbrBuffer(t2) {
              let e2 = false;
              if (!t2.meshes)
                return e2;
              for (const r2 of t2.meshes)
                r2.pbrBuffer && (r2.pbrBuffer.updateData(r2.featureArray), e2 = true);
              return e2;
            }
            needsReEvaluation(t2, e2, r2) {
              const n2 = t2.transform.projectionOptions, i2 = t2.style.getBrightness(), s2 = this.brightness !== i2;
              return !!(!this.uploaded || this.dirty || n2.name !== this.projection.name || hy(r2.paint.get("model-color").value, s2) || hy(r2.paint.get("model-color-mix-intensity").value, s2) || hy(r2.paint.get("model-roughness").value, s2) || hy(r2.paint.get("model-emissive-strength").value, s2) || hy(r2.paint.get("model-height-based-emissive-strength-multiplier").value, s2)) && (this.projection = n2, this.brightness = i2, true);
            }
            evaluateScale(t2, e2) {
              if (t2.transform.zoom === this.zoom)
                return;
              this.zoom = t2.transform.zoom;
              const r2 = this.getNodesInfo(), n2 = this.id.canonical;
              for (const t3 of r2) {
                const r3 = t3.feature;
                t3.evaluatedScale = e2.paint.get("model-scale").evaluate(r3, {}, n2);
              }
            }
            evaluate(t2) {
              const e2 = this.getNodesInfo();
              for (const r2 of e2) {
                if (!r2.node.meshes)
                  continue;
                const e3 = r2.feature, n2 = r2.node.meshes && r2.node.meshes[0].featureData, i2 = r2.evaluatedColor[2], s2 = r2.evaluatedRMEA[2], a2 = this.id.canonical;
                if (r2.hasTranslucentParts = false, n2) {
                  for (let n3 = 0; n3 < ly.length; n3++) {
                    const i3 = ly[n3];
                    i3.length && (e3.properties.part = i3);
                    const s3 = t2.paint.get("model-color").evaluate(e3, {}, a2).toRenderColor(null), o2 = t2.paint.get("model-color-mix-intensity").evaluate(e3, {}, a2);
                    r2.evaluatedColor[n3] = [s3.r, s3.g, s3.b, o2], r2.evaluatedRMEA[n3][0] = t2.paint.get("model-roughness").evaluate(e3, {}, a2), r2.evaluatedRMEA[n3][2] = t2.paint.get("model-emissive-strength").evaluate(e3, {}, a2), r2.evaluatedRMEA[n3][3] = s3.a, r2.emissionHeightBasedParams[n3] = t2.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e3, {}, a2), !r2.hasTranslucentParts && s3.a < 1 && (r2.hasTranslucentParts = true);
                  }
                  delete e3.properties.part, fy(r2, i2 !== r2.evaluatedColor[2] || s2 !== r2.evaluatedRMEA[2], this.modelTraits);
                } else
                  r2.evaluatedRMEA[0][2] = t2.paint.get("model-emissive-strength").evaluate(e3, {}, a2);
                r2.evaluatedScale = t2.paint.get("model-scale").evaluate(e3, {}, a2), this.updatePbrBuffer(r2.node) || (this.needsUpload = true);
              }
              this.dirty = false;
            }
            elevationUpdate(t2, e2, r2, n2) {
              const i2 = t2.findDEMTileFor(r2);
              if (i2 && (i2.tileID.canonical !== this.terrainTile || e2 !== this.terrainExaggeration)) {
                if (i2.dem && i2.tileID.overscaledZ !== this.elevationReadFromZ) {
                  this.elevationReadFromZ = i2.tileID.overscaledZ;
                  const e3 = ny.create(t2, r2, i2);
                  if (!e3)
                    return;
                  this.modelTraits & Hm.HasMapboxMeshFeatures && this.updateDEM(t2, e3, r2, n2);
                  for (const t3 of this.getNodesInfo()) {
                    const r3 = t3.node;
                    if (!r3.footprint || !r3.footprint.vertices || !r3.footprint.vertices.length)
                      continue;
                    const n3 = r3.footprint.vertices;
                    let i3 = e3.getElevationAt(n3[0].x, n3[0].y, true, true);
                    for (let t4 = 1; t4 < n3.length; t4++)
                      i3 = Math.min(i3, e3.getElevationAt(n3[t4].x, n3[t4].y, true, true));
                    r3.elevation = i3;
                  }
                }
                this.terrainTile = i2.tileID.canonical, this.terrainExaggeration = e2;
              }
            }
            updateDEM(t2, e2, r2, n2) {
              let i2 = e2._dem._modifiedForSources[n2];
              if (void 0 === i2 && (e2._dem._modifiedForSources[n2] = [], i2 = e2._dem._modifiedForSources[n2]), i2.includes(r2.canonical))
                return;
              const s2 = e2._dem.dim;
              i2.push(r2.canonical);
              let a2 = false;
              for (const t3 of this.getNodesInfo()) {
                const r3 = t3.node;
                if (!r3.footprint || !r3.footprint.grid)
                  continue;
                const n3 = r3.footprint.grid, i3 = e2.tileCoordToPixel(n3.min.x, n3.min.y), o2 = e2.tileCoordToPixel(n3.max.x, n3.max.y), l2 = Math.min(Math.min(s2 - o2.y, i3.x), Math.min(i3.y, s2 - o2.x));
                if (l2 < 0)
                  continue;
                const u2 = Q(l2, 2, 5);
                let c2 = Math.max(0, i3.x - u2), h2 = Math.max(0, i3.y - u2), p2 = Math.min(o2.x + u2, s2 - 1), f2 = Math.min(o2.y + u2, s2 - 1);
                for (let t4 = h2; t4 <= f2; ++t4)
                  for (let e3 = c2; e3 <= p2; ++e3)
                    sy[t4 * s2 + e3] = 255;
                let d2 = 0, m2 = 0;
                for (let t4 = 0; t4 < n3.cellsY; ++t4)
                  for (let r4 = 0; r4 < n3.cellsX; ++r4) {
                    if (!n3.cells[t4 * n3.cellsX + r4])
                      continue;
                    const i4 = e2.tileCoordToPixel(n3.min.x + r4 / n3.xScale, n3.min.y + t4 / n3.yScale), a3 = e2.tileCoordToPixel(n3.min.x + (r4 + 1) / n3.xScale, n3.min.y + (t4 + 1) / n3.yScale);
                    for (let t5 = i4.y; t5 <= Math.min(a3.y + 1, s2 - 1); ++t5)
                      for (let r5 = i4.x; r5 <= Math.min(a3.x + 1, s2 - 1); ++r5)
                        255 === sy[t5 * s2 + r5] && (sy[t5 * s2 + r5] = 0, d2 += e2.getElevationAtPixel(r5, t5), m2++);
                  }
                const y2 = d2 / m2;
                c2 = Math.max(1, i3.x - u2), h2 = Math.max(1, i3.y - u2), p2 = Math.min(o2.x + u2, s2 - 2), f2 = Math.min(o2.y + u2, s2 - 2), a2 = true;
                for (let t4 = h2; t4 <= f2; ++t4)
                  for (let r4 = c2; r4 <= p2; ++r4)
                    0 === sy[t4 * s2 + r4] && (iy[t4 * s2 + r4] = e2._dem.set(r4, t4, y2));
                for (let t4 = 1; t4 < u2; ++t4) {
                  c2 = Math.max(1, i3.x - t4), h2 = Math.max(1, i3.y - t4), p2 = Math.min(o2.x + t4, s2 - 2), f2 = Math.min(o2.y + t4, s2 - 2);
                  for (let r4 = h2; r4 <= f2; ++r4)
                    for (let n4 = c2; n4 <= p2; ++n4) {
                      const i4 = r4 * s2 + n4;
                      if (255 === sy[i4]) {
                        let a3 = 0, o3 = 0, l3 = -1, c3 = -1;
                        for (let e3 = -1; e3 <= 1; ++e3)
                          for (let i5 = -1; i5 <= 1; ++i5) {
                            const u3 = (r4 + e3) * s2 + n4 + i5;
                            if (sy[u3] >= t4)
                              continue;
                            const h3 = iy[u3], p3 = Math.abs(h3);
                            p3 > o3 && (a3 = h3, o3 = p3, l3 = i5, c3 = e3);
                          }
                        if (o3 > 0.1) {
                          const s3 = 1 - (t4 + 0.5 * Math.abs(l3 * c3)) / u2;
                          let o4 = e2._dem.get(n4, r4) + a3 * s3;
                          const h3 = e2._dem.get(n4 + l3, r4 + c3), p3 = e2._dem.get(n4 - l3, r4 - c3, true);
                          (o4 - h3) * (o4 - p3) > 0 && (o4 = (h3 + p3) / 2), iy[i4] = e2._dem.set(n4, r4, o4), sy[i4] = t4;
                        }
                      }
                    }
                }
              }
              a2 && (e2._demTile.needsDEMTextureUpload = true, e2._dem._timestamp = Dt.now());
            }
            getNodesInfo() {
              return this.nodesInfo;
            }
            destroy() {
              const t2 = this.getNodesInfo();
              for (const e2 of t2)
                ey(e2.node), ry(e2.node);
            }
            isEmpty() {
              return !this.nodesInfo.length;
            }
            updateReplacement(t2, e2) {
              if (e2.updateTime === this.replacementUpdateTime)
                return;
              this.replacementUpdateTime = e2.updateTime;
              const r2 = e2.getReplacementRegionsForTile(t2.toUnwrapped()), n2 = this.getNodesInfo();
              for (let t3 = 0; t3 < this.nodesInfo.length; t3++) {
                const e3 = n2[t3].node;
                n2[t3].hiddenByReplacement = !!e3.footprint && !r2.find((t4) => t4.footprint === e3.footprint);
              }
            }
            getHeightAtTileCoord(t2, e2) {
              const r2 = this.getNodesInfo(), n2 = [], i2 = [0, 0, 0], s2 = O.mat4.identity([]);
              for (let a2 = 0; a2 < this.nodesInfo.length; a2++) {
                const o2 = r2[a2], l2 = o2.node.meshes[0], u2 = l2.transformedAabb;
                if (t2 < u2.min[0] || e2 < u2.min[1] || t2 > u2.max[0] || e2 > u2.max[1])
                  continue;
                if (true === o2.node.hidden)
                  return { height: 1 / 0, maxHeight: o2.feature.properties.height, hidden: false, verticalScale: o2.evaluatedScale[2] };
                O.mat4.invert(s2, o2.node.matrix), i2[0] = t2, i2[1] = e2, O.vec3.transformMat4(i2, i2, s2);
                const c2 = (i2[0] - l2.aabb.min[0]) / (l2.aabb.max[0] - l2.aabb.min[0]) * Wm | 0, h2 = Math.min(63, (i2[1] - l2.aabb.min[1]) / (l2.aabb.max[1] - l2.aabb.min[1]) * Wm | 0) * Wm + Math.min(63, c2), p2 = l2.heightmap[h2];
                if (!(p2 < 0 && o2.node.footprint)) {
                  if (o2.hiddenByReplacement)
                    return;
                  return { height: p2, maxHeight: o2.feature.properties.height, hidden: false, verticalScale: o2.evaluatedScale[2] };
                }
                if (o2.node.footprint.grid.query(new q(t2, e2), new q(t2, e2), n2), n2.length > 0)
                  return { height: void 0, maxHeight: o2.feature.properties.height, hidden: o2.hiddenByReplacement, verticalScale: o2.evaluatedScale[2] };
              }
            }
          }
          function hy(t2, e2) {
            return !t2.isLightConstant && e2;
          }
          function py(t2, e2, r2, n2, i2, s2, a2, o2) {
            let l2 = (61440 & e2 | (61440 & e2) >> 4) >> 8, u2 = (3840 & e2 | (3840 & e2) >> 4) >> 4, c2 = 240 & e2 | (240 & e2) >> 4;
            r2[3] > 0 && (l2 = ke(l2, 255 * r2[0], r2[3]), u2 = ke(u2, 255 * r2[1], r2[3]), c2 = ke(c2, 255 * r2[2], r2[3]));
            const h2 = l2 << 8 | u2, p2 = c2 << 8 | Math.floor(255 * n2[3]), f2 = function(t3) {
              const e3 = Q(t3, 0, 2);
              return Math.min(Math.round(0.5 * e3 * 255), 255);
            }(n2[2]) << 8 | 15 * n2[0] << 4 | 15 * n2[1], d2 = Q(i2[0], 0, 1), m2 = Q(i2[1], 0, 1), y2 = Q(i2[2], 0, 1), g2 = Q(i2[3], 0, 1);
            let x2, b2, v2, w2;
            if (d2 !== m2 && a2 !== s2 && m2 !== d2) {
              const t3 = a2 - s2;
              b2 = 1 / (t3 * (m2 - d2)), v2 = -(s2 + t3 * d2) / (t3 * (m2 - d2));
              const e3 = Q(i2[4], -1, 1);
              w2 = Math.pow(10, e3), x2 = 255 * y2 << 8 | 255 * g2;
            } else
              x2 = 65535, b2 = 0, v2 = 1, w2 = 1;
            if (t2.emplaceBack(h2, p2, f2, x2, b2, v2, w2), o2) {
              const t3 = o2.length;
              o2.clear();
              for (let e3 = 0; e3 < t3; e3++)
                o2.emplaceBack(h2, p2, f2, x2, b2, v2, w2);
            }
          }
          function fy(t2, e2, r2) {
            const n2 = t2.node;
            let i2 = 0;
            const s2 = r2 & Hm.HasMeshoptCompression;
            for (const r3 of n2.meshes) {
              if (n2.lights && n2.lightMeshIndex === i2)
                continue;
              if (!r3.featureData)
                continue;
              r3.featureArray = new Xa(), r3.featureArray.reserve(r3.featureData.length);
              let a2 = e2;
              for (const e3 of r3.featureData) {
                const i3 = s2 ? 65535 & e3 : e3 >> 16 & 65535, o2 = s2 ? e3 >> 16 & 65535 : 65535 & e3, l2 = (15 & o2) < 8 ? 15 & o2 : 0, u2 = t2.evaluatedRMEA[l2], c2 = t2.evaluatedColor[l2], h2 = t2.emissionHeightBasedParams[l2];
                let p2;
                if (a2 && 2 === l2 && n2.lights && (p2 = new Xa(), p2.resize(10 * n2.lights.length)), py(r3.featureArray, i3, c2, u2, h2, r3.aabb.min[2], r3.aabb.max[2], p2), p2 && a2) {
                  a2 = false;
                  const t3 = n2.meshes[n2.lightMeshIndex];
                  t3.featureArray = p2, t3.featureArray._trim();
                }
              }
              r3.featureArray._trim(), i2++;
            }
          }
          function dy(t2, e2, r2, n2) {
            const i2 = 1 << t2.z;
            e2.lat = hl((n2 / Hr + t2.y) / i2), e2.lng = cl((r2 / Hr + t2.x) / i2);
          }
          os(cy, "Tiled3dModelBucket", { omit: ["layers"] }), os(uy, "Tiled3dModelFeature");
          const my = { circle: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Wl || (Wl = new Gs({ "circle-sort-key": new qs(Xs.layout_circle["circle-sort-key"]), visibility: new Ns(Xs.layout_circle.visibility) })), paint: Hl || (Hl = new Gs({ "circle-radius": new qs(Xs.paint_circle["circle-radius"]), "circle-color": new qs(Xs.paint_circle["circle-color"]), "circle-blur": new qs(Xs.paint_circle["circle-blur"]), "circle-opacity": new qs(Xs.paint_circle["circle-opacity"]), "circle-translate": new Ns(Xs.paint_circle["circle-translate"]), "circle-translate-anchor": new Ns(Xs.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ns(Xs.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ns(Xs.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new qs(Xs.paint_circle["circle-stroke-width"]), "circle-stroke-color": new qs(Xs.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new qs(Xs.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Ns(Xs.paint_circle["circle-emissive-strength"]) })) }, e2, r2, n2);
            }
            createBucket(t2) {
              return new Tl(t2);
            }
            queryRadius(t2) {
              const e2 = t2;
              return Gl("circle-radius", this, e2) + Gl("circle-stroke-width", this, e2) + Xl(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = Zl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
              return $u(t2, n2, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u2);
            }
            getProgramIds() {
              return ["circle"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              const n2 = qu(this);
              return { config: new Lo(this, { zoom: e2, lut: r2 }), defines: n2, overrideFog: false };
            }
          }, heatmap: class extends pa {
            createBucket(t2) {
              return new Wu(t2);
            }
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Hu || (Hu = new Gs({ visibility: new Ns(Xs.layout_heatmap.visibility) })), paint: Ku || (Ku = new Gs({ "heatmap-radius": new qs(Xs.paint_heatmap["heatmap-radius"]), "heatmap-weight": new qs(Xs.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ns(Xs.paint_heatmap["heatmap-intensity"]), "heatmap-color": new $s(Xs.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ns(Xs.paint_heatmap["heatmap-opacity"]) })) }, e2, r2, n2), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "heatmap-color" === t2 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = ac({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius(t2) {
              return Gl("heatmap-radius", this, t2);
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this.paint.get("heatmap-radius").evaluate(e2, r2);
              return $u(t2, n2, s2, a2, o2, true, true, new q(0, 0), l2);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
            getProgramIds() {
              return ["heatmap", "heatmapTexture"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return "heatmap" === t2 ? { config: new Lo(this, { zoom: e2, lut: r2 }), overrideFog: false } : {};
            }
          }, hillshade: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Ju || (Ju = new Gs({ visibility: new Ns(Xs.layout_hillshade.visibility) })), paint: Qu || (Qu = new Gs({ "hillshade-illumination-direction": new Ns(Xs.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ns(Xs.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ns(Xs.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ns(Xs.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ns(Xs.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ns(Xs.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Ns(Xs.paint_hillshade["hillshade-emissive-strength"]) })) }, e2, r2, n2);
            }
            shouldRedrape() {
              return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
            getProgramIds() {
              return ["hillshade", "hillshadePrepare"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { overrideFog: false };
            }
          }, fill: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Oc || (Oc = new Gs({ "fill-sort-key": new qs(Xs.layout_fill["fill-sort-key"]), visibility: new Ns(Xs.layout_fill.visibility) })), paint: Uc || (Uc = new Gs({ "fill-antialias": new Ns(Xs.paint_fill["fill-antialias"]), "fill-opacity": new qs(Xs.paint_fill["fill-opacity"]), "fill-color": new qs(Xs.paint_fill["fill-color"]), "fill-outline-color": new qs(Xs.paint_fill["fill-outline-color"]), "fill-translate": new Ns(Xs.paint_fill["fill-translate"]), "fill-translate-anchor": new Ns(Xs.paint_fill["fill-translate-anchor"]), "fill-pattern": new qs(Xs.paint_fill["fill-pattern"]), "fill-emissive-strength": new Ns(Xs.paint_fill["fill-emissive-strength"]), "fill-z-offset": new qs(Xs.paint_fill["fill-z-offset"]) })) }, e2, r2, n2);
            }
            getProgramIds() {
              const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
              return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { config: new Lo(this, { zoom: e2, lut: r2 }), overrideFog: false };
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
              const r2 = this.paint._values["fill-outline-color"];
              "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new Fc(t2);
            }
            queryRadius() {
              return Xl(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              return !t2.queryGeometry.isAboveHorizon && Vl(Yl(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
            }
            isTileClipped() {
              return true;
            }
            is3D() {
              return 0 !== this.paint.get("fill-z-offset").constantOr(1);
            }
          }, "fill-extrusion": class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: sp || (sp = new Gs({ visibility: new Ns(Xs["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Ns(Xs["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: ap || (ap = new Gs({ "fill-extrusion-opacity": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new qs(Xs["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new Ns(Xs["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]) })) }, e2, r2, n2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
            }
            createBucket(t2) {
              return new Zh(t2);
            }
            queryRadius() {
              return Xl(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            hasShadowPass() {
              return this.paint.get("fill-extrusion-cast-shadows");
            }
            cutoffRange() {
              return this.paint.get("fill-extrusion-cutoff-fade-range");
            }
            canCastShadows() {
              return true;
            }
            getProgramIds() {
              return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = Zl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = [0, 0], f2 = o2 && s2.elevation, d2 = s2.elevation ? s2.elevation.exaggeration() : 1, m2 = t2.tile.getBucket(this);
              if (f2 && m2 instanceof Zh) {
                const t3 = m2.centroidVertexArray, e3 = l2 + 1;
                e3 < t3.length && (p2[0] = t3.geta_centroid_pos0(e3), p2[1] = t3.geta_centroid_pos1(e3));
              }
              if (0 === p2[0] && 1 === p2[1])
                return false;
              "globe" === s2.projection.name && (n2 = np([n2], [new q(0, 0), new q(Hr, Hr)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
              const y2 = f2 ? o2 : null, [g2, x2] = function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) {
                return "globe" === t3.projection.name ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4, u4, c4) {
                  const h3 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d3 = [0, 0, 0, 1], m3 = [0, 0, 0, 1], y3 = (t5, e5, r5, n5) => {
                    t5[0] = e5, t5[1] = r5, t5[2] = n5, t5[3] = 1;
                  }, g3 = rp();
                  r4 > 0 && (r4 += g3), n4 += g3;
                  for (const g4 of e4) {
                    const e5 = [], x3 = [];
                    for (const h4 of g4) {
                      const p4 = h4.x + i4.x, g5 = h4.y + i4.y, b3 = t4.projection.projectTilePoint(p4, g5, c4), v2 = t4.projection.upVector(c4, h4.x, h4.y);
                      let w2 = r4, _2 = n4;
                      if (a4) {
                        const t5 = up(p4, g5, r4, n4, a4, o4, l4, u4);
                        w2 += t5.base, _2 += t5.top;
                      }
                      0 !== r4 ? y3(d3, b3.x + v2[0] * f3 * w2, b3.y + v2[1] * f3 * w2, b3.z + v2[2] * f3 * w2) : y3(d3, b3.x, b3.y, b3.z), y3(m3, b3.x + v2[0] * f3 * _2, b3.y + v2[1] * f3 * _2, b3.z + v2[2] * f3 * _2), O.vec3.transformMat4(d3, d3, s4), O.vec3.transformMat4(m3, m3, s4), e5.push(new hh(d3[0], d3[1], d3[2])), x3.push(new hh(m3[0], m3[1], m3[2]));
                    }
                    h3.push(e5), p3.push(x3);
                  }
                  return [h3, p3];
                }(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3) : a3 ? function(t4, e4, r4, n4, i4, s4, a4, o4, l4) {
                  const u4 = [], c4 = [], h3 = [0, 0, 0, 1];
                  for (const p3 of t4) {
                    const t5 = [], f3 = [];
                    for (const u5 of p3) {
                      const c5 = u5.x + n4.x, p4 = u5.y + n4.y, d3 = up(c5, p4, e4, r4, s4, a4, o4, l4);
                      h3[0] = c5, h3[1] = p4, h3[2] = d3.base, h3[3] = 1, O.vec4.transformMat4(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                      const m3 = new hh(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                      h3[0] = c5, h3[1] = p4, h3[2] = d3.top, h3[3] = 1, O.vec4.transformMat4(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                      const y3 = new hh(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                      t5.push(m3), f3.push(y3);
                    }
                    u4.push(t5), c4.push(f3);
                  }
                  return [u4, c4];
                }(e3, r3, n3, i3, s3, a3, o3, l3, u3) : function(t4, e4, r4, n4, i4) {
                  const s4 = [], a4 = [], o4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h3 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d3 = i4[11] * r4;
                  for (const e5 of t4) {
                    const t5 = [], r5 = [];
                    for (const s5 of e5) {
                      const e6 = s5.x + n4.x, a5 = s5.y + n4.y, m3 = i4[0] * e6 + i4[4] * a5 + i4[12], y3 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x3 = i4[3] * e6 + i4[7] * a5 + i4[15], b3 = m3 + o4, v2 = y3 + l4, w2 = g3 + u4, _2 = Math.max(x3 + c4, 1e-5), M2 = m3 + h3, A2 = y3 + p3, S2 = g3 + f3, I2 = Math.max(x3 + d3, 1e-5);
                      t5.push(new hh(b3 / _2, v2 / _2, w2 / _2)), r5.push(new hh(M2 / I2, A2 / I2, S2 / I2));
                    }
                    s4.push(t5), a4.push(r5);
                  }
                  return [s4, a4];
                }(e3, r3, n3, i3, s3);
              }(s2, n2, h2, c2, u2, a2, y2, p2, d2, s2.center.lat, t2.tileID.canonical), b2 = t2.queryGeometry;
              return function(t3, e3, r3) {
                let n3 = 1 / 0;
                Vl(r3, e3) && (n3 = lp(r3, e3[0]));
                for (let i3 = 0; i3 < e3.length; i3++) {
                  const s3 = e3[i3], a3 = t3[i3];
                  for (let t4 = 0; t4 < s3.length - 1; t4++) {
                    const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                    El(r3, i4) && (n3 = Math.min(n3, lp(r3, i4)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(g2, x2, b2.isPointQuery() ? b2.screenBounds : b2.screenGeometry);
            }
          }, line: class extends pa {
            constructor(t2, e2, r2, n2) {
              const i2 = Ep();
              super(t2, i2, e2, r2, n2), i2.layout && (this.layout = new js(i2.layout)), this.gradientVersion = 0;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              if ("line-gradient" === t2) {
                const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
                this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof Un, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            widthExpression() {
              return this._transitionablePaint._values["line-width"].value.expression;
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = (() => {
                if (Vp)
                  return Vp;
                const t3 = Ep();
                return Vp = new Bp(t3.paint.properties["line-width"].specification), Vp.useIntegerZoom = true, Vp;
              })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new wp(t2);
            }
            getProgramIds() {
              return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              const n2 = zp(this);
              return { config: new Lo(this, { zoom: e2, lut: r2 }), defines: n2, overrideFog: false };
            }
            queryRadius(t2) {
              const e2 = t2, r2 = Cp(Gl("line-width", this, e2), Gl("line-gap-width", this, e2)), n2 = Gl("line-offset", this, e2);
              return r2 / 2 + Math.abs(n2) + Xl(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              if (t2.queryGeometry.isAboveHorizon)
                return false;
              const a2 = Yl(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * Cp(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), l2 = this.paint.get("line-offset").evaluate(e2, r2);
              return l2 && (n2 = function(t3, e3) {
                const r3 = [], n3 = new q(0, 0);
                for (let i3 = 0; i3 < t3.length; i3++) {
                  const s3 = t3[i3], a3 = [];
                  for (let t4 = 0; t4 < s3.length; t4++) {
                    const r4 = s3[t4], i4 = s3[t4 + 1], o3 = 0 === t4 ? n3 : r4.sub(s3[t4 - 1])._unit()._perp(), l3 = t4 === s3.length - 1 ? n3 : i4.sub(r4)._unit()._perp(), u2 = o3._add(l3)._unit();
                    u2._mult(1 / (u2.x * l3.x + u2.y * l3.y)), a3.push(u2._mult(e3)._add(r4));
                  }
                  r3.push(a3);
                }
                return r3;
              }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i3 = e3[n3];
                  if (t3.length >= 3) {
                    for (let e4 = 0; e4 < i3.length; e4++)
                      if (Ul(t3, i3[e4]))
                        return true;
                  }
                  if (Cl(t3, i3, r3))
                    return true;
                }
                return false;
              }(a2, n2, o2);
            }
            isTileClipped() {
              return true;
            }
            isDraped(t2) {
              const e2 = this.layout.get("line-z-offset");
              return e2.isConstant() && !e2.constantOr(0);
            }
          }, symbol: tm, background: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: em || (em = new Gs({ visibility: new Ns(Xs.layout_background.visibility) })), paint: rm || (rm = new Gs({ "background-pitch-alignment": new Ns(Xs.paint_background["background-pitch-alignment"]), "background-color": new Ns(Xs.paint_background["background-color"]), "background-pattern": new Ns(Xs.paint_background["background-pattern"]), "background-opacity": new Ns(Xs.paint_background["background-opacity"]), "background-emissive-strength": new Ns(Xs.paint_background["background-emissive-strength"]) })) }, e2, r2, n2);
            }
            getProgramIds() {
              return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { overrideFog: false };
            }
            is3D() {
              return "viewport" === this.paint.get("background-pitch-alignment");
            }
          }, raster: mm, "raster-particle": wm, sky: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: xm || (xm = new Gs({ visibility: new Ns(Xs.layout_sky.visibility) })), paint: bm || (bm = new Gs({ "sky-type": new Ns(Xs.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ns(Xs.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ns(Xs.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ns(Xs.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ns(Xs.paint_sky["sky-gradient-radius"]), "sky-gradient": new $s(Xs.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ns(Xs.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ns(Xs.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ns(Xs.paint_sky["sky-opacity"]) })) }, e2, r2, n2), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
            }
            _updateColorRamp() {
              this.colorRamp = ac({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
            }
            needsSkyboxCapture(t2) {
              if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                return true;
              if (!this.paint.get("sky-atmosphere-sun")) {
                const e2 = t2.style.light.properties.get("position");
                return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
              }
              return false;
            }
            getCenter(t2, e2) {
              if ("atmosphere" === this.paint.get("sky-type")) {
                const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
                return n2 && "viewport" === i2.properties.get("anchor") && ft("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? Mm(s2.azimuthal, 90 - s2.polar, e2) : Mm(r3[0], 90 - r3[1], e2);
              }
              const r2 = this.paint.get("sky-gradient-center");
              return Mm(r2[0], 90 - r2[1], e2);
            }
            isSky() {
              return true;
            }
            markSkyboxValid(t2) {
              this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
            }
            hasOffscreenPass() {
              return true;
            }
            getProgramIds() {
              const t2 = this.paint.get("sky-type");
              return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
            }
          }, slot: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { paint: vm || (vm = new Gs({})) }, e2, null);
            }
          }, model: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Ym || (Ym = new Gs({ visibility: new Ns(Xs.layout_model.visibility), "model-id": new qs(Xs.layout_model["model-id"]) })), paint: Zm || (Zm = new Gs({ "model-opacity": new Ns(Xs.paint_model["model-opacity"]), "model-rotation": new qs(Xs.paint_model["model-rotation"]), "model-scale": new qs(Xs.paint_model["model-scale"]), "model-translation": new qs(Xs.paint_model["model-translation"]), "model-color": new qs(Xs.paint_model["model-color"]), "model-color-mix-intensity": new qs(Xs.paint_model["model-color-mix-intensity"]), "model-type": new Ns(Xs.paint_model["model-type"]), "model-cast-shadows": new Ns(Xs.paint_model["model-cast-shadows"]), "model-receive-shadows": new Ns(Xs.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Ns(Xs.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new qs(Xs.paint_model["model-emissive-strength"]), "model-roughness": new qs(Xs.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new qs(Xs.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Ns(Xs.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Ns(Xs.paint_model["model-front-cutoff"]) })) }, e2, r2, n2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
            }
            createBucket(t2) {
              return new Xm(t2);
            }
            getProgramIds() {
              return ["model"];
            }
            is3D() {
              return true;
            }
            hasShadowPass() {
              return true;
            }
            canCastShadows() {
              return true;
            }
            hasLightBeamPass() {
              return true;
            }
            cutoffRange() {
              return this.paint.get("model-cutoff-fade-range");
            }
            queryRadius(t2) {
              return t2 instanceof cy ? Hr - 1 : 0;
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              if (!this.modelManager)
                return false;
              const a2 = this.modelManager, o2 = t2.tile.getBucket(this);
              if (!(o2 && o2 instanceof Xm))
                return false;
              const l2 = o2;
              for (const r3 in l2.instancesPerModel) {
                const n3 = l2.instancesPerModel[r3], i3 = void 0 !== e2.id ? e2.id : e2.properties && e2.properties.hasOwnProperty("id") ? e2.properties.id : void 0;
                if (n3.idToFeaturesIndex.hasOwnProperty(i3)) {
                  const e3 = n3.features[n3.idToFeaturesIndex[i3]], o3 = a2.getModel(r3, this.scope);
                  if (!o3)
                    return false;
                  let u2 = O.mat4.create();
                  const c2 = new rl(0, 0), h2 = l2.canonical;
                  let p2 = Number.MAX_VALUE;
                  for (let r4 = 0; r4 < e3.instancedDataCount; ++r4) {
                    const i4 = 16 * (e3.instancedDataOffset + r4), a3 = n3.instancedDataArray.float32, l3 = [a3[i4 + 4], a3[i4 + 5], a3[i4 + 6]];
                    dy(h2, c2, a3[i4], 0 | a3[i4 + 1]), Km(u2, o3, s2, c2, e3.rotation, e3.scale, l3, false, false, false), "globe" === s2.projection.name && (u2 = Bm(u2, s2));
                    const f2 = O.mat4.multiply([], s2.projMatrix, u2), d2 = t2.queryGeometry, m2 = Vm(d2.isPointQuery() ? d2.screenBounds : d2.screenGeometry, s2, f2, o3.aabb);
                    null != m2 && (p2 = Math.min(m2, p2));
                  }
                  return p2 !== Number.MAX_VALUE && p2;
                }
              }
              return false;
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven() || "model-color" !== t2 && "model-color-mix-intensity" !== t2 && "model-rotation" !== t2 && "model-scale" !== t2 && "model-translation" !== t2 && "model-emissive-strength" !== t2);
            }
            _isPropertyZoomDependent(t2) {
              const e2 = this._transitionablePaint._values[t2];
              return null != e2 && null != e2.value && null != e2.value.expression && e2.value.expression instanceof Ji;
            }
            isZoomDependent() {
              return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
            }
            queryIntersectsMatchingFeature(t2, e2, r2, n2) {
              const i2 = t2.tile, s2 = i2.getBucket(this);
              let a2 = null, o2 = Number.MAX_VALUE;
              if (!(s2 && s2 instanceof cy))
                return { queryFeature: a2, intersectionZ: o2 };
              const l2 = s2.getNodesInfo()[e2];
              if (l2.hiddenByReplacement || !l2.node.meshes || !r2.filter(new Vs(i2.tileID.overscaledZ), l2.feature, i2.tileID.canonical))
                return { queryFeature: a2, intersectionZ: o2 };
              const u2 = l2.node, c2 = n2.calculatePosMatrix(i2.tileID.toUnwrapped(), n2.worldSize), h2 = l2.evaluatedScale;
              let p2 = 0;
              n2.elevation && u2.elevation && (p2 = u2.elevation * n2.elevation.exaggeration()), O.mat4.translate(c2, c2, [(u2.anchor ? u2.anchor[0] : 0) * (h2[0] - 1), (u2.anchor ? u2.anchor[1] : 0) * (h2[1] - 1), p2]), O.mat4.scale(c2, c2, h2), O.mat4.multiply(c2, c2, u2.matrix);
              const f2 = t2.queryGeometry, d2 = f2.isPointQuery() ? f2.screenBounds : f2.screenGeometry, m2 = function(t3) {
                const e3 = O.mat4.multiply([], c2, t3.matrix), r3 = O.mat4.multiply(e3, n2.expandedFarZProjMatrix, e3);
                for (let e4 = 0; e4 < t3.meshes.length; ++e4) {
                  const i3 = t3.meshes[e4];
                  if (e4 === t3.lightMeshIndex)
                    continue;
                  const s3 = Vm(d2, n2, r3, i3.aabb);
                  null != s3 && (o2 = Math.min(s3, o2));
                }
                if (t3.children)
                  for (const e4 of t3.children)
                    m2(e4);
              };
              if (m2(u2), o2 === Number.MAX_VALUE)
                return { queryFeature: a2, intersectionZ: o2 };
              const y2 = new rl(0, 0);
              return dy(i2.tileID.canonical, y2, l2.node.anchor[0], l2.node.anchor[1]), a2 = { type: "Feature", geometry: { type: "Point", coordinates: [y2.lng, y2.lat] }, properties: l2.feature.properties, id: l2.feature.id, state: {}, layer: this.serialize() }, { queryFeature: a2, intersectionZ: o2 };
            }
          }, clip: class extends pa {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: jc || (jc = new Gs({ "clip-layer-types": new Ns(Xs.layout_clip["clip-layer-types"]), "clip-layer-scope": new Ns(Xs.layout_clip["clip-layer-scope"]) })), paint: Nc || (Nc = new Gs({})) }, e2, r2, n2);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
            }
            createBucket(t2) {
              return new Gc(t2);
            }
            isTileClipped() {
              return true;
            }
            is3D() {
              return true;
            }
          } };
          class yy {
            constructor(t2) {
              this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              this._channel = void 0, this._callback = () => {
              };
            }
          }
          class gy {
            constructor() {
              this.tasks = {}, this.taskQueue = [], ot(["process"], this), this.invoker = new yy(this.process), this.nextId = 0;
            }
            add(t2, e2) {
              const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
                return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
              }(e2);
              if (0 === n2) {
                try {
                  t2();
                } finally {
                }
                return null;
              }
              return this.tasks[r2] = { fn: t2, metadata: e2, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
                delete this.tasks[r2];
              } };
            }
            process() {
              try {
                if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
                  return;
                const t2 = this.pick();
                if (null === t2)
                  return;
                const e2 = this.tasks[t2];
                if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2)
                  return;
                e2.fn();
              } finally {
              }
            }
            pick() {
              let t2 = null, e2 = 1 / 0;
              for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
                const n2 = this.tasks[this.taskQueue[r3]];
                n2.priority < e2 && (e2 = n2.priority, t2 = r3);
              }
              if (null === t2)
                return null;
              const r2 = this.taskQueue[t2];
              return this.taskQueue.splice(t2, 1), r2;
            }
            remove() {
              this.invoker.remove();
            }
          }
          class xy {
            constructor(t2, e2, r2) {
              this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.cancelCallbacks = {}, ot(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new gy();
            }
            send(t2, e2, r2, n2, i2 = false, s2) {
              const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r2 && (r2.metadata = s2, this.callbacks[a2] = r2);
              const o2 = /* @__PURE__ */ new Set();
              return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: cs(e2, o2) }, o2), { cancel: () => {
                r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
              } };
            }
            receive(t2) {
              const e2 = t2.data, r2 = e2.id;
              if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
                if ("<cancel>" === e2.type) {
                  const t3 = this.cancelCallbacks[r2];
                  delete this.cancelCallbacks[r2], t3 && t3.cancel();
                } else if (e2.mustQueue || gt()) {
                  const t3 = this.callbacks[r2], n2 = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
                  n2 && (this.cancelCallbacks[r2] = n2);
                } else
                  this.processTask(r2, e2);
            }
            processTask(t2, e2) {
              if (delete this.cancelCallbacks[t2], "<response>" === e2.type) {
                const r2 = this.callbacks[t2];
                delete this.callbacks[t2], r2 && (e2.error ? r2(hs(e2.error)) : r2(null, hs(e2.data)));
              } else {
                const r2 = /* @__PURE__ */ new Set(), n2 = e2.hasCallback ? (e3, n3) => {
                  this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? cs(e3) : null, data: cs(n3, r2) }, r2);
                } : (t3) => {
                }, i2 = hs(e2.data);
                if (this.parent[e2.type])
                  this.parent[e2.type](e2.sourceMapId, i2, n2);
                else if (this.parent.getWorkerSource) {
                  const t3 = e2.type.split(".");
                  this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source, i2.scope)[t3[1]](i2, n2);
                } else
                  n2(new Error(`Could not find function ${e2.type}`));
              }
            }
            remove() {
              this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }
          class by {
            constructor(t2, e2) {
              this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = st();
              const r2 = this.workerPool.acquire(this.id);
              for (let t3 = 0; t3 < r2.length; t3++) {
                const n2 = new by.Actor(r2[t3], e2, this.id);
                n2.name = `Worker ${t3}`, this.actors.push(n2);
              }
              this.ready = false, this.broadcast("checkIfReady", null, () => {
                this.ready = true;
              });
            }
            broadcast(t2, e2, r2) {
              rt(this.actors, (r3, n2) => {
                r3.send(t2, e2, n2);
              }, r2 = r2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
              this.actors.forEach((t2) => {
                t2.remove();
              }), this.actors = [], this.workerPool.release(this.id);
            }
          }
          by.Actor = xy;
          class vy {
            constructor(t2) {
              this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t2, e2) {
              const r2 = this.toIdx(t2, e2);
              return { min: this.minimums[r2], max: this.maximums[r2] };
            }
            isLeaf(t2, e2) {
              return this.leaves[this.toIdx(t2, e2)];
            }
            toIdx(t2, e2) {
              return e2 * this.size + t2;
            }
          }
          function wy(t2, e2, r2, n2) {
            let i2 = 0, s2 = Number.MAX_VALUE;
            for (let a2 = 0; a2 < 3; a2++)
              if (Math.abs(n2[a2]) < 1e-15) {
                if (r2[a2] < t2[a2] || r2[a2] > e2[a2])
                  return null;
              } else {
                const o2 = 1 / n2[a2];
                let l2 = (t2[a2] - r2[a2]) * o2, u2 = (e2[a2] - r2[a2]) * o2;
                if (l2 > u2) {
                  const t3 = l2;
                  l2 = u2, u2 = t3;
                }
                if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2)
                  return null;
              }
            return i2;
          }
          function _y(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = n2 - t2, p2 = i2 - e2, f2 = s2 - r2, d2 = a2 - t2, m2 = o2 - e2, y2 = l2 - r2, g2 = c2[1] * y2 - c2[2] * m2, x2 = c2[2] * d2 - c2[0] * y2, b2 = c2[0] * m2 - c2[1] * d2, v2 = h2 * g2 + p2 * x2 + f2 * b2;
            if (Math.abs(v2) < 1e-15)
              return null;
            const w2 = 1 / v2, _2 = u2[0] - t2, M2 = u2[1] - e2, A2 = u2[2] - r2, S2 = (_2 * g2 + M2 * x2 + A2 * b2) * w2;
            if (S2 < 0 || S2 > 1)
              return null;
            const I2 = M2 * f2 - A2 * p2, P2 = A2 * h2 - _2 * f2, z2 = _2 * p2 - M2 * h2, k2 = (c2[0] * I2 + c2[1] * P2 + c2[2] * z2) * w2;
            return k2 < 0 || S2 + k2 > 1 ? null : (d2 * I2 + m2 * P2 + y2 * z2) * w2;
          }
          function My(t2, e2, r2) {
            return (t2 - e2) / (r2 - e2);
          }
          function Ay(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = 1 << r2, c2 = s2 - n2, h2 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, f2 = (e2 + 0) / u2 * h2 + i2, d2 = (e2 + 1) / u2 * h2 + i2;
            o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = f2, l2[0] = p2, l2[1] = d2;
          }
          class Sy {
            constructor(t2) {
              if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
                return;
              const e2 = function(t3) {
                const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
                let n3 = Math.ceil(Math.pow(2, e3));
                const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
                  const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
                  i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l2;
                };
                let a2 = new vy(n3);
                const o2 = [];
                for (let e4 = 0; e4 < n3 * n3; e4++) {
                  s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
                  const r4 = Py(o2[0], o2[1], t3), l2 = Py(o2[2], o2[1], t3), u2 = Py(o2[2], o2[3], t3), c2 = Py(o2[0], o2[3], t3);
                  a2.minimums.push(Math.min(r4, l2, u2, c2)), a2.maximums.push(Math.max(r4, l2, u2, c2)), a2.leaves.push(1);
                }
                for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
                  const t4 = r3[r3.length - 1];
                  a2 = new vy(n3);
                  for (let e4 = 0; e4 < n3 * n3; e4++) {
                    s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                    const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h2 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), f2 = t4.isLeaf(o2[0], o2[3]), d2 = Math.min(r4.min, i3.min, l2.min, u2.min), m2 = Math.max(r4.max, i3.max, l2.max, u2.max), y2 = c2 && h2 && p2 && f2;
                    a2.maximums.push(m2), a2.minimums.push(d2), a2.leaves.push(m2 - d2 <= 5 && y2 ? 1 : 0);
                  }
                  r3.push(a2);
                }
                return r3;
              }(this.dem), r2 = e2.length - 1, n2 = e2[r2];
              this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r2, 0);
            }
            raycastRoot(t2, e2, r2, n2, i2, s2, a2 = 1) {
              return wy([t2, e2, -100], [r2, n2, this.maximums[0] * a2], i2, s2);
            }
            raycast(t2, e2, r2, n2, i2, s2, a2 = 1) {
              if (!this.nodeCount)
                return null;
              const o2 = this.raycastRoot(t2, e2, r2, n2, i2, s2, a2);
              if (null == o2)
                return null;
              const l2 = [], u2 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
              for (; p2.length > 0; ) {
                const { idx: o3, t: f2, nodex: d2, nodey: m2, depth: y2 } = p2.pop();
                if (this.leaves[o3]) {
                  Ay(d2, m2, y2, t2, e2, r2, n2, c2, h2);
                  const o4 = 1 << y2, l3 = (d2 + 0) / o4, u3 = (d2 + 1) / o4, p3 = (m2 + 0) / o4, g3 = (m2 + 1) / o4, x2 = Py(l3, p3, this.dem) * a2, b2 = Py(u3, p3, this.dem) * a2, v2 = Py(u3, g3, this.dem) * a2, w2 = Py(l3, g3, this.dem) * a2, _2 = _y(c2[0], c2[1], x2, h2[0], c2[1], b2, h2[0], h2[1], v2, i2, s2), M2 = _y(h2[0], h2[1], v2, c2[0], h2[1], w2, c2[0], c2[1], x2, i2, s2), A2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== M2 ? M2 : Number.MAX_VALUE);
                  if (A2 !== Number.MAX_VALUE)
                    return A2;
                  {
                    const t3 = O.vec3.scaleAndAdd([], i2, s2, f2);
                    if (Iy(x2, b2, w2, v2, My(t3[0], c2[0], h2[0]), My(t3[1], c2[1], h2[1])) >= t3[2])
                      return f2;
                  }
                  continue;
                }
                let g2 = 0;
                for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                  Ay((d2 << 1) + this._siblingOffset[p3][0], (m2 << 1) + this._siblingOffset[p3][1], y2 + 1, t2, e2, r2, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
                  const f3 = wy(c2, h2, i2, s2);
                  if (null != f3) {
                    const t3 = f3;
                    l2[p3] = t3;
                    let e3 = false;
                    for (let r3 = 0; r3 < g2 && !e3; r3++)
                      t3 >= l2[u2[r3]] && (u2.splice(r3, 0, p3), e3 = true);
                    e3 || (u2[g2] = p3), g2++;
                  }
                }
                for (let t3 = 0; t3 < g2; t3++) {
                  const e3 = u2[t3];
                  p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (d2 << 1) + this._siblingOffset[e3][0], nodey: (m2 << 1) + this._siblingOffset[e3][1], depth: y2 + 1 });
                }
              }
              return null;
            }
            _addNode(t2, e2, r2) {
              return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t2, e2, r2, n2, i2) {
              if (1 === t2[n2].isLeaf(e2, r2))
                return;
              this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
              const s2 = n2 - 1, a2 = t2[s2];
              let o2 = 0, l2 = 0;
              for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
                const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
                u2 && (o2 |= 1 << t3), l2 || (l2 = c2);
              }
              for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
                o2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, l2 + n3);
            }
          }
          function Iy(t2, e2, r2, n2, i2, s2) {
            return ke(ke(t2, r2, s2), ke(e2, n2, s2), i2);
          }
          function Py(t2, e2, r2) {
            const n2 = r2.dim, i2 = Q(t2 * n2 - 0.5, 0, n2 - 1), s2 = Q(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
            return Iy(r2.get(a2, o2), r2.get(l2, o2), r2.get(a2, u2), r2.get(l2, u2), i2 - a2, s2 - o2);
          }
          const zy = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
          function ky(t2, e2, r2) {
            return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
          }
          function Ty(t2, e2, r2) {
            return 256 * t2 + e2 + r2 / 256 - 32768;
          }
          class Ey {
            get tree() {
              return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t2, e2, r2, n2 = false) {
              if (this.uid = t2, e2.height !== e2.width)
                throw new RangeError("DEM tiles must be square");
              if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
                return void ft(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e2.height;
              const i2 = this.dim = e2.height - 2, s2 = new Uint32Array(e2.data.buffer);
              if (this.pixels = new Uint8Array(e2.data.buffer), this.floatView = new Float32Array(e2.data.buffer), this.borderReady = n2, this._modifiedForSources = {}, !n2) {
                for (let t3 = 0; t3 < i2; t3++)
                  s2[this._idx(-1, t3)] = s2[this._idx(0, t3)], s2[this._idx(i2, t3)] = s2[this._idx(i2 - 1, t3)], s2[this._idx(t3, -1)] = s2[this._idx(t3, 0)], s2[this._idx(t3, i2)] = s2[this._idx(t3, i2 - 1)];
                s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(i2, -1)] = s2[this._idx(i2 - 1, 0)], s2[this._idx(-1, i2)] = s2[this._idx(0, i2 - 1)], s2[this._idx(i2, i2)] = s2[this._idx(i2 - 1, i2 - 1)];
              }
              const a2 = "terrarium" === r2 ? Ty : ky;
              for (let t3 = 0; t3 < s2.length; ++t3) {
                const e3 = 4 * t3;
                this.floatView[t3] = a2(this.pixels[e3], this.pixels[e3 + 1], this.pixels[e3 + 2]);
              }
              this._timestamp = Dt.now();
            }
            _buildQuadTree() {
              this._tree = new Sy(this);
            }
            get(t2, e2, r2 = false) {
              r2 && (t2 = Q(t2, -1, this.dim), e2 = Q(e2, -1, this.dim));
              const n2 = this._idx(t2, e2);
              return this.floatView[n2];
            }
            set(t2, e2, r2) {
              const n2 = this._idx(t2, e2), i2 = this.floatView[n2];
              return this.floatView[n2] = r2, r2 - i2;
            }
            static getUnpackVector(t2) {
              return zy[t2];
            }
            _idx(t2, e2) {
              if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e2 + 1) * this.stride + (t2 + 1);
            }
            static pack(t2, e2) {
              const r2 = [0, 0, 0, 0], n2 = Ey.getUnpackVector(e2);
              let i2 = Math.floor((t2 + n2[3]) / n2[2]);
              return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
            }
            getPixels() {
              return new sc({ width: this.stride, height: this.stride }, this.pixels);
            }
            backfillBorder(t2, e2, r2) {
              if (this.dim !== t2.dim)
                throw new Error("dem dimension mismatch");
              let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
              switch (e2) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r2) {
                case -1:
                  s2 = a2 - 1;
                  break;
                case 1:
                  a2 = s2 + 1;
              }
              const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
              for (let e3 = s2; e3 < a2; e3++)
                for (let r3 = n2; r3 < i2; r3++) {
                  const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l2);
                  this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
                }
            }
            onDeserialize() {
              this._tree && (this._tree.dem = this);
            }
          }
          function By(t2, e2, r2) {
            1 === t2 ? e2.header_length = r2.readFixed32() : 2 === t2 ? e2.x = r2.readVarint() : 3 === t2 ? e2.y = r2.readVarint() : 4 === t2 ? e2.z = r2.readVarint() : 5 === t2 && e2.layers.push(function(t3, e3) {
              return t3.readFields(Ly, { version: 0, name: "", units: "", tilesize: 0, buffer: 0, pixel_format: 0, data_index: [] }, e3);
            }(r2, r2.readVarint() + r2.pos));
          }
          function Vy(t2, e2, r2) {
            1 === t2 ? (e2.delta_filter = function(t3, e3) {
              return t3.readFields(Cy, { block_size: 0 }, e3);
            }(r2, r2.readVarint() + r2.pos), e2.filter = "delta_filter") : 2 === t2 ? (r2.readVarint(), e2.filter = "zigzag_filter") : 3 === t2 ? (r2.readVarint(), e2.filter = "bitshuffle_filter") : 4 === t2 && (r2.readVarint(), e2.filter = "byteshuffle_filter");
          }
          function Cy(t2, e2, r2) {
            1 === t2 && (e2.block_size = r2.readVarint());
          }
          function Ry(t2, e2, r2) {
            1 === t2 ? (r2.readVarint(), e2.codec = "gzip_data") : 2 === t2 ? (r2.readVarint(), e2.codec = "jpeg_image") : 3 === t2 ? (r2.readVarint(), e2.codec = "webp_image") : 4 === t2 && (r2.readVarint(), e2.codec = "png_image");
          }
          function Dy(t2, e2, r2) {
            1 === t2 ? e2.first_byte = r2.readFixed64() : 2 === t2 ? e2.last_byte = r2.readFixed64() : 3 === t2 ? e2.filters.push(function(t3, e3) {
              return t3.readFields(Vy, {}, e3);
            }(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.codec = function(t3, e3) {
              return t3.readFields(Ry, {}, e3);
            }(r2, r2.readVarint() + r2.pos) : 5 === t2 ? e2.deprecated_offset = r2.readFloat() : 6 === t2 ? e2.deprecated_scale = r2.readFloat() : 7 === t2 ? e2.bands.push(r2.readString()) : 8 === t2 ? e2.offset = r2.readDouble() : 9 === t2 && (e2.scale = r2.readDouble());
          }
          function Ly(t2, e2, r2) {
            1 === t2 ? e2.version = r2.readVarint() : 2 === t2 ? e2.name = r2.readString() : 3 === t2 ? e2.units = r2.readString() : 4 === t2 ? e2.tilesize = r2.readVarint() : 5 === t2 ? e2.buffer = r2.readVarint() : 6 === t2 ? e2.pixel_format = r2.readVarint() : 7 === t2 && e2.data_index.push(function(t3, e3) {
              return t3.readFields(Dy, { first_byte: 0, last_byte: 0, filters: [], codec: null, offset: 0, scale: 0, deprecated_offset: 0, deprecated_scale: 0, bands: [] }, e3);
            }(r2, r2.readVarint() + r2.pos));
          }
          function Fy(t2, e2, r2) {
            if (2 === t2)
              !function(t3, e3, r3) {
                t3.readFields(Oy, r3, e3);
              }(r2, r2.readVarint() + r2.pos, e2);
            else if (3 === t2)
              throw new Error("Not implemented");
          }
          function Oy(t2, e2, r2) {
            if (1 === t2) {
              let t3 = 0;
              const n2 = r2.readVarint() + r2.pos;
              for (; r2.pos < n2; )
                e2[t3++] = r2.readVarint();
            }
          }
          os(Ey, "DEMData"), os(Sy, "DemMinMaxQuadTree", { omit: ["dem"] });
          class Uy {
            constructor(t2) {
              this.capacity = t2, this.cache = /* @__PURE__ */ new Map();
            }
            get(t2) {
              if (!this.cache.has(t2))
                return;
              const e2 = this.cache.get(t2);
              return this.cache.delete(t2), this.cache.set(t2, e2), e2;
            }
            put(t2, e2) {
              this.cache.has(t2) ? this.cache.delete(t2) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t2, e2);
            }
          }
          function jy(t2, e2) {
            if (4 !== e2.length)
              throw new Error(`Expected data of dimension 4 but got ${e2.length}.`);
            let r2 = e2[3];
            for (let n2 = 2; n2 >= 1; n2--) {
              const i2 = 1 === n2 ? 1 : 0, s2 = 2 === n2 ? 1 : 0;
              for (let n3 = 0; n3 < e2[0]; n3++) {
                const a2 = e2[1] * n3;
                for (let n4 = i2; n4 < e2[1]; n4++) {
                  const i3 = e2[2] * (n4 + a2);
                  for (let n5 = s2; n5 < e2[2]; n5++) {
                    const s3 = e2[3] * (n5 + i3);
                    for (let n6 = 0; n6 < e2[3]; n6++) {
                      const e3 = s3 + n6;
                      t2[e3] += t2[e3 - r2];
                    }
                  }
                }
              }
              r2 *= e2[n2];
            }
            return t2;
          }
          function Ny(t2) {
            for (let e2 = 0, r2 = t2.length; e2 < r2; e2++)
              t2[e2] = t2[e2] >>> 1 ^ -(1 & t2[e2]);
            return t2;
          }
          function qy(t2, e2) {
            switch (e2) {
              case "uint32":
                return t2;
              case "uint16":
                for (let e3 = 0; e3 < t2.length; e3 += 2) {
                  const r2 = t2[e3], n2 = t2[e3 + 1];
                  t2[e3] = (240 & r2) >> 4 | (61440 & r2) >> 8 | (240 & n2) << 4 | 61440 & n2, t2[e3 + 1] = 15 & r2 | (3840 & r2) >> 4 | (15 & n2) << 8 | (3840 & n2) << 4;
                }
                return t2;
              case "uint8":
                for (let e3 = 0; e3 < t2.length; e3 += 4) {
                  const r2 = t2[e3], n2 = t2[e3 + 1], i2 = t2[e3 + 2], s2 = t2[e3 + 3];
                  t2[e3 + 0] = (192 & r2) >> 6 | (192 & n2) >> 4 | (192 & i2) >> 2 | 192 & s2, t2[e3 + 1] = (48 & r2) >> 4 | (48 & n2) >> 2 | 48 & i2 | (48 & s2) << 2, t2[e3 + 2] = (12 & r2) >> 2 | 12 & n2 | (12 & i2) << 2 | (12 & s2) << 4, t2[e3 + 3] = 3 & r2 | (3 & n2) << 2 | (3 & i2) << 4 | (3 & s2) << 6;
                }
                return t2;
              default:
                throw new Error(`Invalid pixel format, "${e2}"`);
            }
          }
          var $y = Uint8Array, Gy = Uint16Array, Xy = Int32Array, Yy = new $y([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Zy = new $y([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Wy = new $y([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Hy = function(t2, e2) {
            for (var r2 = new Gy(31), n2 = 0; n2 < 31; ++n2)
              r2[n2] = e2 += 1 << t2[n2 - 1];
            var i2 = new Xy(r2[30]);
            for (n2 = 1; n2 < 30; ++n2)
              for (var s2 = r2[n2]; s2 < r2[n2 + 1]; ++s2)
                i2[s2] = s2 - r2[n2] << 5 | n2;
            return { b: r2, r: i2 };
          }, Ky = Hy(Yy, 2), Jy = Ky.b, Qy = Ky.r;
          Jy[28] = 258, Qy[258] = 28;
          for (var tg = Hy(Zy, 0).b, eg = new Gy(32768), rg = 0; rg < 32768; ++rg) {
            var ng = (43690 & rg) >> 1 | (21845 & rg) << 1;
            eg[rg] = ((65280 & (ng = (61680 & (ng = (52428 & ng) >> 2 | (13107 & ng) << 2)) >> 4 | (3855 & ng) << 4)) >> 8 | (255 & ng) << 8) >> 1;
          }
          var ig = function(t2, e2, r2) {
            for (var n2 = t2.length, i2 = 0, s2 = new Gy(e2); i2 < n2; ++i2)
              t2[i2] && ++s2[t2[i2] - 1];
            var a2, o2 = new Gy(e2);
            for (i2 = 1; i2 < e2; ++i2)
              o2[i2] = o2[i2 - 1] + s2[i2 - 1] << 1;
            a2 = new Gy(1 << e2);
            var l2 = 15 - e2;
            for (i2 = 0; i2 < n2; ++i2)
              if (t2[i2])
                for (var u2 = i2 << 4 | t2[i2], c2 = e2 - t2[i2], h2 = o2[t2[i2] - 1]++ << c2, p2 = h2 | (1 << c2) - 1; h2 <= p2; ++h2)
                  a2[eg[h2] >> l2] = u2;
            return a2;
          }, sg = new $y(288);
          for (rg = 0; rg < 144; ++rg)
            sg[rg] = 8;
          for (rg = 144; rg < 256; ++rg)
            sg[rg] = 9;
          for (rg = 256; rg < 280; ++rg)
            sg[rg] = 7;
          for (rg = 280; rg < 288; ++rg)
            sg[rg] = 8;
          var ag = new $y(32);
          for (rg = 0; rg < 32; ++rg)
            ag[rg] = 5;
          var og = ig(sg, 9), lg = ig(ag, 5), ug = function(t2) {
            for (var e2 = t2[0], r2 = 1; r2 < t2.length; ++r2)
              t2[r2] > e2 && (e2 = t2[r2]);
            return e2;
          }, cg = function(t2, e2, r2) {
            var n2 = e2 / 8 | 0;
            return (t2[n2] | t2[n2 + 1] << 8) >> (7 & e2) & r2;
          }, hg = function(t2, e2) {
            var r2 = e2 / 8 | 0;
            return (t2[r2] | t2[r2 + 1] << 8 | t2[r2 + 2] << 16) >> (7 & e2);
          }, pg = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], fg = function(t2, e2, r2) {
            var n2 = new Error(e2 || pg[t2]);
            if (n2.code = t2, Error.captureStackTrace && Error.captureStackTrace(n2, fg), !r2)
              throw n2;
            return n2;
          }, dg = new $y(0), mg = "undefined" != typeof TextDecoder && new TextDecoder();
          try {
            mg.decode(dg, { stream: true });
          } catch (t2) {
          }
          const yg = { gzip_data: "gzip" };
          class gg extends Error {
            constructor(t2) {
              super(t2), this.name = "MRTError";
            }
          }
          const xg = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, bg = { uint32: 1, uint16: 2, uint8: 4 }, vg = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
          let wg;
          class _g {
            constructor(t2 = 5) {
              this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t2;
            }
            getLayer(t2) {
              const e2 = this.layers[t2];
              if (!e2)
                throw new gg(`Layer '${t2}' not found`);
              return e2;
            }
            getHeaderLength(t2) {
              const e2 = new Uint8Array(t2), r2 = new DataView(t2);
              if (13 !== e2[0])
                throw new gg("File is not a valid MRT.");
              return r2.getUint32(1, true);
            }
            parseHeader(t2) {
              const e2 = new Uint8Array(t2), r2 = this.getHeaderLength(t2);
              if (e2.length < r2)
                throw new gg(`Expected header with length >= ${r2} but got buffer of length ${e2.length}`);
              const n2 = function(t3, e3) {
                return t3.readFields(By, { header_length: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
              }(new wg(e2.subarray(0, r2)));
              if (!isNaN(this.x) && (this.x !== n2.x || this.y !== n2.y || this.z !== n2.z))
                throw new gg(`Invalid attempt to parse header ${n2.z}/${n2.x}/${n2.y} for tile ${this.z}/${this.x}/${this.y}`);
              this.x = n2.x, this.y = n2.y, this.z = n2.z;
              for (const t3 of n2.layers)
                this.layers[t3.name] = new Mg(t3, { cacheSize: this._cacheSize });
              return this;
            }
            createDecodingTask(t2) {
              const e2 = [], r2 = this.getLayer(t2.layerName);
              for (let n2 of t2.blockIndices) {
                const i2 = r2.dataIndex[n2], s2 = i2.first_byte - t2.firstByte, a2 = i2.last_byte - t2.firstByte;
                if (r2._blocksInProgress.has(n2))
                  continue;
                const o2 = { layerName: r2.name, firstByte: s2, lastByte: a2, pixelFormat: r2.pixelFormat, blockIndex: n2, blockShape: [i2.bands.length].concat(r2.bandShape), buffer: r2.buffer, codec: i2.codec.codec, filters: i2.filters.map((t3) => t3.filter) };
                r2._blocksInProgress.add(n2), e2.push(o2);
              }
              return new Ag(e2, () => {
                e2.forEach((t3) => r2._blocksInProgress.delete(t3.blockIndex));
              }, (t3, n2) => {
                if (e2.forEach((t4) => r2._blocksInProgress.delete(t4.blockIndex)), t3)
                  throw t3;
                n2.forEach((t4) => {
                  this.getLayer(t4.layerName).processDecodedData(t4);
                });
              });
            }
          }
          class Mg {
            constructor({ version: t2, name: e2, units: r2, tilesize: n2, pixel_format: i2, buffer: s2, data_index: a2 }, o2) {
              if (this.version = t2, 1 !== this.version)
                throw new gg(`Cannot parse raster layer encoded with MRT version ${t2}`);
              this.name = e2, this.units = r2, this.tileSize = n2, this.buffer = s2, this.pixelFormat = xg[i2], this.dataIndex = a2, this.bandShape = [n2 + 2 * s2, n2 + 2 * s2, bg[this.pixelFormat]], this._decodedBlocks = new Uy(o2 ? o2.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
            }
            get dimension() {
              return bg[this.pixelFormat];
            }
            get cacheSize() {
              return this._decodedBlocks.capacity;
            }
            getBandList() {
              return this.dataIndex.map(({ bands: t2 }) => t2).flat();
            }
            processDecodedData(t2) {
              const e2 = t2.blockIndex.toString();
              this._decodedBlocks.get(e2) || this._decodedBlocks.put(e2, t2.data);
            }
            getBlockForBand(t2) {
              let e2 = 0;
              switch (typeof t2) {
                case "string":
                  for (const [r2, n2] of this.dataIndex.entries()) {
                    for (const [i2, s2] of n2.bands.entries())
                      if (s2 === t2)
                        return { bandIndex: e2 + i2, blockIndex: r2, blockBandIndex: i2 };
                    e2 += n2.bands.length;
                  }
                  break;
                case "number":
                  for (const [r2, n2] of this.dataIndex.entries()) {
                    if (t2 >= e2 && t2 < e2 + n2.bands.length)
                      return { bandIndex: t2, blockIndex: r2, blockBandIndex: t2 - e2 };
                    e2 += n2.bands.length;
                  }
                  break;
                default:
                  throw new gg(`Invalid band \`${JSON.stringify(t2)}\`. Expected string or integer.`);
              }
              throw new gg(`Band not found: ${JSON.stringify(t2)}`);
            }
            getDataRange(t2) {
              let e2 = 1 / 0, r2 = -1 / 0;
              const n2 = [], i2 = /* @__PURE__ */ new Set();
              for (const s2 of t2) {
                const { blockIndex: t3 } = this.getBlockForBand(s2);
                if (t3 < 0)
                  throw new gg(`Invalid band: ${JSON.stringify(s2)}`);
                const a2 = this.dataIndex[t3];
                n2.includes(t3) || n2.push(t3), i2.add(t3), e2 = Math.min(e2, a2.first_byte), r2 = Math.max(r2, a2.last_byte);
              }
              if (i2.size > this.cacheSize)
                throw new gg(`Number of blocks to decode (${i2.size}) exceeds cache size (${this.cacheSize}).`);
              return { layerName: this.name, firstByte: e2, lastByte: r2, blockIndices: n2 };
            }
            hasBand(t2) {
              const { blockIndex: e2 } = this.getBlockForBand(t2);
              return e2 >= 0;
            }
            hasDataForBand(t2) {
              const { blockIndex: e2 } = this.getBlockForBand(t2);
              return e2 >= 0 && !!this._decodedBlocks.get(e2.toString());
            }
            getBandView(t2) {
              const { blockIndex: e2, blockBandIndex: r2 } = this.getBlockForBand(t2), n2 = this._decodedBlocks.get(e2.toString());
              if (!n2)
                throw new gg(`Data for band ${JSON.stringify(t2)} of layer "${this.name}" not decoded.`);
              const i2 = this.dataIndex[e2], s2 = this.bandShape.reduce((t3, e3) => t3 * e3, 1), a2 = r2 * s2, o2 = n2.subarray(a2, a2 + s2);
              return { data: o2, bytes: new Uint8Array(o2.buffer).subarray(o2.byteOffset, o2.byteOffset + o2.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: 0 !== i2.offset ? i2.offset : i2.deprecated_offset, scale: 0 !== i2.scale ? i2.scale : i2.deprecated_scale };
            }
          }
          _g.setPbf = function(t2) {
            wg = t2;
          };
          class Ag {
            constructor(t2, e2, r2) {
              this.tasks = t2, this._onCancel = e2, this._onComplete = r2, this._finalized = false;
            }
            cancel() {
              this._finalized || (this._onCancel(), this._finalized = true);
            }
            complete(t2, e2) {
              this._finalized || (this._onComplete(t2, e2), this._finalized = true);
            }
          }
          _g.performDecoding = function(t2, e2) {
            const r2 = new Uint8Array(t2);
            return Promise.all(e2.tasks.map((t3) => {
              const { layerName: e3, firstByte: n2, lastByte: i2, pixelFormat: s2, blockShape: a2, blockIndex: o2, filters: l2, codec: u2 } = t3, c2 = r2.subarray(n2, i2 + 1), h2 = new Uint32Array(a2[0] * a2[1] * a2[2]);
              let p2;
              if ("gzip_data" !== u2)
                throw new gg(`Unhandled codec: ${u2}`);
              return p2 = function(t4, e4) {
                if (!globalThis.DecompressionStream && "gzip_data" === e4)
                  return Promise.resolve(((s3 = function(t5) {
                    31 == t5[0] && 139 == t5[1] && 8 == t5[2] || fg(6, "invalid gzip data");
                    var e5 = t5[3], r4 = 10;
                    4 & e5 && (r4 += 2 + (t5[10] | t5[11] << 8));
                    for (var n4 = (e5 >> 3 & 1) + (e5 >> 4 & 1); n4 > 0; n4 -= !t5[r4++])
                      ;
                    return r4 + (2 & e5);
                  }(i3 = t4)) + 8 > i3.length && fg(6, "invalid gzip data"), function(t5, e5, r4, n4) {
                    var i4 = t5.length;
                    if (!i4 || e5.f && !e5.l)
                      return r4 || new $y(0);
                    var s4 = !r4, a4 = s4 || 2 != e5.i, o4 = e5.i;
                    s4 && (r4 = new $y(3 * i4));
                    var l3, u3, c3 = function(t6) {
                      var e6 = r4.length;
                      if (t6 > e6) {
                        var n5 = new $y(Math.max(2 * e6, t6));
                        n5.set(r4), r4 = n5;
                      }
                    }, h3 = e5.f || 0, p3 = e5.p || 0, f2 = e5.b || 0, d2 = e5.l, m2 = e5.d, y2 = e5.m, g2 = e5.n, x2 = 8 * i4;
                    do {
                      if (!d2) {
                        h3 = cg(t5, p3, 1);
                        var b2 = cg(t5, p3 + 1, 3);
                        if (p3 += 3, !b2) {
                          var v2 = t5[(E2 = 4 + ((p3 + 7) / 8 | 0)) - 4] | t5[E2 - 3] << 8, w2 = E2 + v2;
                          if (w2 > i4) {
                            o4 && fg(0);
                            break;
                          }
                          a4 && c3(f2 + v2), r4.set(t5.subarray(E2, w2), f2), e5.b = f2 += v2, e5.p = p3 = 8 * w2, e5.f = h3;
                          continue;
                        }
                        if (1 == b2)
                          d2 = og, m2 = lg, y2 = 9, g2 = 5;
                        else if (2 == b2) {
                          var _2 = cg(t5, p3, 31) + 257, M2 = cg(t5, p3 + 10, 15) + 4, A2 = _2 + cg(t5, p3 + 5, 31) + 1;
                          p3 += 14;
                          for (var S2 = new $y(A2), I2 = new $y(19), P2 = 0; P2 < M2; ++P2)
                            I2[Wy[P2]] = cg(t5, p3 + 3 * P2, 7);
                          p3 += 3 * M2;
                          var z2 = ug(I2), k2 = (1 << z2) - 1, T2 = ig(I2, z2);
                          for (P2 = 0; P2 < A2; ) {
                            var E2, B2 = T2[cg(t5, p3, k2)];
                            if (p3 += 15 & B2, (E2 = B2 >> 4) < 16)
                              S2[P2++] = E2;
                            else {
                              var V2 = 0, C2 = 0;
                              for (16 == E2 ? (C2 = 3 + cg(t5, p3, 3), p3 += 2, V2 = S2[P2 - 1]) : 17 == E2 ? (C2 = 3 + cg(t5, p3, 7), p3 += 3) : 18 == E2 && (C2 = 11 + cg(t5, p3, 127), p3 += 7); C2--; )
                                S2[P2++] = V2;
                            }
                          }
                          var R2 = S2.subarray(0, _2), D2 = S2.subarray(_2);
                          y2 = ug(R2), g2 = ug(D2), d2 = ig(R2, y2), m2 = ig(D2, g2);
                        } else
                          fg(1);
                        if (p3 > x2) {
                          o4 && fg(0);
                          break;
                        }
                      }
                      a4 && c3(f2 + 131072);
                      for (var L2 = (1 << y2) - 1, F2 = (1 << g2) - 1, O2 = p3; ; O2 = p3) {
                        var U2 = (V2 = d2[hg(t5, p3) & L2]) >> 4;
                        if ((p3 += 15 & V2) > x2) {
                          o4 && fg(0);
                          break;
                        }
                        if (V2 || fg(2), U2 < 256)
                          r4[f2++] = U2;
                        else {
                          if (256 == U2) {
                            O2 = p3, d2 = null;
                            break;
                          }
                          var j2 = U2 - 254;
                          U2 > 264 && (j2 = cg(t5, p3, (1 << ($2 = Yy[P2 = U2 - 257])) - 1) + Jy[P2], p3 += $2);
                          var N2 = m2[hg(t5, p3) & F2], q2 = N2 >> 4;
                          if (N2 || fg(3), p3 += 15 & N2, D2 = tg[q2], q2 > 3) {
                            var $2 = Zy[q2];
                            D2 += hg(t5, p3) & (1 << $2) - 1, p3 += $2;
                          }
                          if (p3 > x2) {
                            o4 && fg(0);
                            break;
                          }
                          a4 && c3(f2 + 131072);
                          var G2 = f2 + j2;
                          if (f2 < D2) {
                            var X2 = 0 - D2, Y2 = Math.min(D2, G2);
                            for (X2 + f2 < 0 && fg(3); f2 < Y2; ++f2)
                              r4[f2] = (void 0)[X2 + f2];
                          }
                          for (; f2 < G2; ++f2)
                            r4[f2] = r4[f2 - D2];
                        }
                      }
                      e5.l = d2, e5.p = O2, e5.b = f2, e5.f = h3, d2 && (h3 = 1, e5.m = y2, e5.d = m2, e5.n = g2);
                    } while (!h3);
                    return f2 != r4.length && s4 ? (l3 = r4, (null == (u3 = f2) || u3 > l3.length) && (u3 = l3.length), new $y(l3.subarray(0, u3))) : r4.subarray(0, f2);
                  }(i3.subarray(s3, -8), { i: 2 }, new $y(((r3 = i3)[(n3 = r3.length) - 4] | r3[n3 - 3] << 8 | r3[n3 - 2] << 16 | r3[n3 - 1] << 24) >>> 0))));
                var r3, n3, i3, s3;
                const a3 = yg[e4];
                if (!a3)
                  throw new Error(`Unhandled codec: ${e4}`);
                const o3 = new globalThis.DecompressionStream(a3);
                return new Response(new Blob([t4]).stream().pipeThrough(o3)).arrayBuffer().then((t5) => new Uint8Array(t5));
              }(c2, u2).then((t4) => (function(t5, e4) {
                t5.readFields(Fy, e4);
              }(new wg(t4), h2), new (0, vg[s2])(h2.buffer))), p2.then((t4) => {
                for (let e4 = l2.length - 1; e4 >= 0; e4--)
                  switch (l2[e4]) {
                    case "delta_filter":
                      jy(t4, a2);
                      break;
                    case "zigzag_filter":
                      Ny(t4);
                      break;
                    case "bitshuffle_filter":
                      qy(t4, s2);
                      break;
                    default:
                      throw new gg(`Unhandled filter "${l2[e4]}"`);
                  }
                return { layerName: e3, blockIndex: o2, data: t4 };
              }).catch((t4) => {
                throw t4;
              });
            }));
          }, os(Ag, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
          var Sg = { workerUrl: "", workerClass: null, workerParams: void 0 };
          const Ig = "mapboxgl_preloaded_worker_pool";
          class Pg {
            constructor() {
              this.active = {};
            }
            acquire(t2) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < Pg.workerCount; )
                  this.workers.push(null != Sg.workerClass ? new Sg.workerClass() : new self.Worker(Sg.workerUrl, Sg.workerParams));
              return this.active[t2] = true, this.workers.slice();
            }
            release(t2) {
              delete this.active[t2], this.workers && 0 === this.numActive() && (this.workers.forEach((t3) => {
                t3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[Ig];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          let zg;
          function kg() {
            return zg || (zg = new Pg()), zg;
          }
          Pg.workerCount = 2;
          let Tg, Eg, Bg, Vg, Cg, Rg = null;
          function Dg() {
            return gt() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Eg || It.DRACO_URL;
          }
          function Lg() {
            if (gt() && self.worker && self.worker.meshoptUrl)
              return self.worker.meshoptUrl;
            if (Vg)
              return Vg;
            const t2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
            if ("object" != typeof WebAssembly)
              throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
            return Vg = WebAssembly.validate(t2) ? It.MESHOPT_SIMD_URL : It.MESHOPT_URL, Vg;
          }
          const Fg = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Og = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, Ug = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
          function jg(t2, e2, r2) {
            const n2 = r2.json.bufferViews.length, i2 = r2.buffers.length;
            e2.bufferView = n2, r2.json.bufferViews[n2] = { buffer: i2, byteLength: t2.byteLength }, r2.buffers[i2] = t2;
          }
          const Ng = "KHR_draco_mesh_compression";
          function qg(t2, e2) {
            const r2 = t2.extensions && t2.extensions[Ng];
            if (!r2)
              return;
            const n2 = new Bg.Decoder(), i2 = Hg(e2, r2.bufferView), s2 = new Bg.Mesh();
            if (!n2.DecodeArrayToMesh(i2, i2.byteLength, s2))
              throw new Error("Failed to decode Draco mesh");
            const a2 = e2.json.accessors[t2.indices], o2 = Fg[a2.componentType], l2 = a2.count * o2.BYTES_PER_ELEMENT, u2 = Bg._malloc(l2);
            o2 === Uint16Array ? n2.GetTrianglesUInt16Array(s2, l2, u2) : n2.GetTrianglesUInt32Array(s2, l2, u2), jg(Bg.memory.buffer.slice(u2, u2 + l2), a2, e2), Bg._free(u2);
            for (const i3 of Object.keys(r2.attributes)) {
              const a3 = n2.GetAttributeByUniqueId(s2, r2.attributes[i3]), o3 = e2.json.accessors[t2.attributes[i3]], l3 = Og[o3.componentType], u3 = o3.count * Ug[o3.type] * Fg[o3.componentType].BYTES_PER_ELEMENT, c2 = Bg._malloc(u3);
              n2.GetAttributeDataArrayForAllPoints(s2, a3, Bg[l3], u3, c2), jg(Bg.memory.buffer.slice(c2, c2 + u3), o3, e2), Bg._free(c2);
            }
            n2.destroy(), s2.destroy(), delete t2.extensions[Ng];
          }
          const $g = "EXT_meshopt_compression";
          function Gg(t2, e2) {
            if (!t2.extensions || !t2.extensions[$g])
              return;
            const r2 = t2.extensions[$g], n2 = new Uint8Array(e2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength || 0), i2 = new Uint8Array(r2.count * r2.byteStride);
            Cg.decodeGltfBuffer(i2, r2.count, r2.byteStride, n2, r2.mode, r2.filter), t2.buffer = e2.buffers.length, t2.byteOffset = 0, e2.buffers[t2.buffer] = i2.buffer, delete t2.extensions[$g];
          }
          const Xg = 1179937895, Yg = new TextDecoder("utf8");
          function Zg(t2, e2) {
            return new URL(t2, e2).href;
          }
          function Wg(t2, e2, r2, n2) {
            return fetch(Zg(t2.uri, n2)).then((t3) => t3.arrayBuffer()).then((t3) => {
              e2.buffers[r2] = t3;
            });
          }
          function Hg(t2, e2) {
            const r2 = t2.json.bufferViews[e2];
            return new Uint8Array(t2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength);
          }
          function Kg(t2, e2, r2, n2) {
            if (t2.uri) {
              const i2 = Zg(t2.uri, n2);
              return fetch(i2).then((t3) => t3.blob()).then((t3) => createImageBitmap(t3)).then((t3) => {
                e2.images[r2] = t3;
              });
            }
            if (void 0 !== t2.bufferView) {
              const n3 = Hg(e2, t2.bufferView), i2 = new Blob([n3], { type: t2.mimeType });
              return createImageBitmap(i2).then((t3) => {
                e2.images[r2] = t3;
              });
            }
          }
          function Jg(t2, e2 = 0, r2) {
            const n2 = { json: null, images: [], buffers: [] };
            if (new Uint32Array(t2, e2, 1)[0] === Xg) {
              const r3 = new Uint32Array(t2, e2);
              let i3 = 2;
              const s3 = (r3[i3++] >> 2) - 3, a3 = r3[i3++] >> 2;
              if (i3++, n2.json = JSON.parse(Yg.decode(r3.subarray(i3, i3 + a3))), i3 += a3, i3 < s3) {
                const s4 = r3[i3++];
                i3++;
                const a4 = e2 + (i3 << 2);
                n2.buffers[0] = t2.slice(a4, a4 + s4);
              }
            } else
              n2.json = JSON.parse(Yg.decode(new Uint8Array(t2, e2)));
            const { buffers: i2, images: s2, meshes: a2, extensionsUsed: o2, bufferViews: l2 } = n2.json;
            let u2 = Promise.resolve();
            if (i2) {
              const t3 = [];
              for (let e3 = 0; e3 < i2.length; e3++) {
                const s3 = i2[e3];
                s3.uri ? t3.push(Wg(s3, n2, e3, r2)) : n2.buffers[e3] || (n2.buffers[e3] = null);
              }
              u2 = Promise.all(t3);
            }
            return u2.then(() => {
              const t3 = [], e3 = o2 && o2.includes(Ng), i3 = o2 && o2.includes($g);
              if (e3 && t3.push(function() {
                if (!Bg)
                  return null != Tg ? Tg : (Tg = function(t4) {
                    let e4, r3 = null;
                    function n3() {
                      e4 = new Uint8Array(r3.buffer);
                    }
                    function i4() {
                      throw new Error("Unexpected Draco error.");
                    }
                    const s3 = { a: { a: i4, d: function(t5, r4, n4) {
                      return e4.copyWithin(t5, r4, r4 + n4);
                    }, c: function(t5) {
                      const i5 = e4.length, s4 = Math.max(t5 >>> 0, Math.ceil(1.2 * i5)), a3 = Math.ceil((s4 - i5) / 65536);
                      try {
                        return r3.grow(a3), n3(), true;
                      } catch (t6) {
                        return false;
                      }
                    }, b: i4 } };
                    return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t4, s3) : t4.then((t5) => t5.arrayBuffer()).then((t5) => WebAssembly.instantiate(t5, s3))).then((t5) => {
                      const { Rb: i5, Qb: s4, P: a3, T: o3, X: l3, Ja: u3, La: c2, Qa: h2, Va: p2, Wa: f2, eb: d2, jb: m2, f: y2, e: g2, yb: x2, zb: b2, Ab: v2, Bb: w2, Db: _2, Gb: M2 } = t5.instance.exports;
                      r3 = g2;
                      const A2 = /* @__PURE__ */ (() => {
                        let t6 = 0, r4 = 0, n4 = 0, a4 = 0;
                        return (o4) => {
                          n4 && (i5(a4), i5(t6), r4 += n4, n4 = t6 = 0), t6 || (r4 += 128, t6 = s4(r4));
                          const l4 = o4.length + 7 & -8;
                          let u4 = t6;
                          l4 >= r4 && (n4 = l4, u4 = a4 = s4(l4));
                          for (let t7 = 0; t7 < o4.length; t7++)
                            e4[u4 + t7] = o4[t7];
                          return u4;
                        };
                      })();
                      return n3(), y2(), { memory: g2, _free: i5, _malloc: s4, Mesh: class {
                        constructor() {
                          this.ptr = a3();
                        }
                        destroy() {
                          o3(this.ptr);
                        }
                      }, Decoder: class {
                        constructor() {
                          this.ptr = u3();
                        }
                        destroy() {
                          m2(this.ptr);
                        }
                        DecodeArrayToMesh(t6, e5, r4) {
                          const n4 = A2(t6), i6 = c2(this.ptr, n4, e5, r4.ptr);
                          return !!l3(i6);
                        }
                        GetAttributeByUniqueId(t6, e5) {
                          return { ptr: h2(this.ptr, t6.ptr, e5) };
                        }
                        GetTrianglesUInt16Array(t6, e5, r4) {
                          p2(this.ptr, t6.ptr, e5, r4);
                        }
                        GetTrianglesUInt32Array(t6, e5, r4) {
                          f2(this.ptr, t6.ptr, e5, r4);
                        }
                        GetAttributeDataArrayForAllPoints(t6, e5, r4, n4, i6) {
                          d2(this.ptr, t6.ptr, e5.ptr, r4, n4, i6);
                        }
                      }, DT_INT8: x2(), DT_UINT8: b2(), DT_INT16: v2(), DT_UINT16: w2(), DT_UINT32: _2(), DT_FLOAT32: M2() };
                    });
                  }(fetch(Dg())), Tg.then((t4) => {
                    Bg = t4, Tg = void 0;
                  }));
              }()), i3 && t3.push(function() {
                if (Cg)
                  return;
                const t4 = function(t5) {
                  let e4;
                  const r3 = WebAssembly.instantiateStreaming(t5, {}).then((t6) => {
                    e4 = t6.instance, e4.exports.__wasm_call_ctors();
                  }), n3 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i4 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                  return { ready: r3, supported: true, decodeGltfBuffer(t6, r4, s3, a3, o3, l3) {
                    !function(t7, e5, r5, n4, i5, s4, a4) {
                      const o4 = t7.exports.sbrk, l4 = n4 + 3 & -4, u3 = o4(l4 * i5), c2 = o4(s4.length), h2 = new Uint8Array(t7.exports.memory.buffer);
                      h2.set(s4, c2);
                      const p2 = e5(u3, n4, i5, c2, s4.length);
                      if (0 === p2 && a4 && a4(u3, l4, i5), r5.set(h2.subarray(u3, u3 + n4 * i5)), o4(u3 - o4(0)), 0 !== p2)
                        throw new Error(`Malformed buffer data: ${p2}`);
                    }(e4, e4.exports[i4[o3]], t6, r4, s3, a3, e4.exports[n3[l3]]);
                  } };
                }(fetch(Lg()));
                return t4.ready.then(() => {
                  Cg = t4;
                });
              }()), s2)
                for (let e4 = 0; e4 < s2.length; e4++)
                  t3.push(Kg(s2[e4], n2, e4, r2));
              return (t3.length ? Promise.all(t3) : Promise.resolve()).then(() => {
                if (e3 && a2)
                  for (const { primitives: t4 } of a2)
                    for (const e4 of t4)
                      qg(e4, n2);
                if (i3 && a2 && l2)
                  for (const t4 of l2)
                    Gg(t4, n2);
                return n2;
              });
            });
          }
          function Qg(t2, e2) {
            const r2 = t2.json.bufferViews[e2.bufferView], n2 = Fg[e2.componentType];
            return new n2(t2.buffers[r2.buffer], (e2.byteOffset || 0) + (r2.byteOffset || 0), e2.count * (r2.byteStride && r2.byteStride !== Ug[e2.type] * n2.BYTES_PER_ELEMENT ? r2.byteStride / n2.BYTES_PER_ELEMENT : Ug[e2.type]));
          }
          function tx(t2, e2, r2, n2) {
            const i2 = Fg[e2.componentType], s2 = function(t3) {
              switch (t3) {
                case Int8Array:
                  return 1 / 127;
                case Uint8Array:
                  return 1 / 255;
                case Int16Array:
                  return 1 / 32767;
                case Uint16Array:
                  return 1 / 65535;
                default:
                  return 1;
              }
            }(i2), a2 = t2.json.bufferViews[e2.bufferView], o2 = a2.byteStride ? a2.byteStride / i2.BYTES_PER_ELEMENT : Ug[e2.type], l2 = r2.float32, u2 = l2.length / r2.capacity;
            for (let t3 = 0, r3 = 0; t3 < e2.count * o2; t3 += o2, r3 += u2)
              for (let e3 = 0; e3 < u2; e3++)
                l2[r3 + e3] = n2[t3 + e3] * s2;
            r2._trim();
          }
          function ex(t2, e2, r2) {
            const n2 = t2.indices, i2 = t2.attributes, s2 = {};
            s2.indexArray = new Da();
            const a2 = e2.json.accessors[n2], o2 = a2.count / 3;
            s2.indexArray.reserve(o2);
            const l2 = Qg(e2, a2);
            for (let t3 = 0; t3 < o2; t3++)
              s2.indexArray.emplaceBack(l2[3 * t3], l2[3 * t3 + 1], l2[3 * t3 + 2]);
            s2.indexArray._trim(), s2.vertexArray = new Aa();
            const u2 = e2.json.accessors[i2.POSITION];
            s2.vertexArray.reserve(u2.count);
            const c2 = Qg(e2, u2);
            for (let t3 = 0; t3 < u2.count; t3++)
              s2.vertexArray.emplaceBack(c2[3 * t3], c2[3 * t3 + 1], c2[3 * t3 + 2]);
            if (s2.vertexArray._trim(), s2.aabb = new yu(u2.min, u2.max), s2.centroid = function(t3, e3) {
              const r3 = [0, 0, 0], n3 = t3.length;
              if (n3 > 0) {
                for (let i3 = 0; i3 < n3; i3++) {
                  const n4 = 3 * t3[i3];
                  r3[0] += e3[n4], r3[1] += e3[n4 + 1], r3[2] += e3[n4 + 2];
                }
                r3[0] /= n3, r3[1] /= n3, r3[2] /= n3;
              }
              return r3;
            }(l2, c2), void 0 !== i2.COLOR_0) {
              const t3 = e2.json.accessors[i2.COLOR_0], r3 = Ug[t3.type], n3 = Qg(e2, t3);
              s2.colorArray = 3 === r3 ? new Aa() : new Ma(), s2.colorArray.resize(t3.count), tx(e2, t3, s2.colorArray, n3);
            }
            if (void 0 !== i2.NORMAL) {
              s2.normalArray = new Aa();
              const t3 = e2.json.accessors[i2.NORMAL];
              s2.normalArray.resize(t3.count);
              const r3 = Qg(e2, t3);
              tx(e2, t3, s2.normalArray, r3);
            }
            if (void 0 !== i2.TEXCOORD_0 && r2.length > 0) {
              s2.texcoordArray = new $a();
              const t3 = e2.json.accessors[i2.TEXCOORD_0];
              s2.texcoordArray.resize(t3.count);
              const r3 = Qg(e2, t3);
              tx(e2, t3, s2.texcoordArray, r3);
            }
            if (void 0 !== i2._FEATURE_ID_RGBA4444) {
              const t3 = e2.json.accessors[i2._FEATURE_ID_RGBA4444];
              e2.json.extensionsUsed && e2.json.extensionsUsed.includes("EXT_meshopt_compression") && (s2.featureData = Qg(e2, t3));
            }
            void 0 !== i2._FEATURE_RGBA4444 && (s2.featureData = new Uint32Array(Qg(e2, e2.json.accessors[i2._FEATURE_RGBA4444]).buffer));
            const h2 = t2.material;
            return s2.material = function(t3, e3) {
              const { emissiveFactor: r3 = [0, 0, 0], alphaMode: n3 = "OPAQUE", alphaCutoff: i3 = 0.5, normalTexture: s3, occlusionTexture: a3, emissiveTexture: o3, doubleSided: l3 } = t3, { baseColorFactor: u3 = [1, 1, 1, 1], metallicFactor: c3 = 1, roughnessFactor: h3 = 1, baseColorTexture: p2, metallicRoughnessTexture: f2 } = t3.pbrMetallicRoughness || {}, d2 = a3 ? e3[a3.index] : void 0;
              if (a3 && a3.extensions && a3.extensions.KHR_texture_transform && d2) {
                const t4 = a3.extensions.KHR_texture_transform;
                d2.offsetScale = [t4.offset[0], t4.offset[1], t4.scale[0], t4.scale[1]];
              }
              return { pbrMetallicRoughness: { baseColorFactor: new Pe(...u3), metallicFactor: c3, roughnessFactor: h3, baseColorTexture: p2 ? e3[p2.index] : void 0, metallicRoughnessTexture: f2 ? e3[f2.index] : void 0 }, doubleSided: l3, emissiveFactor: r3, alphaMode: n3, alphaCutoff: i3, normalTexture: s3 ? e3[s3.index] : void 0, occlusionTexture: d2, emissionTexture: o3 ? e3[o3.index] : void 0, defined: void 0 === t3.defined };
            }(void 0 !== h2 ? e2.json.materials[h2] : { defined: false }, r2), s2;
          }
          function rx(t2, e2, r2) {
            const { matrix: n2, rotation: i2, translation: s2, scale: a2, mesh: o2, extras: l2, children: u2 } = t2, c2 = {};
            if (c2.matrix = n2 || O.mat4.fromRotationTranslationScale([], i2 || [0, 0, 0, 1], s2 || [0, 0, 0], a2 || [1, 1, 1]), void 0 !== o2) {
              c2.meshes = r2[o2];
              const t3 = c2.anchor = [0, 0];
              for (const e3 of c2.meshes) {
                const { min: r3, max: n3 } = e3.aabb;
                t3[0] += r3[0] + n3[0], t3[1] += r3[1] + n3[1];
              }
              t3[0] = Math.floor(t3[0] / c2.meshes.length / 2), t3[1] = Math.floor(t3[1] / c2.meshes.length / 2);
            }
            if (l2 && (l2.id && (c2.id = l2.id), l2.lights && (c2.lights = function(t3) {
              if (!t3.length)
                return [];
              const e3 = function(t4) {
                const e4 = atob(t4), r4 = new Uint8Array(e4.length);
                for (let t5 = 0; t5 < e4.length; t5++)
                  r4[t5] = e4.codePointAt(t5);
                return r4;
              }(t3), r3 = [], n3 = e3.length / 24, i3 = new Uint16Array(e3.buffer), s3 = new Float32Array(e3.buffer);
              for (let t4 = 0; t4 < n3; t4++) {
                const e4 = i3[2 * t4 * 6] / 30, n4 = i3[2 * t4 * 6 + 1] / 30, a3 = i3[2 * t4 * 6 + 10] / 100, o3 = s3[6 * t4 + 1], l3 = s3[6 * t4 + 2], u3 = s3[6 * t4 + 3], c3 = s3[6 * t4 + 4], h2 = u3 - o3, p2 = c3 - l3, f2 = Math.hypot(h2, p2);
                r3.push({ pos: [o3 + 0.5 * h2, l3 + 0.5 * p2, n4], normal: [p2 / f2, -h2 / f2, 0], width: f2, height: e4, depth: a3, points: [o3, l3, u3, c3] });
              }
              return r3;
            }(l2.lights))), u2) {
              const t3 = [];
              for (const n3 of u2)
                t3.push(rx(e2.json.nodes[n3], e2, r2));
              c2.children = t3;
            }
            return c2;
          }
          function nx(t2) {
            if (0 === t2.vertices.length || 0 === t2.indices.length)
              return null;
            const e2 = new qc(t2.vertices, t2.indices, 8, 256), [r2, n2] = [e2.min.clone(), e2.max.clone()];
            return { vertices: t2.vertices, indices: t2.indices, grid: e2, min: r2, max: n2 };
          }
          function ix(t2) {
            if (!t2.extras || !t2.extras.ground)
              return null;
            const e2 = t2.extras.ground;
            if (!e2 || !Array.isArray(e2) || 0 === e2.length)
              return null;
            const r2 = e2[0];
            if (!r2 || !Array.isArray(r2) || 0 === r2.length)
              return null;
            const n2 = [];
            for (const t3 of r2) {
              if (!Array.isArray(t3) || 2 !== t3.length)
                continue;
              const e3 = t3[0], r3 = t3[1];
              "number" == typeof e3 && "number" == typeof r3 && n2.push(new q(e3, r3));
            }
            if (n2.length < 3)
              return null;
            n2.length > 1 && n2[n2.length - 1].equals(n2[0]) && n2.pop();
            let i2 = 0;
            for (let t3 = 0; t3 < n2.length; t3++) {
              const e3 = n2[t3], r3 = n2[(t3 + 1) % n2.length], s3 = n2[(t3 + 2) % n2.length];
              i2 += (e3.x - r3.x) * (s3.y - r3.y) - (s3.x - r3.x) * (e3.y - r3.y);
            }
            i2 > 0 && n2.reverse();
            const s2 = uc(n2.flatMap((t3) => [t3.x, t3.y]), []);
            return 0 === s2.length ? null : { vertices: n2, indices: s2 };
          }
          function sx(t2, e2) {
            const r2 = [], n2 = [];
            let i2 = 0;
            const s2 = [];
            for (const a2 of t2) {
              i2 = r2.length;
              const t3 = a2.vertexArray.float32, o2 = a2.indexArray.uint16;
              for (let n3 = 0; n3 < a2.vertexArray.length; n3++)
                s2[0] = t3[3 * n3 + 0], s2[1] = t3[3 * n3 + 1], s2[2] = t3[3 * n3 + 2], O.vec3.transformMat4(s2, s2, e2), r2.push(new q(s2[0], s2[1]));
              for (let t4 = 0; t4 < 3 * a2.indexArray.length; t4++)
                n2.push(o2[t4] + i2);
            }
            if (n2.length % 3 != 0)
              return null;
            for (let t3 = 0; t3 < n2.length; t3 += 3) {
              const e3 = r2[n2[t3 + 0]], i3 = r2[n2[t3 + 1]], s3 = r2[n2[t3 + 2]];
              (e3.x - i3.x) * (s3.y - i3.y) - (s3.x - i3.x) * (e3.y - i3.y) > 0 && ([n2[t3 + 1], n2[t3 + 2]] = [n2[t3 + 2], n2[t3 + 1]]);
            }
            return { vertices: r2, indices: n2 };
          }
          function ax(t2) {
            const e2 = function(t3, e3) {
              const r3 = [], n3 = WebGL2RenderingContext;
              if (t3.json.textures)
                for (const i3 of t3.json.textures) {
                  const s3 = { magFilter: n3.LINEAR, minFilter: n3.NEAREST, wrapS: n3.REPEAT, wrapT: n3.REPEAT };
                  void 0 !== i3.sampler && Object.assign(s3, t3.json.samplers[i3.sampler]), r3.push({ image: e3[i3.source], sampler: s3, uploaded: false });
                }
              return r3;
            }(t2, t2.images), r2 = function(t3, e3) {
              const r3 = [];
              for (const n3 of t3.json.meshes) {
                const i3 = [];
                for (const r4 of n3.primitives)
                  i3.push(ex(r4, t3, e3));
                r3.push(i3);
              }
              return r3;
            }(t2, e2), { scenes: n2, scene: i2, nodes: s2 } = t2.json, a2 = n2 ? n2[i2 || 0].nodes : s2, o2 = [];
            for (const e3 of a2)
              o2.push(rx(s2[e3], t2, r2));
            return function(t3, e3, r3) {
              const n3 = {}, i3 = /* @__PURE__ */ new Set();
              for (let s3 = 0; s3 < t3.length; s3++) {
                const t4 = r3[e3[s3]];
                if (!t4.extras)
                  continue;
                const a3 = t4.extras["mapbox:footprint:version"], o3 = t4.extras["mapbox:footprint:id"];
                (a3 || o3) && i3.add(s3), "1.0.0" === a3 && o3 && (n3[o3] = s3);
              }
              for (let s3 = 0; s3 < t3.length; s3++) {
                if (i3.has(s3))
                  continue;
                const a3 = t3[s3], o3 = r3[e3[s3]];
                if (!o3.extras)
                  continue;
                let l2 = null;
                a3.id in n3 && (l2 = sx(t3[n3[a3.id]].meshes, a3.matrix)), l2 || (l2 = ix(o3)), l2 && (a3.footprint = nx(l2));
              }
              if (i3.size > 0) {
                const e4 = Array.from(i3.values()).sort((t4, e5) => t4 - e5);
                for (let r4 = e4.length - 1; r4 >= 0; r4--)
                  t3.splice(e4[r4], 1);
              }
            }(o2, a2, t2.json.nodes), o2;
          }
          function ox(t2) {
            t2.heightmap = new Float32Array(4096), t2.heightmap.fill(-1);
            const e2 = t2.vertexArray.float32, r2 = t2.aabb.min[0] - 1, n2 = t2.aabb.min[1] - 1, i2 = Wm / (t2.aabb.max[0] - r2 + 2), s2 = Wm / (t2.aabb.max[1] - n2 + 2);
            for (let a2 = 0; a2 < e2.length; a2 += 3) {
              const o2 = e2[a2 + 2], l2 = (e2[a2 + 0] - r2) * i2 | 0, u2 = (e2[a2 + 1] - n2) * s2 | 0;
              o2 > t2.heightmap[u2 * Wm + l2] && (t2.heightmap[u2 * Wm + l2] = o2);
            }
          }
          function lx(t2, e2) {
            const r2 = {};
            r2.indexArray = new Da(), r2.indexArray.reserve(4 * t2.length), r2.vertexArray = new Aa(), r2.vertexArray.reserve(10 * t2.length), r2.colorArray = new Ma(), r2.vertexArray.reserve(10 * t2.length);
            let n2 = 0;
            for (const i3 of t2) {
              const t3 = Math.min(10, Math.max(4, 1.3 * i3.height)) * e2, s3 = [-i3.normal[1], i3.normal[0], 0], a2 = Math.min(0.29, 0.1 * i3.width / i3.depth), o2 = i3.width - 2 * i3.depth * e2 * (a2 + 0.01), l2 = O.vec3.scaleAndAdd([], i3.pos, s3, o2 / 2), u2 = O.vec3.scaleAndAdd([], i3.pos, s3, -o2 / 2), c2 = [l2[0], l2[1], l2[2] + i3.height], h2 = [u2[0], u2[1], u2[2] + i3.height], p2 = O.vec3.scaleAndAdd([], i3.normal, s3, a2);
              O.vec3.scale(p2, p2, t3);
              const f2 = O.vec3.scaleAndAdd([], i3.normal, s3, -a2);
              O.vec3.scale(f2, f2, t3), O.vec3.add(p2, l2, p2), O.vec3.add(f2, u2, f2), l2[2] += 0.1, u2[2] += 0.1, r2.vertexArray.emplaceBack(p2[0], p2[1], p2[2]), r2.vertexArray.emplaceBack(f2[0], f2[1], f2[2]), r2.vertexArray.emplaceBack(l2[0], l2[1], l2[2]), r2.vertexArray.emplaceBack(u2[0], u2[1], u2[2]), r2.vertexArray.emplaceBack(c2[0], c2[1], c2[2]), r2.vertexArray.emplaceBack(h2[0], h2[1], h2[2]), r2.vertexArray.emplaceBack(l2[0], l2[1], l2[2]), r2.vertexArray.emplaceBack(u2[0], u2[1], u2[2]), r2.vertexArray.emplaceBack(p2[0], p2[1], p2[2]), r2.vertexArray.emplaceBack(f2[0], f2[1], f2[2]);
              const d2 = o2 / t3 / 2;
              r2.colorArray.emplaceBack(-d2 - a2, -1, d2, 0.8), r2.colorArray.emplaceBack(d2 + a2, -1, d2, 0.8), r2.colorArray.emplaceBack(-d2, 0, d2, 1.3), r2.colorArray.emplaceBack(d2, 0, d2, 1.3), r2.colorArray.emplaceBack(d2 + a2, -0.8, d2, 0.7), r2.colorArray.emplaceBack(d2 + a2, -0.8, d2, 0.7), r2.colorArray.emplaceBack(0, 0, d2, 1.3), r2.colorArray.emplaceBack(0, 0, d2, 1.3), r2.colorArray.emplaceBack(d2 + a2, -1.2, d2, 0.8), r2.colorArray.emplaceBack(d2 + a2, -1.2, d2, 0.8), r2.indexArray.emplaceBack(6 + n2, 4 + n2, 8 + n2), r2.indexArray.emplaceBack(7 + n2, 9 + n2, 5 + n2), r2.indexArray.emplaceBack(0 + n2, 1 + n2, 2 + n2), r2.indexArray.emplaceBack(1 + n2, 3 + n2, 2 + n2), n2 += 10;
            }
            const i2 = { defined: true, emissiveFactor: [0, 0, 0] }, s2 = {};
            return s2.baseColorFactor = Pe.white, i2.pbrMetallicRoughness = s2, r2.material = i2, r2.aabb = new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r2;
          }
          class ux {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r2 = t2[e2];
                this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              return this._numberToString[t2];
            }
          }
          const cx = ["id", "tile", "layer", "source", "sourceLayer", "state"];
          class hx {
            constructor(t2, e2, r2, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r2, this._y = n2, this.properties = t2.properties, this.id = i2;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
              for (const e2 of cx)
                void 0 !== this[e2] && (t2[e2] = this[e2]);
              return t2;
            }
          }
          class px {
            constructor(t2, e2) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new ss2(Hr, 16, 0), this.featureIndexArray = new io(), this.promoteId = e2, this.is3DTile = false;
            }
            insert(t2, e2, r2, n2, i2, s2 = 0, a2 = 0) {
              const o2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
              const l2 = this.grid;
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r3.length; t4++) {
                  const e3 = r3[t4];
                  n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
                }
                0 !== a2 && (n3[0] -= a2, n3[1] -= a2, n3[2] += a2, n3[3] += a2), n3[0] < Hr && n3[1] < Hr && n3[2] >= 0 && n3[3] >= 0 && l2.insert(o2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              if (!this.vtLayers) {
                this.vtLayers = new ch.VectorTile(new of(this.rawTileData)).layers, this.sourceLayerCoder = new ux(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
                for (const t2 in this.vtLayers)
                  this.vtFeatures[t2] = [];
              }
              return this.vtLayers;
            }
            query(t2, e2, r2, n2) {
              this.loadVTLayers();
              const i2 = t2.params || {}, s2 = Hs(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r3, n3) => jl(a2.bufferedTilespaceGeometry, t3, e3, r3, n3));
              u2.sort(dx);
              let c2 = null;
              o2.elevation && u2.length > 0 && (c2 = ny.create(o2.elevation, this.tileID));
              const h2 = {};
              let p2;
              for (let l3 = 0; l3 < u2.length; l3++) {
                const f2 = u2[l3];
                if (f2 === p2)
                  continue;
                p2 = f2;
                const d2 = this.featureIndexArray.get(f2);
                let m2 = null;
                if (this.is3DTile) {
                  const t3 = this.bucketLayerIDs[0][0], r3 = e2[t3];
                  if ("model" !== r3.type)
                    continue;
                  const { queryFeature: n3, intersectionZ: i3 } = r3.queryIntersectsMatchingFeature(a2, d2.featureIndex, s2, o2);
                  n3 && this.appendToResult(h2, t3, d2.featureIndex, n3, i3);
                } else
                  this.loadMatchingFeature(h2, d2, s2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3, i3 = 0) => (m2 || (m2 = Il(e3, this.tileID.canonical, t2.tileTransform)), r3.queryIntersectsFeature(a2, e3, n3, m2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
              }
              return h2;
            }
            loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h2, layoutVertexArrayOffset: p2 } = e2, f2 = this.bucketLayerIDs[c2];
              if (n2 && !function(t3, e3) {
                for (let r3 = 0; r3 < t3.length; r3++)
                  if (e3.indexOf(t3[r3]) >= 0)
                    return true;
                return false;
              }(n2, f2))
                return;
              const d2 = this.sourceLayerCoder.decode(h2), m2 = this.vtLayers[d2].feature(u2);
              if (r2.needGeometry) {
                const t3 = Pl(m2, true);
                if (!r2.filter(new Vs(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  return;
              } else if (!r2.filter(new Vs(this.tileID.overscaledZ), m2))
                return;
              const y2 = this.getId(m2, d2);
              for (let e3 = 0; e3 < f2.length; e3++) {
                const r3 = f2[e3];
                if (n2 && n2.indexOf(r3) < 0)
                  continue;
                const c3 = s2[r3];
                if (!c3)
                  continue;
                let h3 = {};
                void 0 !== y2 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", y2));
                const d3 = !l2 || l2(m2, c3, h3, p2);
                if (!d3)
                  continue;
                const g2 = new hx(m2, this.z, this.x, this.y, y2), x2 = nt({}, a2[r3]);
                x2.paint = fx(x2.paint, c3.paint, m2, h3, i2), x2.layout = fx(x2.layout, c3.layout, m2, h3, i2), g2.layer = x2, this.appendToResult(t2, r3, u2, g2, d3);
              }
            }
            appendToResult(t2, e2, r2, n2, i2) {
              let s2 = t2[e2];
              void 0 === s2 && (s2 = t2[e2] = []), s2.push({ featureIndex: r2, feature: n2, intersectionZ: i2 });
            }
            lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = Hs(i2);
              for (const i3 of t2)
                this.loadMatchingFeature(l2, { bucketIndex: r2, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e2);
              return l2;
            }
            loadFeature(t2) {
              const { featureIndex: e2, sourceLayerIndex: r2 } = t2;
              this.loadVTLayers();
              const n2 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n2];
              if (i2[e2])
                return i2[e2];
              const s2 = this.vtLayers[n2].feature(e2);
              return i2[e2] = s2, s2;
            }
            hasLayer(t2) {
              for (const e2 of this.bucketLayerIDs)
                for (const r2 of e2)
                  if (t2 === r2)
                    return true;
              return false;
            }
            getId(t2, e2) {
              let r2 = t2.id;
              if (this.promoteId) {
                const n2 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2];
                null != n2 && (r2 = t2.properties[n2]), "boolean" == typeof r2 && (r2 = Number(r2));
              }
              return r2;
            }
          }
          function fx(t2, e2, r2, n2, i2) {
            return ut(t2, (t3, s2) => {
              const a2 = e2 instanceof js ? e2.get(s2) : null;
              return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
            });
          }
          function dx(t2, e2) {
            return e2 - t2;
          }
          os(px, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
          const mx = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          class yx {
            static from(t2) {
              if (!(t2 instanceof ArrayBuffer))
                throw new Error("Data must be an instance of ArrayBuffer.");
              const [e2, r2] = new Uint8Array(t2, 0, 2);
              if (219 !== e2)
                throw new Error("Data does not appear to be in a KDBush format.");
              const n2 = r2 >> 4;
              if (1 !== n2)
                throw new Error(`Got v${n2} data when expected v1.`);
              const i2 = mx[15 & r2];
              if (!i2)
                throw new Error("Unrecognized array type.");
              const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
              return new yx(a2, s2, i2, t2);
            }
            constructor(t2, e2 = 64, r2 = Float64Array, n2) {
              if (isNaN(t2) || t2 < 0)
                throw new Error(`Unpexpected numItems value: ${t2}.`);
              this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
              const i2 = mx.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
              if (i2 < 0)
                throw new Error(`Unexpected typed array class: ${r2}.`);
              n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
            }
            add(t2, e2) {
              const r2 = this._pos >> 1;
              return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
            }
            finish() {
              const t2 = this._pos >> 1;
              if (t2 !== this.numItems)
                throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
              return gx(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
            }
            range(t2, e2, r2, n2) {
              if (!this._finished)
                throw new Error("Data not yet indexed - call index.finish().");
              const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
              for (; o2.length; ) {
                const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
                if (c2 - h2 <= a2) {
                  for (let a3 = h2; a3 <= c2; a3++) {
                    const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                    o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i2[a3]);
                  }
                  continue;
                }
                const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
                f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (0 === u2 ? t2 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
              }
              return l2;
            }
            within(t2, e2, r2) {
              if (!this._finished)
                throw new Error("Data not yet indexed - call index.finish().");
              const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
              for (; a2.length; ) {
                const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
                if (c2 - h2 <= s2) {
                  for (let r3 = h2; r3 <= c2; r3++)
                    wx(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
                  continue;
                }
                const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
                wx(f2, d2, t2, e2) <= l2 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
              }
              return o2;
            }
          }
          function gx(t2, e2, r2, n2, i2, s2) {
            if (i2 - n2 <= r2)
              return;
            const a2 = n2 + i2 >> 1;
            xx(t2, e2, a2, n2, i2, s2), gx(t2, e2, r2, n2, a2 - 1, 1 - s2), gx(t2, e2, r2, a2 + 1, i2, 1 - s2);
          }
          function xx(t2, e2, r2, n2, i2, s2) {
            for (; i2 > n2; ) {
              if (i2 - n2 > 600) {
                const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
                xx(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
              }
              const a2 = e2[2 * r2 + s2];
              let o2 = n2, l2 = i2;
              for (bx(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && bx(t2, e2, n2, i2); o2 < l2; ) {
                for (bx(t2, e2, o2, l2), o2++, l2--; e2[2 * o2 + s2] < a2; )
                  o2++;
                for (; e2[2 * l2 + s2] > a2; )
                  l2--;
              }
              e2[2 * n2 + s2] === a2 ? bx(t2, e2, n2, l2) : (l2++, bx(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
            }
          }
          function bx(t2, e2, r2, n2) {
            vx(t2, r2, n2), vx(e2, 2 * r2, 2 * n2), vx(e2, 2 * r2 + 1, 2 * n2 + 1);
          }
          function vx(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function wx(t2, e2, r2, n2) {
            const i2 = t2 - r2, s2 = e2 - n2;
            return i2 * i2 + s2 * s2;
          }
          t.$ = Ds, t.A = class extends Nm {
          }, t.B = hr, t.C = Be, t.D = Ys, t.E = Me, t.F = Oi, t.G = Di, t.H = Fi, t.I = Of, t.J = Wi, t.K = Zs, t.L = Qi, t.M = Hi, t.N = Bn, t.O = Cn, t.P = q, t.Q = En, t.R = ee, t.S = yr, t.T = lm, t.U = Ie, t.V = Nm, t.W = Ws, t.X = Ui, t.Y = Li, t.Z = function(t2) {
            const e2 = t2.value;
            let r2 = [];
            if (!e2)
              return r2;
            const n2 = hr(e2);
            return "string" !== n2 ? (r2 = r2.concat([new Nm(t2.key, e2, `string expected, "${n2}" found`)]), r2) : (qm(e2, true) || (r2 = r2.concat([new Nm(t2.key, e2, `invalid url "${e2}"`)])), r2);
          }, t._ = Xs, t.a = function(t2) {
            return It.API_CDN_URL_REGEX.test(t2);
          }, t.a$ = qa, t.a0 = Gs, t.a1 = Ns, t.a2 = class {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return yt(t2.expression.evaluate(e2));
            }
            interpolate(t2, e2, r2) {
              return { x: ke(t2.x, e2.x, r2), y: ke(t2.y, e2.y, r2), z: ke(t2.z, e2.z, r2), azimuthal: ke(t2.azimuthal, e2.azimuthal, r2), polar: ke(t2.polar, e2.polar, r2) };
            }
          }, t.a3 = Vs, t.a4 = Ji, t.a5 = xl, t.a6 = O, t.a7 = tt, t.a8 = js, t.a9 = Du, t.aA = ru, t.aB = mm, t.aC = wm, t.aD = fm, t.aE = function(t2, e2) {
            const r2 = document.createElement("video");
            r2.muted = true, r2.onloadstart = function() {
              e2(null, r2);
            };
            for (let e3 = 0; e3 < t2.length; e3++) {
              const n2 = document.createElement("source");
              ae(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
            }
            return { cancel: () => {
            } };
          }, t.aF = um, t.aG = function(t2) {
            return fetch(t2).then((t3) => t3.arrayBuffer()).then((e2) => Jg(e2, 0, t2));
          }, t.aH = ax, t.aI = class {
            constructor(t2, e2, r2, n2) {
              this.id = t2, this.position = null != e2 ? new rl(e2[0], e2[1]) : new rl(0, 0), this.orientation = null != r2 ? r2 : [0, 0, 0], this.nodes = n2, this.uploaded = false, this.aabb = new yu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
            }
            _applyTransformations(t2, e2) {
              if (O.mat4.multiply(t2.matrix, e2, t2.matrix), t2.meshes)
                for (const e3 of t2.meshes) {
                  const r2 = yu.applyTransformFast(e3.aabb, t2.matrix);
                  this.aabb.encapsulate(r2);
                }
              if (t2.children)
                for (const e3 of t2.children)
                  this._applyTransformations(e3, t2.matrix);
            }
            computeBoundsAndApplyParent() {
              const t2 = O.mat4.identity([]);
              for (const e2 of this.nodes)
                this._applyTransformations(e2, t2);
            }
            computeModelMatrix(t2, e2, r2, n2, i2, s2, a2 = false) {
              Km(this.matrix, this, t2.transform, this.position, e2, r2, n2, i2, s2, a2);
            }
            upload(t2) {
              if (!this.uploaded) {
                for (const e2 of this.nodes)
                  ty(e2, t2);
                for (const t3 of this.nodes)
                  ey(t3);
                this.uploaded = true;
              }
            }
            destroy() {
              for (const t2 of this.nodes)
                ry(t2);
            }
          }, t.aJ = ot, t.aK = yd, t.aL = cl, t.aM = hl, t.aN = va, t.aO = Da, t.aP = st, t.aQ = Ha, t.aR = Zd, t.aS = function() {
            Bs.isLoading() || Bs.isLoaded() || "deferred" !== Ts() || Es();
          }, t.aT = Hs, t.aU = Pl, t.aV = hx, t.aW = xt, t.aX = wp, t.aY = Fc, t.aZ = Il, t.a_ = xa, t.aa = ke, t.ab = Hr, t.ac = Te, t.ad = class {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return function([t3, e3]) {
                const r2 = yt([1, t3, e3]);
                return { x: r2.x, y: r2.y, z: r2.z };
              }(t2.expression.evaluate(e2));
            }
            interpolate(t2, e2, r2) {
              return { x: ke(t2.x, e2.x, r2), y: ke(t2.y, e2.y, r2), z: ke(t2.z, e2.z, r2) };
            }
          }, t.ae = function(t2, e2, r2 = 0, n2 = true) {
            const i2 = new q(r2, r2), s2 = t2.sub(i2), a2 = e2.add(i2), o2 = [s2, new q(a2.x, s2.y), a2, new q(s2.x, a2.y)];
            return n2 && o2.push(s2.clone()), o2;
          }, t.af = function(t2, e2) {
            const r2 = [];
            for (let n2 = 0; n2 < t2.length; n2++) {
              const i2 = et(n2 - 1, -1, t2.length - 1), s2 = et(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h2 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
              r2.push(a2.add(h2));
            }
            return r2;
          }, t.ag = gd, t.ah = jl, t.ai = function(t2, e2, r2 = 0) {
            return O.vec3.fromValues(((e2.x - r2) * t2.scale - t2.x) * Hr, (e2.y * t2.scale - t2.y) * Hr, pl(e2.z, e2.y));
          }, t.aj = uu, t.ak = Sp, t.al = function(t2) {
            let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const s2 of t2)
              e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            return { min: new q(e2, r2), max: new q(n2, i2) };
          }, t.am = ol, t.an = Ul, t.ao = vl, t.ap = Q, t.aq = $o, t.ar = function(t2, e2) {
            const r2 = {};
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.as = nl, t.at = ll, t.au = class {
            constructor(t2) {
              this.entries = {}, this.scheduler = t2;
            }
            request(t2, e2, r2, n2) {
              const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
              if (i2.result) {
                const [t3, r3] = i2.result;
                return this.scheduler ? this.scheduler.add(() => {
                  n2(t3, r3);
                }, e2) : n2(t3, r3), () => {
                };
              }
              return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
                i2.result = [r3, n3];
                for (const t3 of i2.callbacks)
                  this.scheduler ? this.scheduler.add(() => {
                    t3(r3, n3);
                  }, e2) : t3(r3, n3);
                setTimeout(() => delete this.entries[t2], 3e3);
              })), () => {
                i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
              };
            }
          }, t.av = ua, t.aw = function(t2, e2, r2) {
            const n2 = JSON.stringify(t2.request);
            return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
              const n3 = se(t2.request, (t3, n4, i2, s2) => {
                t3 ? e3(t3) : n4 && e3(null, { vectorTile: r2 ? void 0 : new ch.VectorTile(new of(n4)), rawData: n4, cacheControl: i2, expires: s2 });
              });
              return () => {
                n3.cancel(), e3();
              };
            }, e2);
          }, t.ax = function(t2) {
            Yt++, Yt > jt && (t2.getActor().send("enforceCacheSizeLimit", Ut), Yt = 0);
          }, t.ay = Rt, t.az = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
          }, t.b = function(t2) {
            return It.API_FONTS_REGEX.test(t2);
          }, t.b$ = function(t2) {
            const { x: e2, y: r2 } = t2.point, { lng: n2, lat: i2 } = t2._center;
            return Ru(e2, r2, t2.worldSize, n2, i2);
          }, t.b0 = lu, t.b1 = co, t.b2 = uc, t.b3 = sm, t.b4 = function(t2, e2) {
            const r2 = Du(e2.zoom);
            if (0 === r2)
              return _u(t2);
            const n2 = Iu(t2), i2 = Pu(n2), s2 = ol(n2.getWest()) * e2.worldSize, a2 = ol(n2.getEast()) * e2.worldSize, o2 = ll(n2.getNorth()) * e2.worldSize, l2 = ll(n2.getSouth()) * e2.worldSize, u2 = [s2, o2, 0], c2 = [a2, o2, 0], h2 = [s2, l2, 0], p2 = [a2, l2, 0], f2 = O.mat4.invert([], e2.globeMatrix);
            return O.vec3.transformMat4(u2, u2, f2), O.vec3.transformMat4(c2, c2, f2), O.vec3.transformMat4(h2, h2, f2), O.vec3.transformMat4(p2, p2, f2), i2[0] = Mu(i2[0], h2, r2), i2[1] = Mu(i2[1], p2, r2), i2[2] = Mu(i2[2], c2, r2), i2[3] = Mu(i2[3], u2, r2), yu.fromPoints(i2);
          }, t.b5 = Eu, t.b6 = zu, t.b7 = Mu, t.b8 = ba, t.b9 = ou, t.bA = et, t.bB = Y, t.bC = wt, t.bD = ul, t.bE = function(t2, e2, r2) {
            t2[4 * e2 + 0] = r2[0], t2[4 * e2 + 1] = r2[1], t2[4 * e2 + 2] = r2[2], t2[4 * e2 + 3] = r2[3];
          }, t.bF = Po, t.bG = _o, t.bH = Mo, t.bI = wo, t.bJ = vo, t.bK = rl, t.bL = Fd, t.bM = eu, t.bN = mu, t.bO = Sm, t.bP = tu, t.bQ = Su, t.bR = function(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            if ("globe" === l2.name)
              return Su(t2, e2, new tu(r2, n2, i2), false);
            const u2 = yd({ z: r2, x: n2, y: i2 }, l2);
            return new yu([(s2 + u2.x / u2.scale) * e2, e2 * (u2.y / u2.scale), a2], [(s2 + u2.x2 / u2.scale) * e2, e2 * (u2.y2 / u2.scale), o2]);
          }, t.bS = function(t2, e2, r2) {
            let n2 = 0;
            for (let r3 = 0; r3 < 2; ++r3) {
              const i2 = 0;
              t2[r3] > i2 && (n2 += (t2[r3] - i2) * (t2[r3] - i2)), e2[r3] < i2 && (n2 += (i2 - e2[r3]) * (i2 - e2[r3]));
            }
            return n2;
          }, t.bT = fl, t.bU = Xo, t.bV = function(t2) {
            const e2 = O.mat4.identity(new Float64Array(16));
            O.mat4.multiply(e2, t2.pixelMatrix, t2.globeMatrix);
            const r2 = [0, Ho, 0], n2 = [0, Ko, 0];
            return O.vec3.transformMat4(r2, r2, e2), O.vec3.transformMat4(n2, n2, e2), [r2[0] > 0 && r2[0] <= t2.width && r2[1] > 0 && r2[1] <= t2.height && !Fu(t2, new rl(t2.center.lat, 90)), n2[0] > 0 && n2[0] <= t2.width && n2[1] > 0 && n2[1] <= t2.height && !Fu(t2, new rl(t2.center.lat, -90))];
          }, t.bW = function(t2, e2) {
            const { scale: r2 } = t2.tileTransform, n2 = r2 * Hr / (t2.tileSize * Math.pow(2, e2.zoom - t2.tileID.overscaledZ + t2.tileID.canonical.z));
            return O.mat2.scale(new Float32Array(4), e2.inverseAdjustmentMatrix, [n2, n2]);
          }, t.bX = Im, t.bY = Am, t.bZ = function(t2) {
            const e2 = Am(t2, true);
            return O.mat2.invert([], [e2[0], e2[1], e2[4], e2[5]]);
          }, t.b_ = cu, t.ba = _g, t.bb = of, t.bc = se, t.bd = function(t2) {
            const e2 = [];
            for (const r2 in t2)
              e2.push(t2[r2]);
            return e2;
          }, t.be = function(t2, e2) {
            const r2 = [];
            for (const n2 in t2)
              n2 in e2 || r2.push(n2);
            return r2;
          }, t.bf = rt, t.bg = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.bh = $, t.bi = function(t2, e2) {
            const { x: r2, y: n2 } = t2.point, i2 = Ru(r2, n2, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
            return O.mat4.multiply(i2, i2, Bu(_u(e2)));
          }, t.bj = Zp, t.bk = ff, t.bl = Yp, t.bm = function(t2, e2, r2, n2, i2) {
            const s2 = 5 * e2 + 2;
            t2.float32[s2 + 0] = r2, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
          }, t.bn = $d, t.bo = Df, t.bp = El, t.bq = $p, t.br = gh, t.bs = jm, t.bt = Ih, t.bu = Ph, t.bv = ad, t.bw = sd, t.bx = Af, t.by = yx, t.bz = Pe, t.c = zt, t.c$ = iu, t.c0 = Z, t.c1 = nu, t.c2 = Go, t.c3 = function(t2) {
            const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
            return W[e2];
          }, t.c4 = 45, t.c5 = al, t.c6 = Ao, t.c7 = function(t2, e2, r2) {
            const n2 = Math.sqrt(t2 * t2 + e2 * e2 + r2 * r2), i2 = n2 > 0 ? Math.acos(r2 / n2) * X : 0;
            let s2 = 0 !== t2 || 0 !== e2 ? Math.atan2(-e2, -t2) * X + 90 : 0;
            return s2 < 0 && (s2 += 360), [n2, s2, i2];
          }, t.c8 = gl, t.c9 = yu, t.cA = function(t2) {
            const e2 = fl - 5;
            t2 = Q(t2, -e2, e2) / e2 * 90;
            const r2 = Math.pow(Math.abs(Math.sin(Y(t2))), 3);
            return Math.round(r2 * (Wo.length - 1));
          }, t.cB = function(t2, e2, r2, n2) {
            const i2 = e2.getNorth(), s2 = e2.getSouth(), a2 = e2.getWest(), o2 = e2.getEast(), l2 = 1 << t2.z, u2 = o2 - a2, c2 = i2 - s2, h2 = u2 / Zo, p2 = -c2 / Wo[r2], f2 = [0, h2, 0, p2, 0, 0, i2, a2, 0];
            if (t2.z > 0) {
              const t3 = 180 / n2;
              O.mat3.multiply(f2, f2, [t3 / u2 + 1, 0, 0, 0, t3 / c2 + 1, 0, -0.5 * t3 / h2, 0.5 * t3 / p2, 1]);
            }
            return f2[2] = l2, f2[5] = t2.x, f2[8] = t2.y, f2;
          }, t.cC = _u, t.cD = function(t2, e2, r2) {
            const n2 = O.mat4.identity(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
            return O.mat4.rotateY(n2, r2.globeMatrix, i2), Float32Array.from(n2);
          }, t.cE = class {
            isDataAvailableAtPoint(t2) {
              const e2 = this._source();
              if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1)
                return false;
              const r2 = e2.getSource().maxzoom, n2 = 1 << r2, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), a2 = Math.floor(t2.y * n2), o2 = this.findDEMTileFor(new ru(r2, i2, r2, s2, a2));
              return !(!o2 || !o2.dem);
            }
            getAtPointOrZero(t2, e2 = 0) {
              return this.getAtPoint(t2, e2) || 0;
            }
            getAtPoint(t2, e2, r2 = true) {
              if (this.isUsingMockSource())
                return null;
              null == e2 && (e2 = null);
              const n2 = this._source();
              if (!n2)
                return e2;
              if (t2.y < 0 || t2.y > 1)
                return e2;
              const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new ru(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
              if (!u2 || !u2.dem)
                return e2;
              const c2 = u2.dem, h2 = 1 << u2.tileID.canonical.z, p2 = (o2 * h2 - u2.tileID.canonical.x) * c2.dim, f2 = (t2.y * h2 - u2.tileID.canonical.y) * c2.dim, d2 = Math.floor(p2), m2 = Math.floor(f2);
              return (r2 ? this.exaggeration() : 1) * ke(ke(c2.get(d2, m2), c2.get(d2, m2 + 1), f2 - m2), ke(c2.get(d2 + 1, m2), c2.get(d2 + 1, m2 + 1), f2 - m2), p2 - d2);
            }
            getAtTileOffset(t2, e2, r2) {
              const n2 = 1 << t2.canonical.z;
              return this.getAtPointOrZero(new xl(t2.wrap + (t2.canonical.x + e2 / Hr) / n2, (t2.canonical.y + r2 / Hr) / n2));
            }
            getAtTileOffsetFunc(t2, e2, r2, n2) {
              return (i2) => {
                const s2 = this.getAtTileOffset(t2, i2.x, i2.y), a2 = n2.upVector(t2.canonical, i2.x, i2.y), o2 = n2.upVectorScale(t2.canonical, e2, r2).metersToTile;
                return O.vec3.scale(a2, a2, s2 * o2), a2;
              };
            }
            getForTilePoints(t2, e2, r2, n2) {
              if (this.isUsingMockSource())
                return false;
              const i2 = ny.create(this, t2, n2);
              return !!i2 && (e2.forEach((t3) => {
                t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
              }), true);
            }
            getMinMaxForTile(t2) {
              if (this.isUsingMockSource())
                return null;
              const e2 = this.findDEMTileFor(t2);
              if (!e2 || !e2.dem)
                return null;
              const r2 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
              let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
              for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[o2]; e3++) {
                s2 *= 2, a2 *= 2;
                const t3 = 2 * Math.floor(a2) + Math.floor(s2);
                o2 = r2.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
              }
              return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
            }
            getMinElevationBelowMSL() {
              throw new Error("Pure virtual method called.");
            }
            raycast(t2, e2, r2) {
              throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t2) {
              throw new Error("Pure virtual method called.");
            }
            _source() {
              throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
              throw new Error("Pure virtual method called.");
            }
            exaggeration() {
              throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t2) {
              throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
              throw new Error("Getter must be implemented in subclass.");
            }
            getMinMaxForVisibleTiles() {
              const t2 = this.visibleDemTiles;
              if (0 === t2.length)
                return null;
              let e2 = false, r2 = Number.MAX_VALUE, n2 = Number.MIN_VALUE;
              for (const i2 of t2) {
                const t3 = this.getMinMaxForTile(i2.tileID);
                t3 && (r2 = Math.min(r2, t3.min), n2 = Math.max(n2, t3.max), e2 = true);
              }
              return e2 ? { min: r2, max: n2 } : null;
            }
          }, t.cF = sc, t.cG = gu, t.cH = function(t2, e2) {
            return [Math.pow(t2[0], 2.2) * e2, Math.pow(t2[1], 2.2) * e2, Math.pow(t2[2], 2.2) * e2];
          }, t.cI = Cu, t.cJ = St, t.cK = At, t.cL = 256, t.cM = function(t2, e2) {
            const r2 = [0, 0, 0], n2 = Eu(_u(e2.canonical));
            return O.vec3.transformMat4(r2, r2, n2), O.vec3.transformMat4(r2, r2, t2), r2;
          }, t.cN = (t2) => ({ u_camera_to_center_distance: new wo(t2), u_extrude_scale: new To(t2), u_device_pixel_ratio: new wo(t2), u_matrix: new Po(t2), u_inv_rot_matrix: new Po(t2), u_merc_center: new _o(t2), u_tile_id: new Mo(t2), u_zoom_transition: new wo(t2), u_up_dir: new Mo(t2), u_emissive_strength: new wo(t2) }), t.cO = (t2) => ({ u_matrix: new Po(t2), u_pixels_to_tile_units: new To(t2), u_device_pixel_ratio: new wo(t2), u_units_to_pixels: new _o(t2), u_dash_image: new vo(t2), u_gradient_image: new vo(t2), u_image_height: new wo(t2), u_texsize: new _o(t2), u_tile_units_to_pixels: new wo(t2), u_alpha_discard_threshold: new wo(t2), u_trim_offset: new _o(t2), u_trim_fade_range: new _o(t2), u_trim_color: new Ao(t2), u_emissive_strength: new wo(t2) }), t.cP = (t2) => ({ u_matrix: new Po(t2), u_texsize: new _o(t2), u_pixels_to_tile_units: new To(t2), u_device_pixel_ratio: new wo(t2), u_image: new vo(t2), u_units_to_pixels: new _o(t2), u_tile_units_to_pixels: new wo(t2), u_alpha_discard_threshold: new wo(t2), u_trim_offset: new _o(t2) }), t.cQ = Ca, t.cR = qp, t.cS = Wp, t.cT = qu, t.cU = (t2, e2, r2, n2, i2, s2) => {
            const a2 = t2.transform, o2 = "globe" === a2.projection.name;
            let l2;
            if ("map" === s2.paint.get("circle-pitch-alignment"))
              if (o2) {
                const t3 = Cu(a2.zoom, e2.canonical) * a2._pixelsPerMercatorPixel;
                l2 = Float32Array.from([t3, 0, 0, t3]);
              } else
                l2 = a2.calculatePixelsToTileUnitsMatrix(r2);
            else
              l2 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
            const u2 = { u_camera_to_center_distance: t2.transform.getCameraToCenterDistance(a2.projection), u_matrix: t2.translatePosMatrix(e2.projMatrix, r2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Dt.devicePixelRatio, u_extrude_scale: l2, u_inv_rot_matrix: Nu, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s2.paint.get("circle-emissive-strength") };
            if (o2) {
              u2.u_inv_rot_matrix = n2, u2.u_merc_center = i2, u2.u_tile_id = [e2.canonical.x, e2.canonical.y, 1 << e2.canonical.z], u2.u_zoom_transition = Du(a2.zoom);
              const t3 = i2[0] * Hr, r3 = i2[1] * Hr;
              u2.u_up_dir = a2.projection.upVector(new tu(0, 0, 0), t3, r3);
            }
            return u2;
          }, t.cV = zp, t.cW = (t2, e2, r2, n2, i2, s2) => {
            const a2 = t2.transform;
            return { u_matrix: Pp(t2, e2, r2, n2), u_texsize: e2.imageAtlasTexture ? e2.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: a2.calculatePixelsToTileUnitsMatrix(e2), u_device_pixel_ratio: i2, u_image: 0, u_tile_units_to_pixels: Ip(e2, a2), u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: s2 };
          }, t.cX = (t2, e2, r2, n2, i2, s2, a2) => {
            const o2 = t2.transform, l2 = o2.calculatePixelsToTileUnitsMatrix(e2);
            return { u_matrix: Pp(t2, e2, r2, n2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: s2, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i2, u_texsize: kp(r2) && e2.lineAtlasTexture ? e2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Ip(e2, t2.transform), u_alpha_discard_threshold: 0, u_trim_offset: a2, u_trim_fade_range: r2.paint.get("line-trim-fade-range"), u_trim_color: r2.paint.get("line-trim-color").toRenderColor(r2.lut).toArray01(), u_emissive_strength: r2.paint.get("line-emissive-strength") };
          }, t.cY = at, t.cZ = ac, t.c_ = rp, t.ca = yt, t.cb = function(t2) {
            return [Math.pow(t2[0], 1 / 2.2), Math.pow(t2[1], 1 / 2.2), Math.pow(t2[2], 1 / 2.2)];
          }, t.cc = function(t2) {
            return t2({ pluginStatus: Ss, pluginURL: Is }), ks.on("pluginStateChange", t2), t2;
          }, t.cd = by, t.ce = kg, t.cf = Xf, t.cg = Gf, t.ch = ne, t.ci = Ps, t.cj = Ft, t.ck = xe, t.cl = ht, t.cm = function(t2) {
            const e2 = t2.indexOf(la);
            return e2 >= 0 ? t2.slice(0, e2) : t2;
          }, t.cn = function(t2) {
            return t2.indexOf(la) >= 0;
          }, t.co = function(t2) {
            const e2 = t2.indexOf(la);
            return e2 >= 0 ? t2.slice(e2 + 1) : "";
          }, t.cp = function(t2) {
            const e2 = [], r2 = t2.id;
            return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
          }, t.cq = function(t2, e2, r2, n2) {
            return "custom" === t2.type ? new _m(t2, e2) : new my[t2.type](t2, e2, r2, n2);
          }, t.cr = ct, t.cs = ks, t.ct = ie, t.cu = So, t.cv = class extends bo {
            constructor(t2) {
              super(t2), this.current = zo;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                for (let t3 = 0; t3 < 9; t3++)
                  if (r2[t3] !== this.current[t3]) {
                    this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                    break;
                  }
              }
            }
          }, t.cw = H, t.cx = function(t2, e2, r2) {
            const n2 = Du(r2.zoom), i2 = t2.style.map._antialias, s2 = e2.options.extStandardDerivativesForceOff || t2.terrain && t2.terrain.exaggeration() > 0;
            return 0 === n2 && !i2 && !s2;
          }, t.cy = function(t2) {
            const e2 = t2.pixelsPerMeter, r2 = e2 / ul(1, t2.center.lat), n2 = O.mat4.identity(new Float64Array(16));
            return O.mat4.translate(n2, n2, [t2.point.x, t2.point.y, 0]), O.mat4.scale(n2, n2, [r2, r2, e2]), Float32Array.from(n2);
          }, t.cz = Iu, t.d = function(t2) {
            return It.API_TILEJSON_REGEX.test(t2);
          }, t.d$ = e, t.d0 = Zh, t.d1 = Dh, t.d2 = 450, t.d3 = 7, t.d4 = dm, t.d5 = ya, t.d6 = Ya, t.d7 = 256, t.d8 = Bu, t.d9 = Aa, t.dA = Lu, t.dB = function(t2) {
            const e2 = [0, 0, 0], r2 = O.mat4.identity(new Float64Array(16));
            return O.mat4.multiply(r2, t2.pixelMatrix, t2.globeMatrix), O.vec3.transformMat4(e2, e2, r2), new q(e2[0], e2[1]);
          }, t.dC = function(t2, e2, r2 = false) {
            if (Ss === ws || Ss === _s || Ss === Ms)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Is = Dt.resolveURL(t2), Ss = ws, As = e2, zs(), r2 || Es();
          }, t.dD = Ts, t.dE = function() {
            kg().acquire(Ig);
          }, t.dF = function() {
            const t2 = zg;
            t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(Ig), zg = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, t.dG = Pg, t.dH = function(t2) {
            const e2 = Gt();
            if (!e2)
              return;
            const r2 = e2.delete(Ot);
            t2 && r2.catch(t2).then(() => t2());
          }, t.dI = Sg, t.dJ = Dg, t.dK = function(t2) {
            Eg = Dt.resolveURL(t2), Rg || (Rg = new by(kg(), new Me())), Rg.broadcast("setDracoUrl", Eg);
          }, t.dL = Lg, t.dM = function(t2) {
            Vg = Dt.resolveURL(t2), Rg || (Rg = new by(kg(), new Me())), Rg.broadcast("setMeshoptUrl", Vg);
          }, t.dN = os, t.dO = nc, t.dP = $f, t.dQ = ux, t.dR = px, t.dS = gp, t.dT = ut, t.dU = Uf, t.dV = function(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            t2.createArrays(), t2.tilePixelRatio = Hr / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
            const h2 = t2.layers[0].layout, p2 = t2.layers[0]._unevaluatedLayout._values, f2 = {};
            if ("composite" === t2.textSizeData.kind) {
              const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
              f2.compositeTextSizes = [p2["text-size"].possiblyEvaluate(new Vs(e3), o2), p2["text-size"].possiblyEvaluate(new Vs(r3), o2)];
            }
            if ("composite" === t2.iconSizeData.kind) {
              const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
              f2.compositeIconSizes = [p2["icon-size"].possiblyEvaluate(new Vs(e3), o2), p2["icon-size"].possiblyEvaluate(new Vs(r3), o2)];
            }
            f2.layoutTextSize = p2["text-size"].possiblyEvaluate(new Vs(l2 + 1), o2), f2.layoutIconSize = p2["icon-size"].possiblyEvaluate(new Vs(l2 + 1), o2), f2.textMaxSize = p2["text-size"].possiblyEvaluate(new Vs(18), o2);
            const d2 = "map" === h2.get("text-rotation-alignment") && "point" !== h2.get("symbol-placement"), m2 = h2.get("text-size");
            let y2 = false;
            for (const e3 of t2.features)
              if (e3.icon && e3.icon.nameSecondary) {
                y2 = true;
                break;
              }
            for (const s3 of t2.features) {
              const l3 = h2.get("text-font").evaluate(s3, {}, o2).join(","), p3 = m2.evaluate(s3, {}, o2), g2 = f2.layoutTextSize.evaluate(s3, {}, o2), x2 = (f2.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), b2 = s3.text;
              let v2, w2 = [0, 0];
              if (b2) {
                const n3 = b2.toString(), a3 = h2.get("text-letter-spacing").evaluate(s3, {}, o2) * $p, u3 = h2.get("text-line-height").evaluate(s3, {}, o2) * $p, c3 = ds(n3) ? a3 : 0, f3 = h2.get("text-anchor").evaluate(s3, {}, o2), m3 = h2.get("text-variable-anchor");
                if (!m3) {
                  const t3 = h2.get("text-radial-offset").evaluate(s3, {}, o2);
                  w2 = t3 ? sd(f3, [t3 * $p, nd]) : h2.get("text-offset").evaluate(s3, {}, o2).map((t4) => t4 * $p);
                }
                let y3 = d2 ? "center" : h2.get("text-justify").evaluate(s3, {}, o2);
                const v3 = "point" === h2.get("symbol-placement"), _3 = v3 ? h2.get("text-max-width").evaluate(s3, {}, o2) * $p : 1 / 0, M3 = (s4) => {
                  t2.allowVerticalPlacement && fs(n3) && (x2.vertical = yf(b2, e2, r2, i2, l3, _3, u3, f3, s4, c3, w2, ff.vertical, true, g2, p3));
                };
                if (!d2 && m3) {
                  const t3 = "auto" === y3 ? m3.map((t4) => ad(t4)) : [y3];
                  let n4 = false;
                  for (let s4 = 0; s4 < t3.length; s4++) {
                    const a4 = t3[s4];
                    if (!x2.horizontal[a4])
                      if (n4)
                        x2.horizontal[a4] = x2.horizontal[0];
                      else {
                        const t4 = yf(b2, e2, r2, i2, l3, _3, u3, "center", a4, c3, w2, ff.horizontal, false, g2, p3);
                        t4 && (x2.horizontal[a4] = t4, n4 = 1 === t4.positionedLines.length);
                      }
                  }
                  M3("left");
                } else {
                  if ("auto" === y3 && (y3 = ad(f3)), v3 || h2.get("text-writing-mode").indexOf("horizontal") >= 0 || !fs(n3)) {
                    const t3 = yf(b2, e2, r2, i2, l3, _3, u3, f3, y3, c3, w2, ff.horizontal, false, g2, p3);
                    t3 && (x2.horizontal[y3] = t3);
                  }
                  M3(v3 ? "left" : y3);
                }
              }
              let _2 = false;
              if (s3.icon && s3.icon.namePrimary) {
                const e3 = n2[s3.icon.namePrimary];
                e3 && (v2 = If(i2[s3.icon.namePrimary], s3.icon.nameSecondary ? i2[s3.icon.nameSecondary] : void 0, h2.get("icon-offset").evaluate(s3, {}, o2), h2.get("icon-anchor").evaluate(s3, {}, o2)), _2 = e3.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && ft("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || 0 !== h2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
              }
              const M2 = hd(x2.horizontal) || x2.vertical;
              t2.iconsInText || (t2.iconsInText = !!M2 && M2.iconsInText), (M2 || v2) && od(t2, s3, x2, v2, n2, f2, g2, 0, w2, _2, a2, o2, u2, c2, y2);
            }
            s2 && t2.generateCollisionDebugBuffers(l2, t2.collisionBoxArray);
          }, t.dW = ch, t.dX = Ey, t.dY = N, t.dZ = uh, t.d_ = af, t.da = Ua, t.db = ja, t.dc = function(t2, e2, r2, n2, i2) {
            return Q((t2 - e2) / (r2 - e2) * (i2 - n2) + n2, n2, i2);
          }, t.dd = Ii, t.de = ml, t.df = class {
            constructor(t2, e2, r2, n2) {
              this.context = t2, this.format = n2, this.size = r2, this.texture = t2.gl.createTexture();
              const [i2, s2, a2] = this.size, { gl: o2 } = t2;
              o2.bindTexture(o2.TEXTURE_3D, this.texture), t2.pixelStoreUnpackFlipY.set(false), t2.pixelStoreUnpack.set(1), t2.pixelStoreUnpackPremultiplyAlpha.set(false), o2.texImage3D(o2.TEXTURE_3D, 0, this.format, i2, s2, a2, 0, am(this.format), om(this.format), e2.data);
            }
            bind(t2, e2) {
              const { context: r2 } = this, { gl: n2 } = r2;
              n2.bindTexture(n2.TEXTURE_3D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e2 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }, t.dg = Bm, t.dh = [1, 1, 1], t.di = ny, t.dj = Hm, t.dk = Ea, t.dl = class {
            constructor() {
              this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new q(1 / 0, 1 / 0), max: new q(-1 / 0, -1 / 0) };
            }
            clear() {
              this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
            }
            get updateTime() {
              return this._updateTime;
            }
            getReplacementRegionsForTile(t2, e2 = false) {
              const r2 = _h(new q(0, 0), new q(Hr, Hr), t2), n2 = [];
              if (e2 && !vh(r2, this._globalClipBounds))
                return n2;
              for (const e3 of this._activeRegions) {
                if (e3.hiddenByOverlap)
                  continue;
                if (!vh(r2, e3))
                  continue;
                const i2 = Mh(e3.min, e3.max, t2);
                n2.push({ min: i2.min, max: i2.max, sourceId: this._sourceIds[e3.priority], footprint: e3.footprint, footprintTileId: e3.tileId, order: e3.order, clipMask: e3.clipMask, clipScope: e3.clipScope });
              }
              return n2;
            }
            setSources(t2) {
              this._setSources(t2.map((t3) => ({ getSourceId: () => t3.cache.id, getFootprints: () => {
                const e2 = [];
                for (const r2 of t3.cache.getVisibleCoordinates()) {
                  const n2 = t3.cache.getTile(r2).buckets[t3.layer];
                  n2 && n2.updateFootprints(r2.toUnwrapped(), e2);
                }
                return e2;
              }, getOrder: () => t3.order, getClipMask: () => t3.clipMask, getClipScope: () => t3.clipScope })));
            }
            _addSource(t2) {
              const e2 = t2.getFootprints();
              if (0 === e2.length)
                return;
              const r2 = t2.getOrder(), n2 = t2.getClipMask(), i2 = t2.getClipScope();
              for (const t3 of e2) {
                if (!t3.footprint)
                  continue;
                const e3 = _h(t3.footprint.min, t3.footprint.max, t3.id);
                this._activeRegions.push({ min: e3.min, max: e3.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t3.id, footprint: t3.footprint, order: r2, clipMask: n2, clipScope: i2 });
              }
              this._sourceIds.push(t2.getSourceId());
            }
            _computeReplacement() {
              this._activeRegions.sort((t3, e2) => t3.priority - e2.priority || xh(t3.min, e2.min) || xh(t3.max, e2.max) || t3.order - e2.order || t3.clipMask - e2.clipMask || function(t4, e3) {
                const r2 = (t5, e4) => t5 + e4;
                return t4.length - e3.length || t4.reduce(r2, "").localeCompare(e3.reduce(r2, ""));
              }(t3.clipScope, e2.clipScope));
              let t2 = this._activeRegions.length !== this._prevRegions.length;
              if (!t2) {
                let e2 = 0;
                for (; !t2 && e2 !== this._activeRegions.length; ) {
                  const r2 = this._activeRegions[e2], n2 = this._prevRegions[e2];
                  t2 = r2.priority !== n2.priority || !bh(r2, n2) || r2.order !== n2.order || r2.clipMask !== n2.clipMask || !$(r2.clipScope, n2.clipScope), ++e2;
                }
              }
              if (t2) {
                ++this._updateTime;
                for (const t4 of this._activeRegions)
                  t4.order !== yh && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t4.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t4.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t4.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t4.max.y));
                const t3 = (t4) => {
                  const e2 = this._activeRegions;
                  if (t4 >= e2.length)
                    return t4;
                  const r2 = e2[t4].priority;
                  for (; t4 < e2.length && e2[t4].priority === r2; )
                    ++t4;
                  return t4;
                };
                if (this._sourceIds.length > 1) {
                  let e2 = 0, r2 = t3(e2);
                  for (; e2 !== r2; ) {
                    let n2 = e2;
                    const i2 = e2;
                    for (; n2 !== r2; ) {
                      const t4 = this._activeRegions[n2];
                      t4.hiddenByOverlap = false;
                      for (let e3 = 0; e3 < i2; e3++) {
                        const r3 = this._activeRegions[e3];
                        if (!r3.hiddenByOverlap && t4.order === yh && vh(t4, r3) && (t4.hiddenByOverlap = Sh(t4.footprint, t4.tileId, r3.footprint, r3.tileId), t4.hiddenByOverlap))
                          break;
                      }
                      ++n2;
                    }
                    e2 = r2, r2 = t3(e2);
                  }
                }
              }
            }
            _setSources(t2) {
              [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
              for (let e2 = t2.length - 1; e2 >= 0; e2--)
                this._addSource(t2[e2]);
              this._computeReplacement();
            }
          }, t.dm = class {
            constructor(t2) {
              this._createGrid(t2), this._createPoles(t2);
            }
            destroy() {
              this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
              for (const t2 of this._poleSegments)
                t2.destroy();
              for (const t2 of this._gridSegments)
                t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
            }
            _fillGridMeshWithLods(t2, e2) {
              const r2 = new xa(), n2 = new Da(), i2 = [], s2 = t2 + 1 + 2, a2 = e2[0] + 1, o2 = e2[0] + 1 + (1 + e2.length), l2 = (t3, e3, r3) => {
                let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
                return n3 += r3 ? 24575 : 0, [n3, e3];
              };
              for (let t3 = 0; t3 < s2; ++t3)
                r2.emplaceBack(...l2(t3, 0, true));
              for (let t3 = 0; t3 < a2; ++t3)
                for (let e3 = 0; e3 < s2; ++e3)
                  r2.emplaceBack(...l2(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const n3 = e2[t3];
                for (let t4 = 0; t4 < s2; ++t4)
                  r2.emplaceBack(...l2(t4, n3, true));
              }
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const a3 = n2.length, l3 = e2[t3] + 1 + 2, u2 = new Da();
                for (let r3 = 0; r3 < l3 - 1; r3++) {
                  const i3 = r3 === l3 - 2, a4 = i3 ? s2 * (o2 - e2.length + t3 - r3) : s2;
                  for (let t4 = 0; t4 < s2 - 1; t4++) {
                    const e3 = r3 * s2 + t4;
                    0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u2.emplaceBack(e3 + 1, e3, e3 + a4), u2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + a4), n2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
                  }
                }
                const c2 = co.simpleSegment(0, a3, r2.length, n2.length - a3);
                for (let t4 = 0; t4 < u2.uint16.length; t4 += 3)
                  n2.emplaceBack(u2.uint16[t4], u2.uint16[t4 + 1], u2.uint16[t4 + 2]);
                const h2 = co.simpleSegment(0, a3, r2.length, n2.length - a3);
                i2.push({ withoutSkirts: c2, withSkirts: h2 });
              }
              return { vertices: r2, indices: n2, segments: i2 };
            }
            _createGrid(t2) {
              const e2 = this._fillGridMeshWithLods(Zo, Wo);
              this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, lu.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
            }
            _createPoles(t2) {
              const e2 = new Da();
              for (let t3 = 0; t3 <= Zo; t3++)
                e2.emplaceBack(0, t3 + 1, t3 + 2);
              this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
              const r2 = new Ua(), n2 = new Ua(), i2 = new Ua(), s2 = new Ua();
              this._poleSegments = [];
              for (let t3 = 0, e3 = 0; t3 < Go; t3++) {
                const a2 = 360 / (1 << t3);
                r2.emplaceBack(0, -$o, 0, 0.5, 0), n2.emplaceBack(0, -$o, 0, 0.5, 1), i2.emplaceBack(0, -$o, 0, 0.5, 0.5), s2.emplaceBack(0, -$o, 0, 0.5, 0.5);
                for (let t4 = 0; t4 <= Zo; t4++) {
                  let e4 = t4 / Zo, o2 = 0;
                  const l2 = ke(0, a2, e4), [u2, c2, h2] = Jo(Uu, ju, l2, $o);
                  r2.emplaceBack(u2, c2, h2, e4, o2), n2.emplaceBack(u2, c2, h2, e4, 1 - o2);
                  const p2 = Y(l2);
                  e4 = 0.5 + 0.5 * Math.sin(p2), o2 = 0.5 + 0.5 * Math.cos(p2), i2.emplaceBack(u2, c2, h2, e4, o2), s2.emplaceBack(u2, c2, h2, e4, 1 - o2);
                }
                this._poleSegments.push(co.simpleSegment(e3, 0, 66, 64)), e3 += 66;
              }
              this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, au, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, au, false), this._texturedPoleNorthVertexBuffer = t2.createVertexBuffer(i2, au, false), this._texturedPoleSouthVertexBuffer = t2.createVertexBuffer(s2, au, false);
            }
            getGridBuffers(t2, e2) {
              return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
            }
            getPoleBuffers(t2, e2) {
              return [e2 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e2 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
            }
          }, t.dn = yh, t.dp = K, t.dq = function() {
            return !!document.fullscreenElement || !!document.webkitFullscreenElement;
          }, t.dr = J, t.ds = yl, t.dt = Qo, t.du = function([t2, e2, r2]) {
            const n2 = Math.hypot(t2, e2, r2), i2 = Math.atan2(t2, r2), s2 = 0.5 * Math.PI - Math.acos(-e2 / n2);
            return new rl(Z(i2), Z(s2));
          }, t.dv = zm, t.dw = tl, t.dx = function(t2) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            return !!function(t3) {
              if (null == vt) {
                const e3 = t3.navigator ? t3.navigator.userAgent : null;
                vt = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
              }
              return vt;
            }(t2) && e2 && (e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
          }, t.dy = function(t2, e2) {
            Ut = t2, jt = e2;
          }, t.dz = Fu, t.e = It, t.e0 = function(t2) {
            let e2 = 0;
            if (new Uint32Array(t2, 0, 1)[0] !== Xg) {
              const r2 = new Uint32Array(t2, 0, 7), [, , n2, i2, s2, a2] = r2;
              e2 = r2.byteLength + i2 + s2 + a2 + s2, (n2 !== t2.byteLength || e2 >= t2.byteLength) && ft("Invalid b3dm header information.");
            }
            return Jg(t2, e2);
          }, t.e1 = function(t2, e2) {
            const r2 = ax(t2);
            for (const t3 of r2) {
              for (const e3 of t3.meshes)
                ox(e3);
              t3.lights && (t3.lightMeshIndex = t3.meshes.length, t3.meshes.push(lx(t3.lights, e2)));
            }
            return r2;
          }, t.e2 = cy, t.e3 = xy, t.e4 = Bs, t.e5 = function(t2) {
            Xt(), null != qt && qt.then((e2) => {
              e2.keys().then((r2) => {
                for (let n2 = 0; n2 < r2.length - t2; n2++)
                  e2.delete(r2[n2]);
              });
            });
          }, t.f = function(t2) {
            return 0 === t2.indexOf("mapbox:");
          }, t.g = function(t2, e2) {
            return ie(nt(t2, { method: "GET" }), e2);
          }, t.h = Pt, t.i = function(t2) {
            return It.API_STYLE_REGEX.test(t2) && !zt(t2);
          }, t.j = function(t2) {
            return decodeURIComponent(atob(t2).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join(""));
          }, t.k = function(t2) {
            return btoa(encodeURIComponent(t2).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2))));
          }, t.l = nt, t.m = Zt, t.n = function(t2, e2) {
            return ie(nt(t2, { type: "json" }), e2);
          }, t.o = ce, t.p = function(t2, e2) {
            return ie(nt(t2, { method: "POST" }), e2);
          }, t.q = Dt, t.r = ic, t.s = function(t2) {
            try {
              const e2 = self[t2];
              return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
            } catch (t3) {
              return false;
            }
          }, t.t = ve, t.u = function() {
            return function t2(e2) {
              return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
            }();
          }, t.v = function(t2) {
            return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
          }, t.w = ft, t.x = be, t.y = 2, t.z = Lf;
        });
        define2(["./shared"], function(e) {
          function t(e2) {
            const t2 = e2 ? e2.url.toString() : void 0;
            return t2 ? performance.getEntriesByName(t2) : [];
          }
          function o(e2) {
            if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2)
              return JSON.stringify(e2);
            if (Array.isArray(e2)) {
              let t3 = "[";
              for (const s2 of e2)
                t3 += `${o(s2)},`;
              return `${t3}]`;
            }
            let t2 = "{";
            for (const s2 of Object.keys(e2).sort())
              t2 += `${s2}:${o(e2[s2])},`;
            return `${t2}}`;
          }
          function s(t2) {
            let s2 = "";
            for (const i2 of e.bg)
              s2 += `/${o(t2[i2])}`;
            return s2;
          }
          class i {
            constructor(e2) {
              this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e2 && this.replace(e2);
            }
            replace(e2, t2) {
              this._layerConfigs = {}, this._layers = {}, this.update(e2, [], t2);
            }
            update(t2, o2, i2) {
              this._options = i2;
              for (const o3 of t2)
                this._layerConfigs[o3.id] = o3, (this._layers[o3.id] = e.cq(o3, this.scope, null, this._options)).compileFilter(i2), this.keyCache[o3.id] && delete this.keyCache[o3.id];
              for (const e2 of o2)
                delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
              this.familiesBySource = {};
              const n2 = function(e2, t3) {
                const o3 = {};
                for (let i4 = 0; i4 < e2.length; i4++) {
                  const n3 = t3 && t3[e2[i4].id] || s(e2[i4]);
                  t3 && (t3[e2[i4].id] = n3);
                  let r2 = o3[n3];
                  r2 || (r2 = o3[n3] = []), r2.push(e2[i4]);
                }
                const i3 = [];
                for (const e3 in o3)
                  i3.push(o3[e3]);
                return i3;
              }(e.bd(this._layerConfigs), this.keyCache);
              for (const e2 of n2) {
                const t3 = e2.map((e3) => this._layers[e3.id]), o3 = t3[0];
                if ("none" === o3.visibility)
                  continue;
                const s2 = o3.source || "";
                let i3 = this.familiesBySource[s2];
                i3 || (i3 = this.familiesBySource[s2] = {});
                const n3 = o3.sourceLayer || "_geojsonTileLayer";
                let r2 = i3[n3];
                r2 || (r2 = i3[n3] = []), r2.push(t3);
              }
            }
          }
          const n = 1 * e.dP;
          class r {
            constructor(t2) {
              const o2 = {}, s2 = [];
              for (const e2 in t2) {
                const i3 = t2[e2], r3 = o2[e2] = {};
                for (const e3 in i3.glyphs) {
                  const t3 = i3.glyphs[+e3];
                  if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height)
                    continue;
                  const o3 = t3.metrics.localGlyph ? n : 1, a3 = { x: 0, y: 0, w: t3.bitmap.width + 2 * o3, h: t3.bitmap.height + 2 * o3 };
                  s2.push(a3), r3[e3] = a3;
                }
              }
              const { w: i2, h: r2 } = e.z(s2), a2 = new e.dO({ width: i2 || 1, height: r2 || 1 });
              for (const s3 in t2) {
                const i3 = t2[s3];
                for (const t3 in i3.glyphs) {
                  const r3 = i3.glyphs[+t3];
                  if (!r3 || 0 === r3.bitmap.width || 0 === r3.bitmap.height)
                    continue;
                  const l2 = o2[s3][t3], c2 = r3.metrics.localGlyph ? n : 1;
                  e.dO.copy(r3.bitmap, a2, { x: 0, y: 0 }, { x: l2.x + c2, y: l2.y + c2 }, r3.bitmap);
                }
              }
              this.image = a2, this.positions = o2;
            }
          }
          e.dN(r, "GlyphAtlas");
          class a {
            constructor(t2) {
              this.tileID = new e.aA(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.lut = t2.lut, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.scope = t2.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.promoteId = t2.promoteId, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = e.aK(t2.tileID.canonical, t2.projection), this.projection = t2.projection, this.brightness = t2.brightness, this.extraShadowCaster = !!t2.extraShadowCaster, this.tessellationStep = t2.tessellationStep;
            }
            parse(t2, o2, s2, i2, n2) {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.aQ();
              const a2 = new e.dQ(Object.keys(t2.layers).sort()), c2 = new e.dR(this.tileID, this.promoteId);
              c2.bucketLayerIDs = [];
              const h2 = {}, u2 = new e.dS(256, 256), d2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: u2, availableImages: s2, brightness: this.brightness }, f2 = o2.familiesBySource[this.source];
              for (const o3 in f2) {
                const i3 = t2.layers[o3];
                if (!i3)
                  continue;
                let n3 = false, r2 = false, u3 = false;
                for (const e2 of f2[o3])
                  "symbol" === e2[0].type ? n3 = true : r2 = true, e2[0].is3D() && "model" !== e2[0].type && (u3 = true);
                if (this.extraShadowCaster && !u3)
                  continue;
                if (true === this.isSymbolTile && !n3)
                  continue;
                if (false === this.isSymbolTile && !r2)
                  continue;
                1 === i3.version && e.w(`Vector tile source "${this.source}" layer "${o3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const p3 = a2.encode(o3), g3 = [];
                for (let e2 = 0; e2 < i3.length; e2++) {
                  const t3 = i3.feature(e2), s3 = c2.getId(t3, o3);
                  g3.push({ feature: t3, id: s3, index: e2, sourceLayerIndex: p3 });
                }
                for (const e2 of f2[o3]) {
                  const t3 = e2[0];
                  (!this.extraShadowCaster || t3.is3D() && "model" !== t3.type) && (void 0 !== this.isSymbolTile && "symbol" === t3.type !== this.isSymbolTile || t3.minzoom && this.zoom < Math.floor(t3.minzoom) || t3.maxzoom && this.zoom >= t3.maxzoom || "none" !== t3.visibility && (l(e2, this.zoom, d2.brightness, s2), (h2[t3.id] = t3.createBucket({ index: c2.bucketLayerIDs.length, layers: e2, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: p3, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep })).populate(g3, d2, this.tileID.canonical, this.tileTransform), c2.bucketLayerIDs.push(e2.map((e3) => e3.id))));
                }
              }
              let p2, g2, m2, y2;
              u2.trim();
              const x2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, w2 = () => {
                if (p2)
                  return this.status = "done", n2(p2);
                if (this.extraShadowCaster)
                  this.status = "done", n2(null, { buckets: e.bd(h2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: d2.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
                else if (g2 && m2 && y2) {
                  const t3 = new r(g2), o3 = new e.dU(m2, y2, this.lut);
                  for (const i3 in h2) {
                    const n3 = h2[i3];
                    n3 instanceof e.aR ? (l(n3.layers, this.zoom, d2.brightness, s2), e.dV(n3, g2, t3.positions, m2, o3.iconPositions, this.showCollisionBoxes, s2, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : n3.hasPattern && (n3 instanceof e.aX || n3 instanceof e.aY || n3 instanceof e.d0) && (l(n3.layers, this.zoom, d2.brightness, s2), n3.addFeatures(d2, this.tileID.canonical, o3.patternPositions, s2, this.tileTransform, this.brightness));
                  }
                  this.status = "done", n2(null, { buckets: e.bd(h2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: u2, imageAtlas: o3, brightness: d2.brightness });
                }
              };
              if (!this.extraShadowCaster) {
                const t3 = e.dT(d2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
                Object.keys(t3).length ? i2.send("getGlyphs", { uid: this.uid, stacks: t3, scope: this.scope }, (e2, t4) => {
                  p2 || (p2 = e2, g2 = t4, w2());
                }, void 0, false, x2) : g2 = {};
                const o3 = Object.keys(d2.iconDependencies);
                o3.length ? i2.send("getImages", { icons: o3, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e2, t4) => {
                  p2 || (p2 = e2, m2 = t4, w2());
                }, void 0, false, x2) : m2 = {};
                const s3 = Object.keys(d2.patternDependencies);
                s3.length ? i2.send("getImages", { icons: s3, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e2, t4) => {
                  p2 || (p2 = e2, y2 = t4, w2());
                }, void 0, false, x2) : y2 = {};
              }
              w2();
            }
          }
          function l(t2, o2, s2, i2) {
            const n2 = new e.a3(o2, { brightness: s2 });
            for (const e2 of t2)
              e2.recalculate(n2, i2);
          }
          class c extends e.E {
            constructor(t2, o2, s2, i2, n2, r2) {
              super(), this.actor = t2, this.layerIndex = o2, this.availableImages = s2, this.loadVectorData = n2 || e.aw, this.loading = {}, this.loaded = {}, this.deduped = new e.au(t2.scheduler), this.isSpriteLoaded = i2, this.scheduler = t2.scheduler, this.brightness = r2;
            }
            loadTile(o2, s2) {
              const i2 = o2.uid, n2 = o2 && o2.request, r2 = n2 && n2.collectResourceTiming, l2 = this.loading[i2] = new a(o2);
              l2.abort = this.loadVectorData(o2, (a2, c2) => {
                const h2 = !this.loading[i2];
                if (delete this.loading[i2], h2 || a2 || !c2)
                  return l2.status = "done", h2 || (this.loaded[i2] = l2), s2(a2);
                const u2 = c2.rawData, d2 = {};
                c2.expires && (d2.expires = c2.expires), c2.cacheControl && (d2.cacheControl = c2.cacheControl), l2.vectorTile = c2.vectorTile || new e.dW.VectorTile(new e.bb(u2));
                const f2 = () => {
                  l2.parse(l2.vectorTile, this.layerIndex, this.availableImages, this.actor, (o3, i3) => {
                    if (o3 || !i3)
                      return s2(o3);
                    const a3 = {};
                    if (r2) {
                      const e2 = t(n2);
                      e2.length > 0 && (a3.resourceTiming = JSON.parse(JSON.stringify(e2)));
                    }
                    s2(null, e.l({ rawTileData: u2.slice(0) }, i3, d2, a3));
                  });
                };
                this.isSpriteLoaded ? f2() : this.once("isSpriteLoaded", () => {
                  this.scheduler ? this.scheduler.add(f2, { type: "parseTile", isSymbolTile: o2.isSymbolTile, zoom: o2.tileZoom }) : f2();
                }), this.loaded = this.loaded || {}, this.loaded[i2] = l2;
              });
            }
            reloadTile(t2, o2) {
              const s2 = this.loaded, i2 = t2.uid;
              if (s2 && s2[i2]) {
                const n2 = s2[i2];
                n2.showCollisionBoxes = t2.showCollisionBoxes, n2.projection = t2.projection, n2.brightness = t2.brightness, n2.tileTransform = e.aK(t2.tileID.canonical, t2.projection), n2.extraShadowCaster = t2.extraShadowCaster, n2.lut = t2.lut;
                const r2 = (e2, t3) => {
                  const s3 = n2.reloadCallback;
                  s3 && (delete n2.reloadCallback, n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, s3)), o2(e2, t3);
                };
                "parsing" === n2.status ? n2.reloadCallback = r2 : "done" === n2.status && (n2.vectorTile ? n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, r2) : r2());
              } else
                o2(null, void 0);
            }
            abortTile(e2, t2) {
              const o2 = e2.uid, s2 = this.loading[o2];
              s2 && (s2.abort && s2.abort(), delete this.loading[o2]), t2();
            }
            removeTile(e2, t2) {
              const o2 = this.loaded, s2 = e2.uid;
              o2 && o2[s2] && delete o2[s2], t2();
            }
          }
          class h {
            loadTile(t2, o2) {
              const { uid: s2, encoding: i2, rawImageData: n2, padding: r2 } = t2, a2 = ImageBitmap && n2 instanceof ImageBitmap ? this.getImageData(n2, r2) : n2;
              o2(null, new e.dX(s2, a2, i2, r2 < 1));
            }
            getImageData(e2, t2) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
              const o2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), o2;
            }
          }
          e.ba.setPbf(e.bb);
          class u {
            decodeRasterArray({ task: t2, buffer: o2 }, s2) {
              e.ba.performDecoding(o2, t2).then((e2) => {
                s2(null, e2);
              }, (e2) => {
                s2(e2);
              });
            }
          }
          const d = e.dW.VectorTileFeature.prototype.toGeoJSON;
          class f {
            constructor(t2) {
              this._feature = t2, this.extent = e.ab, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                const t2 = [];
                for (const o2 of this._feature.geometry)
                  t2.push([new e.P(o2[0], o2[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const o2 of this._feature.geometry) {
                  const s2 = [];
                  for (const t3 of o2)
                    s2.push(new e.P(t3[0], t3[1]));
                  t2.push(s2);
                }
                return t2;
              }
            }
            toGeoJSON(e2, t2, o2) {
              return d.call(this, e2, t2, o2);
            }
          }
          class p {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.ab, this.length = t2.length, this._features = t2;
            }
            feature(e2) {
              return new f(this._features[e2]);
            }
          }
          const g = 64 / 4096, m = 128;
          class y {
            constructor() {
              this.features = /* @__PURE__ */ new Map();
            }
            clear() {
              this.features.clear();
            }
            load(e2 = [], t2) {
              for (const o2 of e2) {
                const e3 = o2.id;
                if (null == e3)
                  continue;
                let s2 = this.features.get(e3);
                s2 && this.updateCache(s2, t2), o2.geometry ? (s2 = w(o2), this.updateCache(s2, t2), this.features.set(e3, s2)) : this.features.delete(e3), this.updateCache(s2, t2);
              }
            }
            updateCache(e2, t2) {
              for (const { canonical: o2, uid: s2 } of Object.values(t2)) {
                const { z: i2, x: n2, y: r2 } = o2;
                x(e2, Math.pow(2, i2), n2, r2) && delete t2[s2];
              }
            }
            getTile(e2, t2, o2) {
              const s2 = Math.pow(2, e2), i2 = [];
              for (const e3 of this.features.values())
                x(e3, s2, t2, o2) && i2.push(I(e3, s2, t2, o2));
              return { features: i2 };
            }
            getFeatures() {
              return [...this.features.values()];
            }
          }
          function x({ minX: e2, minY: t2, maxX: o2, maxY: s2 }, i2, n2, r2) {
            return e2 < (n2 + 1 + g) / i2 && t2 < (r2 + 1 + g) / i2 && o2 > (n2 - g) / i2 && s2 > (r2 - g) / i2;
          }
          function w(e2) {
            const { id: t2, geometry: o2, properties: s2 } = e2;
            if (!o2)
              return;
            if ("GeometryCollection" === o2.type)
              throw new Error("GeometryCollection not supported in dynamic mode.");
            const { type: i2, coordinates: n2 } = o2, r2 = { id: t2, type: 1, geometry: [], tags: s2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, a2 = r2.geometry;
            if ("Point" === i2)
              b(n2, a2, r2);
            else if ("MultiPoint" === i2)
              for (const e3 of n2)
                b(e3, a2, r2);
            else if ("LineString" === i2)
              r2.type = 2, S(n2, a2, r2);
            else if ("MultiLineString" === i2)
              r2.type = 2, v(n2, a2, r2);
            else if ("Polygon" === i2)
              r2.type = 3, v(n2, a2, r2, true);
            else {
              if ("MultiPolygon" !== i2)
                throw new Error("Input data is not a valid GeoJSON object.");
              r2.type = 3;
              for (const e3 of n2)
                v(e3, a2, r2, true);
            }
            return r2;
          }
          function b([t2, o2], s2, i2) {
            const n2 = e.am(t2);
            let r2 = e.at(o2);
            r2 = r2 < 0 ? 0 : r2 > 1 ? 1 : r2, s2.push(n2, r2), i2.minX = Math.min(i2.minX, n2), i2.minY = Math.min(i2.minY, r2), i2.maxX = Math.max(i2.maxX, n2), i2.maxY = Math.max(i2.maxY, r2);
          }
          function S(e2, t2, o2, s2 = false, i2 = false) {
            const n2 = [];
            for (const t3 of e2)
              b(t3, n2, o2);
            t2.push(n2), s2 && function(e3, t3) {
              let o3 = 0;
              for (let t4 = 0, s3 = e3.length, i3 = s3 - 2; t4 < s3; i3 = t4, t4 += 2)
                o3 += (e3[t4] - e3[i3]) * (e3[t4 + 1] + e3[i3 + 1]);
              if (o3 > 0 === t3)
                for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
                  const s3 = e3[t4], i3 = e3[t4 + 1];
                  e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = s3, e3[o4 - 1 - t4] = i3;
                }
            }(n2, i2);
          }
          function v(e2, t2, o2, s2 = false) {
            for (let i2 = 0; i2 < e2.length; i2++)
              S(e2[i2], t2, o2, s2, 0 === i2);
          }
          function I(t2, o2, s2, i2) {
            const { id: n2, type: r2, geometry: a2, tags: l2 } = t2, c2 = [];
            if (1 === r2)
              !function(t3, o3, s3, i3, n3) {
                for (let r3 = 0; r3 < t3.length; r3 += 2) {
                  const a3 = Math.round(e.ab * (t3[r3 + 0] * o3 - s3)), l3 = Math.round(e.ab * (t3[r3 + 1] * o3 - i3));
                  n3.push([a3, l3]);
                }
              }(a2, o2, s2, i2, c2);
            else
              for (const e2 of a2)
                M(e2, o2, s2, i2, c2);
            return { id: n2, type: r2, geometry: c2, tags: l2 };
          }
          function M(t2, o2, s2, i2, n2) {
            const r2 = -m, a2 = e.ab + m;
            let l2;
            for (let c2 = 0; c2 < t2.length - 2; c2 += 2) {
              let h2 = Math.round(e.ab * (t2[c2 + 0] * o2 - s2)), u2 = Math.round(e.ab * (t2[c2 + 1] * o2 - i2)), d2 = Math.round(e.ab * (t2[c2 + 2] * o2 - s2)), f2 = Math.round(e.ab * (t2[c2 + 3] * o2 - i2));
              const p2 = d2 - h2, g2 = f2 - u2;
              h2 < r2 && d2 < r2 || (h2 < r2 ? (u2 += Math.round(g2 * ((r2 - h2) / p2)), h2 = r2) : d2 < r2 && (f2 = u2 + Math.round(g2 * ((r2 - h2) / p2)), d2 = r2), u2 < r2 && f2 < r2 || (u2 < r2 ? (h2 += Math.round(p2 * ((r2 - u2) / g2)), u2 = r2) : f2 < r2 && (d2 = h2 + Math.round(p2 * ((r2 - u2) / g2)), f2 = r2), h2 >= a2 && d2 >= a2 || (h2 >= a2 ? (u2 += Math.round(g2 * ((a2 - h2) / p2)), h2 = a2) : d2 >= a2 && (f2 = u2 + Math.round(g2 * ((a2 - h2) / p2)), d2 = a2), u2 >= a2 && f2 >= a2 || (u2 >= a2 ? (h2 += Math.round(p2 * ((a2 - u2) / g2)), u2 = a2) : f2 >= a2 && (d2 = h2 + Math.round(p2 * ((a2 - u2) / g2)), f2 = a2), l2 && h2 === l2[l2.length - 1][0] && u2 === l2[l2.length - 1][1] || (l2 = [[h2, u2]], n2.push(l2)), l2.push([d2, f2])))));
            }
          }
          var k, T, P, C = { exports: {} }, _ = function() {
            if (P)
              return C.exports;
            P = 1;
            var t2 = e.d_(), o2 = function() {
              if (T)
                return k;
              T = 1;
              var t3 = e.dY(), o3 = e.dZ().VectorTileFeature;
              function s3(e2, t4) {
                this.options = t4 || {}, this.features = e2, this.length = e2.length;
              }
              function i3(e2, t4) {
                this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t4 || 4096;
              }
              return k = s3, s3.prototype.feature = function(e2) {
                return new i3(this.features[e2], this.options.extent);
              }, i3.prototype.loadGeometry = function() {
                var e2 = this.rawGeometry;
                this.geometry = [];
                for (var o4 = 0; o4 < e2.length; o4++) {
                  for (var s4 = e2[o4], i4 = [], n3 = 0; n3 < s4.length; n3++)
                    i4.push(new t3(s4[n3][0], s4[n3][1]));
                  this.geometry.push(i4);
                }
                return this.geometry;
              }, i3.prototype.bbox = function() {
                this.geometry || this.loadGeometry();
                for (var e2 = this.geometry, t4 = 1 / 0, o4 = -1 / 0, s4 = 1 / 0, i4 = -1 / 0, n3 = 0; n3 < e2.length; n3++)
                  for (var r3 = e2[n3], a3 = 0; a3 < r3.length; a3++) {
                    var l3 = r3[a3];
                    t4 = Math.min(t4, l3.x), o4 = Math.max(o4, l3.x), s4 = Math.min(s4, l3.y), i4 = Math.max(i4, l3.y);
                  }
                return [t4, s4, o4, i4];
              }, i3.prototype.toGeoJSON = o3.prototype.toGeoJSON, k;
            }();
            function s2(e2) {
              var o3 = new t2();
              return function(e3, t3) {
                for (var o4 in e3.layers)
                  t3.writeMessage(3, i2, e3.layers[o4]);
              }(e2, o3), o3.finish();
            }
            function i2(e2, t3) {
              var o3;
              t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
              var s3 = { keys: [], values: [], keycache: {}, valuecache: {} };
              for (o3 = 0; o3 < e2.length; o3++)
                s3.feature = e2.feature(o3), t3.writeMessage(2, n2, s3);
              var i3 = s3.keys;
              for (o3 = 0; o3 < i3.length; o3++)
                t3.writeStringField(3, i3[o3]);
              var r3 = s3.values;
              for (o3 = 0; o3 < r3.length; o3++)
                t3.writeMessage(4, h2, r3[o3]);
            }
            function n2(e2, t3) {
              var o3 = e2.feature;
              void 0 !== o3.id && t3.writeVarintField(1, o3.id), t3.writeMessage(2, r2, e2), t3.writeVarintField(3, o3.type), t3.writeMessage(4, c2, o3);
            }
            function r2(e2, t3) {
              var o3 = e2.feature, s3 = e2.keys, i3 = e2.values, n3 = e2.keycache, r3 = e2.valuecache;
              for (var a3 in o3.properties) {
                var l3 = o3.properties[a3], c3 = n3[a3];
                if (null !== l3) {
                  void 0 === c3 && (s3.push(a3), n3[a3] = c3 = s3.length - 1), t3.writeVarint(c3);
                  var h3 = typeof l3;
                  "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
                  var u2 = h3 + ":" + l3, d2 = r3[u2];
                  void 0 === d2 && (i3.push(l3), r3[u2] = d2 = i3.length - 1), t3.writeVarint(d2);
                }
              }
            }
            function a2(e2, t3) {
              return (t3 << 3) + (7 & e2);
            }
            function l2(e2) {
              return e2 << 1 ^ e2 >> 31;
            }
            function c2(e2, t3) {
              for (var o3 = e2.loadGeometry(), s3 = e2.type, i3 = 0, n3 = 0, r3 = o3.length, c3 = 0; c3 < r3; c3++) {
                var h3 = o3[c3], u2 = 1;
                1 === s3 && (u2 = h3.length), t3.writeVarint(a2(1, u2));
                for (var d2 = 3 === s3 ? h3.length - 1 : h3.length, f2 = 0; f2 < d2; f2++) {
                  1 === f2 && 1 !== s3 && t3.writeVarint(a2(2, d2 - 1));
                  var p2 = h3[f2].x - i3, g2 = h3[f2].y - n3;
                  t3.writeVarint(l2(p2)), t3.writeVarint(l2(g2)), i3 += p2, n3 += g2;
                }
                3 === s3 && t3.writeVarint(a2(7, 1));
              }
            }
            function h2(e2, t3) {
              var o3 = typeof e2;
              "string" === o3 ? t3.writeStringField(1, e2) : "boolean" === o3 ? t3.writeBooleanField(7, e2) : "number" === o3 && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
            }
            return C.exports = s2, C.exports.fromVectorTileJs = s2, C.exports.fromGeojsonVt = function(e2, t3) {
              t3 = t3 || {};
              var i3 = {};
              for (var n3 in e2)
                i3[n3] = new o2(e2[n3].features, t3), i3[n3].name = n3, i3[n3].version = t3.version, i3[n3].extent = t3.extent;
              return s2({ layers: i3 });
            }, C.exports.GeoJSONWrapper = o2, C.exports;
          }(), L = e.d$(_);
          const D = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, j = Math.fround || (O = new Float32Array(1), (e2) => (O[0] = +e2, O[0]));
          var O;
          const z = 3, A = 5, Z = 6;
          class E {
            constructor(e2) {
              this.options = Object.assign(Object.create(D), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e2) {
              const { log: t2, minZoom: o2, maxZoom: s2 } = this.options;
              t2 && console.time("total time");
              const i2 = `prepare ${e2.length} points`;
              t2 && console.time(i2), this.points = e2;
              const n2 = [];
              for (let t3 = 0; t3 < e2.length; t3++) {
                const o3 = e2[t3];
                if (!o3.geometry)
                  continue;
                const [s3, i3] = o3.geometry.coordinates, r3 = j(N(s3)), a2 = j(X(i3));
                n2.push(r3, a2, 1 / 0, t3, -1, 1), this.options.reduce && n2.push(0);
              }
              let r2 = this.trees[s2 + 1] = this._createTree(n2);
              t2 && console.timeEnd(i2);
              for (let e3 = s2; e3 >= o2; e3--) {
                const o3 = +Date.now();
                r2 = this.trees[e3] = this._createTree(this._cluster(r2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, r2.numItems, +Date.now() - o3);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e2, t2) {
              let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
              const s2 = Math.max(-90, Math.min(90, e2[1]));
              let i2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
              const n2 = Math.max(-90, Math.min(90, e2[3]));
              if (e2[2] - e2[0] >= 360)
                o2 = -180, i2 = 180;
              else if (o2 > i2) {
                const e3 = this.getClusters([o2, s2, 180, n2], t2), r3 = this.getClusters([-180, s2, i2, n2], t2);
                return e3.concat(r3);
              }
              const r2 = this.trees[this._limitZoom(t2)], a2 = r2.range(N(o2), X(n2), N(i2), X(s2)), l2 = r2.data, c2 = [];
              for (const e3 of a2) {
                const t3 = this.stride * e3;
                c2.push(l2[t3 + A] > 1 ? F(l2, t3, this.clusterProps) : this.points[l2[t3 + z]]);
              }
              return c2;
            }
            getChildren(e2) {
              const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), s2 = "No cluster with the specified id.", i2 = this.trees[o2];
              if (!i2)
                throw new Error(s2);
              const n2 = i2.data;
              if (t2 * this.stride >= n2.length)
                throw new Error(s2);
              const r2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = i2.within(n2[t2 * this.stride], n2[t2 * this.stride + 1], r2), l2 = [];
              for (const t3 of a2) {
                const o3 = t3 * this.stride;
                n2[o3 + 4] === e2 && l2.push(n2[o3 + A] > 1 ? F(n2, o3, this.clusterProps) : this.points[n2[o3 + z]]);
              }
              if (0 === l2.length)
                throw new Error(s2);
              return l2;
            }
            getLeaves(e2, t2, o2) {
              const s2 = [];
              return this._appendLeaves(s2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), s2;
            }
            getTile(e2, t2, o2) {
              const s2 = this.trees[this._limitZoom(e2)], i2 = Math.pow(2, e2), { extent: n2, radius: r2 } = this.options, a2 = r2 / n2, l2 = (o2 - a2) / i2, c2 = (o2 + 1 + a2) / i2, h2 = { features: [] };
              return this._addTileFeatures(s2.range((t2 - a2) / i2, l2, (t2 + 1 + a2) / i2, c2), s2.data, t2, o2, i2, h2), 0 === t2 && this._addTileFeatures(s2.range(1 - a2 / i2, l2, 1, c2), s2.data, i2, o2, i2, h2), t2 === i2 - 1 && this._addTileFeatures(s2.range(0, l2, a2 / i2, c2), s2.data, -1, o2, i2, h2), h2.features.length ? h2 : null;
            }
            getClusterExpansionZoom(e2) {
              let t2 = this._getOriginZoom(e2) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const o2 = this.getChildren(e2);
                if (t2++, 1 !== o2.length)
                  break;
                e2 = o2[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e2, t2, o2, s2, i2) {
              const n2 = this.getChildren(t2);
              for (const t3 of n2) {
                const n3 = t3.properties;
                if (n3 && n3.cluster ? i2 + n3.point_count <= s2 ? i2 += n3.point_count : i2 = this._appendLeaves(e2, n3.cluster_id, o2, s2, i2) : i2 < s2 ? i2++ : e2.push(t3), e2.length === o2)
                  break;
              }
              return i2;
            }
            _createTree(t2) {
              const o2 = new e.by(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
              for (let e2 = 0; e2 < t2.length; e2 += this.stride)
                o2.add(t2[e2], t2[e2 + 1]);
              return o2.finish(), o2.data = t2, o2;
            }
            _addTileFeatures(e2, t2, o2, s2, i2, n2) {
              for (const r2 of e2) {
                const e3 = r2 * this.stride, a2 = t2[e3 + A] > 1;
                let l2, c2, h2;
                if (a2)
                  l2 = Y(t2, e3, this.clusterProps), c2 = t2[e3], h2 = t2[e3 + 1];
                else {
                  const o3 = this.points[t2[e3 + z]];
                  l2 = o3.properties;
                  const [s3, i3] = o3.geometry.coordinates;
                  c2 = N(s3), h2 = X(i3);
                }
                const u2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * i2 - o2)), Math.round(this.options.extent * (h2 * i2 - s2))]], tags: l2 };
                let d2;
                d2 = a2 || this.options.generateId ? t2[e3 + z] : this.points[t2[e3 + z]].id, void 0 !== d2 && (u2.id = d2), n2.features.push(u2);
              }
            }
            _limitZoom(e2) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
            }
            _cluster(e2, t2) {
              const { radius: o2, extent: s2, reduce: i2, minPoints: n2 } = this.options, r2 = o2 / (s2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
              for (let o3 = 0; o3 < a2.length; o3 += c2) {
                if (a2[o3 + 2] <= t2)
                  continue;
                a2[o3 + 2] = t2;
                const s3 = a2[o3], h2 = a2[o3 + 1], u2 = e2.within(a2[o3], a2[o3 + 1], r2), d2 = a2[o3 + A];
                let f2 = d2;
                for (const e3 of u2) {
                  const o4 = e3 * c2;
                  a2[o4 + 2] > t2 && (f2 += a2[o4 + A]);
                }
                if (f2 > d2 && f2 >= n2) {
                  let e3, n3 = s3 * d2, r3 = h2 * d2, p2 = -1;
                  const g2 = (o3 / c2 << 5) + (t2 + 1) + this.points.length;
                  for (const s4 of u2) {
                    const l3 = s4 * c2;
                    if (a2[l3 + 2] <= t2)
                      continue;
                    a2[l3 + 2] = t2;
                    const h3 = a2[l3 + A];
                    n3 += a2[l3] * h3, r3 += a2[l3 + 1] * h3, a2[l3 + 4] = g2, i2 && (e3 || (e3 = this._map(a2, o3, true), p2 = this.clusterProps.length, this.clusterProps.push(e3)), i2(e3, this._map(a2, l3)));
                  }
                  a2[o3 + 4] = g2, l2.push(n3 / f2, r3 / f2, 1 / 0, g2, -1, f2), i2 && l2.push(p2);
                } else {
                  for (let e3 = 0; e3 < c2; e3++)
                    l2.push(a2[o3 + e3]);
                  if (f2 > 1)
                    for (const e3 of u2) {
                      const o4 = e3 * c2;
                      if (!(a2[o4 + 2] <= t2)) {
                        a2[o4 + 2] = t2;
                        for (let e4 = 0; e4 < c2; e4++)
                          l2.push(a2[o4 + e4]);
                      }
                    }
                }
              }
              return l2;
            }
            _getOriginId(e2) {
              return e2 - this.points.length >> 5;
            }
            _getOriginZoom(e2) {
              return (e2 - this.points.length) % 32;
            }
            _map(e2, t2, o2) {
              if (e2[t2 + A] > 1) {
                const s3 = this.clusterProps[e2[t2 + Z]];
                return o2 ? Object.assign({}, s3) : s3;
              }
              const s2 = this.points[e2[t2 + z]].properties, i2 = this.options.map(s2);
              return o2 && i2 === s2 ? Object.assign({}, i2) : i2;
            }
          }
          function F(e2, t2, o2) {
            return { type: "Feature", id: e2[t2 + z], properties: Y(e2, t2, o2), geometry: { type: "Point", coordinates: [(s2 = e2[t2], 360 * (s2 - 0.5)), W(e2[t2 + 1])] } };
            var s2;
          }
          function Y(e2, t2, o2) {
            const s2 = e2[t2 + A], i2 = s2 >= 1e4 ? `${Math.round(s2 / 1e3)}k` : s2 >= 1e3 ? Math.round(s2 / 100) / 10 + "k" : s2, n2 = e2[t2 + Z], r2 = -1 === n2 ? {} : Object.assign({}, o2[n2]);
            return Object.assign(r2, { cluster: true, cluster_id: e2[t2 + z], point_count: s2, point_count_abbreviated: i2 });
          }
          function N(e2) {
            return e2 / 360 + 0.5;
          }
          function X(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function W(e2) {
            const t2 = (180 - 360 * e2) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function G(e2, t2, o2, s2) {
            let i2 = s2;
            const n2 = t2 + (o2 - t2 >> 1);
            let r2, a2 = o2 - t2;
            const l2 = e2[t2], c2 = e2[t2 + 1], h2 = e2[o2], u2 = e2[o2 + 1];
            for (let s3 = t2 + 3; s3 < o2; s3 += 3) {
              const t3 = B(e2[s3], e2[s3 + 1], l2, c2, h2, u2);
              if (t3 > i2)
                r2 = s3, i2 = t3;
              else if (t3 === i2) {
                const e3 = Math.abs(s3 - n2);
                e3 < a2 && (r2 = s3, a2 = e3);
              }
            }
            i2 > s2 && (r2 - t2 > 3 && G(e2, t2, r2, s2), e2[r2 + 2] = i2, o2 - r2 > 3 && G(e2, r2, o2, s2));
          }
          function B(e2, t2, o2, s2, i2, n2) {
            let r2 = i2 - o2, a2 = n2 - s2;
            if (0 !== r2 || 0 !== a2) {
              const l2 = ((e2 - o2) * r2 + (t2 - s2) * a2) / (r2 * r2 + a2 * a2);
              l2 > 1 ? (o2 = i2, s2 = n2) : l2 > 0 && (o2 += r2 * l2, s2 += a2 * l2);
            }
            return r2 = e2 - o2, a2 = t2 - s2, r2 * r2 + a2 * a2;
          }
          function J(e2, t2, o2, s2) {
            const i2 = { id: e2 ?? null, type: t2, geometry: o2, tags: s2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2)
              R(i2, o2);
            else if ("Polygon" === t2)
              R(i2, o2[0]);
            else if ("MultiLineString" === t2)
              for (const e3 of o2)
                R(i2, e3);
            else if ("MultiPolygon" === t2)
              for (const e3 of o2)
                R(i2, e3[0]);
            return i2;
          }
          function R(e2, t2) {
            for (let o2 = 0; o2 < t2.length; o2 += 3)
              e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
          }
          function V(e2, t2, o2, s2) {
            if (!t2.geometry)
              return;
            const i2 = t2.geometry.coordinates;
            if (i2 && 0 === i2.length)
              return;
            const n2 = t2.geometry.type, r2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
            let a2 = [], l2 = t2.id;
            if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = s2 || 0), "Point" === n2)
              $(i2, a2);
            else if ("MultiPoint" === n2)
              for (const e3 of i2)
                $(e3, a2);
            else if ("LineString" === n2)
              q(i2, a2, r2, false);
            else if ("MultiLineString" === n2) {
              if (o2.lineMetrics) {
                for (const o3 of i2)
                  a2 = [], q(o3, a2, r2, false), e2.push(J(l2, "LineString", a2, t2.properties));
                return;
              }
              U(i2, a2, r2, false);
            } else if ("Polygon" === n2)
              U(i2, a2, r2, true);
            else {
              if ("MultiPolygon" !== n2) {
                if ("GeometryCollection" === n2) {
                  for (const i3 of t2.geometry.geometries)
                    V(e2, { id: l2, geometry: i3, properties: t2.properties }, o2, s2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (const e3 of i2) {
                const t3 = [];
                U(e3, t3, r2, true), a2.push(t3);
              }
            }
            e2.push(J(l2, n2, a2, t2.properties));
          }
          function $(e2, t2) {
            t2.push(K(e2[0]), Q(e2[1]), 0);
          }
          function q(e2, t2, o2, s2) {
            let i2, n2, r2 = 0;
            for (let o3 = 0; o3 < e2.length; o3++) {
              const a3 = K(e2[o3][0]), l2 = Q(e2[o3][1]);
              t2.push(a3, l2, 0), o3 > 0 && (r2 += s2 ? (i2 * l2 - a3 * n2) / 2 : Math.sqrt(Math.pow(a3 - i2, 2) + Math.pow(l2 - n2, 2))), i2 = a3, n2 = l2;
            }
            const a2 = t2.length - 3;
            t2[2] = 1, G(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(r2), t2.start = 0, t2.end = t2.size;
          }
          function U(e2, t2, o2, s2) {
            for (let i2 = 0; i2 < e2.length; i2++) {
              const n2 = [];
              q(e2[i2], n2, o2, s2), t2.push(n2);
            }
          }
          function K(e2) {
            return e2 / 360 + 0.5;
          }
          function Q(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function H(e2, t2, o2, s2, i2, n2, r2, a2) {
            if (s2 /= t2, n2 >= (o2 /= t2) && r2 < s2)
              return e2;
            if (r2 < o2 || n2 >= s2)
              return null;
            const l2 = [];
            for (const t3 of e2) {
              const e3 = t3.geometry;
              let n3 = t3.type;
              const r3 = 0 === i2 ? t3.minX : t3.minY, c2 = 0 === i2 ? t3.maxX : t3.maxY;
              if (r3 >= o2 && c2 < s2) {
                l2.push(t3);
                continue;
              }
              if (c2 < o2 || r3 >= s2)
                continue;
              let h2 = [];
              if ("Point" === n3 || "MultiPoint" === n3)
                ee(e3, h2, o2, s2, i2);
              else if ("LineString" === n3)
                te(e3, h2, o2, s2, i2, false, a2.lineMetrics);
              else if ("MultiLineString" === n3)
                se(e3, h2, o2, s2, i2, false);
              else if ("Polygon" === n3)
                se(e3, h2, o2, s2, i2, true);
              else if ("MultiPolygon" === n3)
                for (const t4 of e3) {
                  const e4 = [];
                  se(t4, e4, o2, s2, i2, true), e4.length && h2.push(e4);
                }
              if (h2.length) {
                if (a2.lineMetrics && "LineString" === n3) {
                  for (const e4 of h2)
                    l2.push(J(t3.id, n3, e4, t3.tags));
                  continue;
                }
                "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h2.length ? (n3 = "LineString", h2 = h2[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h2.length ? "Point" : "MultiPoint"), l2.push(J(t3.id, n3, h2, t3.tags));
              }
            }
            return l2.length ? l2 : null;
          }
          function ee(e2, t2, o2, s2, i2) {
            for (let n2 = 0; n2 < e2.length; n2 += 3) {
              const r2 = e2[n2 + i2];
              r2 >= o2 && r2 <= s2 && ie(t2, e2[n2], e2[n2 + 1], e2[n2 + 2]);
            }
          }
          function te(e2, t2, o2, s2, i2, n2, r2) {
            let a2 = oe(e2);
            const l2 = 0 === i2 ? ne : re;
            let c2, h2, u2 = e2.start;
            for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
              const f3 = e2[d3], p3 = e2[d3 + 1], g3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], x2 = 0 === i2 ? f3 : p3, w2 = 0 === i2 ? m2 : y2;
              let b2 = false;
              r2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(p3 - y2, 2))), x2 < o2 ? w2 > o2 && (h2 = l2(a2, f3, p3, m2, y2, o2), r2 && (a2.start = u2 + c2 * h2)) : x2 > s2 ? w2 < s2 && (h2 = l2(a2, f3, p3, m2, y2, s2), r2 && (a2.start = u2 + c2 * h2)) : ie(a2, f3, p3, g3), w2 < o2 && x2 >= o2 && (h2 = l2(a2, f3, p3, m2, y2, o2), b2 = true), w2 > s2 && x2 <= s2 && (h2 = l2(a2, f3, p3, m2, y2, s2), b2 = true), !n2 && b2 && (r2 && (a2.end = u2 + c2 * h2), t2.push(a2), a2 = oe(e2)), r2 && (u2 += c2);
            }
            let d2 = e2.length - 3;
            const f2 = e2[d2], p2 = e2[d2 + 1], g2 = 0 === i2 ? f2 : p2;
            g2 >= o2 && g2 <= s2 && ie(a2, f2, p2, e2[d2 + 2]), d2 = a2.length - 3, n2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && ie(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
          }
          function oe(e2) {
            const t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function se(e2, t2, o2, s2, i2, n2) {
            for (const r2 of e2)
              te(r2, t2, o2, s2, i2, n2, false);
          }
          function ie(e2, t2, o2, s2) {
            e2.push(t2, o2, s2);
          }
          function ne(e2, t2, o2, s2, i2, n2) {
            const r2 = (n2 - t2) / (s2 - t2);
            return ie(e2, n2, o2 + (i2 - o2) * r2, 1), r2;
          }
          function re(e2, t2, o2, s2, i2, n2) {
            const r2 = (n2 - o2) / (i2 - o2);
            return ie(e2, t2 + (s2 - t2) * r2, n2, 1), r2;
          }
          function ae(e2, t2) {
            const o2 = [];
            for (let s2 = 0; s2 < e2.length; s2++) {
              const i2 = e2[s2], n2 = i2.type;
              let r2;
              if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2)
                r2 = le(i2.geometry, t2);
              else if ("MultiLineString" === n2 || "Polygon" === n2) {
                r2 = [];
                for (const e3 of i2.geometry)
                  r2.push(le(e3, t2));
              } else if ("MultiPolygon" === n2) {
                r2 = [];
                for (const e3 of i2.geometry) {
                  const o3 = [];
                  for (const s3 of e3)
                    o3.push(le(s3, t2));
                  r2.push(o3);
                }
              }
              o2.push(J(i2.id, n2, r2, i2.tags));
            }
            return o2;
          }
          function le(e2, t2) {
            const o2 = [];
            o2.size = e2.size, void 0 !== e2.start && (o2.start = e2.start, o2.end = e2.end);
            for (let s2 = 0; s2 < e2.length; s2 += 3)
              o2.push(e2[s2] + t2, e2[s2 + 1], e2[s2 + 2]);
            return o2;
          }
          function ce(e2, t2) {
            if (e2.transformed)
              return e2;
            const o2 = 1 << e2.z, s2 = e2.x, i2 = e2.y;
            for (const n2 of e2.features) {
              const e3 = n2.geometry, r2 = n2.type;
              if (n2.geometry = [], 1 === r2)
                for (let r3 = 0; r3 < e3.length; r3 += 2)
                  n2.geometry.push(he(e3[r3], e3[r3 + 1], t2, o2, s2, i2));
              else
                for (let r3 = 0; r3 < e3.length; r3++) {
                  const a2 = [];
                  for (let n3 = 0; n3 < e3[r3].length; n3 += 2)
                    a2.push(he(e3[r3][n3], e3[r3][n3 + 1], t2, o2, s2, i2));
                  n2.geometry.push(a2);
                }
            }
            return e2.transformed = true, e2;
          }
          function he(e2, t2, o2, s2, i2, n2) {
            return [Math.round(o2 * (e2 * s2 - i2)), Math.round(o2 * (t2 * s2 - n2))];
          }
          function ue(e2, t2, o2, s2, i2) {
            const n2 = t2 === i2.maxZoom ? 0 : i2.tolerance / ((1 << t2) * i2.extent), r2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: o2, y: s2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
            for (const t3 of e2)
              de(r2, t3, n2, i2);
            return r2;
          }
          function de(e2, t2, o2, s2) {
            const i2 = t2.geometry, n2 = t2.type, r2 = [];
            if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === n2 || "MultiPoint" === n2)
              for (let t3 = 0; t3 < i2.length; t3 += 3)
                r2.push(i2[t3], i2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
            else if ("LineString" === n2)
              fe(r2, i2, e2, o2, false, false);
            else if ("MultiLineString" === n2 || "Polygon" === n2)
              for (let t3 = 0; t3 < i2.length; t3++)
                fe(r2, i2[t3], e2, o2, "Polygon" === n2, 0 === t3);
            else if ("MultiPolygon" === n2)
              for (let t3 = 0; t3 < i2.length; t3++) {
                const s3 = i2[t3];
                for (let t4 = 0; t4 < s3.length; t4++)
                  fe(r2, s3[t4], e2, o2, true, 0 === t4);
              }
            if (r2.length) {
              let o3 = t2.tags || null;
              if ("LineString" === n2 && s2.lineMetrics) {
                o3 = {};
                for (const e3 in t2.tags)
                  o3[e3] = t2.tags[e3];
                o3.mapbox_clip_start = i2.start / i2.size, o3.mapbox_clip_end = i2.end / i2.size;
              }
              const a2 = { geometry: r2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: o3 };
              null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
            }
          }
          function fe(e2, t2, o2, s2, i2, n2) {
            const r2 = s2 * s2;
            if (s2 > 0 && t2.size < (i2 ? r2 : s2))
              return void (o2.numPoints += t2.length / 3);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3 += 3)
              (0 === s2 || t2[e3 + 2] > r2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
            i2 && function(e3, t3) {
              let o3 = 0;
              for (let t4 = 0, s3 = e3.length, i3 = s3 - 2; t4 < s3; i3 = t4, t4 += 2)
                o3 += (e3[t4] - e3[i3]) * (e3[t4 + 1] + e3[i3 + 1]);
              if (o3 > 0 === t3)
                for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
                  const s3 = e3[t4], i3 = e3[t4 + 1];
                  e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = s3, e3[o4 - 1 - t4] = i3;
                }
            }(a2, n2), e2.push(a2);
          }
          const pe = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
          class ge {
            constructor(e2, t2) {
              const o2 = (t2 = this.options = function(e3, t3) {
                for (const o3 in t3)
                  e3[o3] = t3[o3];
                return e3;
              }(Object.create(pe), t2)).debug;
              if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
                throw new Error("maxZoom should be in the 0-24 range");
              if (t2.promoteId && t2.generateId)
                throw new Error("promoteId and generateId cannot be used together.");
              let s2 = function(e3, t3) {
                const o3 = [];
                if ("FeatureCollection" === e3.type)
                  for (let s3 = 0; s3 < e3.features.length; s3++)
                    V(o3, e3.features[s3], t3, s3);
                else
                  V(o3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
                return o3;
              }(e2, t2);
              this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), s2 = function(e3, t3) {
                const o3 = t3.buffer / t3.extent;
                let s3 = e3;
                const i2 = H(e3, 1, -1 - o3, o3, 0, -1, 2, t3), n2 = H(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
                return (i2 || n2) && (s3 = H(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], i2 && (s3 = ae(i2, 1).concat(s3)), n2 && (s3 = s3.concat(ae(n2, -1)))), s3;
              }(s2, t2), s2.length && this.splitTile(s2, 0, 0, 0), o2 && (s2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e2, t2, o2, s2, i2, n2, r2) {
              const a2 = [e2, t2, o2, s2], l2 = this.options, c2 = l2.debug;
              for (; a2.length; ) {
                s2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
                const h2 = 1 << t2, u2 = me(t2, o2, s2);
                let d2 = this.tiles[u2];
                if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[u2] = ue(e2, t2, o2, s2, l2), this.tileCoords.push({ z: t2, x: o2, y: s2 }), c2)) {
                  c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, s2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
                  const e3 = `z${t2}`;
                  this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
                }
                if (d2.source = e2, null == i2) {
                  if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints)
                    continue;
                } else {
                  if (t2 === l2.maxZoom || t2 === i2)
                    continue;
                  if (null != i2) {
                    const e3 = i2 - t2;
                    if (o2 !== n2 >> e3 || s2 !== r2 >> e3)
                      continue;
                  }
                }
                if (d2.source = null, 0 === e2.length)
                  continue;
                c2 > 1 && console.time("clipping");
                const f2 = 0.5 * l2.buffer / l2.extent, p2 = 0.5 - f2, g2 = 0.5 + f2, m2 = 1 + f2;
                let y2 = null, x2 = null, w2 = null, b2 = null, S2 = H(e2, h2, o2 - f2, o2 + g2, 0, d2.minX, d2.maxX, l2), v2 = H(e2, h2, o2 + p2, o2 + m2, 0, d2.minX, d2.maxX, l2);
                e2 = null, S2 && (y2 = H(S2, h2, s2 - f2, s2 + g2, 1, d2.minY, d2.maxY, l2), x2 = H(S2, h2, s2 + p2, s2 + m2, 1, d2.minY, d2.maxY, l2), S2 = null), v2 && (w2 = H(v2, h2, s2 - f2, s2 + g2, 1, d2.minY, d2.maxY, l2), b2 = H(v2, h2, s2 + p2, s2 + m2, 1, d2.minY, d2.maxY, l2), v2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * o2, 2 * s2), a2.push(x2 || [], t2 + 1, 2 * o2, 2 * s2 + 1), a2.push(w2 || [], t2 + 1, 2 * o2 + 1, 2 * s2), a2.push(b2 || [], t2 + 1, 2 * o2 + 1, 2 * s2 + 1);
              }
            }
            getTile(e2, t2, o2) {
              e2 = +e2, t2 = +t2, o2 = +o2;
              const s2 = this.options, { extent: i2, debug: n2 } = s2;
              if (e2 < 0 || e2 > 24)
                return null;
              const r2 = 1 << e2, a2 = me(e2, t2 = t2 + r2 & r2 - 1, o2);
              if (this.tiles[a2])
                return ce(this.tiles[a2], i2);
              n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
              let l2, c2 = e2, h2 = t2, u2 = o2;
              for (; !l2 && c2 > 0; )
                c2--, h2 >>= 1, u2 >>= 1, l2 = this.tiles[me(c2, h2, u2)];
              return l2 && l2.source ? (n2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, h2, u2), console.time("drilling down")), this.splitTile(l2.source, c2, h2, u2, e2, t2, o2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ce(this.tiles[a2], i2) : null) : null;
            }
          }
          function me(e2, t2, o2) {
            return 32 * ((1 << e2) * o2 + t2) + e2;
          }
          function ye(e2, t2) {
            const o2 = e2.tileID.canonical;
            if (!this._geoJSONIndex)
              return void t2(null, null);
            const s2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
            if (!s2)
              return void t2(null, null);
            const i2 = new p(s2.features);
            let n2 = L(i2);
            0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: i2, rawData: n2.buffer });
          }
          class xe extends c {
            constructor(e2, t2, o2, s2, i2, n2) {
              super(e2, t2, o2, s2, ye, n2), i2 && (this.loadGeoJSON = i2), this._dynamicIndex = new y();
            }
            loadData(o2, s2) {
              const i2 = o2 && o2.request, n2 = i2 && i2.collectResourceTiming;
              this.loadGeoJSON(o2, (r2, a2) => {
                if (r2 || !a2)
                  return s2(r2);
                if ("object" != typeof a2)
                  return s2(new Error(`Input data given to '${o2.source}' is not a valid GeoJSON object.`));
                {
                  try {
                    if (o2.filter) {
                      const t2 = e.M(o2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === t2.result)
                        throw new Error(t2.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                      a2.features = a2.features.filter((e2) => t2.value.evaluate({ zoom: 0 }, e2));
                    }
                    o2.dynamic ? ("Feature" === a2.type && (a2 = { type: "FeatureCollection", features: [a2] }), o2.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a2.features, this.loaded), o2.cluster && (a2.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = o2.cluster ? new E(function({ superclusterOptions: t2, clusterProperties: o3 }) {
                      if (!o3 || !t2)
                        return t2;
                      const s3 = {}, i3 = {}, n3 = { accumulated: null, zoom: 0 }, r4 = { properties: null }, a3 = Object.keys(o3);
                      for (const t3 of a3) {
                        const [n4, r5] = o3[t3], a4 = e.M(r5), l2 = e.M("string" == typeof n4 ? [n4, ["accumulated"], ["get", t3]] : n4);
                        s3[t3] = a4.value, i3[t3] = l2.value;
                      }
                      return t2.map = (e2) => {
                        r4.properties = e2;
                        const t3 = {};
                        for (const e3 of a3)
                          t3[e3] = s3[e3].evaluate(n3, r4);
                        return t3;
                      }, t2.reduce = (e2, t3) => {
                        r4.properties = t3;
                        for (const t4 of a3)
                          n3.accumulated = e2[t4], e2[t4] = i3[t4].evaluate(n3, r4);
                      }, t2;
                    }(o2)).load(a2.features) : o2.dynamic ? this._dynamicIndex : function(e2, t2) {
                      return new ge(e2, t2);
                    }(a2, o2.geojsonVtOptions);
                  } catch (e2) {
                    return s2(e2);
                  }
                  const r3 = {};
                  if (n2) {
                    const e2 = t(i2);
                    e2 && (r3.resourceTiming = {}, r3.resourceTiming[o2.source] = JSON.parse(JSON.stringify(e2)));
                  }
                  s2(null, r3);
                }
              });
            }
            reloadTile(e2, t2) {
              const o2 = this.loaded;
              return o2 && o2[e2.uid] ? e2.partial ? t2(null, void 0) : super.reloadTile(e2, t2) : this.loadTile(e2, t2);
            }
            loadGeoJSON(t2, o2) {
              if (t2.request)
                e.n(t2.request, o2);
              else {
                if ("string" != typeof t2.data)
                  return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                try {
                  return o2(null, JSON.parse(t2.data));
                } catch (e2) {
                  return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              }
            }
            getClusterExpansionZoom(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterChildren(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterLeaves(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
              } catch (e3) {
                t2(e3);
              }
            }
          }
          class we {
            constructor(t2, o2) {
              this.tileID = new e.aA(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t2.projection, this.brightness = o2;
            }
            parse(t2, o2, s2, i2) {
              this.status = "parsing";
              const n2 = new e.aA(s2.tileID.overscaledZ, s2.tileID.wrap, s2.tileID.canonical.z, s2.tileID.canonical.x, s2.tileID.canonical.y), r2 = {}, a2 = o2.familiesBySource[s2.source], l2 = new e.dR(n2, s2.promoteId);
              return l2.bucketLayerIDs = [], l2.is3DTile = true, e.e0(t2).then((t3) => {
                if (!t3)
                  return i2(new Error("Could not parse tile"));
                const o3 = e.e1(t3, 1 / e.c8(s2.tileID.canonical)), c2 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("MAPBOX_mesh_features") || t3.json.asset.extras && t3.json.asset.extras.MAPBOX_mesh_features, h2 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("EXT_meshopt_compression"), u2 = new e.a3(this.zoom, { brightness: this.brightness });
                for (const t4 in a2)
                  for (const s3 of a2[t4]) {
                    const t5 = s3[0];
                    l2.bucketLayerIDs.push(s3.map((e2) => e2.id)), t5.recalculate(u2, []);
                    const i3 = new e.e2(o3, n2, c2, h2, this.brightness, l2);
                    c2 || (i3.needsUpload = true), r2[t5.fqid] = i3, i3.evaluate(t5);
                  }
                this.status = "done", i2(null, { buckets: r2, featureIndex: l2 });
              }).catch((e2) => i2(new Error(e2.message)));
            }
          }
          class be {
            constructor(e2, t2, o2, s2, i2, n2) {
              this.actor = e2, this.layerIndex = t2, this.brightness = n2, this.loading = {}, this.loaded = {};
            }
            loadTile(t2, o2) {
              const s2 = t2.uid, i2 = this.loading[s2] = new we(t2, this.brightness);
              e.bc(t2.request, (e2, n2) => {
                const r2 = !this.loading[s2];
                return delete this.loading[s2], r2 || e2 ? (i2.status = "done", r2 || (this.loaded[s2] = i2), o2(e2)) : n2 && 0 !== n2.byteLength ? void i2.parse(n2, this.layerIndex, t2, (e3, t3) => {
                  i2.status = "done", this.loaded = this.loaded || {}, this.loaded[s2] = i2, e3 || !t3 ? o2(e3) : o2(null, t3);
                }) : (i2.status = "done", this.loaded[s2] = i2, o2());
              });
            }
            reloadTile(e2, t2) {
              const o2 = this.loaded, s2 = e2.uid;
              if (o2 && o2[s2]) {
                const i2 = o2[s2];
                i2.projection = e2.projection, i2.brightness = e2.brightness;
                const n2 = (o3, s3) => {
                  i2.reloadCallback && (delete i2.reloadCallback, this.loadTile(e2, t2)), t2(o3, s3);
                };
                "parsing" === i2.status ? i2.reloadCallback = n2 : "done" === i2.status && this.loadTile(e2, t2);
              }
            }
            abortTile(e2, t2) {
              const o2 = e2.uid;
              this.loading[o2] && delete this.loading[o2], t2();
            }
            removeTile(e2, t2) {
              const o2 = this.loaded, s2 = e2.uid;
              o2 && o2[s2] && delete o2[s2], t2();
            }
          }
          class Se {
            constructor(t2) {
              this.self = t2, this.actor = new e.e3(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.bL({ name: "mercator" }), this.workerSourceTypes = { vector: c, geojson: xe, "batched-model": be }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
                if (this.workerSourceTypes[e2])
                  throw new Error(`Worker source with name "${e2}" already registered.`);
                this.workerSourceTypes[e2] = t3;
              }, this.self.registerRTLTextPlugin = (t3) => {
                if (e.e4.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e.e4.applyArabicShaping = t3.applyArabicShaping, e.e4.processBidirectionalText = t3.processBidirectionalText, e.e4.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              };
            }
            clearCaches(e2, t2, o2) {
              delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.workerSources[e2], delete this.demWorkerSources[e2], delete this.rasterArrayWorkerSource, o2();
            }
            checkIfReady(e2, t2, o2) {
              o2();
            }
            setReferrer(e2, t2) {
              this.referrer = t2;
            }
            spriteLoaded(t2, { scope: o2, isLoaded: s2 }) {
              if (this.isSpriteLoaded[t2] || (this.isSpriteLoaded[t2] = {}), this.isSpriteLoaded[t2][o2] = s2, this.workerSources[t2] && this.workerSources[t2][o2])
                for (const i2 in this.workerSources[t2][o2]) {
                  const n2 = this.workerSources[t2][o2][i2];
                  for (const t3 in n2) {
                    const o3 = n2[t3];
                    o3 instanceof c && (o3.isSpriteLoaded = s2, o3.fire(new e.x("isSpriteLoaded")));
                  }
                }
            }
            setImages(e2, { scope: t2, images: o2 }, s2) {
              if (this.availableImages[e2] || (this.availableImages[e2] = {}), this.availableImages[e2][t2] = o2, this.workerSources[e2] && this.workerSources[e2][t2]) {
                for (const s3 in this.workerSources[e2][t2]) {
                  const i2 = this.workerSources[e2][t2][s3];
                  for (const e3 in i2)
                    i2[e3].availableImages = o2;
                }
                s2();
              } else
                s2();
            }
            setProjection(t2, o2) {
              this.projections[t2] = e.bL(o2);
            }
            setBrightness(e2, t2, o2) {
              this.brightness = t2, o2();
            }
            setLayers(e2, t2, o2) {
              this.getLayerIndex(e2, t2.scope).replace(t2.layers, t2.options), o2();
            }
            updateLayers(e2, t2, o2) {
              this.getLayerIndex(e2, t2.scope).update(t2.layers, t2.removedIds, t2.options), o2();
            }
            loadTile(e2, t2, o2) {
              t2.projection = this.projections[e2] || this.defaultProjection, this.getWorkerSource(e2, t2.type, t2.source, t2.scope).loadTile(t2, o2);
            }
            loadDEMTile(e2, t2, o2) {
              this.getDEMWorkerSource(e2, t2.source, t2.scope).loadTile(t2, o2);
            }
            decodeRasterArray(e2, t2, o2) {
              this.getRasterArrayWorkerSource().decodeRasterArray(t2, o2);
            }
            reloadTile(e2, t2, o2) {
              t2.projection = this.projections[e2] || this.defaultProjection, this.getWorkerSource(e2, t2.type, t2.source, t2.scope).reloadTile(t2, o2);
            }
            abortTile(e2, t2, o2) {
              this.getWorkerSource(e2, t2.type, t2.source, t2.scope).abortTile(t2, o2);
            }
            removeTile(e2, t2, o2) {
              this.getWorkerSource(e2, t2.type, t2.source, t2.scope).removeTile(t2, o2);
            }
            removeSource(e2, t2, o2) {
              if (!(this.workerSources[e2] && this.workerSources[e2][t2.scope] && this.workerSources[e2][t2.scope][t2.type] && this.workerSources[e2][t2.scope][t2.type][t2.source]))
                return;
              const s2 = this.workerSources[e2][t2.scope][t2.type][t2.source];
              delete this.workerSources[e2][t2.scope][t2.type][t2.source], void 0 !== s2.removeSource ? s2.removeSource(t2, o2) : o2();
            }
            loadWorkerSource(e2, t2, o2) {
              try {
                this.self.importScripts(t2.url), o2();
              } catch (e3) {
                o2(e3.toString());
              }
            }
            syncRTLPluginState(t2, o2, s2) {
              try {
                e.e4.setState(o2);
                const t3 = e.e4.getPluginURL();
                if (e.e4.isLoaded() && !e.e4.isParsed() && null != t3) {
                  this.self.importScripts(t3);
                  const o3 = e.e4.isParsed();
                  s2(o3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), o3);
                }
              } catch (e2) {
                s2(e2.toString());
              }
            }
            setDracoUrl(e2, t2) {
              this.dracoUrl = t2;
            }
            getAvailableImages(e2, t2) {
              this.availableImages[e2] || (this.availableImages[e2] = {});
              let o2 = this.availableImages[e2][t2];
              return o2 || (o2 = []), o2;
            }
            getLayerIndex(e2, t2) {
              this.layerIndexes[e2] || (this.layerIndexes[e2] = {});
              let o2 = this.layerIndexes[e2][t2];
              return o2 || (o2 = this.layerIndexes[e2][t2] = new i(), o2.scope = t2), o2;
            }
            getWorkerSource(e2, t2, o2, s2) {
              return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][s2] || (this.workerSources[e2][s2] = {}), this.workerSources[e2][s2][t2] || (this.workerSources[e2][s2][t2] = {}), this.isSpriteLoaded[e2] || (this.isSpriteLoaded[e2] = {}), this.workerSources[e2][s2][t2][o2] || (this.workerSources[e2][s2][t2][o2] = new this.workerSourceTypes[t2]({ send: (t3, o3, s3, i2, n2, r2) => {
                this.actor.send(t3, o3, s3, e2, n2, r2);
              }, scheduler: this.actor.scheduler }, this.getLayerIndex(e2, s2), this.getAvailableImages(e2, s2), this.isSpriteLoaded[e2][s2], void 0, this.brightness)), this.workerSources[e2][s2][t2][o2];
            }
            getDEMWorkerSource(e2, t2, o2) {
              return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][o2] || (this.demWorkerSources[e2][o2] = {}), this.demWorkerSources[e2][o2][t2] || (this.demWorkerSources[e2][o2][t2] = new h()), this.demWorkerSources[e2][o2][t2];
            }
            getRasterArrayWorkerSource() {
              return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u()), this.rasterArrayWorkerSource;
            }
            enforceCacheSizeLimit(t2, o2) {
              e.e5(o2);
            }
            getWorkerPerformanceMetrics(e2, t2, o2) {
              o2(void 0, void 0);
            }
          }
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;
        });
        define2(["./shared"], function(e) {
          var t = "3.7.0";
          const i = { create: "create", load: "load", fullLoad: "fullLoad" }, o = { mark(e2) {
            performance.mark(e2);
          }, measure(e2, t2, i2) {
            performance.measure(e2, t2, i2);
          } };
          function r(t2) {
            const i2 = t2.name.split("?")[0];
            return e.a(i2) && i2.includes("mapbox-gl.js") ? "javascript" : e.a(i2) && i2.includes("mapbox-gl.css") ? "css" : e.b(i2) ? "fontRange" : e.c(i2) ? "sprite" : e.i(i2) ? "style" : e.d(i2) ? "tilejson" : "other";
          }
          var s, a = {}, n = function() {
            if (s)
              return a;
            function e2(e3) {
              return !t2(e3);
            }
            function t2(t3) {
              return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window))
                  return false;
                var e3, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
                try {
                  t4 = new Worker(o3), e3 = true;
                } catch (t5) {
                  e3 = false;
                }
                return t4 && t4.terminate(), URL.revokeObjectURL(o3), e3;
              }() ? function() {
                var e3 = document.createElement("canvas");
                e3.width = e3.height = 1;
                var t4 = e3.getContext("2d");
                if (!t4)
                  return false;
                var i3 = t4.getImageData(0, 0, 1, 1);
                return i3 && i3.width === e3.width;
              }() ? (void 0 === i2[o2 = t3 && t3.failIfMajorPerformanceCaveat] && (i2[o2] = function(t4) {
                var i3, o3 = function(t5) {
                  var i4 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
                  return o4.failIfMajorPerformanceCaveat = t5, i4.getContext("webgl2", o4);
                }(t4);
                if (!o3)
                  return false;
                try {
                  i3 = o3.createShader(o3.VERTEX_SHADER);
                } catch (e3) {
                  return false;
                }
                return !(!i3 || o3.isContextLost()) && (o3.shaderSource(i3, "void main() {}"), o3.compileShader(i3), true === o3.getShaderParameter(i3, o3.COMPILE_STATUS));
              }(o2)), i2[o2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
              var o2;
            }
            s = 1, a.supported = e2, a.notSupportedReason = t2;
            var i2 = {};
            return e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true }, a;
          }();
          function l(e2, t2, i2) {
            const o2 = document.createElement(e2);
            return null != t2 && (o2.className = t2), i2 && i2.appendChild(o2), o2;
          }
          function c(e2, t2, i2) {
            const o2 = document.createElementNS("http://www.w3.org/2000/svg", e2);
            for (const e3 of Object.keys(t2))
              o2.setAttributeNS(null, e3, String(t2[e3]));
            return i2 && i2.appendChild(o2), o2;
          }
          const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, u = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
          let d;
          function _() {
            h && u && (d = h[u], h[u] = "none");
          }
          function p() {
            h && u && (h[u] = d);
          }
          function m(e2) {
            e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", m, true);
          }
          function f() {
            window.addEventListener("click", m, true), window.setTimeout(() => {
              window.removeEventListener("click", m, true);
            }, 0);
          }
          function g(e2, t2) {
            const i2 = e2.getBoundingClientRect();
            return y(e2, i2, t2);
          }
          function v(e2, t2) {
            const i2 = e2.getBoundingClientRect(), o2 = [];
            for (let r2 = 0; r2 < t2.length; r2++)
              o2.push(y(e2, i2, t2[r2]));
            return o2;
          }
          function x(e2) {
            return void 0 !== window.InstallTrigger && 2 === e2.button && e2.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e2.button;
          }
          function y(t2, i2, o2) {
            const r2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
            return new e.P((o2.clientX - i2.left) * r2, (o2.clientY - i2.top) * r2);
          }
          const b = "01", w = "NO_ACCESS_TOKEN";
          class T {
            constructor(e2, t2, i2) {
              this._transformRequestFn = e2, this._customAccessToken = t2, this._silenceAuthErrors = !!i2, this._createSkuToken();
            }
            _createSkuToken() {
              const e2 = function() {
                let e3 = "";
                for (let t2 = 0; t2 < 10; t2++)
                  e3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                return { token: ["1", b, e3].join(""), tokenExpiresAt: Date.now() + 432e5 };
              }();
              this._skuToken = e2.token, this._skuTokenExpiresAt = e2.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
              return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(e2, t2) {
              return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
            }
            normalizeStyleURL(i2, o2) {
              if (!e.f(i2))
                return i2;
              const r2 = C(i2);
              return r2.params.push(`sdk=js-${t}`), r2.path = `/styles/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || o2);
            }
            normalizeGlyphsURL(t2, i2) {
              if (!e.f(t2))
                return t2;
              const o2 = C(t2);
              return o2.path = `/fonts/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i2);
            }
            normalizeModelURL(t2, i2) {
              if (!e.f(t2))
                return t2;
              const o2 = C(t2);
              return o2.path = `/models/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i2);
            }
            normalizeSourceURL(t2, i2, o2, r2) {
              if (!e.f(t2))
                return t2;
              const s2 = C(t2);
              return s2.path = `/v4/${s2.authority}.json`, s2.params.push("secure"), o2 && s2.params.push(`language=${o2}`), r2 && s2.params.push(`worldview=${r2}`), this._makeAPIURL(s2, this._customAccessToken || i2);
            }
            normalizeSpriteURL(t2, i2, o2, r2) {
              const s2 = C(t2);
              return e.f(t2) ? (s2.path = `/styles/v1${s2.path}/sprite${i2}${o2}`, this._makeAPIURL(s2, this._customAccessToken || r2)) : (s2.path += `${i2}${o2}`, S(s2));
            }
            normalizeTileURL(t2, i2, o2) {
              if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !e.f(t2))
                return t2;
              const r2 = C(t2);
              r2.path = r2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i2 || o2 && "raster" !== r2.authority && 512 === o2 ? "@2x" : ""}${e.m.supported ? ".webp" : "$1"}`), "raster" === r2.authority ? r2.path = `/${e.e.RASTER_URL_PREFIX}${r2.path}` : "rasterarrays" === r2.authority ? r2.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${r2.path}` : "3dtiles" === r2.authority ? r2.path = `/${e.e.TILES3D_URL_PREFIX}${r2.path}` : (r2.path = r2.path.replace(/^.+\/v4\//, "/"), r2.path = `/${e.e.TILE_URL_VERSION}${r2.path}`);
              const s2 = this._customAccessToken || function(e2) {
                for (const t3 of e2) {
                  const e3 = t3.match(/^access_token=(.*)$/);
                  if (e3)
                    return e3[1];
                }
                return null;
              }(r2.params) || e.e.ACCESS_TOKEN;
              return e.e.REQUIRE_ACCESS_TOKEN && s2 && this._skuToken && r2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(r2, s2);
            }
            canonicalizeTileURL(t2, i2) {
              const o2 = C(t2);
              if (!o2.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o2.path.match(/\.[\w]+$/))
                return t2;
              let r2 = "mapbox://";
              o2.path.match(/^\/raster\/v1\//) ? r2 += `raster/${o2.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o2.path.match(/^\/rasterarrays\/v1\//) ? r2 += `rasterarrays/${o2.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : r2 += `tiles/${o2.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
              let s2 = o2.params;
              return i2 && (s2 = s2.filter((e2) => !e2.match(/^access_token=/))), s2.length && (r2 += `?${s2.join("&")}`), r2;
            }
            canonicalizeTileset(t2, i2) {
              const o2 = !!i2 && e.f(i2), r2 = [];
              for (const i3 of t2.tiles || [])
                e.h(i3) ? r2.push(this.canonicalizeTileURL(i3, o2)) : r2.push(i3);
              return r2;
            }
            _makeAPIURL(t2, i2) {
              const o2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", r2 = C(e.e.API_URL);
              if (t2.protocol = r2.protocol, t2.authority = r2.authority, "http" === t2.protocol) {
                const e2 = t2.params.indexOf("secure");
                e2 >= 0 && t2.params.splice(e2, 1);
              }
              if ("/" !== r2.path && (t2.path = `${r2.path}${t2.path}`), !e.e.REQUIRE_ACCESS_TOKEN)
                return S(t2);
              if (i2 = i2 || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                if (!i2)
                  throw new Error(`An API access token is required to use Mapbox GL. ${o2}`);
                if ("s" === i2[0])
                  throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o2}`);
              }
              return t2.params = t2.params.filter((e2) => -1 === e2.indexOf("access_token")), t2.params.push(`access_token=${i2 || ""}`), S(t2);
            }
          }
          const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function C(e2) {
            const t2 = e2.match(E);
            if (!t2)
              throw new Error("Unable to parse URL object");
            return { protocol: t2[1], authority: t2[2], path: t2[3] || "/", params: t2[4] ? t2[4].split("&") : [] };
          }
          function S(e2) {
            const t2 = e2.params.length ? `?${e2.params.join("&")}` : "";
            return `${e2.protocol}://${e2.authority}${e2.path}${t2}`;
          }
          const I = "mapbox.eventData";
          function D(t2) {
            if (!t2)
              return null;
            const i2 = t2.split(".");
            if (!i2 || 3 !== i2.length)
              return null;
            try {
              return JSON.parse(e.j(i2[1]));
            } catch (e2) {
              return null;
            }
          }
          class R {
            constructor(e2) {
              this.type = e2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t2) {
              const i2 = D(e.e.ACCESS_TOKEN);
              let o2 = "";
              return o2 = i2 && i2.u ? e.k(i2.u) : e.e.ACCESS_TOKEN || "", t2 ? `${I}.${t2}:${o2}` : `${I}:${o2}`;
            }
            fetchEventData() {
              const t2 = e.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid");
              if (t2)
                try {
                  const e2 = localStorage.getItem(i2);
                  e2 && (this.eventData = JSON.parse(e2));
                  const t3 = localStorage.getItem(o2);
                  t3 && (this.anonId = t3);
                } catch (t3) {
                  e.w("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
              const t2 = e.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid"), r2 = this.anonId;
              if (t2 && r2)
                try {
                  localStorage.setItem(o2, r2), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i2, JSON.stringify(this.eventData));
                } catch (t3) {
                  e.w("Unable to write to LocalStorage");
                }
            }
            processRequests(e2) {
            }
            postEvent(t2, i2, o2, r2) {
              if (!e.e.EVENTS_URL)
                return;
              const s2 = C(e.e.EVENTS_URL);
              s2.params.push(`access_token=${r2 || e.e.ACCESS_TOKEN || ""}`);
              const a2 = { event: this.type, created: new Date(t2).toISOString() }, n2 = i2 ? e.l(a2, i2) : a2, l2 = { url: S(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([n2]) };
              this.pendingRequest = e.p(l2, (e2) => {
                this.pendingRequest = null, o2(e2), this.saveEventData(), this.processRequests(r2);
              });
            }
            queueRequest(e2, t2) {
              this.queue.push(e2), this.processRequests(t2);
            }
          }
          const A = new class extends R {
            constructor(e2) {
              super("appUserTurnstile"), this._customAccessToken = e2;
            }
            postTurnstileEvent(t2, i2) {
              e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => e.f(t3) || e.h(t3)) && this.queueRequest(Date.now(), i2);
            }
            processRequests(i2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              const o2 = D(e.e.ACCESS_TOKEN), r2 = o2 ? o2.u : e.e.ACCESS_TOKEN;
              let s2 = r2 !== this.eventData.tokenU;
              e.v(this.anonId) || (this.anonId = e.u(), s2 = true);
              const a2 = this.queue.shift();
              if (this.eventData.lastSuccess) {
                const e2 = new Date(this.eventData.lastSuccess), t2 = new Date(a2), i3 = (a2 - this.eventData.lastSuccess) / 864e5;
                s2 = s2 || i3 >= 1 || i3 < -1 || e2.getDate() !== t2.getDate();
              } else
                s2 = true;
              s2 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: b, "enabled.telemetry": false, userId: this.anonId }, (e2) => {
                e2 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = r2);
              }, i2) : this.processRequests();
            }
          }(), L = A.postTurnstileEvent.bind(A), P = new class extends R {
            constructor() {
              super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t2, i2, o2, r2) {
              this.skuToken = i2, this.errorCb = r2, e.e.EVENTS_URL && (o2 || e.e.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, o2) : this.errorCb(new Error(w)));
            }
            processRequests(i2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { id: o2, timestamp: r2 } = this.queue.shift();
              o2 && this.success[o2] || (this.anonId || this.fetchEventData(), e.v(this.anonId) || (this.anonId = e.u()), this.postEvent(r2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: b, skuToken: this.skuToken, userId: this.anonId }, (e2) => {
                e2 ? this.errorCb(e2) : o2 && (this.success[o2] = true);
              }, i2));
            }
            remove() {
              this.errorCb = null;
            }
          }(), M = P.postMapLoadEvent.bind(P), z = new class extends R {
            constructor() {
              super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
            }
            getMapInstanceId(t2) {
              let i2 = this.mapInstanceIdMap.get(t2);
              return i2 || (i2 = e.u(), this.mapInstanceIdMap.set(t2, i2)), i2;
            }
            getEventId(e2) {
              const t2 = this.eventIdPerMapInstanceMap.get(e2) || 0;
              return this.eventIdPerMapInstanceMap.set(e2, t2 + 1), t2;
            }
            postStyleLoadEvent(t2, i2) {
              const { map: o2, style: r2, importedStyles: s2 } = i2;
              if (!e.e.EVENTS_URL || !t2 && !e.e.ACCESS_TOKEN)
                return;
              const a2 = this.getMapInstanceId(o2), n2 = { mapInstanceId: a2, eventId: this.getEventId(a2), style: r2 };
              s2.length && (n2.importedStyles = s2), this.queueRequest({ timestamp: Date.now(), payload: n2 }, t2);
            }
            processRequests(e2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { timestamp: t2, payload: i2 } = this.queue.shift();
              this.postEvent(t2, i2, () => {
              }, e2);
            }
          }(), O = z.postStyleLoadEvent.bind(z), F = new class extends R {
            constructor() {
              super("gljs.performance");
            }
            postPerformanceEvent(t2, i2) {
              e.e.EVENTS_URL && (t2 || e.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: i2 }, t2);
            }
            processRequests(o2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { timestamp: s2, performanceData: a2 } = this.queue.shift(), n2 = function(o3) {
                const s3 = performance.getEntriesByType("resource"), a3 = performance.getEntriesByType("mark"), n3 = function(e2) {
                  const t2 = {};
                  if (e2) {
                    for (const i2 in e2)
                      if ("other" !== i2)
                        for (const o4 of e2[i2]) {
                          const e3 = `${i2}ResolveRangeMin`, r2 = `${i2}ResolveRangeMax`, s4 = `${i2}RequestCount`, a4 = `${i2}RequestCachedCount`;
                          t2[e3] = Math.min(t2[e3] || 1 / 0, o4.startTime), t2[r2] = Math.max(t2[r2] || -1 / 0, o4.responseEnd);
                          const n4 = (e4) => {
                            void 0 === t2[e4] && (t2[e4] = 0), ++t2[e4];
                          };
                          void 0 !== o4.transferSize && 0 === o4.transferSize && n4(a4), n4(s4);
                        }
                  }
                  return t2;
                }(function(e2, t2) {
                  const i2 = {};
                  if (e2)
                    for (const o4 of e2) {
                      const e3 = t2(o4);
                      void 0 === i2[e3] && (i2[e3] = []), i2[e3].push(o4);
                    }
                  return i2;
                }(s3, r)), l2 = window.devicePixelRatio, c2 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h2 = c2 ? c2.effectiveType : void 0, u2 = { counters: [], metadata: [], attributes: [] }, d2 = (e2, t2, i2) => {
                  null != i2 && e2.push({ name: t2, value: i2.toString() });
                };
                for (const e2 in n3)
                  d2(u2.counters, e2, n3[e2]);
                if (o3.interactionRange[0] !== 1 / 0 && o3.interactionRange[1] !== -1 / 0 && (d2(u2.counters, "interactionRangeMin", o3.interactionRange[0]), d2(u2.counters, "interactionRangeMax", o3.interactionRange[1])), a3)
                  for (const e2 of Object.keys(i)) {
                    const t2 = i[e2], o4 = a3.find((e3) => e3.name === t2);
                    o4 && d2(u2.counters, t2, o4.startTime);
                  }
                return d2(u2.counters, "visibilityHidden", o3.visibilityHidden), d2(u2.attributes, "style", function(t2) {
                  if (t2)
                    for (const i2 of t2) {
                      const t3 = i2.name.split("?")[0];
                      if (e.i(t3)) {
                        const e2 = t3.split("/").slice(-2);
                        if (2 === e2.length)
                          return `mapbox://styles/${e2[0]}/${e2[1]}`;
                      }
                    }
                }(s3)), d2(u2.attributes, "terrainEnabled", o3.terrainEnabled ? "true" : "false"), d2(u2.attributes, "fogEnabled", o3.fogEnabled ? "true" : "false"), d2(u2.attributes, "projection", o3.projection), d2(u2.attributes, "zoom", o3.zoom), d2(u2.metadata, "devicePixelRatio", l2), d2(u2.metadata, "connectionEffectiveType", h2), d2(u2.metadata, "navigatorUserAgent", navigator.userAgent), d2(u2.metadata, "screenWidth", window.screen.width), d2(u2.metadata, "screenHeight", window.screen.height), d2(u2.metadata, "windowWidth", window.innerWidth), d2(u2.metadata, "windowHeight", window.innerHeight), d2(u2.metadata, "mapWidth", o3.width / l2), d2(u2.metadata, "mapHeight", o3.height / l2), d2(u2.metadata, "webglRenderer", o3.renderer), d2(u2.metadata, "webglVendor", o3.vendor), d2(u2.metadata, "sdkVersion", t), d2(u2.metadata, "sdkIdentifier", "mapbox-gl-js"), u2;
              }(a2);
              for (const e2 of n2.metadata)
                ;
              for (const e2 of n2.counters)
                ;
              for (const e2 of n2.attributes)
                ;
              this.postEvent(s2, n2, () => {
              }, o2);
            }
          }(), k = F.postPerformanceEvent.bind(F), B = new class extends R {
            constructor() {
              super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t2, i2, o2, r2) {
              if (!e.e.API_URL || !e.e.SESSION_PATH)
                return;
              const s2 = C(e.e.API_URL + e.e.SESSION_PATH);
              s2.params.push(`sku=${i2 || ""}`), s2.params.push(`access_token=${r2 || e.e.ACCESS_TOKEN || ""}`);
              const a2 = { url: S(s2), headers: { "Content-Type": "text/plain" } };
              this.pendingRequest = e.g(a2, (e2) => {
                this.pendingRequest = null, o2(e2), this.saveEventData(), this.processRequests(r2);
              });
            }
            getSessionAPI(t2, i2, o2, r2) {
              this.skuToken = i2, this.errorCb = r2, e.e.SESSION_PATH && e.e.API_URL && (o2 || e.e.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, o2) : this.errorCb(new Error(w)));
            }
            processRequests(e2) {
              if (this.pendingRequest || 0 === this.queue.length)
                return;
              const { id: t2, timestamp: i2 } = this.queue.shift();
              t2 && this.success[t2] || this.getSession(i2, this.skuToken, (e3) => {
                e3 ? this.errorCb(e3) : t2 && (this.success[t2] = true);
              }, e2);
            }
            remove() {
              this.errorCb = null;
            }
          }(), N = B.getSessionAPI.bind(B), U = /* @__PURE__ */ new Set();
          function G(e2, t2) {
            t2 ? U.add(e2) : U.delete(e2);
          }
          class j {
            constructor() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
            }
            isDirty() {
              return this._changed;
            }
            setDirty() {
              this._changed = true;
            }
            getUpdatedSourceCaches() {
              return this._updatedSourceCaches;
            }
            updateSourceCache(e2, t2) {
              this._updatedSourceCaches[e2] = t2, this.setDirty();
            }
            discardSourceCacheUpdate(e2) {
              delete this._updatedSourceCaches[e2];
            }
            updateLayer(e2) {
              const t2 = e2.scope;
              this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._updatedLayers[t2].add(e2.id), this.setDirty();
            }
            removeLayer(e2) {
              const t2 = e2.scope;
              this._removedLayers[t2] = this._removedLayers[t2] || {}, this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._removedLayers[t2][e2.id] = e2, this._updatedLayers[t2].delete(e2.id), this._updatedPaintProps.delete(e2.fqid), this.setDirty();
            }
            getRemovedLayer(e2) {
              return this._removedLayers[e2.scope] ? this._removedLayers[e2.scope][e2.id] : null;
            }
            discardLayerRemoval(e2) {
              this._removedLayers[e2.scope] && delete this._removedLayers[e2.scope][e2.id];
            }
            getLayerUpdatesByScope() {
              const e2 = {};
              for (const t2 in this._updatedLayers)
                e2[t2] = e2[t2] || {}, e2[t2].updatedIds = Array.from(this._updatedLayers[t2].values());
              for (const t2 in this._removedLayers)
                e2[t2] = e2[t2] || {}, e2[t2].removedIds = Object.keys(this._removedLayers[t2]);
              return e2;
            }
            getUpdatedPaintProperties() {
              return this._updatedPaintProps;
            }
            updatePaintProperties(e2) {
              this._updatedPaintProps.add(e2.fqid), this.setDirty();
            }
            getUpdatedImages() {
              return Array.from(this._updatedImages.values());
            }
            updateImage(e2) {
              this._updatedImages.add(e2), this.setDirty();
            }
            resetUpdatedImages() {
              this._updatedImages.clear();
            }
            reset() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
            }
          }
          function V(e2) {
            const { userImage: t2 } = e2;
            return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
          }
          class q extends e.E {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = true;
            }
            createScope(t2) {
              this.images[t2] = {}, this.loaded[t2] = false, this.updatedImages[t2] = {}, this.patterns[t2] = {}, this.callbackDispatchedThisFrame[t2] = {}, this.atlasImage[t2] = new e.r({ width: 1, height: 1 });
            }
            isLoaded() {
              for (const e2 in this.loaded)
                if (!this.loaded[e2])
                  return false;
              return true;
            }
            setLoaded(e2, t2) {
              if (this.loaded[t2] !== e2 && (this.loaded[t2] = e2, e2)) {
                for (const { ids: e3, callback: i2 } of this.requestors)
                  this._notify(e3, t2, i2);
                this.requestors = [];
              }
            }
            hasImage(e2, t2) {
              return !!this.getImage(e2, t2);
            }
            getImage(e2, t2) {
              return this.images[t2][e2];
            }
            addImage(e2, t2, i2) {
              this._validate(e2, i2) && (this.images[t2][e2] = i2);
            }
            _validate(t2, i2) {
              let o2 = true;
              return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.t(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.t(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.t(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
            }
            _validateStretch(e2, t2) {
              if (!e2)
                return true;
              let i2 = 0;
              for (const o2 of e2) {
                if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1])
                  return false;
                i2 = o2[1];
              }
              return true;
            }
            _validateContent(e2, t2) {
              return !(e2 && (4 !== e2.length || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
            }
            updateImage(e2, t2, i2) {
              i2.version = this.images[t2][e2].version + 1, this.images[t2][e2] = i2, this.updatedImages[t2][e2] = true;
            }
            removeImage(e2, t2) {
              const i2 = this.images[t2][e2];
              delete this.images[t2][e2], delete this.patterns[t2][e2], i2.userImage && i2.userImage.onRemove && i2.userImage.onRemove();
            }
            listImages(e2) {
              return Object.keys(this.images[e2]);
            }
            getImages(e2, t2, i2) {
              let o2 = true;
              const r2 = !!this.loaded[t2];
              if (!r2)
                for (const i3 of e2)
                  this.images[t2][i3] || (o2 = false);
              r2 || o2 ? this._notify(e2, t2, i2) : this.requestors.push({ ids: e2, scope: t2, callback: i2 });
            }
            getUpdatedImages(e2) {
              return this.updatedImages[e2];
            }
            _notify(t2, i2, o2) {
              const r2 = {};
              for (const o3 of t2) {
                this.images[i2][o3] || this.fire(new e.x("styleimagemissing", { id: o3 }));
                const t3 = this.images[i2][o3];
                t3 ? r2[o3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.w(`Image "${o3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              o2(null, r2);
            }
            getPixelSize(e2) {
              const { width: t2, height: i2 } = this.atlasImage[e2];
              return { width: t2, height: i2 };
            }
            getPattern(t2, i2, o2) {
              const r2 = this.patterns[i2][t2], s2 = this.getImage(t2, i2);
              if (!s2)
                return null;
              if (r2 && r2.position.version === s2.version)
                return r2.position;
              if (r2)
                r2.position.version = s2.version;
              else {
                const o3 = { w: s2.data.width + 2 * e.y, h: s2.data.height + 2 * e.y, x: 0, y: 0 }, r3 = new e.I(o3, s2, e.y);
                this.patterns[i2][t2] = { bin: o3, position: r3 };
              }
              return this._updatePatternAtlas(i2, o2), this.patterns[i2][t2].position;
            }
            bind(t2, i2) {
              const o2 = t2.gl;
              let r2 = this.atlasTexture[i2];
              r2 ? this.dirty && (r2.update(this.atlasImage[i2]), this.dirty = false) : (r2 = new e.T(t2, this.atlasImage[i2], o2.RGBA8), this.atlasTexture[i2] = r2), r2.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas(t2, i2) {
              const o2 = [];
              for (const e2 in this.patterns[t2])
                o2.push(this.patterns[t2][e2].bin);
              const { w: r2, h: s2 } = e.z(o2), a2 = this.atlasImage[t2];
              a2.resize({ width: r2 || 1, height: s2 || 1 });
              for (const o3 in this.patterns[t2]) {
                const { bin: r3, position: s3 } = this.patterns[t2][o3];
                let n2 = s3.padding;
                const l2 = r3.x + n2, c2 = r3.y + n2, h2 = this.images[t2][o3].data, u2 = h2.width, d2 = h2.height;
                n2 = n2 > 1 ? n2 - 1 : n2, e.r.copy(h2, a2, { x: 0, y: 0 }, { x: l2, y: c2 }, { width: u2, height: d2 }, i2), e.r.copy(h2, a2, { x: 0, y: d2 - n2 }, { x: l2, y: c2 - n2 }, { width: u2, height: n2 }, i2), e.r.copy(h2, a2, { x: 0, y: 0 }, { x: l2, y: c2 + d2 }, { width: u2, height: n2 }, i2), e.r.copy(h2, a2, { x: u2 - n2, y: 0 }, { x: l2 - n2, y: c2 }, { width: n2, height: d2 }, i2), e.r.copy(h2, a2, { x: 0, y: 0 }, { x: l2 + u2, y: c2 }, { width: n2, height: d2 }, i2), e.r.copy(h2, a2, { x: u2 - n2, y: d2 - n2 }, { x: l2 - n2, y: c2 - n2 }, { width: n2, height: n2 }, i2), e.r.copy(h2, a2, { x: 0, y: d2 - n2 }, { x: l2 + u2, y: c2 - n2 }, { width: n2, height: n2 }, i2), e.r.copy(h2, a2, { x: 0, y: 0 }, { x: l2 + u2, y: c2 + d2 }, { width: n2, height: n2 }, i2), e.r.copy(h2, a2, { x: u2 - n2, y: 0 }, { x: l2 - n2, y: c2 + d2 }, { width: n2, height: n2 }, i2);
              }
              this.dirty = true;
            }
            beginFrame() {
              for (const e2 in this.images)
                this.callbackDispatchedThisFrame[e2] = {};
            }
            dispatchRenderCallbacks(e2, t2) {
              for (const i2 of e2) {
                if (this.callbackDispatchedThisFrame[t2][i2])
                  continue;
                this.callbackDispatchedThisFrame[t2][i2] = true;
                const e3 = this.images[t2][i2];
                V(e3) && this.updateImage(i2, t2, e3);
              }
            }
          }
          function Z(t2) {
            const i2 = t2.key, o2 = t2.value, r2 = t2.valueSpec || {}, s2 = t2.objectElementValidators || {}, a2 = t2.style, n2 = t2.styleSpec;
            let l2 = [];
            const c2 = e.B(o2);
            if ("object" !== c2)
              return [new e.V(i2, o2, `object expected, ${c2} found`)];
            for (const t3 in o2) {
              const c3 = t3.split(".")[0];
              let h2;
              s2[c3] ? h2 = s2[c3] : r2[c3] ? h2 = _e : s2["*"] ? h2 = s2["*"] : r2["*"] && (h2 = _e), h2 ? l2 = l2.concat(h2({ key: (i2 ? `${i2}.` : i2) + t3, value: o2[t3], valueSpec: r2[c3] || r2["*"], style: a2, styleSpec: n2, object: o2, objectKey: t3 }, o2)) : l2.push(new e.A(i2, o2[t3], `unknown property "${t3}"`));
            }
            for (const t3 in r2)
              s2[t3] || r2[t3].required && void 0 === r2[t3].default && void 0 === o2[t3] && l2.push(new e.V(i2, o2, `missing required property "${t3}"`));
            return l2;
          }
          function H(t2) {
            const i2 = t2.value, o2 = t2.valueSpec, r2 = t2.style, s2 = t2.styleSpec, a2 = t2.key, n2 = t2.arrayElementValidator || _e;
            if ("array" !== e.B(i2))
              return [new e.V(a2, i2, `array expected, ${e.B(i2)} found`)];
            if (o2.length && i2.length !== o2.length)
              return [new e.V(a2, i2, `array length ${o2.length} expected, length ${i2.length} found`)];
            if (o2["min-length"] && i2.length < o2["min-length"])
              return [new e.V(a2, i2, `array length at least ${o2["min-length"]} expected, length ${i2.length} found`)];
            let l2 = { type: o2.value, values: o2.values, minimum: o2.minimum, maximum: o2.maximum, function: void 0 };
            s2.$version < 7 && (l2.function = o2.function), "object" === e.B(o2.value) && (l2 = o2.value);
            let c2 = [];
            for (let e2 = 0; e2 < i2.length; e2++)
              c2 = c2.concat(n2({ array: i2, arrayIndex: e2, value: i2[e2], valueSpec: l2, style: r2, styleSpec: s2, key: `${a2}[${e2}]` }, true));
            return c2;
          }
          function W(t2) {
            const i2 = t2.key, o2 = t2.value, r2 = t2.valueSpec;
            let s2 = e.B(o2);
            if ("number" === s2 && o2 != o2 && (s2 = "NaN"), "number" !== s2)
              return [new e.V(i2, o2, `number expected, ${s2} found`)];
            if ("minimum" in r2) {
              let s3 = r2.minimum;
              if ("array" === e.B(r2.minimum) && (s3 = r2.minimum[t2.arrayIndex]), o2 < s3)
                return [new e.V(i2, o2, `${o2} is less than the minimum value ${s3}`)];
            }
            if ("maximum" in r2) {
              let s3 = r2.maximum;
              if ("array" === e.B(r2.maximum) && (s3 = r2.maximum[t2.arrayIndex]), o2 > s3)
                return [new e.V(i2, o2, `${o2} is greater than the maximum value ${s3}`)];
            }
            return [];
          }
          function $(t2) {
            const i2 = t2.valueSpec, o2 = e.D(t2.value.type);
            let r2, s2, a2, n2 = {};
            const l2 = "categorical" !== o2 && void 0 === t2.value.property, c2 = !l2, h2 = "array" === e.B(t2.value.stops) && "array" === e.B(t2.value.stops[0]) && "object" === e.B(t2.value.stops[0][0]), u2 = Z({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if ("identity" === o2)
                return [new e.V(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let i3 = [];
              const r3 = t3.value;
              return i3 = i3.concat(H({ key: t3.key, value: r3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: d2 })), "array" === e.B(r3) && 0 === r3.length && i3.push(new e.V(t3.key, r3, "array must have at least one stop")), i3;
            }, default: function(e2) {
              return _e({ key: e2.key, value: e2.value, valueSpec: i2, style: e2.style, styleSpec: e2.styleSpec });
            } } });
            return "identity" === o2 && l2 && u2.push(new e.V(t2.key, t2.value, 'missing required property "property"')), "identity" === o2 || t2.value.stops || u2.push(new e.V(t2.key, t2.value, 'missing required property "stops"')), "exponential" === o2 && t2.valueSpec.expression && !e.F(t2.valueSpec) && u2.push(new e.V(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (c2 && !e.G(t2.valueSpec) ? u2.push(new e.V(t2.key, t2.value, "property functions not supported")) : l2 && !e.H(t2.valueSpec) && u2.push(new e.V(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== o2 && !h2 || void 0 !== t2.value.property || u2.push(new e.V(t2.key, t2.value, '"property" property is required')), u2;
            function d2(t3) {
              let o3 = [];
              const r3 = t3.value, l3 = t3.key;
              if ("array" !== e.B(r3))
                return [new e.V(l3, r3, `array expected, ${e.B(r3)} found`)];
              if (2 !== r3.length)
                return [new e.V(l3, r3, `array length 2 expected, length ${r3.length} found`)];
              if (h2) {
                if ("object" !== e.B(r3[0]))
                  return [new e.V(l3, r3, `object expected, ${e.B(r3[0])} found`)];
                if (void 0 === r3[0].zoom)
                  return [new e.V(l3, r3, "object stop key must have zoom")];
                if (void 0 === r3[0].value)
                  return [new e.V(l3, r3, "object stop key must have value")];
                const i3 = e.D(r3[0].zoom);
                if ("number" != typeof i3)
                  return [new e.V(l3, r3[0].zoom, "stop zoom values must be numbers")];
                if (a2 && a2 > i3)
                  return [new e.V(l3, r3[0].zoom, "stop zoom values must appear in ascending order")];
                i3 !== a2 && (a2 = i3, s2 = void 0, n2 = {}), o3 = o3.concat(Z({ key: `${l3}[0]`, value: r3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: W, value: _2 } }));
              } else
                o3 = o3.concat(_2({ key: `${l3}[0]`, value: r3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, r3));
              return e.J(e.K(r3[1])) ? o3.concat([new e.V(`${l3}[1]`, r3[1], "expressions are not allowed in function stops.")]) : o3.concat(_e({ key: `${l3}[1]`, value: r3[1], valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function _2(t3, a3) {
              const l3 = e.B(t3.value), c3 = e.D(t3.value), h3 = null !== t3.value ? t3.value : a3;
              if (r2) {
                if (l3 !== r2)
                  return [new e.V(t3.key, h3, `${l3} stop domain type must match previous stop domain type ${r2}`)];
              } else
                r2 = l3;
              if ("number" !== l3 && "string" !== l3 && "boolean" !== l3 && "number" != typeof c3 && "string" != typeof c3 && "boolean" != typeof c3)
                return [new e.V(t3.key, h3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== l3 && "categorical" !== o2) {
                let r3 = `number expected, ${l3} found`;
                return e.G(i2) && void 0 === o2 && (r3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e.V(t3.key, h3, r3)];
              }
              return "categorical" !== o2 || "number" !== l3 || "number" == typeof c3 && isFinite(c3) && Math.floor(c3) === c3 ? "categorical" !== o2 && "number" === l3 && "number" == typeof c3 && "number" == typeof s2 && void 0 !== s2 && c3 < s2 ? [new e.V(t3.key, h3, "stop domain values must appear in ascending order")] : (s2 = c3, "categorical" === o2 && c3 in n2 ? [new e.V(t3.key, h3, "stop domain values must be unique")] : (n2[c3] = true, [])) : [new e.V(t3.key, h3, `integer expected, found ${String(c3)}`)];
            }
          }
          function X(t2) {
            const i2 = ("property" === t2.expressionContext ? e.L : e.M)(e.K(t2.value), t2.valueSpec);
            if ("error" === i2.result)
              return i2.value.map((i3) => new e.V(`${t2.key}${i3.key}`, t2.value, i3.message));
            const o2 = i2.value.expression || i2.value._styleExpression.expression;
            if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !o2.outputDefined())
              return [new e.V(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t2.expressionContext && "layout" === t2.propertyType && !e.N(o2))
              return [new e.V(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t2.expressionContext)
              return Y(o2, t2);
            if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
              if (!e.O(o2, ["zoom", "feature-state"]))
                return [new e.V(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t2.expressionContext && !e.Q(o2))
                return [new e.V(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function Y(t2, i2) {
            const o2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
            if (i2.valueSpec && i2.valueSpec.expression)
              for (const e2 of i2.valueSpec.expression.parameters)
                o2.delete(e2);
            if (0 === o2.size)
              return [];
            const r2 = [];
            return t2 instanceof e.S && o2.has(t2.name) ? [new e.V(i2.key, i2.value, `["${t2.name}"] expression is not supported in a filter for a ${i2.object.type} layer with id: ${i2.object.id}`)] : (t2.eachChild((e2) => {
              r2.push(...Y(e2, i2));
            }), r2);
          }
          function K(t2) {
            const i2 = t2.key, o2 = t2.value, r2 = t2.valueSpec, s2 = [];
            return Array.isArray(r2.values) ? -1 === r2.values.indexOf(e.D(o2)) && s2.push(new e.V(i2, o2, `expected one of [${r2.values.join(", ")}], ${JSON.stringify(o2)} found`)) : -1 === Object.keys(r2.values).indexOf(e.D(o2)) && s2.push(new e.V(i2, o2, `expected one of [${Object.keys(r2.values).join(", ")}], ${JSON.stringify(o2)} found`)), s2;
          }
          function J(t2) {
            return e.W(e.K(t2.value)) ? X(e.C({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : Q(t2);
          }
          function Q(t2) {
            const i2 = t2.value, o2 = t2.key;
            if ("array" !== e.B(i2))
              return [new e.V(o2, i2, `array expected, ${e.B(i2)} found`)];
            const r2 = t2.styleSpec;
            let s2, a2 = [];
            if (i2.length < 1)
              return [new e.V(o2, i2, "filter array must have at least 1 element")];
            switch (a2 = a2.concat(K({ key: `${o2}[0]`, value: i2[0], valueSpec: r2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), e.D(i2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                i2.length >= 2 && "$type" === e.D(i2[1]) && a2.push(new e.V(o2, i2, `"$type" cannot be use with operator "${i2[0]}"`));
              case "==":
              case "!=":
                3 !== i2.length && a2.push(new e.V(o2, i2, `filter array for operator "${i2[0]}" must have 3 elements`));
              case "in":
              case "!in":
                i2.length >= 2 && (s2 = e.B(i2[1]), "string" !== s2 && a2.push(new e.V(`${o2}[1]`, i2[1], `string expected, ${s2} found`)));
                for (let n2 = 2; n2 < i2.length; n2++)
                  s2 = e.B(i2[n2]), "$type" === e.D(i2[1]) ? a2 = a2.concat(K({ key: `${o2}[${n2}]`, value: i2[n2], valueSpec: r2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== s2 && "number" !== s2 && "boolean" !== s2 && a2.push(new e.V(`${o2}[${n2}]`, i2[n2], `string, number, or boolean expected, ${s2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let e2 = 1; e2 < i2.length; e2++)
                  a2 = a2.concat(Q({ key: `${o2}[${e2}]`, value: i2[e2], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                s2 = e.B(i2[1]), 2 !== i2.length ? a2.push(new e.V(o2, i2, `filter array for "${i2[0]}" operator must have 2 elements`)) : "string" !== s2 && a2.push(new e.V(`${o2}[1]`, i2[1], `string expected, ${s2} found`));
            }
            return a2;
          }
          function ee(t2, i2) {
            const o2 = t2.key, r2 = t2.style, s2 = t2.layer, a2 = t2.styleSpec, n2 = t2.value, l2 = t2.objectKey, c2 = a2[`${i2}_${t2.layerType}`];
            if (!c2)
              return [];
            const h2 = l2.match(/^(.*)-transition$/);
            if ("paint" === i2 && h2 && c2[h2[1]] && c2[h2[1]].transition)
              return _e({ key: o2, value: n2, valueSpec: a2.transition, style: r2, styleSpec: a2 });
            const u2 = t2.valueSpec || c2[l2];
            if (!u2)
              return [new e.A(o2, n2, `unknown property "${l2}"`)];
            let d2;
            if ("string" === e.B(n2) && e.G(u2) && !u2.tokens && (d2 = /^{([^}]+)}$/.exec(n2))) {
              const t3 = `\`{ "type": "identity", "property": ${d2 ? JSON.stringify(d2[1]) : '"_"'} }\``;
              return [new e.V(o2, n2, `"${l2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
            }
            const _2 = [];
            if ("symbol" === t2.layerType)
              "text-field" !== l2 || !r2 || r2.glyphs || r2.imports || _2.push(new e.V(o2, n2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l2 && e.X(e.K(n2)) && "identity" === e.D(n2.type) && _2.push(new e.V(o2, n2, '"text-font" does not support identity functions'));
            else if ("model" === t2.layerType && "paint" === i2 && s2 && s2.layout && s2.layout.hasOwnProperty("model-id") && e.G(u2) && (e.Y(u2) || e.H(u2))) {
              const t3 = e.L(e.K(n2), u2), i3 = t3.value.expression || t3.value._styleExpression.expression;
              i3 && !e.O(i3, ["measure-light"]) && ("model-emissive-strength" === l2 && e.Q(i3) && e.N(i3) || _2.push(new e.V(o2, n2, `${l2} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
            }
            return _2.concat(_e({ key: t2.key, value: n2, valueSpec: u2, style: r2, styleSpec: a2, expressionContext: "property", propertyType: i2, propertyKey: l2 }));
          }
          function te(e2) {
            return ee(e2, "paint");
          }
          function ie(e2) {
            return ee(e2, "layout");
          }
          function oe(t2) {
            let i2 = [];
            const o2 = t2.value, r2 = t2.key, s2 = t2.style, a2 = t2.styleSpec;
            o2.type || o2.ref || i2.push(new e.V(r2, o2, 'either "type" or "ref" is required'));
            let n2 = e.D(o2.type);
            const l2 = e.D(o2.ref);
            if (o2.id) {
              const a3 = e.D(o2.id);
              for (let n3 = 0; n3 < t2.arrayIndex; n3++) {
                const t3 = s2.layers[n3];
                e.D(t3.id) === a3 && i2.push(new e.V(r2, o2.id, `duplicate layer id "${o2.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in o2) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in o2 && i2.push(new e.V(r2, o2[t4], `"${t4}" is prohibited for ref layers`));
              }), s2.layers.forEach((i3) => {
                e.D(i3.id) === l2 && (t3 = i3);
              }), t3 ? t3.ref ? i2.push(new e.V(r2, o2.ref, "ref cannot reference another ref layer")) : n2 = e.D(t3.type) : "string" == typeof l2 && i2.push(new e.V(r2, o2.ref, `ref layer "${l2}" not found`));
            } else if ("background" !== n2 && "sky" !== n2 && "slot" !== n2)
              if (o2.source) {
                const t3 = s2.sources && s2.sources[o2.source], a3 = t3 && e.D(t3.type);
                t3 ? "vector" === a3 && "raster" === n2 ? i2.push(new e.V(r2, o2.source, `layer "${o2.id}" requires a raster source`)) : "raster" === a3 && "raster" !== n2 ? i2.push(new e.V(r2, o2.source, `layer "${o2.id}" requires a vector source`)) : "vector" !== a3 || o2["source-layer"] ? "raster-dem" === a3 && "hillshade" !== n2 ? i2.push(new e.V(r2, o2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== a3 || ["raster", "raster-particle"].includes(n2) ? "line" !== n2 || !o2.paint || !o2.paint["line-gradient"] && !o2.paint["line-trim-offset"] || "geojson" === a3 && t3.lineMetrics ? "raster-particle" === n2 && "raster-array" !== a3 && i2.push(new e.V(r2, o2.source, `layer "${o2.id}" requires a 'raster-array' source.`)) : i2.push(new e.V(r2, o2, `layer "${o2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : i2.push(new e.V(r2, o2.source, "raster-array source can only be used with layer type 'raster'.")) : i2.push(new e.V(r2, o2, `layer "${o2.id}" must specify a "source-layer"`)) : i2.push(new e.V(r2, o2.source, `source "${o2.source}" not found`));
              } else
                i2.push(new e.V(r2, o2, 'missing required property "source"'));
            return i2 = i2.concat(Z({ key: r2, value: o2, valueSpec: a2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => _e({ key: `${r2}.type`, value: o2.type, valueSpec: a2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: o2, objectKey: "type" }), filter: (t3) => J(e.C({ layerType: n2 }, t3)), layout: (t3) => Z({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => ie(e.C({ layerType: n2 }, t4)) } }), paint: (t3) => Z({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => te(e.C({ layerType: n2, layer: o2 }, t4)) } }) } })), i2;
          }
          function re(t2) {
            const i2 = t2.value, o2 = t2.key, r2 = e.B(i2);
            return "string" !== r2 ? [new e.V(o2, i2, `string expected, ${r2} found`)] : [];
          }
          const se = { promoteId: function({ key: t2, value: i2 }) {
            if ("string" === e.B(i2))
              return re({ key: t2, value: i2 });
            {
              const e2 = [];
              for (const o2 in i2)
                e2.push(...re({ key: `${t2}.${o2}`, value: i2[o2] }));
              return e2;
            }
          } };
          function ae(t2) {
            const i2 = t2.value, o2 = t2.key, r2 = t2.styleSpec, s2 = t2.style;
            if (!i2.type)
              return [new e.V(o2, i2, '"type" is required')];
            const a2 = e.D(i2.type);
            let n2 = [];
            switch (["vector", "raster", "raster-dem", "raster-array"].includes(a2) && (i2.url || i2.tiles || n2.push(new e.A(o2, i2, 'Either "url" or "tiles" is required.'))), a2) {
              case "vector":
              case "raster":
              case "raster-dem":
              case "raster-array":
                return n2 = n2.concat(Z({ key: o2, value: i2, valueSpec: r2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: r2, objectElementValidators: se })), n2;
              case "geojson":
                if (n2 = Z({ key: o2, value: i2, valueSpec: r2.source_geojson, style: s2, styleSpec: r2, objectElementValidators: se }), i2.cluster)
                  for (const e2 in i2.clusterProperties) {
                    const [t3, r3] = i2.clusterProperties[e2], s3 = "string" == typeof t3 ? [t3, ["accumulated"], ["get", e2]] : t3;
                    n2.push(...X({ key: `${o2}.${e2}.map`, value: r3, expressionContext: "cluster-map" })), n2.push(...X({ key: `${o2}.${e2}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
                  }
                return n2;
              case "video":
                return Z({ key: o2, value: i2, valueSpec: r2.source_video, style: s2, styleSpec: r2 });
              case "image":
                return Z({ key: o2, value: i2, valueSpec: r2.source_image, style: s2, styleSpec: r2 });
              case "canvas":
                return [new e.V(o2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return K({ key: `${o2}.type`, value: i2.type, valueSpec: { values: ne(r2) }, style: s2, styleSpec: r2 });
            }
          }
          function ne(e2) {
            return e2.source.reduce((t2, i2) => {
              const o2 = e2[i2];
              return "enum" === o2.type.type && (t2 = t2.concat(Object.keys(o2.type.values))), t2;
            }, []);
          }
          function le(t2) {
            const i2 = t2.value, o2 = t2.styleSpec, r2 = o2.light, s2 = t2.style;
            let a2 = [];
            const n2 = e.B(i2);
            if (void 0 === i2)
              return a2;
            if ("object" !== n2)
              return a2 = a2.concat([new e.V("light", i2, `object expected, ${n2} found`)]), a2;
            for (const t3 in i2) {
              const n3 = t3.match(/^(.*)-transition$/);
              a2 = a2.concat(n3 && r2[n3[1]] && r2[n3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: o2.transition, style: s2, styleSpec: o2 }) : r2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: r2[t3], style: s2, styleSpec: o2 }) : [new e.V(t3, i2[t3], `unknown property "${t3}"`)]);
            }
            return a2;
          }
          function ce(t2) {
            const i2 = t2.value;
            let o2 = [];
            if (!i2)
              return o2;
            const r2 = e.B(i2);
            if ("object" !== r2)
              return o2 = o2.concat([new e.V("light-3d", i2, `object expected, ${r2} found`)]), o2;
            const s2 = t2.styleSpec, a2 = s2["light-3d"], n2 = t2.key, l2 = t2.style, c2 = t2.style.lights;
            for (const t3 of ["type", "id"])
              if (!(t3 in i2))
                return o2 = o2.concat([new e.V("light-3d", i2, `missing property ${t3} on light`)]), o2;
            if (i2.type && c2)
              for (let r3 = 0; r3 < t2.arrayIndex; r3++) {
                const t3 = e.D(i2.type), s3 = c2[r3];
                e.D(s3.type) === t3 && o2.push(new e.V(n2, i2.id, `duplicate light type "${i2.type}", previously defined at line ${s3.id.__line__}`));
              }
            const h2 = `properties_light_${i2.type}`;
            if (!(h2 in s2))
              return o2 = o2.concat([new e.V("light-3d", i2, `Invalid light type ${i2.type}`)]), o2;
            const u2 = s2[h2];
            for (const r3 in i2)
              if ("properties" === r3) {
                const a3 = i2[r3], n3 = e.B(a3);
                if ("object" !== n3)
                  return o2 = o2.concat([new e.V("properties", a3, `object expected, ${n3} found`)]), o2;
                for (const i3 in a3)
                  o2 = o2.concat(u2[i3] ? _e({ key: i3, value: a3[i3], valueSpec: u2[i3], style: l2, styleSpec: s2 }) : [new e.A(t2.key, a3[i3], `unknown property "${i3}"`)]);
              } else {
                const t3 = r3.match(/^(.*)-transition$/);
                o2 = o2.concat(t3 && a2[t3[1]] && a2[t3[1]].transition ? _e({ key: r3, value: i2[r3], valueSpec: s2.transition, style: l2, styleSpec: s2 }) : a2[r3] ? _e({ key: r3, value: i2[r3], valueSpec: a2[r3], style: l2, styleSpec: s2 }) : [new e.A(r3, i2[r3], `unknown property "${r3}"`)]);
              }
            return o2;
          }
          function he(t2) {
            const i2 = t2.value, o2 = t2.key, r2 = t2.style, s2 = t2.styleSpec, a2 = s2.terrain;
            let n2 = [];
            const l2 = e.B(i2);
            if (void 0 === i2)
              return n2;
            if ("null" === l2)
              return n2;
            if ("object" !== l2)
              return n2 = n2.concat([new e.V("terrain", i2, `object expected, ${l2} found`)]), n2;
            for (const t3 in i2) {
              const o3 = t3.match(/^(.*)-transition$/);
              n2 = n2.concat(o3 && a2[o3[1]] && a2[o3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: s2.transition, style: r2, styleSpec: s2 }) : a2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: a2[t3], style: r2, styleSpec: s2 }) : [new e.A(t3, i2[t3], `unknown property "${t3}"`)]);
            }
            if (i2.source) {
              const t3 = r2.sources && r2.sources[i2.source], s3 = t3 && e.D(t3.type);
              t3 ? "raster-dem" !== s3 && n2.push(new e.V(o2, i2.source, `terrain cannot be used with a source of type ${String(s3)}, it only be used with a "raster-dem" source type`)) : n2.push(new e.V(o2, i2.source, `source "${i2.source}" not found`));
            } else
              n2.push(new e.V(o2, i2, 'terrain is missing required property "source"'));
            return n2;
          }
          function ue(t2) {
            const i2 = t2.value, o2 = t2.style, r2 = t2.styleSpec, s2 = r2.fog;
            let a2 = [];
            const n2 = e.B(i2);
            if (void 0 === i2)
              return a2;
            if ("object" !== n2)
              return a2 = a2.concat([new e.V("fog", i2, `object expected, ${n2} found`)]), a2;
            for (const t3 in i2) {
              const n3 = t3.match(/^(.*)-transition$/);
              a2 = a2.concat(n3 && s2[n3[1]] && s2[n3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: r2.transition, style: o2, styleSpec: r2 }) : s2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: s2[t3], style: o2, styleSpec: r2 }) : [new e.A(t3, i2[t3], `unknown property "${t3}"`)]);
            }
            return a2;
          }
          const de = { "*": () => [], array: H, boolean: function(t2) {
            const i2 = t2.value, o2 = t2.key, r2 = e.B(i2);
            return "boolean" !== r2 ? [new e.V(o2, i2, `boolean expected, ${r2} found`)] : [];
          }, number: W, color: function(t2) {
            const i2 = t2.key, o2 = t2.value, r2 = e.B(o2);
            return "string" !== r2 ? [new e.V(i2, o2, `color expected, ${r2} found`)] : null === e.U.parseCSSColor(o2) ? [new e.V(i2, o2, `color expected, "${o2}" found`)] : [];
          }, enum: K, filter: J, function: $, layer: oe, object: Z, source: ae, model: e.Z, light: le, "light-3d": ce, terrain: he, fog: ue, string: re, formatted: function(e2) {
            return 0 === re(e2).length ? [] : X(e2);
          }, resolvedImage: function(e2) {
            return 0 === re(e2).length ? [] : X(e2);
          }, projection: function(t2) {
            const i2 = t2.value, o2 = t2.styleSpec, r2 = o2.projection, s2 = t2.style;
            let a2 = [];
            const n2 = e.B(i2);
            if ("object" === n2)
              for (const e2 in i2)
                a2 = a2.concat(_e({ key: e2, value: i2[e2], valueSpec: r2[e2], style: s2, styleSpec: o2 }));
            else
              "string" !== n2 && (a2 = a2.concat([new e.V("projection", i2, `object or string expected, ${n2} found`)]));
            return a2;
          }, import: function(t2) {
            const { value: i2, styleSpec: o2 } = t2, { data: r2, ...s2 } = i2;
            Object.defineProperty(s2, "__line__", { value: i2.__line__, enumerable: false });
            let a2 = Z(e.C({}, t2, { value: s2, valueSpec: o2.import }));
            return "" === e.D(s2.id) && a2.push(new e.V(`${t2.key}.id`, s2, "import id can't be an empty string")), r2 && (a2 = a2.concat(me(r2, o2, { key: `${t2.key}.data` }))), a2;
          } };
          function _e(t2, i2 = false) {
            const o2 = t2.value, r2 = t2.valueSpec, s2 = t2.styleSpec;
            if (r2.expression && e.X(e.D(o2)))
              return $(t2);
            if (r2.expression && e.J(e.K(o2)))
              return X(t2);
            if (r2.type && de[r2.type]) {
              const o3 = de[r2.type](t2);
              return true === i2 && o3.length > 0 && "array" === e.B(t2.value) ? X(t2) : o3;
            }
            return Z(e.C({}, t2, { valueSpec: r2.type ? s2[r2.type] : r2 }));
          }
          function pe(t2) {
            const i2 = t2.value, o2 = t2.key, r2 = re(t2);
            return r2.length || (-1 === i2.indexOf("{fontstack}") && r2.push(new e.V(o2, i2, '"glyphs" url must include a "{fontstack}" token')), -1 === i2.indexOf("{range}") && r2.push(new e.V(o2, i2, '"glyphs" url must include a "{range}" token'))), r2;
          }
          function me(t2, i2 = e._, o2 = {}) {
            return _e({ key: o2.key || "", value: t2, valueSpec: i2.$root, styleSpec: i2, style: t2, objectElementValidators: { glyphs: pe, "*": () => [] } });
          }
          function fe(t2, i2 = e._) {
            return Ie(me(t2, i2));
          }
          const ge = (e2) => Ie(ae(e2)), ve = (e2) => Ie(le(e2)), xe = (e2) => Ie(ce(e2)), ye = (e2) => Ie(he(e2)), be = (e2) => Ie(ue(e2)), we = (e2) => Ie(oe(e2)), Te = (e2) => Ie(J(e2)), Ee = (e2) => Ie(te(e2)), Ce = (e2) => Ie(ie(e2)), Se = (t2) => Ie(e.Z(t2));
          function Ie(e2) {
            return e2.slice().sort((e3, t2) => e3.line && t2.line ? e3.line - t2.line : 0);
          }
          function De(t2, i2) {
            let o2 = false;
            if (i2 && i2.length)
              for (const r2 of i2)
                r2 instanceof e.A ? e.w(r2.message) : (t2.fire(new e.t(new Error(r2.message))), o2 = true);
            return o2;
          }
          let Re;
          class Ae extends e.E {
            constructor(t2, i2 = "flat") {
              super(), this._transitionable = new e.$(Re || (Re = new e.a0({ anchor: new e.a1(e._.light.anchor), position: new e.a2(e._.light.position), color: new e.a1(e._.light.color), intensity: new e.a1(e._.light.intensity) }))), this.setLight(t2, i2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e2, t2, i2 = {}) {
              this._validate(ve, e2, i2) || (this._transitionable.setTransitionOrValue(e2), this.id = t2);
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && De(this, t2.call(fe, e.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e._ })));
            }
          }
          const Le = new e.a0({ source: new e.a1(e._.terrain.source), exaggeration: new e.a1(e._.terrain.exaggeration) });
          let Pe = class extends e.E {
            constructor(t2, i2, o2, r2) {
              super(), this.scope = o2, this._transitionable = new e.$(Le, o2, r2), this._transitionable.setTransitionOrValue(t2, r2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
            }
            get() {
              return this._transitionable.serialize();
            }
            set(e2, t2) {
              this._transitionable.setTransitionOrValue(e2, t2);
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            getExaggeration(t2) {
              return this._transitioning.possiblyEvaluate(new e.a3(t2)).get("exaggeration");
            }
            isZoomDependent() {
              const t2 = this._transitionable._values.exaggeration;
              return null != t2 && null != t2.value && null != t2.value.expression && t2.value.expression instanceof e.a4;
            }
          };
          const Me = 45, ze = 65, Oe = 0.05;
          function Fe(t2, i2, o2, r2) {
            const s2 = e.a7(Me, ze, o2), [a2, n2] = ke(t2, r2);
            let l2 = 1 - Math.min(1, Math.exp((i2 - a2) / (n2 - a2) * -6));
            return l2 *= l2 * l2, l2 = Math.min(1, 1.00747 * l2), l2 * s2 * t2.alpha;
          }
          function ke(e2, t2) {
            const i2 = 0.5 / Math.tan(0.5 * t2);
            return [e2.range[0] + i2, e2.range[1] + i2];
          }
          function Be(t2, i2, o2, r2, s2) {
            const a2 = e.a6.vec3.transformMat4([], [i2, o2, r2], s2.mercatorFogMatrix);
            return Fe(t2, e.a6.vec3.length(a2), s2.pitch, s2._fov);
          }
          function Ne(t2, i2, o2, r2, s2, a2, n2) {
            const l2 = [[o2, r2, 0], [s2, r2, 0], [s2, a2, 0], [o2, a2, 0]];
            let c2 = Number.MAX_VALUE, h2 = -Number.MAX_VALUE;
            for (const t3 of l2) {
              const o3 = e.a6.vec3.transformMat4([], t3, i2), r3 = e.a6.vec3.length(o3);
              c2 = Math.min(c2, r3), h2 = Math.max(h2, r3);
            }
            return [Fe(t2, c2, n2.pitch, n2._fov), Fe(t2, h2, n2.pitch, n2._fov)];
          }
          const Ue = new e.a0({ range: new e.a1(e._.fog.range), color: new e.a1(e._.fog.color), "high-color": new e.a1(e._.fog["high-color"]), "space-color": new e.a1(e._.fog["space-color"]), "horizon-blend": new e.a1(e._.fog["horizon-blend"]), "star-intensity": new e.a1(e._.fog["star-intensity"]), "vertical-range": new e.a1(e._.fog["vertical-range"]) });
          class Ge extends e.E {
            constructor(t2, i2, o2, r2) {
              super(), this._transitionable = new e.$(Ue, o2, new Map(r2)), this.set(t2, r2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2, this.properties = new e.a8(Ue), this.scope = o2;
            }
            get state() {
              const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.a9(t2.zoom), r2 = this.properties.get("range"), s2 = [0.5, 3];
              return { range: i2 ? [e.aa(s2[0], r2[0], o2), e.aa(s2[1], r2[1], o2)] : r2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
            }
            get() {
              return this._transitionable.serialize();
            }
            set(t2, i2, o2 = {}) {
              if (this._validate(be, t2, o2))
                return;
              const r2 = e.l({}, t2);
              for (const t3 of Object.keys(e._.fog))
                void 0 === r2[t3] && (r2[t3] = e._.fog[t3].default);
              this._options = r2, this._transitionable.setTransitionOrValue(this._options, i2);
            }
            getOpacity(t2) {
              if (!this._transform.projection.supportsFog)
                return 0;
              const i2 = this.properties && this.properties.get("color") || 1;
              return ("globe" === this._transform.projection.name ? 1 : e.a7(Me, ze, t2)) * i2.a;
            }
            getOpacityAtLatLng(t2, i2) {
              return this._transform.projection.supportsFog ? function(t3, i3, o2) {
                const r2 = e.a5.fromLngLat(i3), s2 = o2.elevation ? o2.elevation.getAtPointOrZero(r2) : 0;
                return Be(t3, r2.x, r2.y, s2, o2);
              }(this.state, t2, i2) : 0;
            }
            getOpacityForTile(t2) {
              if (!this._transform.projection.supportsFog)
                return [1, 1];
              const i2 = this._transform.calculateFogTileMatrix(t2.toUnwrapped());
              return Ne(this.state, i2, 0, 0, e.ab, e.ab, this._transform);
            }
            getOpacityForBounds(e2, t2, i2, o2, r2) {
              return this._transform.projection.supportsFog ? Ne(this.state, e2, t2, i2, o2, r2, this._transform) : [1, 1];
            }
            getFovAdjustedRange(e2) {
              return this._transform.projection.supportsFog ? ke(this.state, e2) : [0, 1];
            }
            isVisibleOnFrustum(t2) {
              if (!this._transform.projection.supportsFog)
                return false;
              const i2 = [4, 5, 6, 7];
              for (const o2 of i2) {
                const i3 = t2.points[o2];
                let r2;
                if (i3[2] >= 0)
                  r2 = i3;
                else {
                  const s2 = t2.points[o2 - 4];
                  r2 = e.ac(s2, i3, s2[2] / (s2[2] - i3[2]));
                }
                if (Be(this.state, r2[0], r2[1], 0, this._transform) >= Oe)
                  return true;
              }
              return false;
            }
            updateConfig(e2) {
              this._transitionable.setTransitionOrValue(this._options, new Map(e2));
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && De(this, t2.call(fe, e.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e._ })));
            }
          }
          class je extends e.E {
            constructor(t2, i2, o2, r2) {
              super(), this.scope = o2, this._options = t2, this.properties = new e.a8(i2), this._transitionable = new e.$(i2, o2, new Map(r2)), this._transitionable.setTransitionOrValue(t2.properties), this._transitioning = this._transitionable.untransitioned();
            }
            updateConfig(e2) {
              this._transitionable.setTransitionOrValue(this._options.properties, new Map(e2));
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            get() {
              return this._options.properties = this._transitionable.serialize(), this._options;
            }
            set(e2, t2) {
              this._options = e2, this._transitionable.setTransitionOrValue(e2.properties, t2);
            }
            shadowsEnabled() {
              return !!this.properties && true === this.properties.get("cast-shadows");
            }
          }
          let Ve, qe;
          class Ze {
            constructor(e2, t2, i2, o2) {
              this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
            }
            static createFromScreenPoints(t2, i2) {
              let o2, r2;
              if (t2 instanceof e.P || "number" == typeof t2[0]) {
                const s2 = e.P.convert(t2);
                o2 = [s2], r2 = i2.isPointAboveHorizon(s2);
              } else {
                const s2 = e.P.convert(t2[0]), a2 = e.P.convert(t2[1]);
                o2 = [s2, a2], r2 = e.ae(s2, a2).every((e2) => i2.isPointAboveHorizon(e2));
              }
              return new Ze(o2, i2.getCameraPoint(), r2, i2);
            }
            isPointQuery() {
              return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t2) {
              return e.ae(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
            }
            bufferedCameraGeometry(t2) {
              const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r2 = e.ae(i2, o2, 0, false);
              return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r2[3] = this.cameraPoint)), e.af(r2, t2);
            }
            bufferedCameraGeometryGlobe(t2) {
              const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r2 = e.ae(i2, o2, t2), s2 = this.cameraPoint.clone();
              switch (3 * ((s2.y > i2.y) + (s2.y > o2.y)) + ((s2.x > i2.x) + (s2.x > o2.x))) {
                case 0:
                  r2[0] = s2, r2[4] = s2.clone();
                  break;
                case 1:
                  r2.splice(1, 0, s2);
                  break;
                case 2:
                  r2[1] = s2;
                  break;
                case 3:
                  r2.splice(4, 0, s2);
                  break;
                case 5:
                  r2.splice(2, 0, s2);
                  break;
                case 6:
                  r2[3] = s2;
                  break;
                case 7:
                  r2.splice(3, 0, s2);
                  break;
                case 8:
                  r2[2] = s2;
              }
              return r2;
            }
            containsTile(t2, i2, o2, r2 = 0) {
              const s2 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, a2 = o2 ? this._bufferedCameraMercator(s2, i2) : this._bufferedScreenMercator(s2, i2);
              let n2 = t2.tileID.wrap + (a2.unwrapped ? r2 : 0);
              const l2 = a2.polygon.map((i3) => e.ag(t2.tileTransform, i3, n2));
              if (!e.ah(l2, 0, 0, e.ab, e.ab))
                return;
              n2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r2 : 0);
              const c2 = this.screenGeometryMercator.polygon.map((i3) => e.ai(t2.tileTransform, i3, n2)), h2 = c2.map((t3) => new e.P(t3[0], t3[1])), u2 = i2.getFreeCameraOptions().position || new e.a5(0, 0, 0), d2 = e.ai(t2.tileTransform, u2, n2), _2 = c2.map((t3) => {
                const i3 = e.a6.vec3.sub(t3, t3, d2);
                return e.a6.vec3.normalize(i3, i3), new e.aj(d2, i3);
              }), p2 = e.ak(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
              return { queryGeometry: this, tilespaceGeometry: h2, tilespaceRays: _2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (m2 = e.al(l2), m2.min.x = e.ap(m2.min.x, 0, e.ab), m2.min.y = e.ap(m2.min.y, 0, e.ab), m2.max.x = e.ap(m2.max.x, 0, e.ab), m2.max.y = e.ap(m2.max.y, 0, e.ab), m2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
              var m2;
            }
            _bufferedScreenMercator(e2, t2) {
              const i2 = $e(e2);
              if (this._screenRaycastCache[i2])
                return this._screenRaycastCache[i2];
              {
                let o2;
                return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
              }
            }
            _bufferedCameraMercator(e2, t2) {
              const i2 = $e(e2);
              if (this._cameraRaycastCache[i2])
                return this._cameraRaycastCache[i2];
              {
                let o2;
                return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
              }
            }
            _projectAndResample(t2, i2) {
              const o2 = function(t3, i3) {
                const o3 = e.a6.mat4.multiply([], i3.pixelMatrix, i3.globeMatrix), r3 = [0, -e.aq, 0, 1], s2 = [0, e.aq, 0, 1], a2 = [0, 0, 0, 1];
                e.a6.vec4.transformMat4(r3, r3, o3), e.a6.vec4.transformMat4(s2, s2, o3), e.a6.vec4.transformMat4(a2, a2, o3);
                const n2 = new e.P(r3[0] / r3[3], r3[1] / r3[3]), l2 = new e.P(s2[0] / s2[3], s2[1] / s2[3]), c2 = e.an(t3, n2) && r3[3] < a2[3], h2 = e.an(t3, l2) && s2[3] < a2[3];
                if (!c2 && !h2)
                  return null;
                const u2 = function(e2, t4, i4) {
                  for (let o4 = 1; o4 < e2.length; o4++) {
                    const r4 = We(t4.pointCoordinate3D(e2[o4 - 1]).x), s3 = We(t4.pointCoordinate3D(e2[o4]).x);
                    if (i4 < 0) {
                      if (r4 < s3)
                        return { idx: o4, t: -r4 / (s3 - 1 - r4) };
                    } else if (s3 < r4)
                      return { idx: o4, t: (1 - r4) / (s3 + 1 - r4) };
                  }
                  return null;
                }(t3, i3, c2 ? -1 : 1);
                if (!u2)
                  return null;
                const { idx: d2, t: _2 } = u2;
                let p2 = d2 > 1 ? He(t3.slice(0, d2), i3) : [], m2 = d2 < t3.length ? He(t3.slice(d2), i3) : [];
                p2 = p2.map((t4) => new e.P(We(t4.x), t4.y)), m2 = m2.map((t4) => new e.P(We(t4.x), t4.y));
                const f2 = [...p2];
                0 === f2.length && f2.push(m2[m2.length - 1]);
                const g2 = e.aa(f2[f2.length - 1].y, (0 === m2.length ? p2[0] : m2[0]).y, _2);
                let v2;
                return v2 = c2 ? [new e.P(0, g2), new e.P(0, 0), new e.P(1, 0), new e.P(1, g2)] : [new e.P(1, g2), new e.P(1, 1), new e.P(0, 1), new e.P(0, g2)], f2.push(...v2), 0 === m2.length ? f2.push(p2[0]) : f2.push(...m2), { polygon: f2.map((t4) => new e.a5(t4.x, t4.y)), unwrapped: false };
              }(t2, i2);
              if (o2)
                return o2;
              const r2 = function(t3, i3) {
                let o3 = false, r3 = -1 / 0, s2 = 0;
                for (let e2 = 0; e2 < t3.length - 1; e2++)
                  t3[e2].x > r3 && (r3 = t3[e2].x, s2 = e2);
                for (let e2 = 0; e2 < t3.length - 1; e2++) {
                  const i4 = (s2 + e2) % (t3.length - 1), r4 = t3[i4], a3 = t3[i4 + 1];
                  Math.abs(r4.x - a3.x) > 0.5 && (r4.x < a3.x ? (r4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (a3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
                }
                const a2 = e.am(i3.center.lng);
                return o3 && a2 < Math.abs(a2 - 1) && t3.forEach((e2) => {
                  e2.x -= 1;
                }), { polygon: t3, unwrapped: o3 };
              }(He(t2, i2).map((t3) => new e.P(We(t3.x), t3.y)), i2);
              return { polygon: r2.polygon.map((t3) => new e.a5(t3.x, t3.y)), unwrapped: r2.unwrapped };
            }
          }
          function He(t2, i2) {
            return e.ao(t2, (e2) => {
              const t3 = i2.pointCoordinate3D(e2);
              e2.x = t3.x, e2.y = t3.y;
            }, 1 / 256);
          }
          function We(e2) {
            return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
          }
          function $e(e2) {
            return 100 * e2 | 0;
          }
          function Xe(t2, i2, o2, r2, s2) {
            const a2 = function(o3, r3) {
              if (o3)
                return s2(o3);
              if (r3) {
                if (t2.url && r3.tiles && t2.tiles && delete t2.tiles, r3.variants) {
                  if (!Array.isArray(r3.variants))
                    return s2(new Error("variants must be an array"));
                  for (const t3 of r3.variants) {
                    if (null == t3 || "object" != typeof t3 || t3.constructor !== Object)
                      return s2(new Error("variant must be an object"));
                    if (!Array.isArray(t3.capabilities))
                      return s2(new Error("capabilities must be an array"));
                    if (1 === t3.capabilities.length && "meshopt" === t3.capabilities[0]) {
                      r3 = e.l(r3, t3);
                      break;
                    }
                  }
                }
                const o4 = e.ar(e.l(r3, t2), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                r3.vector_layers && (o4.vectorLayers = r3.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e2) => e2.id)), r3.raster_layers && (o4.rasterLayers = r3.raster_layers, o4.rasterLayerIds = o4.rasterLayers.map((e2) => e2.id)), o4.tiles = i2.canonicalizeTileset(o4, t2.url), s2(null, o4);
              }
            }, n2 = function(e2, t3, i3) {
              if (!e2)
                return null;
              if (!t3 && !i3)
                return e2;
              i3 = i3 || e2.worldview_default;
              const o3 = Object.values(e2.language || {});
              if (0 === o3.length)
                return null;
              const r3 = Object.values(e2.worldview || {});
              if (0 === r3.length)
                return null;
              const s3 = o3.every((e3) => e3 === t3), a3 = r3.every((e3) => e3 === i3);
              return s3 && a3 ? e2 : t3 in (e2.language_options || {}) || i3 in (e2.worldview_options || {}) ? null : e2.language_options && e2.worldview_options ? e2 : null;
            }(t2.data, o2, r2);
            return n2 ? e.q.frame(() => a2(null, n2)) : t2.url ? e.n(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, r2), e.R.Source), a2) : e.q.frame(() => {
              const { data: e2, ...i3 } = t2;
              a2(null, i3);
            });
          }
          class Ye {
            constructor(t2, i2, o2) {
              this.bounds = e.as.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
            }
            validateBounds(e2) {
              return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
            }
            contains(t2) {
              const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.am(this.bounds.getWest()) * i2), r2 = Math.floor(e.at(this.bounds.getNorth()) * i2), s2 = Math.ceil(e.am(this.bounds.getEast()) * i2), a2 = Math.ceil(e.at(this.bounds.getSouth()) * i2);
              return t2.x >= o2 && t2.x < s2 && t2.y >= r2 && t2.y < a2;
            }
          }
          class Ke extends e.E {
            constructor(t2, i2, o2, r2) {
              if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.l(this, e.ar(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.l({ type: "vector" }, i2), this._collectResourceTiming = !!i2.collectResourceTiming, 512 !== this.tileSize)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(r2), this._tileWorkers = {}, this._deduped = new e.au();
            }
            load(t2) {
              this._loaded = false, this.fire(new e.x("dataloading", { dataType: "source" }));
              const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
              this._tileJSONRequest = Xe(this._options, this.map._requestManager, i2, o2, (r2, s2) => {
                this._tileJSONRequest = null, this._loaded = true, r2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.t(r2))) : s2 && (e.l(this, s2), s2.bounds && (this.tileBounds = new Ye(s2.bounds, this.minzoom, this.maxzoom)), L(s2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.x("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r2);
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest();
              const t2 = e.av(this.id, this.scope);
              this.load(() => this.map.style.clearSource(t2));
            }
            setTiles(e2) {
              return this._options.tiles = e2, this.reload(), this;
            }
            setUrl(e2) {
              return this.url = e2, this._options.url = e2, this.reload(), this;
            }
            onRemove(e2) {
              this.cancelTileJSONRequest();
            }
            serialize() {
              return e.l({}, this._options);
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = this.map._requestManager.transformRequest(o2, e.R.Tile), s2 = this.map.style ? this.map.style.getLut(this.scope) : null, a2 = { request: r2, data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, lut: s2 ? { image: s2.image.clone() } : null, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t2.isExtraShadowCaster, tessellationStep: this.map._tessellationStep };
              if (a2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state)
                "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", a2, n2.bind(this));
              else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
                t2.request = t2.actor.send("loadTile", a2, n2.bind(this), void 0, true);
              else {
                const i3 = e.aw.call({ deduped: this._deduped }, a2, (e2, i4) => {
                  e2 || !i4 ? n2.call(this, e2) : (a2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", a2, n2.bind(this), void 0, true));
                }, true);
                t2.request = { cancel: i3 };
              }
              function n2(o3, r3) {
                return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r3 && r3.resourceTiming && (t2.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && t2.setExpiryData(r3), t2.loadVectorData(r3, this.map.painter), e.ax(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
              }
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope });
            }
            unloadTile(e2, t2) {
              e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope }), e2.destroy();
            }
            hasTransition() {
              return false;
            }
            afterUpdate() {
              this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
          }
          class Je extends e.E {
            constructor(t2, i2, o2, r2) {
              super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.l({ type: "raster" }, i2), e.l(this, e.ar(i2, ["url", "scheme", "tileSize"]));
            }
            load(t2) {
              this._loaded = false, this.fire(new e.x("dataloading", { dataType: "source" })), this._tileJSONRequest = Xe(this._options, this.map._requestManager, null, null, (i2, o2) => {
                this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.t(i2)) : o2 && (e.l(this, o2), o2.bounds && (this.tileBounds = new Ye(o2.bounds, this.minzoom, this.maxzoom)), L(o2.tiles), this.fire(new e.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.x("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest();
              const t2 = e.av(this.id, this.scope);
              this.load(() => this.map.style.clearSource(t2));
            }
            setTiles(e2) {
              return this._options.tiles = e2, this.reload(), this;
            }
            setUrl(e2) {
              return this.url = e2, this._options.url = e2, this.reload(), this;
            }
            onRemove(e2) {
              this.cancelTileJSONRequest();
            }
            serialize() {
              return e.l({}, this._options);
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(t2, i2) {
              const o2 = e.q.devicePixelRatio >= 2, r2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
              t2.request = e.o(this.map._requestManager.transformRequest(r2, e.R.Tile), (o3, r3, s2, a2) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : r3 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s2, expires: a2 }), t2.setTexture(r3, this.map.painter), t2.state = "loaded", e.ax(this.dispatcher), void i2(null)) : i2(null)));
            }
            abortTile(e2, t2) {
              e2.request && (e2.request.cancel(), delete e2.request), t2 && t2();
            }
            unloadTile(t2, i2) {
              t2.texture && t2.texture instanceof e.T ? (t2.destroy(true), t2.texture && t2.texture instanceof e.T && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), i2 && i2();
            }
            hasTransition() {
              return false;
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
          }
          class Qe extends Je {
            constructor(t2, i2, o2, r2) {
              super(t2, i2, o2, r2), this.type = "raster-array", this.maxzoom = 22, this._options = e.l({ type: "raster-array" }, i2);
            }
            triggerRepaint(e2) {
              const t2 = this.map.painter._terrain, i2 = this.map.style.getSourceCache(this.id);
              t2 && t2.enabled && i2 && t2._clearRenderCacheForTile(i2.id, e2.tileID), this.map.triggerRepaint();
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), r2 = this.map._requestManager.transformRequest(o2, e.R.Tile);
              t2.requestParams = r2, t2.actor || (t2.actor = this.dispatcher.getActor()), t2.request = t2.fetchHeader(void 0, (e2, o3, r3, s2) => {
                if (delete t2.request, t2.aborted)
                  return t2.state = "unloaded", i2(null);
                if (e2) {
                  if (20 === e2.code)
                    return;
                  return t2.state = "errored", i2(e2);
                }
                this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: r3, expires: s2 }), t2.state = "empty", i2(null);
              });
            }
            unloadTile(t2, i2) {
              const o2 = t2.texture;
              o2 && o2 instanceof e.T ? (t2.destroy(true), this.map.painter.saveTileTexture(o2)) : (t2.destroy(), t2.flushQueues(), t2._isHeaderLoaded = false, delete t2._mrt, delete t2.textureDescriptor), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), delete t2.request, delete t2.requestParams, delete t2.neighboringTiles, t2.state = "unloaded";
            }
            prepareTile(t2, i2, o2) {
              t2._isHeaderLoaded && ("empty" !== t2.state && (t2.state = "reloading"), t2.fetchBand(i2, o2, (i3, o3) => {
                if (i3)
                  return t2.state = "errored", this.fire(new e.t(i3)), void this.triggerRepaint(t2);
                o3 && (t2.setTexture(o3, this.map.painter), t2.state = "loaded", this.triggerRepaint(t2));
              }));
            }
            getInitialBand(e2) {
              if (!this.rasterLayers)
                return 0;
              const t2 = this.rasterLayers.find(({ id: t3 }) => t3 === e2), i2 = t2 && t2.fields, o2 = i2 && i2.bands && i2.bands;
              return o2 ? o2[0] : 0;
            }
            getTextureDescriptor(t2, i2, o2) {
              if (!t2)
                return;
              const r2 = i2.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
              if (!r2)
                return;
              let s2 = null;
              i2 instanceof e.aB ? s2 = i2.paint.get("raster-array-band") : i2 instanceof e.aC && (s2 = i2.paint.get("raster-particle-array-band"));
              const a2 = s2 || this.getInitialBand(r2);
              if (null != a2)
                if (t2.textureDescriptor) {
                  if (!t2.updateNeeded(r2, a2) || o2)
                    return Object.assign({}, t2.textureDescriptor, { texture: t2.texture });
                } else
                  this.prepareTile(t2, r2, a2);
            }
          }
          const et = { vector: Ke, raster: Je, "raster-dem": class extends Je {
            constructor(t2, i2, o2, r2) {
              super(t2, i2, o2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.l({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
              function r2(e2, o3) {
                e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
              }
              t2.request = e.o(this.map._requestManager.transformRequest(o2, e.R.Tile), function(o3, s2, a2, n2) {
                if (delete t2.request, t2.aborted)
                  t2.state = "unloaded", i2(null);
                else if (o3)
                  t2.state = "errored", i2(o3);
                else if (s2) {
                  this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: a2, expires: n2 });
                  const i3 = ImageBitmap && s2 instanceof ImageBitmap && e.ay(), o4 = 1 - (s2.width - e.az(s2.width)) / 2;
                  o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
                  const l2 = i3 ? s2 : e.q.getImageData(s2, o4), c2 = { uid: t2.uid, coord: t2.tileID, source: this.id, scope: this.scope, rawImageData: l2, encoding: this.encoding, padding: o4 };
                  t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c2, r2.bind(this), void 0, true));
                }
              }.bind(this));
            }
            _getNeighboringTiles(t2) {
              const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + o2) % o2, s2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, a2 = (i2.x + 1 + o2) % o2, n2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
              return l2[new e.aA(t2.overscaledZ, s2, i2.z, r2, i2.y).key] = { backfilled: false }, l2[new e.aA(t2.overscaledZ, n2, i2.z, a2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.aA(t2.overscaledZ, s2, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l2[new e.aA(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.aA(t2.overscaledZ, n2, i2.z, a2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.aA(t2.overscaledZ, s2, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l2[new e.aA(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.aA(t2.overscaledZ, n2, i2.z, a2, i2.y + 1).key] = { backfilled: false }), l2;
            }
          }, "raster-array": Qe, geojson: class extends e.E {
            constructor(t2, i2, o2, r2) {
              super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r2), this._data = i2.data, this._options = e.l({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), void 0 !== i2.minzoom && (this.minzoom = i2.minzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
              const s2 = e.ab / this.tileSize;
              this.workerOptions = e.l({ source: this.id, scope: this.scope, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * s2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * s2, extent: e.ab, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.ab, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * s2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter, dynamic: i2.dynamic }, i2.workerOptions);
            }
            onAdd(e2) {
              this.map = e2, this.setData(this._data);
            }
            setData(e2) {
              return this._data = e2, this._updateWorkerData(), this;
            }
            updateData(t2) {
              if (!this._options.dynamic)
                return this.fire(new e.t(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
              if ("string" != typeof t2 && ("Feature" === t2.type && (t2 = { type: "FeatureCollection", features: [t2] }), "FeatureCollection" !== t2.type))
                return this.fire(new e.t(new Error("Data to update should be a feature or a feature collection.")));
              if (this._coalesce && "string" != typeof t2 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
                const e2 = /* @__PURE__ */ new Map();
                for (const t3 of this._data.features)
                  e2.set(t3.id, t3);
                for (const i2 of t2.features)
                  e2.set(i2.id, i2);
                this._data.features = [...e2.values()];
              } else
                this._data = t2;
              return this._updateWorkerData(true), this;
            }
            getClusterExpansionZoom(e2, t2) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id, scope: this.scope }, t2), this;
            }
            getClusterChildren(e2, t2) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id, scope: this.scope }, t2), this;
            }
            getClusterLeaves(e2, t2, i2, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e2, limit: t2, offset: i2 }, o2), this;
            }
            _updateWorkerData(t2 = false) {
              if (this._pendingLoad)
                return void (this._coalesce = true);
              this.fire(new e.x("dataloading", { dataType: "source" })), this._loaded = false;
              const i2 = e.l({ append: t2 }, this.workerOptions);
              i2.scope = this.scope;
              const o2 = this._data;
              "string" == typeof o2 ? (i2.request = this.map._requestManager.transformRequest(e.q.resolveURL(o2), e.R.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i2, (i3, o3) => {
                if (this._loaded = true, this._pendingLoad = null, i3)
                  this.fire(new e.t(i3));
                else {
                  const i4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                  this._collectResourceTiming && o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (i4.resourceTiming = o3.resourceTiming[this.id]), t2 && (this._partialReload = true), this.fire(new e.x("data", i4)), this._partialReload = false, this._metadataFired = true;
                }
                this._coalesce && (this._updateWorkerData(t2), this._coalesce = false);
              });
            }
            loaded() {
              return this._loaded;
            }
            loadTile(t2, i2) {
              const o2 = t2.actor ? "reloadTile" : "loadTile";
              t2.actor = this.actor;
              const r2 = this.map.style ? this.map.style.getLut(this.scope) : null, s2 = this._partialReload, a2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: r2 ? { image: r2.image.clone() } : null, scope: this.scope, pixelRatio: e.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, partial: s2 };
              t2.request = this.actor.send(o2, a2, (e2, r3) => s2 && !r3 ? (t2.state = "loaded", i2(null)) : (delete t2.request, t2.destroy(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(r3, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
            }
            unloadTile(e2, t2) {
              this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope }), e2.destroy();
            }
            onRemove(e2) {
              this._pendingLoad && this._pendingLoad.cancel();
            }
            serialize() {
              return e.l({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }, video: class extends e.aD {
            constructor(e2, t2, i2, o2) {
              super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
            }
            load() {
              this._loaded = false;
              const t2 = this.options;
              this.urls = [];
              for (const i2 of t2.urls)
                this.urls.push(this.map._requestManager.transformRequest(i2, e.R.Source).url);
              e.aE(this.urls, (t3, i2) => {
                this._loaded = true, t3 ? this.fire(new e.t(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(t2) {
              if (this.video) {
                const i2 = this.video.seekable;
                t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.t(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(e2) {
              this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                return;
              const t2 = this.map.painter.context, i2 = t2.gl;
              this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t2, this.video, i2.RGBA8), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }, image: e.aD, model: class extends e.E {
            constructor(e2, t2, i2, o2) {
              super(), this.id = e2, this.type = "model", this.models = [], this._loaded = false, this._options = t2;
            }
            load() {
              const t2 = [];
              for (const i2 in this._options.models) {
                const o2 = this._options.models[i2], r2 = e.aG(this.map._requestManager.transformRequest(o2.uri, e.R.Model).url).then((t3) => {
                  if (!t3)
                    return;
                  const r3 = e.aH(t3), s2 = new e.aI(i2, o2.position, o2.orientation, r3);
                  s2.computeBoundsAndApplyParent(), this.models.push(s2);
                }).catch((t3) => {
                  this.fire(new e.t(new Error(`Could not load model ${i2} from ${o2.uri}: ${t3.message}`)));
                });
                t2.push(r2);
              }
              return Promise.allSettled(t2).then(() => {
                this._loaded = true, this.fire(new e.x("data", { dataType: "source", sourceDataType: "metadata" }));
              }).catch((t3) => {
                this.fire(new e.t(new Error(`Could not load models: ${t3.message}`)));
              });
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            hasTransition() {
              return false;
            }
            loaded() {
              return this._loaded;
            }
            getModels() {
              return this.models;
            }
            loadTile(e2, t2) {
            }
            serialize() {
              return { type: "model" };
            }
          }, "batched-model": class extends e.E {
            constructor(e2, t2, i2, o2) {
              super(), this.type = "batched-model", this.id = e2, this.tileSize = 512, this._options = t2, this.tiles = this._options.tiles, this.maxzoom = t2.maxzoom || 19, this.minzoom = t2.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i2, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o2);
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            load(t2) {
              this._loaded = false, this.fire(new e.x("dataloading", { dataType: "source" }));
              const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
              this._tileJSONRequest = Xe(this._options, this.map._requestManager, i2, o2, (r2, s2) => {
                this._tileJSONRequest = null, this._loaded = true, r2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.t(r2))) : s2 && (e.l(this, s2), s2.bounds && (this.tileBounds = new Ye(s2.bounds, this.minzoom, this.maxzoom)), L(s2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.x("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r2);
              });
            }
            hasTransition() {
              return false;
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loaded() {
              return this._loaded;
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, e.R.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0 };
              if (t2.actor && "expired" !== t2.state)
                if ("loading" === t2.state)
                  t2.reloadCallback = i2;
                else {
                  if (t2.buckets) {
                    const e2 = Object.values(t2.buckets);
                    for (const t3 of e2)
                      t3.dirty = true;
                    return void (t2.state = "loaded");
                  }
                  t2.request = t2.actor.send("reloadTile", r2, s2.bind(this));
                }
              else
                t2.actor = this.dispatcher.getActor(), t2.request = t2.actor.send("loadTile", r2, s2.bind(this), void 0, true);
              function s2(e2, o3) {
                return t2.aborted ? i2(null) : e2 && 404 !== e2.status ? i2(e2) : (o3 && (o3.resourceTiming && (t2.resourceTiming = o3.resourceTiming), this.map._refreshExpiredTiles && t2.setExpiryData(o3), t2.buckets = { ...t2.buckets, ...o3.buckets }, o3.featureIndex && (t2.latestFeatureIndex = o3.featureIndex)), t2.state = "loaded", void i2(null));
              }
            }
            serialize() {
              return e.l({}, this._options);
            }
          }, canvas: class extends e.aD {
            constructor(t2, i2, o2, r2) {
              super(t2, i2, o2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.t(new e.V(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.t(new e.V(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.t(new e.V(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.t(new e.V(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.t(new e.V(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
            }
            load() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.t(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(e2) {
              this.map = e2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove(e2) {
              this.pause();
            }
            prepare() {
              let t2 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
                return;
              if (0 === Object.keys(this.tiles).length)
                return;
              const i2 = this.map.painter.context;
              this.texture ? !t2 && !this._playing || this.texture instanceof e.aF || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.T(i2, this.canvas, i2.gl.RGBA8, { premultiply: true }), this._prepareData(i2);
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const e2 of [this.canvas.width, this.canvas.height])
                if (isNaN(e2) || e2 <= 0)
                  return true;
              return false;
            }
          }, custom: class extends e.E {
            constructor(t2, i2, o2, r2) {
              super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.t(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.t(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Ye(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.l(this, e.ar(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
            }
            serialize() {
              return e.ar(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
            }
            load() {
              this._loaded = true, this.fire(new e.x("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.x("data", { dataType: "source", sourceDataType: "content" }));
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t2) {
              this.map = t2, this._loaded = false, this.fire(new e.x("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
            }
            onRemove(e2) {
              this._implementation.onRemove && this._implementation.onRemove(e2);
            }
            hasTile(e2) {
              if (this._implementation.hasTile) {
                const { x: t2, y: i2, z: o2 } = e2.canonical;
                return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
              }
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(e2, t2) {
              const { x: i2, y: o2, z: r2 } = e2.tileID.canonical, s2 = new AbortController();
              e2.request = Promise.resolve(this._implementation.loadTile({ x: i2, y: o2, z: r2 }, { signal: s2.signal })).then(function(i3) {
                return delete e2.request, e2.aborted ? (e2.state = "unloaded", t2(null)) : void 0 === i3 ? (e2.state = "errored", t2(null)) : null === i3 ? (this.loadTileData(e2, { width: this.tileSize, height: this.tileSize, data: null }), e2.state = "loaded", t2(null)) : function(e3) {
                  return e3 instanceof ImageData || e3 instanceof HTMLCanvasElement || e3 instanceof ImageBitmap || e3 instanceof HTMLImageElement;
                }(i3) ? (this.loadTileData(e2, i3), e2.state = "loaded", void t2(null)) : (e2.state = "errored", t2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
              }.bind(this)).catch((i3) => {
                20 !== i3.code && (e2.state = "errored", t2(i3));
              }), e2.request.cancel = () => s2.abort();
            }
            loadTileData(e2, t2) {
              e2.setTexture(t2, this.map.painter);
            }
            unloadTile(t2, i2) {
              if (t2.texture && t2.texture instanceof e.T ? (t2.destroy(true), t2.texture && t2.texture instanceof e.T && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), this._implementation.unloadTile) {
                const { x: e2, y: i3, z: o2 } = t2.tileID.canonical;
                this._implementation.unloadTile({ x: e2, y: i3, z: o2 });
              }
              i2 && i2();
            }
            abortTile(e2, t2) {
              e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2 && t2();
            }
            hasTransition() {
              return false;
            }
            _coveringTiles() {
              return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
            }
            _clearTiles() {
              const t2 = e.av(this.id, this.scope);
              this.map.style.clearSource(t2);
            }
            _update() {
              this.fire(new e.x("data", { dataType: "source", sourceDataType: "content" }));
            }
          } }, tt = function(t2, i2, o2, r2) {
            const s2 = new et[i2.type](t2, i2, o2, r2);
            if (s2.id !== t2)
              throw new Error(`Expected Source id to be ${t2} instead of ${s2.id}`);
            return e.aJ(["load", "abort", "unload", "serialize", "prepare"], s2), s2;
          };
          function it(t2, i2) {
            const o2 = e.a6.mat4.identity([]);
            return e.a6.mat4.scale(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.a6.mat4.translate(o2, o2, [1, -1, 0]), e.a6.mat4.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
          }
          function ot(e2, t2, i2, o2, r2, s2, a2, n2 = false) {
            const l2 = e2.tilesIn(o2, a2, n2);
            l2.sort(st);
            const c2 = [];
            for (const o3 of l2)
              c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e2._state, o3, r2, s2, it(e2.transform, o3.tile.tileID), n2) });
            const h2 = function(e3) {
              const t3 = {}, i3 = {};
              for (const o3 of e3) {
                const e4 = o3.queryResults, r3 = o3.wrappedTileID, s3 = i3[r3] = i3[r3] || {};
                for (const i4 in e4) {
                  const o4 = e4[i4], r4 = s3[i4] = s3[i4] || {}, a3 = t3[i4] = t3[i4] || [];
                  for (const e5 of o4)
                    r4[e5.featureIndex] || (r4[e5.featureIndex] = true, a3.push(e5));
                }
              }
              return t3;
            }(c2);
            for (const t3 in h2)
              h2[t3].forEach((t4) => {
                const i3 = t4.feature, o3 = i3.layer;
                o3 && "background" !== o3.type && "sky" !== o3.type && "slot" !== o3.type && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = void 0 !== i3.id ? e2.getFeatureState(o3["source-layer"], i3.id) : {});
              });
            return h2;
          }
          function rt(e2, t2) {
            const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], r2 = {};
            for (let e3 = 0; e3 < i2.length; e3++) {
              const s2 = i2[e3], a2 = s2.tileID.canonical.key;
              r2[a2] || (r2[a2] = true, s2.querySourceFeatures(o2, t2));
            }
            return o2;
          }
          function st(e2, t2) {
            const i2 = e2.tileID, o2 = t2.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          const at = 32, nt = 33, lt = new Uint16Array(8184);
          for (let e2 = 0; e2 < 2046; e2++) {
            let t2 = e2 + 2, i2 = 0, o2 = 0, r2 = 0, s2 = 0, a2 = 0, n2 = 0;
            for (1 & t2 ? r2 = s2 = a2 = at : i2 = o2 = n2 = at; (t2 >>= 1) > 1; ) {
              const e3 = i2 + r2 >> 1, l3 = o2 + s2 >> 1;
              1 & t2 ? (r2 = i2, s2 = o2, i2 = a2, o2 = n2) : (i2 = r2, o2 = s2, r2 = a2, s2 = n2), a2 = e3, n2 = l3;
            }
            const l2 = 4 * e2;
            lt[l2 + 0] = i2, lt[l2 + 1] = o2, lt[l2 + 2] = r2, lt[l2 + 3] = s2;
          }
          const ct = new Uint16Array(2178), ht = new Uint8Array(1089), ut = new Uint16Array(1089);
          function dt(e2) {
            return 0 === e2 ? -0.03125 : 32 === e2 ? 0.03125 : 0;
          }
          const _t = (() => ({ type: 2, extent: e.ab, loadGeometry: () => [[new e.P(0, 0), new e.P(e.ab + 1, 0), new e.P(e.ab + 1, e.ab + 1), new e.P(0, e.ab + 1), new e.P(0, 0)]] }))();
          class pt {
            constructor(t2, i2, o2, r2, s2) {
              this.tileID = t2, this.uid = e.aP(), this.uses = 0, this.tileSize = i2, this.tileZoom = o2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = s2, r2 && r2.style && (this._lastUpdatedBrightness = r2.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", r2 && r2.transform && (this.projection = r2.transform.projection);
            }
            registerFadeDuration(t2) {
              const i2 = t2 + this.timeAdded;
              i2 < e.q.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
              return this._tileTransform || (this._tileTransform = e.aK(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t2, i2, o2) {
              if (this.unloadVectorData(), this.state = "loaded", t2) {
                t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(e2, t3) {
                  const i3 = {};
                  if (!t3)
                    return i3;
                  for (const o3 of e2) {
                    const e3 = o3.layerIds.map((e4) => t3.getLayer(e4)).filter(Boolean);
                    if (0 !== e3.length) {
                      o3.layers = e3, o3.stateDependentLayerIds && (o3.stateDependentLayers = o3.stateDependentLayerIds.map((t4) => e3.filter((e4) => e4.id === t4)[0]));
                      for (const t4 of e3)
                        i3[t4.fqid] = o3;
                    }
                  }
                  return i3;
                }(t2.buckets, i2.style), this.hasSymbolBuckets = false;
                for (const t3 in this.buckets) {
                  const i3 = this.buckets[t3];
                  if (i3 instanceof e.aR) {
                    if (this.hasSymbolBuckets = true, !o2)
                      break;
                    i3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const t3 in this.buckets) {
                    const i3 = this.buckets[t3];
                    if (i3 instanceof e.aR && i3.hasRTLText) {
                      this.hasRTLText = true, e.aS();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const e2 in this.buckets) {
                  const t3 = this.buckets[e2], o3 = i2.style.getOwnLayer(e2);
                  if (!o3)
                    continue;
                  const r2 = o3.queryRadius(t3);
                  this.queryPadding = Math.max(this.queryPadding, r2);
                }
                t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas), this._lastUpdatedBrightness = t2.brightness;
              } else
                this.collisionBoxArray = new e.aQ();
            }
            unloadVectorData() {
              if (this.hasData()) {
                for (const e2 in this.buckets)
                  this.buckets[e2].destroy();
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
              }
            }
            getBucket(e2) {
              return this.buckets[e2.fqid];
            }
            upload(t2) {
              for (const e2 in this.buckets) {
                const i3 = this.buckets[e2];
                i3.uploadPending() && i3.upload(t2);
              }
              const i2 = t2.gl, o2 = this.imageAtlas;
              if (o2 && !o2.uploaded) {
                const r2 = !!Object.keys(o2.patternPositions).length;
                this.imageAtlasTexture = new e.T(t2, o2.image, i2.RGBA8, { useMipmap: r2 }), this.imageAtlas.uploaded = true;
              }
              this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t2, this.glyphAtlasImage, i2.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t2, this.lineAtlas.image, i2.R8), this.lineAtlas.uploaded = true);
            }
            prepare(e2, t2, i2) {
              if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture, i2), !t2 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
                return;
              const o2 = t2.style.getBrightness();
              (this._lastUpdatedBrightness || o2) && (this._lastUpdatedBrightness && o2 && Math.abs(this._lastUpdatedBrightness - o2) < 1e-3 || (this._lastUpdatedBrightness = o2, this.updateBuckets(t2)));
            }
            queryRenderedFeatures(e2, t2, i2, o2, r2, s2, a2, n2) {
              return this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) ? this.latestFeatureIndex.query({ tileResult: o2, pixelPosMatrix: a2, transform: s2, params: r2, tileTransform: this.tileTransform }, e2, t2, i2) : {};
            }
            querySourceFeatures(t2, i2) {
              const o2 = this.latestFeatureIndex;
              if (!o2 || !o2.rawTileData)
                return;
              const r2 = o2.loadVTLayers(), s2 = i2 ? i2.sourceLayer : "", a2 = r2._geojsonTileLayer || r2[s2];
              if (!a2)
                return;
              const n2 = e.aT(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
              for (let i3 = 0; i3 < a2.length; i3++) {
                const r3 = a2.feature(i3);
                if (n2.needGeometry) {
                  const t3 = e.aU(r3, true);
                  if (!n2.filter(new e.a3(this.tileID.overscaledZ), t3, this.tileID.canonical))
                    continue;
                } else if (!n2.filter(new e.a3(this.tileID.overscaledZ), r3))
                  continue;
                const d2 = o2.getId(r3, s2), _2 = new e.aV(r3, l2, c2, h2, d2);
                _2.tile = u2, t2.push(_2);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t2) {
              const i2 = this.expirationTime;
              if (t2.cacheControl) {
                const i3 = e.aW(t2.cacheControl);
                i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
              } else
                t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
              if (this.expirationTime) {
                const e2 = Date.now();
                let t3 = false;
                if (this.expirationTime > e2)
                  t3 = false;
                else if (i2)
                  if (this.expirationTime < i2)
                    t3 = true;
                  else {
                    const o2 = this.expirationTime - i2;
                    o2 ? this.expirationTime = e2 + Math.max(o2, 3e4) : t3 = true;
                  }
                else
                  t3 = true;
                t3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(e2, t2) {
              this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e2).length && t2 && this.updateBuckets(t2);
            }
            updateBuckets(t2) {
              if (!this.latestFeatureIndex)
                return;
              const i2 = this.latestFeatureIndex.loadVTLayers(), o2 = t2.style.listImages(), r2 = t2.style.getBrightness();
              for (const s2 in this.buckets) {
                if (!t2.style.hasLayer(s2))
                  continue;
                const a2 = this.buckets[s2], n2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", l2 = i2[n2], c2 = t2.style.getOwnSourceCache(a2.layers[0].source);
                let h2 = {};
                c2 && (h2 = c2._state.getState(n2, void 0)), a2.update(h2, l2, o2, this.imageAtlas && this.imageAtlas.patternPositions || {}, r2), (a2 instanceof e.aX || a2 instanceof e.aY) && t2._terrain && t2._terrain.enabled && c2 && a2.programConfigurations.needsUpload && t2._terrain._clearRenderCacheForTile(c2.id, this.tileID);
                const u2 = t2 && t2.style && t2.style.getOwnLayer(s2);
                u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(a2)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.q.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t2) {
              this.symbolFadeHoldUntil = e.q.now() + t2;
            }
            setTexture(t2, i2) {
              const o2 = i2.context, r2 = o2.gl;
              this.texture = this.texture || i2.getTileTexture(t2.width), this.texture && this.texture instanceof e.T ? this.texture.update(t2) : (this.texture = new e.T(o2, t2, r2.RGBA8, { useMipmap: true }), this.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE));
            }
            setDependencies(e2, t2) {
              const i2 = {};
              for (const e3 of t2)
                i2[e3] = true;
              this.dependencies[e2] = i2;
            }
            hasDependency(e2, t2) {
              for (const i2 of e2) {
                const e3 = this.dependencies[i2];
                if (e3) {
                  for (const i3 of t2)
                    if (e3[i3])
                      return true;
                }
              }
              return false;
            }
            clearQueryDebugViz() {
            }
            _makeDebugTileBoundsBuffers(t2, i2) {
              if (!i2 || "mercator" === i2.name || this._tileDebugBuffer)
                return;
              const o2 = e.aZ(_t, this.tileID.canonical, this.tileTransform)[0], r2 = new e.a_(), s2 = new e.a$();
              for (let e2 = 0; e2 < o2.length; e2++) {
                const { x: t3, y: i3 } = o2[e2];
                r2.emplaceBack(t3, i3), s2.emplaceBack(e2);
              }
              s2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(s2), this._tileDebugBuffer = t2.createVertexBuffer(r2, e.b0.members), this._tileDebugSegments = e.b1.simpleSegment(0, 0, r2.length, s2.length);
            }
            _makeTileBoundsBuffers(t2, i2) {
              if (this._tileBoundsBuffer || !i2 || "mercator" === i2.name)
                return;
              const o2 = e.aZ(_t, this.tileID.canonical, this.tileTransform)[0];
              let r2, s2;
              if (this.isRaster) {
                const t3 = function(t4, i3) {
                  const o3 = e.aK(t4, i3), r3 = Math.pow(2, t4.z);
                  for (let s4 = 0; s4 < nt; s4++)
                    for (let a3 = 0; a3 < nt; a3++) {
                      const n3 = e.aL((t4.x + (a3 + dt(a3)) / at) / r3), l3 = e.aM((t4.y + (s4 + dt(s4)) / at) / r3), c3 = i3.project(n3, l3), h2 = s4 * nt + a3;
                      ct[2 * h2 + 0] = Math.round((c3.x * o3.scale - o3.x) * e.ab), ct[2 * h2 + 1] = Math.round((c3.y * o3.scale - o3.y) * e.ab);
                    }
                  ht.fill(0), ut.fill(0);
                  for (let e2 = 2045; e2 >= 0; e2--) {
                    const t5 = 4 * e2, i4 = lt[t5 + 0], o4 = lt[t5 + 1], r4 = lt[t5 + 2], s4 = lt[t5 + 3], a3 = i4 + r4 >> 1, n3 = o4 + s4 >> 1, l3 = a3 + n3 - o4, c3 = n3 + i4 - a3, h2 = o4 * nt + i4, u2 = s4 * nt + r4, d2 = n3 * nt + a3, _2 = Math.hypot((ct[2 * h2 + 0] + ct[2 * u2 + 0]) / 2 - ct[2 * d2 + 0], (ct[2 * h2 + 1] + ct[2 * u2 + 1]) / 2 - ct[2 * d2 + 1]) >= 16;
                    ht[d2] = ht[d2] || (_2 ? 1 : 0), e2 < 1022 && (ht[d2] = ht[d2] || ht[(o4 + c3 >> 1) * nt + (i4 + l3 >> 1)] || ht[(s4 + c3 >> 1) * nt + (r4 + l3 >> 1)]);
                  }
                  const s3 = new e.aN(), a2 = new e.aO();
                  let n2 = 0;
                  function l2(t5, i4) {
                    const o4 = i4 * nt + t5;
                    return 0 === ut[o4] && (s3.emplaceBack(ct[2 * o4 + 0], ct[2 * o4 + 1], t5 * e.ab / at, i4 * e.ab / at), ut[o4] = ++n2), ut[o4] - 1;
                  }
                  function c2(e2, t5, i4, o4, r4, s4) {
                    const n3 = e2 + i4 >> 1, h2 = t5 + o4 >> 1;
                    if (Math.abs(e2 - r4) + Math.abs(t5 - s4) > 1 && ht[h2 * nt + n3])
                      c2(r4, s4, e2, t5, n3, h2), c2(i4, o4, r4, s4, n3, h2);
                    else {
                      const n4 = l2(e2, t5), c3 = l2(i4, o4), h3 = l2(r4, s4);
                      a2.emplaceBack(n4, c3, h3);
                    }
                  }
                  return c2(0, 0, at, at, at, 0), c2(at, at, 0, 0, 0, at), { vertices: s3, indices: a2 };
                }(this.tileID.canonical, i2);
                r2 = t3.vertices, s2 = t3.indices;
              } else {
                r2 = new e.aN(), s2 = new e.aO();
                for (const { x: e2, y: t4 } of o2)
                  r2.emplaceBack(e2, t4, 0, 0);
                const t3 = e.b2(r2.int16, void 0, 4);
                for (let e2 = 0; e2 < t3.length; e2 += 3)
                  s2.emplaceBack(t3[e2], t3[e2 + 1], t3[e2 + 2]);
              }
              this._tileBoundsBuffer = t2.createVertexBuffer(r2, e.b3.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(s2), this._tileBoundsSegments = e.b1.simpleSegment(0, 0, r2.length, s2.length);
            }
            _makeGlobeTileDebugBuffers(t2, i2) {
              const o2 = i2.projection;
              if (!o2 || "globe" !== o2.name || i2.freezeTileCoverage)
                return;
              const r2 = this.tileID.canonical, s2 = e.b4(r2, i2), a2 = e.b5(s2), n2 = e.a9(i2.zoom);
              let l2;
              n2 > 0 && (l2 = e.a6.mat4.invert(new Float64Array(16), i2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, r2, i2, a2, l2, n2), this._makeGlobeTileDebugTextBuffer(t2, r2, i2, a2, l2, n2);
            }
            _globePoint(t2, i2, o2, r2, s2, a2, n2) {
              let l2 = e.b6(t2, i2, o2);
              if (a2) {
                const s3 = 1 << o2.z, c2 = e.am(r2.center.lng), h2 = e.at(r2.center.lat), u2 = (o2.x + 0.5) / s3 - c2;
                let d2 = 0;
                u2 > 0.5 ? d2 = -1 : u2 < -0.5 && (d2 = 1);
                let _2 = (t2 / e.ab + o2.x) / s3 + d2, p2 = (i2 / e.ab + o2.y) / s3;
                _2 = (_2 - c2) * r2._pixelsPerMercatorPixel + c2, p2 = (p2 - h2) * r2._pixelsPerMercatorPixel + h2;
                const m2 = [_2 * r2.worldSize, p2 * r2.worldSize, 0];
                e.a6.vec3.transformMat4(m2, m2, a2), l2 = e.b7(l2, m2, n2);
              }
              return e.a6.vec3.transformMat4(l2, l2, s2);
            }
            _makeGlobeTileDebugBorderBuffer(t2, i2, o2, r2, s2, a2) {
              const n2 = new e.a_(), l2 = new e.a$(), c2 = new e.b8(), h2 = (e2, t3, h3, u3, d2) => {
                const _2 = (h3 - e2) / (d2 - 1), p2 = (u3 - t3) / (d2 - 1), m2 = n2.length;
                for (let h4 = 0; h4 < d2; h4++) {
                  const u4 = e2 + h4 * _2, d3 = t3 + h4 * p2;
                  n2.emplaceBack(u4, d3);
                  const f2 = this._globePoint(u4, d3, i2, o2, r2, s2, a2);
                  c2.emplaceBack(f2[0], f2[1], f2[2]), l2.emplaceBack(m2 + h4);
                }
              }, u2 = e.ab;
              h2(0, 0, u2, 0, 16), h2(u2, 0, u2, u2, 16), h2(u2, u2, 0, u2, 16), h2(0, u2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(l2), this._tileDebugBuffer = t2.createVertexBuffer(n2, e.b0.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(c2, e.b9.members), this._tileDebugSegments = e.b1.simpleSegment(0, 0, n2.length, l2.length);
            }
            _makeGlobeTileDebugTextBuffer(t2, i2, o2, r2, s2, a2) {
              const n2 = e.ab / 4, l2 = new e.a_(), c2 = new e.aO(), h2 = new e.b8(), u2 = 25;
              c2.reserve(32), l2.reserve(u2), h2.reserve(u2);
              const d2 = (e2, t3) => u2 * e2 + t3;
              for (let e2 = 0; e2 < u2; e2++) {
                const t3 = e2 * n2;
                for (let e3 = 0; e3 < u2; e3++) {
                  const c3 = e3 * n2;
                  l2.emplaceBack(c3, t3);
                  const u3 = this._globePoint(c3, t3, i2, o2, r2, s2, a2);
                  h2.emplaceBack(u3[0], u3[1], u3[2]);
                }
              }
              for (let e2 = 0; e2 < 4; e2++)
                for (let t3 = 0; t3 < 4; t3++) {
                  const i3 = d2(e2, t3), o3 = d2(e2, t3 + 1), r3 = d2(e2 + 1, t3), s3 = d2(e2 + 1, t3 + 1);
                  c2.emplaceBack(i3, o3, r3), c2.emplaceBack(r3, o3, s3);
                }
              this._tileDebugTextIndexBuffer = t2.createIndexBuffer(c2), this._tileDebugTextBuffer = t2.createVertexBuffer(l2, e.b0.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(h2, e.b9.members), this._tileDebugTextSegments = e.b1.simpleSegment(0, 0, u2, 32);
            }
            destroy(t2 = false) {
              for (const e2 in this.buckets)
                this.buckets[e2].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t2 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          e.ba.setPbf(e.bb);
          class mt extends pt {
            constructor(e2, t2, i2, o2, r2) {
              super(e2, t2, i2, o2, r2), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = false;
            }
            setTexture(t2, i2) {
              const o2 = i2.context, r2 = o2.gl;
              this.texture = this.texture || i2.getTileTexture(t2.width), this.texture && this.texture instanceof e.T ? this.texture.update(t2, { premultiply: false }) : this.texture = new e.T(o2, t2, r2.RGBA8, { premultiply: false });
            }
            flushQueues() {
              for (; this._workQueue.length; )
                this._workQueue.pop()();
              for (; this._fetchQueue.length; )
                this._fetchQueue.pop()();
            }
            fetchHeader(t2 = 16384, i2) {
              const o2 = this._mrt = new e.ba(30), r2 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t2 - 1) } });
              return this.entireBuffer = null, this.request = e.bc(r2, (e2, r3, s2, a2) => {
                if (e2)
                  i2(e2);
                else
                  try {
                    const e3 = o2.getHeaderLength(r3);
                    if (e3 > t2)
                      return void (this.request = this.fetchHeader(e3, i2));
                    o2.parseHeader(r3), this._isHeaderLoaded = true;
                    let n2 = 0;
                    for (const e4 of Object.values(o2.layers))
                      n2 = Math.max(n2, e4.dataIndex[e4.dataIndex.length - 1].last_byte);
                    r3.byteLength >= n2 && (this.entireBuffer = r3), i2(null, this.entireBuffer || r3, s2, a2);
                  } catch (e3) {
                    i2(e3);
                  }
              }), this.request;
            }
            fetchBand(t2, i2, o2) {
              const r2 = this._mrt;
              if (!this._isHeaderLoaded || !r2)
                return void o2(new Error("Tile header is not ready"));
              const s2 = this.actor;
              if (!s2)
                return void o2(new Error("Can't fetch tile band without an actor"));
              let a2;
              const n2 = (e2, r3) => {
                a2.complete(e2, r3), e2 ? o2(e2) : (this.updateTextureDescriptor(t2, i2), o2(null, this.textureDescriptor && this.textureDescriptor.img));
              }, l2 = (e2, t3) => {
                if (e2)
                  return o2(e2);
                const i3 = s2.send("decodeRasterArray", { buffer: t3, task: a2 }, n2, void 0, true);
                this._workQueue.push(() => {
                  i3 && i3.cancel(), a2.cancel();
                });
              }, c2 = r2.getLayer(t2);
              if (!c2)
                return void o2(new Error(`Unknown sourceLayer "${t2}"`));
              if (c2.hasDataForBand(i2))
                return this.updateTextureDescriptor(t2, i2), void o2(null, this.textureDescriptor ? this.textureDescriptor.img : null);
              const h2 = c2.getDataRange([i2]);
              if (a2 = r2.createDecodingTask(h2), !a2 || a2.tasks.length)
                if (this.flushQueues(), this.entireBuffer)
                  l2(null, this.entireBuffer.slice(h2.firstByte, h2.lastByte + 1));
                else {
                  const t3 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${h2.firstByte}-${h2.lastByte}` } }), i3 = e.bc(t3, l2);
                  this._fetchQueue.push(() => {
                    i3.cancel(), a2.cancel();
                  });
                }
              else
                o2(null);
            }
            updateNeeded(e2, t2) {
              return (!this.textureDescriptor || this.textureDescriptor.band !== t2 || this.textureDescriptor.layer !== e2) && "errored" !== this.state;
            }
            updateTextureDescriptor(t2, i2) {
              if (!this._mrt)
                return;
              const o2 = this._mrt.getLayer(t2);
              if (!o2 || !o2.hasBand(i2) || !o2.hasDataForBand(i2))
                return;
              const { bytes: r2, tileSize: s2, buffer: a2, offset: n2, scale: l2 } = o2.getBandView(i2), c2 = s2 + 2 * a2, h2 = { data: r2, width: c2, height: c2 }, u2 = this.texture;
              u2 && u2 instanceof e.T && u2.update(h2, { premultiply: false }), this.textureDescriptor = { layer: t2, band: i2, img: h2, buffer: a2, offset: n2, tileSize: s2, format: o2.pixelFormat, mix: [l2, 256 * l2, 65536 * l2, 16777216 * l2] };
            }
          }
          class ft {
            constructor(e2, t2) {
              this.max = e2, this.onRemove = t2, this.reset();
            }
            reset() {
              for (const e2 in this.data)
                for (const t2 of this.data[e2])
                  t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
              return this.data = {}, this.order = [], this;
            }
            add(e2, t2, i2) {
              const o2 = e2.wrapped().key;
              void 0 === this.data[o2] && (this.data[o2] = []);
              const r2 = { value: t2, timeout: void 0 };
              if (void 0 !== i2 && (r2.timeout = setTimeout(() => {
                this.remove(e2, r2);
              }, i2)), this.data[o2].push(r2), this.order.push(o2), this.order.length > this.max) {
                const e3 = this._getAndRemoveByKey(this.order[0]);
                e3 && this.onRemove(e3);
              }
              return this;
            }
            has(e2) {
              return e2.wrapped().key in this.data;
            }
            getAndRemove(e2) {
              return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
            }
            _getAndRemoveByKey(e2) {
              const t2 = this.data[e2].shift();
              return t2.timeout && clearTimeout(t2.timeout), 0 === this.data[e2].length && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
            }
            getByKey(e2) {
              const t2 = this.data[e2];
              return t2 ? t2[0].value : null;
            }
            get(e2) {
              return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
            }
            remove(e2, t2) {
              if (!this.has(e2))
                return this;
              const i2 = e2.wrapped().key, o2 = void 0 === t2 ? 0 : this.data[i2].indexOf(t2), r2 = this.data[i2][o2];
              return this.data[i2].splice(o2, 1), r2.timeout && clearTimeout(r2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(r2.value), this.order.splice(this.order.indexOf(i2), 1), this;
            }
            setMaxSize(e2) {
              for (this.max = e2; this.order.length > this.max; ) {
                const e3 = this._getAndRemoveByKey(this.order[0]);
                e3 && this.onRemove(e3);
              }
              return this;
            }
            filter(e2) {
              const t2 = [];
              for (const i2 in this.data)
                for (const o2 of this.data[i2])
                  e2(o2.value) || t2.push(o2);
              for (const e3 of t2)
                this.remove(e3.value.tileID, e3);
            }
          }
          class gt {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t2, i2, o2) {
              const r2 = String(i2);
              if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][r2] = this.stateChanges[t2][r2] || {}, e.l(this.stateChanges[t2][r2], o2), null === this.deletedStates[t2]) {
                this.deletedStates[t2] = {};
                for (const e2 in this.state[t2])
                  e2 !== r2 && (this.deletedStates[t2][e2] = null);
              } else if (this.deletedStates[t2] && null === this.deletedStates[t2][r2]) {
                this.deletedStates[t2][r2] = {};
                for (const e2 in this.state[t2][r2])
                  o2[e2] || (this.deletedStates[t2][r2][e2] = null);
              } else
                for (const e2 in o2)
                  this.deletedStates[t2] && this.deletedStates[t2][r2] && null === this.deletedStates[t2][r2][e2] && delete this.deletedStates[t2][r2][e2];
            }
            removeFeatureState(e2, t2, i2) {
              if (null === this.deletedStates[e2])
                return;
              const o2 = String(t2);
              if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2)
                null !== this.deletedStates[e2][o2] && (this.deletedStates[e2][o2] = this.deletedStates[e2][o2] || {}, this.deletedStates[e2][o2][i2] = null);
              else if (void 0 !== t2)
                if (this.stateChanges[e2] && this.stateChanges[e2][o2])
                  for (i2 in this.deletedStates[e2][o2] = {}, this.stateChanges[e2][o2])
                    this.deletedStates[e2][o2][i2] = null;
                else
                  this.deletedStates[e2][o2] = null;
              else
                this.deletedStates[e2] = null;
            }
            getState(t2, i2) {
              const o2 = this.state[t2] || {}, r2 = this.stateChanges[t2] || {}, s2 = this.deletedStates[t2];
              if (null === s2)
                return {};
              if (void 0 !== i2) {
                const t3 = String(i2), a3 = e.l({}, o2[t3], r2[t3]);
                if (s2) {
                  const e2 = s2[i2];
                  if (null === e2)
                    return {};
                  for (const t4 in e2)
                    delete a3[t4];
                }
                return a3;
              }
              const a2 = e.l({}, o2, r2);
              if (s2)
                for (const e2 in s2)
                  delete a2[e2];
              return a2;
            }
            initializeTileState(e2, t2) {
              e2.setFeatureState(this.state, t2);
            }
            coalesceChanges(t2, i2) {
              const o2 = {};
              for (const t3 in this.stateChanges) {
                this.state[t3] = this.state[t3] || {};
                const i3 = {};
                for (const o3 in this.stateChanges[t3])
                  this.state[t3][o3] || (this.state[t3][o3] = {}), e.l(this.state[t3][o3], this.stateChanges[t3][o3]), i3[o3] = this.state[t3][o3];
                o2[t3] = i3;
              }
              for (const t3 in this.deletedStates) {
                this.state[t3] = this.state[t3] || {};
                const i3 = {};
                if (null === this.deletedStates[t3])
                  for (const e2 in this.state[t3])
                    i3[e2] = {}, this.state[t3][e2] = {};
                else
                  for (const e2 in this.deletedStates[t3]) {
                    if (null === this.deletedStates[t3][e2])
                      this.state[t3][e2] = {};
                    else if (this.state[t3][e2])
                      for (const i4 of Object.keys(this.deletedStates[t3][e2]))
                        delete this.state[t3][e2][i4];
                    i3[e2] = this.state[t3][e2];
                  }
                o2[t3] = o2[t3] || {}, e.l(o2[t3], i3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o2).length)
                for (const e2 in t2)
                  t2[e2].setFeatureState(o2, i2);
            }
          }
          class vt extends e.E {
            constructor(e2, t2, i2) {
              super(), this.id = e2, this._onlySymbols = i2, t2.on("data", (e3) => {
                "source" === e3.dataType && "metadata" === e3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e3.dataType && "content" === e3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
              }), t2.on("error", () => {
                this._sourceErrored = true;
              }), this._source = t2, this._tiles = {}, this._cache = new ft(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new gt(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(e2) {
              this.map = e2, this._minTileCacheSize = void 0 === this._minTileCacheSize && e2 ? e2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e2 ? e2._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              for (const e2 in this._tiles) {
                const t2 = this._tiles[e2];
                if ("loaded" !== t2.state && "errored" !== t2.state)
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const e2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(e2, t2) {
              return e2.isSymbolTile = this._onlySymbols, e2.isExtraShadowCaster = this._shadowCasterTiles[e2.tileID.key], this._source.loadTile(e2, t2);
            }
            _unloadTile(e2) {
              if (this._source.unloadTile)
                return this._source.unloadTile(e2);
            }
            _abortTile(e2) {
              if (this._source.abortTile)
                return this._source.abortTile(e2);
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(e2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const t2 in this._tiles) {
                const i2 = this._tiles[t2];
                i2.upload(e2), i2.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
              }
            }
            getIds() {
              return e.bd(this._tiles).map((e2) => e2.tileID).sort(xt).map((e2) => e2.key);
            }
            getRenderableIds(t2, i2) {
              const o2 = [];
              for (const e2 in this._tiles)
                this._isIdRenderable(+e2, t2, i2) && o2.push(this._tiles[e2]);
              return t2 ? o2.sort((t3, i3) => {
                const o3 = t3.tileID, r2 = i3.tileID, s2 = new e.P(o3.canonical.x, o3.canonical.y)._rotate(this.transform.angle), a2 = new e.P(r2.canonical.x, r2.canonical.y)._rotate(this.transform.angle);
                return o3.overscaledZ - r2.overscaledZ || a2.y - s2.y || a2.x - s2.x;
              }).map((e2) => e2.tileID.key) : o2.map((e2) => e2.tileID).sort(xt).map((e2) => e2.key);
            }
            hasRenderableParent(e2) {
              const t2 = this.findLoadedParent(e2, 0);
              return !!t2 && this._isIdRenderable(t2.tileID.key);
            }
            _isIdRenderable(e2, t2, i2) {
              return this._tiles[e2] && this._tiles[e2].hasData() && !this._coveredTiles[e2] && (t2 || !this._tiles[e2].holdingForFade()) && (i2 || !this._shadowCasterTiles[e2]);
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const e2 in this._tiles)
                  "errored" !== this._tiles[e2].state && this._reloadTile(+e2, "reloading");
              }
            }
            _reloadTile(e2, t2) {
              const i2 = this._tiles[e2];
              i2 && ("loading" !== i2.state && (i2.state = t2), this._loadTile(i2, this._tileLoaded.bind(this, i2, e2, t2)));
            }
            _tileLoaded(t2, i2, o2, r2) {
              if (r2)
                if (t2.state = "errored", 404 !== r2.status)
                  this._source.fire(new e.t(r2, { tile: t2 }));
                else {
                  if (this._source.fire(new e.x("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t2 })), !(t2.tileID.key in this._loadedParentTiles))
                    return;
                  if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                    const e2 = this.map.painter.terrain;
                    this.update(this.transform, e2.getScaledDemTileSize(), true), e2.resetTileLookupCache(this.id);
                  } else
                    this.update(this.transform);
                }
              else
                t2.timeAdded = e.q.now(), "expired" === o2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new e.x("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
            }
            _backfillDEM(e2) {
              const t2 = this.getRenderableIds();
              for (let o2 = 0; o2 < t2.length; o2++) {
                const r2 = t2[o2];
                if (e2.neighboringTiles && e2.neighboringTiles[r2]) {
                  const t3 = this.getTileByID(r2);
                  i2(e2, t3), i2(t3, e2);
                }
              }
              function i2(e3, t3) {
                if (!e3.dem || e3.dem.borderReady)
                  return;
                e3.needsHillshadePrepare = true, e3.needsDEMTextureUpload = true;
                let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
                const o2 = t3.tileID.canonical.y - e3.tileID.canonical.y, r2 = Math.pow(2, e3.tileID.canonical.z), s2 = t3.tileID.key;
                0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + r2) ? i3 += r2 : 1 === Math.abs(i3 - r2) && (i3 -= r2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, o2), e3.neighboringTiles && e3.neighboringTiles[s2] && (e3.neighboringTiles[s2].backfilled = true)));
              }
            }
            getTile(e2) {
              return this.getTileByID(e2.key);
            }
            getTileByID(e2) {
              return this._tiles[e2];
            }
            _retainLoadedChildren(e2, t2, i2, o2) {
              for (const r2 in this._tiles) {
                let s2 = this._tiles[r2];
                if (o2[r2] || !s2.hasData() || s2.tileID.overscaledZ <= t2 || s2.tileID.overscaledZ > i2)
                  continue;
                let a2 = s2.tileID;
                for (; s2 && s2.tileID.overscaledZ > t2 + 1; ) {
                  const e3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
                  s2 = this._tiles[e3.key], s2 && s2.hasData() && (a2 = e3);
                }
                let n2 = a2;
                for (; n2.overscaledZ > t2; )
                  if (n2 = n2.scaledTo(n2.overscaledZ - 1), e2[n2.key]) {
                    o2[a2.key] = a2;
                    break;
                  }
              }
            }
            findLoadedParent(e2, t2) {
              if (e2.key in this._loadedParentTiles) {
                const i2 = this._loadedParentTiles[e2.key];
                return i2 && i2.tileID.overscaledZ >= t2 ? i2 : null;
              }
              for (let i2 = e2.overscaledZ - 1; i2 >= t2; i2--) {
                const t3 = e2.scaledTo(i2), o2 = this._getLoadedTile(t3);
                if (o2)
                  return o2;
              }
            }
            _getLoadedTile(e2) {
              const t2 = this._tiles[e2.key];
              return t2 && t2.hasData() ? t2 : this._cache.getByKey(this._source.reparseOverscaled ? e2.wrapped().key : e2.canonical.key);
            }
            updateCacheSize(e2, t2) {
              t2 = t2 || this._source.tileSize;
              const i2 = Math.ceil(e2.width / t2) + 1, o2 = Math.ceil(e2.height / t2) + 1, r2 = Math.floor(i2 * o2 * 5), s2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r2) : r2, a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s2) : s2;
              this._cache.setMaxSize(a2);
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
              if (this._prevLng = e2, t2) {
                const e3 = {};
                for (const i2 in this._tiles) {
                  const o2 = this._tiles[i2];
                  o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t2), e3[o2.tileID.key] = o2;
                }
                this._tiles = e3;
                for (const e4 in this._timers)
                  clearTimeout(this._timers[e4]), delete this._timers[e4];
                for (const e4 in this._tiles)
                  this._setTileReloadTimer(+e4, this._tiles[e4]);
              }
            }
            update(t2, i2, o2, r2) {
              if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
                return;
              if (this.usedForTerrain && !o2)
                return;
              this.updateCacheSize(t2, i2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
              const s2 = "batched-model" === this._source.type;
              let a2;
              if (this.used || this.usedForTerrain) {
                if (this._source.tileID)
                  a2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.aA(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y));
                else if (0 !== this.tileCoverLift) {
                  const r3 = t2.clone();
                  r3.tileCoverLift = this.tileCoverLift, a2 = r3.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: s2 }), this._source.minzoom <= 1 && "globe" === t2.projection.name && (a2.push(new e.aA(1, 0, 1, 0, 0)), a2.push(new e.aA(1, 0, 1, 1, 0)), a2.push(new e.aA(1, 0, 1, 0, 1)), a2.push(new e.aA(1, 0, 1, 1, 1)));
                } else if (a2 = t2.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: s2 }), this._source.hasTile) {
                  const e2 = this._source.hasTile.bind(this._source);
                  a2 = a2.filter((t3) => e2(t3));
                }
              } else
                a2 = [];
              if (a2.length > 0 && this.castsShadows && r2 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !yt(this._source.type)) {
                const e2 = t2.coveringZoomLevel({ tileSize: i2 || this._source.tileSize, roundZoom: this._source.roundZoom && !o2 }), n3 = Math.min(e2, this._source.maxzoom);
                if (s2) {
                  const e3 = t2.extendTileCover(a2, n3);
                  for (const t3 of e3)
                    a2.push(t3);
                } else {
                  const e3 = t2.extendTileCover(a2, n3, r2);
                  for (const t3 of e3)
                    this._shadowCasterTiles[t3.key] = true, a2.push(t3);
                }
              }
              const n2 = this._updateRetainedTiles(a2);
              if (yt(this._source.type) && 0 !== a2.length) {
                const t3 = {}, i3 = {}, o3 = Object.keys(n2);
                for (const r4 of o3) {
                  const o4 = n2[r4], s3 = this._tiles[r4];
                  if (!s3 || s3.fadeEndTime && s3.fadeEndTime <= e.q.now())
                    continue;
                  const a3 = this.findLoadedParent(o4, Math.max(o4.overscaledZ - vt.maxOverzooming, this._source.minzoom));
                  a3 && (this._addTile(a3.tileID), t3[a3.tileID.key] = a3.tileID), i3[r4] = o4;
                }
                const r3 = a2[a2.length - 1].overscaledZ;
                for (const e2 in this._tiles) {
                  const t4 = this._tiles[e2];
                  if (n2[e2] || !t4.hasData())
                    continue;
                  let o4 = t4.tileID;
                  for (; o4.overscaledZ > r3; ) {
                    o4 = o4.scaledTo(o4.overscaledZ - 1);
                    const r4 = this._tiles[o4.key];
                    if (r4 && r4.hasData() && i3[o4.key]) {
                      n2[e2] = t4.tileID;
                      break;
                    }
                  }
                }
                for (const e2 in t3)
                  n2[e2] || (this._coveredTiles[e2] = true, n2[e2] = t3[e2]);
              }
              for (const e2 in n2)
                this._tiles[e2].clearFadeHold();
              const l2 = e.be(this._tiles, n2);
              for (const e2 of l2) {
                const t3 = this._tiles[e2];
                t3.hasSymbolBuckets && !t3.holdingForFade() ? t3.setHoldDuration(this.map._fadeDuration) : t3.hasSymbolBuckets && !t3.symbolFadeFinished() || this._removeTile(+e2);
              }
              this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
              for (const e2 in this._tiles)
                this._tiles[e2].holdingForFade() && this._removeTile(+e2);
            }
            _updateRetainedTiles(e2) {
              const t2 = {};
              if (0 === e2.length)
                return t2;
              const i2 = {}, o2 = e2.reduce((e3, t3) => Math.min(e3, t3.overscaledZ), 1 / 0), r2 = e2[0].overscaledZ, s2 = Math.max(r2 - vt.maxOverzooming, this._source.minzoom), a2 = Math.max(r2 + vt.maxUnderzooming, this._source.minzoom), n2 = {};
              for (const i3 of e2) {
                const e3 = this._addTile(i3);
                t2[i3.key] = i3, e3.hasData() || o2 < this._source.maxzoom && (n2[i3.key] = i3);
              }
              this._retainLoadedChildren(n2, o2, a2, t2);
              for (const o3 of e2) {
                let e3 = this._tiles[o3.key];
                if (e3.hasData())
                  continue;
                if (o3.canonical.z >= this._source.maxzoom) {
                  const e4 = o3.children(this._source.maxzoom)[0], i3 = this.getTile(e4);
                  if (i3 && i3.hasData()) {
                    t2[e4.key] = e4;
                    continue;
                  }
                } else {
                  const e4 = o3.children(this._source.maxzoom);
                  if (t2[e4[0].key] && t2[e4[1].key] && t2[e4[2].key] && t2[e4[3].key])
                    continue;
                }
                let r3 = e3.wasRequested();
                for (let a3 = o3.overscaledZ - 1; a3 >= s2; --a3) {
                  const s3 = o3.scaledTo(a3);
                  if (i2[s3.key])
                    break;
                  if (i2[s3.key] = true, e3 = this.getTile(s3), !e3 && r3 && (e3 = this._addTile(s3)), e3 && (t2[s3.key] = s3, r3 = e3.wasRequested(), e3.hasData()))
                    break;
                }
              }
              return t2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const e2 in this._tiles) {
                const t2 = [];
                let i2, o2 = this._tiles[e2].tileID;
                for (; o2.overscaledZ > 0; ) {
                  if (o2.key in this._loadedParentTiles) {
                    i2 = this._loadedParentTiles[o2.key];
                    break;
                  }
                  t2.push(o2.key);
                  const e3 = o2.scaledTo(o2.overscaledZ - 1);
                  if (i2 = this._getLoadedTile(e3), i2)
                    break;
                  o2 = e3;
                }
                for (const e3 of t2)
                  this._loadedParentTiles[e3] = i2;
              }
            }
            _addTile(t2) {
              let i2 = this._tiles[t2.key];
              if (i2)
                return true !== i2.isExtraShadowCaster || !!this._shadowCasterTiles[t2.key] || this._reloadTile(t2.key, "reloading"), i2;
              i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
              const o2 = Boolean(i2);
              if (!o2) {
                const e2 = this.map ? this.map.painter : null, o3 = this._source.tileSize * t2.overscaleFactor();
                i2 = "raster-array" === this._source.type ? new mt(t2, o3, this.transform.tileZoom, e2, this._isRaster) : new pt(t2, o3, this.transform.tileZoom, e2, this._isRaster), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2.key, i2.state));
              }
              return i2 ? (i2.uses++, this._tiles[t2.key] = i2, o2 || this._source.fire(new e.x("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2) : null;
            }
            _setTileReloadTimer(e2, t2) {
              e2 in this._timers && (clearTimeout(this._timers[e2]), delete this._timers[e2]);
              const i2 = t2.getExpiryTimeout();
              i2 && (this._timers[e2] = setTimeout(() => {
                this._reloadTile(e2, "expired"), delete this._timers[e2];
              }, i2));
            }
            _removeTile(e2) {
              const t2 = this._tiles[e2];
              t2 && (t2.uses--, delete this._tiles[e2], this._timers[e2] && (clearTimeout(this._timers[e2]), delete this._timers[e2]), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state || "empty" === t2.state ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const e2 in this._tiles)
                this._removeTile(+e2);
              this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t2, i2, o2) {
              const r2 = [], s2 = this.transform;
              if (!s2)
                return r2;
              const a2 = "globe" === s2.projection.name, n2 = e.am(s2.center.lng);
              for (const l2 in this._tiles) {
                const c2 = this._tiles[l2];
                if (o2 && c2.clearQueryDebugViz(), c2.holdingForFade())
                  continue;
                let h2;
                if (a2) {
                  const t3 = c2.tileID.canonical;
                  if (0 === t3.z) {
                    const i3 = [Math.abs(e.ap(n2, ...bt(t3, -1)) - n2), Math.abs(e.ap(n2, ...bt(t3, 1)) - n2)];
                    h2 = [0, 2 * i3.indexOf(Math.min(...i3)) - 1];
                  } else {
                    const i3 = [Math.abs(e.ap(n2, ...bt(t3, -1)) - n2), Math.abs(e.ap(n2, ...bt(t3, 0)) - n2), Math.abs(e.ap(n2, ...bt(t3, 1)) - n2)];
                    h2 = [i3.indexOf(Math.min(...i3)) - 1];
                  }
                } else
                  h2 = [0];
                for (const e2 of h2) {
                  const o3 = t2.containsTile(c2, s2, i2, e2);
                  o3 && r2.push(o3);
                }
              }
              return r2;
            }
            getShadowCasterCoordinates() {
              return this._getRenderableCoordinates(false, true);
            }
            getVisibleCoordinates(e2) {
              return this._getRenderableCoordinates(e2);
            }
            _getRenderableCoordinates(e2, t2) {
              const i2 = this.getRenderableIds(e2, t2).map((e3) => this._tiles[e3].tileID), o2 = "globe" === this.transform.projection.name;
              for (const e3 of i2)
                e3.projMatrix = this.transform.calculateProjMatrix(e3.toUnwrapped()), e3.expandedProjMatrix = o2 ? this.transform.calculateProjMatrix(e3.toUnwrapped(), false, true) : e3.projMatrix;
              return i2;
            }
            sortCoordinatesByDistance(e2) {
              const t2 = e2.slice(), i2 = this.transform._camera.position, o2 = this.transform._camera.forward(), r2 = {};
              for (const e3 of t2) {
                const t3 = 1 / (1 << e3.canonical.z);
                r2[e3.key] = ((e3.canonical.x + 0.5) * t3 + e3.wrap - i2[0]) * o2[0] + ((e3.canonical.y + 0.5) * t3 - i2[1]) * o2[1] - i2[2] * o2[2];
              }
              return t2.sort((e3, t3) => r2[e3.key] - r2[t3.key]), t2;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (yt(this._source.type))
                for (const t2 in this._tiles) {
                  const i2 = this._tiles[t2];
                  if (void 0 !== i2.fadeEndTime && i2.fadeEndTime >= e.q.now())
                    return true;
                }
              return false;
            }
            setFeatureState(e2, t2, i2) {
              this._state.updateState(e2 = e2 || "_geojsonTileLayer", t2, i2);
            }
            removeFeatureState(e2, t2, i2) {
              this._state.removeFeatureState(e2 = e2 || "_geojsonTileLayer", t2, i2);
            }
            getFeatureState(e2, t2) {
              return this._state.getState(e2 = e2 || "_geojsonTileLayer", t2);
            }
            setDependencies(e2, t2, i2) {
              const o2 = this._tiles[e2];
              o2 && o2.setDependencies(t2, i2);
            }
            reloadTilesForDependencies(e2, t2) {
              for (const i2 in this._tiles)
                this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(+i2, "reloading");
              this._cache.filter((i2) => !i2.hasDependency(e2, t2));
            }
            _preloadTiles(t2, i2) {
              if (!this._sourceLoaded) {
                const e2 = () => {
                  this._sourceLoaded && (this._source.off("data", e2), this._preloadTiles(t2, i2));
                };
                return void this._source.on("data", e2);
              }
              const o2 = /* @__PURE__ */ new Map(), r2 = Array.isArray(t2) ? t2 : [t2], s2 = this.map.painter.terrain, a2 = this.usedForTerrain && s2 ? s2.getScaledDemTileSize() : this._source.tileSize;
              for (const e2 of r2) {
                const t3 = e2.coveringTiles({ tileSize: a2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
                for (const e3 of t3)
                  o2.set(e3.key, e3);
                this.usedForTerrain && e2.updateElevation(false);
              }
              const n2 = Array.from(o2.values());
              e.bf(n2, (e2, t3) => {
                const i3 = new pt(e2, this._source.tileSize * e2.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                this._loadTile(i3, (e3) => {
                  "raster-dem" === this._source.type && i3.dem && this._backfillDEM(i3), t3(e3, i3);
                });
              }, i2);
            }
          }
          function xt(e2, t2) {
            const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), o2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
            return e2.overscaledZ - t2.overscaledZ || o2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
          }
          function yt(e2) {
            return "raster" === e2 || "image" === e2 || "video" === e2 || "custom" === e2;
          }
          function bt(e2, t2) {
            const i2 = 1 << e2.z;
            return [e2.x / i2 + t2, (e2.x + 1) / i2 + t2];
          }
          vt.maxOverzooming = 10, vt.maxUnderzooming = 3;
          class wt {
            constructor(e2) {
              this.style = e2, this.layersGotHidden = false, this.layers = [];
            }
            processLayersChanged() {
              this.layers = [];
              const e2 = false, t2 = false;
              for (const i2 in this.style._mergedLayers) {
                const o2 = this.style._mergedLayers[i2];
                if ("fill-extrusion" === o2.type)
                  this.layers.push({ layer: o2, visible: e2, visibilityChanged: t2 });
                else if ("model" === o2.type) {
                  const i3 = this.style.getLayerSource(o2);
                  i3 && "batched-model" === i3.type && this.layers.push({ layer: o2, visible: e2, visibilityChanged: t2 });
                }
              }
            }
            onNewFrame(e2) {
              this.layersGotHidden = false;
              for (const t2 of this.layers) {
                const i2 = t2.layer;
                let o2 = false;
                "fill-extrusion" === i2.type ? o2 = !i2.isHidden(e2) && i2.paint.get("fill-extrusion-opacity") > 0 : "model" === i2.type && (o2 = !i2.isHidden(e2) && i2.paint.get("model-opacity") > 0), this.layersGotHidden = this.layersGotHidden || !o2 && t2.visible, t2.visible = o2;
              }
            }
            updateZOffset(e2, t2) {
              this.currentBuildingBuckets = [];
              for (const e3 of this.layers) {
                const i3 = e3.layer, o2 = this.style.getLayerSourceCache(i3);
                let r2 = 1;
                "fill-extrusion" === i3.type && (r2 = e3.visible ? i3.paint.get("fill-extrusion-vertical-scale") : 0);
                let s2 = o2 ? o2.getTile(t2) : null;
                if (!s2 && o2 && t2.canonical.z > o2.getSource().minzoom) {
                  let e4 = t2.scaledTo(Math.min(o2.getSource().maxzoom, t2.overscaledZ - 1));
                  for (; e4.overscaledZ >= o2.getSource().minzoom && (s2 = o2.getTile(e4), !s2 && 0 !== e4.overscaledZ); )
                    e4 = e4.scaledTo(e4.overscaledZ - 1);
                }
                this.currentBuildingBuckets.push({ bucket: s2 ? s2.getBucket(i3) : null, tileID: s2 ? s2.tileID : t2, verticalScale: r2 });
              }
              e2.hasAnyZOffset = false;
              let i2 = false;
              for (let o2 = 0; o2 < e2.symbolInstances.length; o2++) {
                const r2 = e2.symbolInstances.get(o2), s2 = r2.zOffset, a2 = this._getHeightAtTileOffset(t2, r2.tileAnchorX, r2.tileAnchorY);
                r2.zOffset = a2 !== Number.NEGATIVE_INFINITY ? a2 : s2, i2 || s2 === r2.zOffset || (i2 = true), e2.hasAnyZOffset || 0 === r2.zOffset || (e2.hasAnyZOffset = true);
              }
              i2 && (e2.zOffsetBuffersNeedUpload = true, e2.zOffsetSortDirty = true);
            }
            _mapCoordToOverlappingTile(t2, i2, o2, r2) {
              let s2 = i2, a2 = o2;
              if (t2.canonical.z !== r2.canonical.z) {
                const n2 = r2.canonical, l2 = 1 / (1 << t2.canonical.z - n2.z);
                s2 = (i2 + t2.canonical.x * e.ab) * l2 - n2.x * e.ab | 0, a2 = (o2 + t2.canonical.y * e.ab) * l2 - n2.y * e.ab | 0;
              }
              return { tileX: s2, tileY: a2 };
            }
            _getHeightAtTileOffset(e2, t2, i2) {
              let o2, r2;
              for (let s2 = 0; s2 < this.layers.length; ++s2) {
                if ("fill-extrusion" !== this.layers[s2].layer.type)
                  continue;
                const { bucket: a2, tileID: n2, verticalScale: l2 } = this.currentBuildingBuckets[s2];
                if (!a2)
                  continue;
                const { tileX: c2, tileY: h2 } = this._mapCoordToOverlappingTile(e2, t2, i2, n2), u2 = a2.getHeightAtTileCoord(c2, h2);
                u2 && void 0 !== u2.height && (u2.hidden ? o2 = u2.height : r2 = Math.max(u2.height * l2, r2 || 0));
              }
              if (void 0 !== r2)
                return r2;
              for (let r3 = 0; r3 < this.layers.length; ++r3) {
                const s2 = this.layers[r3];
                if ("model" !== s2.layer.type || !s2.visible)
                  continue;
                const { bucket: a2, tileID: n2 } = this.currentBuildingBuckets[r3];
                if (!a2)
                  continue;
                const { tileX: l2, tileY: c2 } = this._mapCoordToOverlappingTile(e2, t2, i2, n2), h2 = a2.getHeightAtTileCoord(l2, c2);
                if (h2 && !h2.hidden)
                  return void 0 === h2.height && void 0 !== o2 ? Math.min(h2.maxHeight, o2) * h2.verticalScale : h2.height ? h2.height * h2.verticalScale : Number.NEGATIVE_INFINITY;
              }
              return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
            }
          }
          function Tt(t2, i2) {
            const o2 = {};
            for (const e2 in t2)
              "ref" !== e2 && (o2[e2] = t2[e2]);
            return e.bg.forEach((e2) => {
              e2 in i2 && (o2[e2] = i2[e2]);
            }), o2;
          }
          function Et(e2) {
            e2 = e2.slice();
            const t2 = /* @__PURE__ */ Object.create(null);
            for (let i2 = 0; i2 < e2.length; i2++)
              t2[e2[i2].id] = e2[i2];
            for (let i2 = 0; i2 < e2.length; i2++)
              "ref" in e2[i2] && (e2[i2] = Tt(e2[i2], t2[e2[i2].ref]));
            return e2;
          }
          const Ct = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
          function St(e2, t2, i2) {
            i2.push({ command: Ct.addSource, args: [e2, t2[e2]] });
          }
          function It(e2, t2, i2) {
            t2.push({ command: Ct.removeSource, args: [e2] }), i2[e2] = true;
          }
          function Dt(e2, t2, i2, o2) {
            It(e2, i2, o2), St(e2, t2, i2);
          }
          function Rt(t2, i2, o2) {
            let r2;
            for (r2 in t2[o2])
              if (t2[o2].hasOwnProperty(r2) && "data" !== r2 && !e.bh(t2[o2][r2], i2[o2][r2]))
                return false;
            for (r2 in i2[o2])
              if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !e.bh(t2[o2][r2], i2[o2][r2]))
                return false;
            return true;
          }
          function At(t2, i2, o2, r2, s2, a2) {
            let n2;
            for (n2 in i2 = i2 || {}, t2 = t2 || {})
              t2.hasOwnProperty(n2) && (e.bh(t2[n2], i2[n2]) || o2.push({ command: a2, args: [r2, n2, i2[n2], s2] }));
            for (n2 in i2)
              i2.hasOwnProperty(n2) && !t2.hasOwnProperty(n2) && (e.bh(t2[n2], i2[n2]) || o2.push({ command: a2, args: [r2, n2, i2[n2], s2] }));
          }
          function Lt(e2) {
            return e2.id;
          }
          function Pt(e2, t2) {
            return e2[t2.id] = t2, e2;
          }
          class Mt {
            constructor(e2, t2) {
              this.reset(e2, t2);
            }
            reset(e2, t2) {
              this.points = e2 || [], this._distances = [0];
              for (let e3 = 1; e3 < this.points.length; e3++)
                this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t2) {
              if (1 === this.points.length)
                return this.points[0];
              t2 = e.ap(t2, 0, 1);
              let i2 = 1, o2 = this._distances[i2];
              const r2 = t2 * this.paddedLength + this.padding;
              for (; o2 < r2 && i2 < this._distances.length; )
                o2 = this._distances[++i2];
              const s2 = i2 - 1, a2 = this._distances[s2], n2 = o2 - a2, l2 = n2 > 0 ? (r2 - a2) / n2 : 0;
              return this.points[s2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          class zt {
            constructor(e2, t2, i2) {
              const o2 = this.boxCells = [], r2 = this.circleCells = [];
              this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
              for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
                o2.push([]), r2.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e2, t2, i2, o2, r2) {
              this._forEachCell(t2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
            }
            insertCircle(e2, t2, i2, o2) {
              this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
            }
            _insertBoxCell(e2, t2, i2, o2, r2, s2) {
              this.boxCells[r2].push(s2);
            }
            _insertCircleCell(e2, t2, i2, o2, r2, s2) {
              this.circleCells[r2].push(s2);
            }
            _query(e2, t2, i2, o2, r2, s2) {
              if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height)
                return !r2 && [];
              const a2 = [];
              if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
                if (r2)
                  return true;
                for (let e3 = 0; e3 < this.boxKeys.length; e3++)
                  a2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
                for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                  const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
                  a2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
                }
                return s2 ? a2.filter(s2) : a2;
              }
              return this._forEachCell(e2, t2, i2, o2, this._queryCell, a2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, s2), r2 ? a2.length > 0 : a2;
            }
            _queryCircle(e2, t2, i2, o2, r2) {
              const s2 = e2 - i2, a2 = e2 + i2, n2 = t2 - i2, l2 = t2 + i2;
              if (a2 < 0 || s2 > this.width || l2 < 0 || n2 > this.height)
                return !o2 && [];
              const c2 = [];
              return this._forEachCell(s2, n2, a2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c2.length > 0 : c2;
            }
            query(e2, t2, i2, o2, r2) {
              return this._query(e2, t2, i2, o2, false, r2);
            }
            hitTest(e2, t2, i2, o2, r2) {
              return this._query(e2, t2, i2, o2, true, r2);
            }
            hitTestCircle(e2, t2, i2, o2) {
              return this._queryCircle(e2, t2, i2, true, o2);
            }
            _queryCell(e2, t2, i2, o2, r2, s2, a2, n2) {
              const l2 = a2.seenUids, c2 = this.boxCells[r2];
              if (null !== c2) {
                const r3 = this.bboxes;
                for (const h3 of c2)
                  if (!l2.box[h3]) {
                    l2.box[h3] = true;
                    const c3 = 4 * h3;
                    if (e2 <= r3[c3 + 2] && t2 <= r3[c3 + 3] && i2 >= r3[c3 + 0] && o2 >= r3[c3 + 1] && (!n2 || n2(this.boxKeys[h3]))) {
                      if (a2.hitTest)
                        return s2.push(true), true;
                      s2.push({ key: this.boxKeys[h3], x1: r3[c3], y1: r3[c3 + 1], x2: r3[c3 + 2], y2: r3[c3 + 3] });
                    }
                  }
              }
              const h2 = this.circleCells[r2];
              if (null !== h2) {
                const r3 = this.circles;
                for (const c3 of h2)
                  if (!l2.circle[c3]) {
                    l2.circle[c3] = true;
                    const h3 = 3 * c3;
                    if (this._circleAndRectCollide(r3[h3], r3[h3 + 1], r3[h3 + 2], e2, t2, i2, o2) && (!n2 || n2(this.circleKeys[c3]))) {
                      if (a2.hitTest)
                        return s2.push(true), true;
                      {
                        const e3 = r3[h3], t3 = r3[h3 + 1], i3 = r3[h3 + 2];
                        s2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                      }
                    }
                  }
              }
            }
            _queryCellCircle(e2, t2, i2, o2, r2, s2, a2, n2) {
              const l2 = a2.circle, c2 = a2.seenUids, h2 = this.boxCells[r2];
              if (null !== h2) {
                const e3 = this.bboxes;
                for (const t3 of h2)
                  if (!c2.box[t3]) {
                    c2.box[t3] = true;
                    const i3 = 4 * t3;
                    if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!n2 || n2(this.boxKeys[t3])))
                      return s2.push(true), true;
                  }
              }
              const u2 = this.circleCells[r2];
              if (null !== u2) {
                const e3 = this.circles;
                for (const t3 of u2)
                  if (!c2.circle[t3]) {
                    c2.circle[t3] = true;
                    const i3 = 3 * t3;
                    if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(this.circleKeys[t3])))
                      return s2.push(true), true;
                  }
              }
            }
            _forEachCell(e2, t2, i2, o2, r2, s2, a2, n2) {
              const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
              for (let d2 = l2; d2 <= h2; d2++)
                for (let l3 = c2; l3 <= u2; l3++)
                  if (r2.call(this, e2, t2, i2, o2, this.xCellCount * l3 + d2, s2, a2, n2))
                    return;
            }
            _convertToXCellCoord(e2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
            }
            _convertToYCellCoord(e2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
            }
            _circlesCollide(e2, t2, i2, o2, r2, s2) {
              const a2 = o2 - e2, n2 = r2 - t2, l2 = i2 + s2;
              return l2 * l2 > a2 * a2 + n2 * n2;
            }
            _circleAndRectCollide(e2, t2, i2, o2, r2, s2, a2) {
              const n2 = (s2 - o2) / 2, l2 = Math.abs(e2 - (o2 + n2));
              if (l2 > n2 + i2)
                return false;
              const c2 = (a2 - r2) / 2, h2 = Math.abs(t2 - (r2 + c2));
              if (h2 > c2 + i2)
                return false;
              if (l2 <= n2 || h2 <= c2)
                return true;
              const u2 = l2 - n2, d2 = h2 - c2;
              return u2 * u2 + d2 * d2 <= i2 * i2;
            }
          }
          const Ot = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, Ft = Math.tan(85 * Math.PI / 180);
          function kt(t2, i2, o2, r2, s2, a2, n2) {
            const l2 = e.a6.mat4.create();
            if (o2)
              if ("globe" === a2.name) {
                const t3 = e.bi(s2, i2);
                e.a6.mat4.multiply(l2, l2, t3);
              } else {
                const t3 = e.a6.mat2.invert([], n2);
                l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], r2 || e.a6.mat4.rotateZ(l2, l2, s2.angle);
              }
            else
              e.a6.mat4.multiply(l2, s2.labelPlaneMatrix, t2);
            return l2;
          }
          function Bt(e2, t2, i2, o2, r2, s2, a2) {
            const n2 = kt(e2, t2, i2, o2, r2, s2, a2);
            return "globe" === s2.name && i2 || (n2[2] = n2[6] = n2[10] = n2[14] = 0), n2;
          }
          function Nt(t2, i2, o2, r2, s2, a2, n2) {
            if (o2) {
              if ("globe" === a2.name) {
                const l2 = kt(t2, i2, o2, r2, s2, a2, n2);
                return e.a6.mat4.invert(l2, l2), e.a6.mat4.multiply(l2, t2, l2), l2;
              }
              {
                const i3 = e.a6.mat4.clone(t2), o3 = e.a6.mat4.identity([]);
                return o3[0] = n2[0], o3[1] = n2[1], o3[4] = n2[2], o3[5] = n2[3], e.a6.mat4.multiply(i3, i3, o3), r2 || e.a6.mat4.rotateZ(i3, i3, -s2.angle), i3;
              }
            }
            return s2.glCoordMatrix;
          }
          function Ut(t2, i2, o2, r2) {
            const s2 = [t2, i2, o2, 1];
            o2 ? e.a6.vec4.transformMat4(s2, s2, r2) : Kt(s2, s2, r2);
            const a2 = s2[3];
            return s2[0] /= a2, s2[1] /= a2, s2[2] /= a2, s2;
          }
          function Gt(e2, t2) {
            return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
          }
          function jt(e2, t2) {
            const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
            return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
          }
          function Vt(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2) {
            const u2 = o2.transform, d2 = r2 ? t2.textSizeData : t2.iconSizeData, _2 = e.bj(d2, o2.transform.zoom), p2 = "globe" === u2.projection.name, m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
            f2.clear();
            let g2 = null;
            p2 && (g2 = r2 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
            const v2 = t2.lineVertexArray, x2 = r2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, y2 = o2.transform.width / o2.transform.height;
            let b2, w2 = false;
            for (let r3 = 0; r3 < x2.length; r3++) {
              const p3 = x2.get(r3), { numGlyphs: T2, writingMode: E2 } = p3;
              if (E2 !== e.bk.vertical || w2 || b2 === e.bk.horizontal || (w2 = true), b2 = E2, (p3.hidden || E2 === e.bk.vertical) && !w2) {
                Yt(T2, f2);
                continue;
              }
              w2 = false;
              const C2 = new e.P(p3.tileAnchorX, p3.tileAnchorY);
              let { x: S2, y: I2, z: D2 } = u2.projection.projectTilePoint(C2.x, C2.y, h2.canonical);
              if (c2) {
                const [e2, t3, i3] = c2(C2);
                S2 += e2, I2 += t3, D2 += i3;
              }
              const R2 = [S2, I2, D2, 1];
              if (e.a6.vec4.transformMat4(R2, R2, i2), !jt(R2, m2)) {
                Yt(T2, f2);
                continue;
              }
              const A2 = R2[3], L2 = Gt(o2.transform.getCameraToCenterDistance(u2.projection), A2), P2 = e.bl(d2, _2, p3), M2 = n2 ? P2 / L2 : P2 * L2, z2 = Ut(S2, I2, D2, s2);
              if (z2[3] <= 0) {
                Yt(T2, f2);
                continue;
              }
              let O2 = {};
              const F2 = n2 ? null : c2, k2 = Ht(p3, M2, false, l2, i2, s2, a2, t2.glyphOffsetArray, v2, f2, g2, z2, C2, O2, y2, F2, u2.projection, h2, n2);
              w2 = k2.useVertical, F2 && k2.needsFlipping && (O2 = {}), (k2.notEnoughRoom || w2 || k2.needsFlipping && Ht(p3, M2, true, l2, i2, s2, a2, t2.glyphOffsetArray, v2, f2, g2, z2, C2, O2, y2, F2, u2.projection, h2, n2).notEnoughRoom) && Yt(T2, f2);
            }
            r2 ? (t2.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.text.globeExtVertexBuffer && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.icon.globeExtVertexBuffer && t2.icon.globeExtVertexBuffer.updateData(g2));
          }
          function qt(e2, t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2) {
            const { lineStartIndex: f2, glyphStartIndex: g2, segment: v2 } = n2, x2 = g2 + n2.numGlyphs, y2 = f2 + n2.lineLength, b2 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T2 = Xt(e2 * b2, i2, o2, r2, s2, a2, v2, f2, y2, l2, c2, h2, u2, d2, true, _2, p2, m2);
            if (!T2)
              return null;
            const E2 = Xt(e2 * w2, i2, o2, r2, s2, a2, v2, f2, y2, l2, c2, h2, u2, d2, true, _2, p2, m2);
            return E2 ? { first: T2, last: E2 } : null;
          }
          function Zt(t2, i2, o2, r2) {
            return t2 === e.bk.horizontal && Math.abs(r2) > Math.abs(o2) ? { useVertical: true } : t2 === e.bk.vertical ? r2 > 0 ? { needsFlipping: true } : null : i2 !== Ot.unknown && function(e2, t3) {
              return 0 === e2 || Math.abs(t3 / e2) > Ft;
            }(o2, r2) ? i2 === Ot.flipRequired ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
          }
          function Ht(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2, x2) {
            const y2 = i2 / 24, b2 = t2.lineOffsetX * y2, w2 = t2.lineOffsetY * y2, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: C2, segment: S2, writingMode: I2, flipState: D2 } = t2, R2 = T2 + t2.lineLength, A2 = (t3) => {
              if (u2) {
                const [i4, o4, r4] = t3.up, s3 = h2.length;
                e.bm(u2, s3 + 0, i4, o4, r4), e.bm(u2, s3 + 1, i4, o4, r4), e.bm(u2, s3 + 2, i4, o4, r4), e.bm(u2, s3 + 3, i4, o4, r4);
              }
              const [i3, o3, r3] = t3.point;
              e.bn(h2, i3, o3, r3, t3.angle);
            };
            if (C2 > 1) {
              const e2 = qt(y2, l2, b2, w2, o2, d2, _2, t2, c2, a2, p2, f2, false, g2, v2, x2);
              if (!e2)
                return { notEnoughRoom: true };
              if (r2 && !o2) {
                let [i3, o3, r3] = e2.first.point, [s3, a3, l3] = e2.last.point;
                [i3, o3] = Ut(i3, o3, r3, n2), [s3, a3] = Ut(s3, a3, l3, n2);
                const c3 = Zt(I2, D2, (s3 - i3) * m2, a3 - o3);
                if (t2.flipState = c3 && c3.needsFlipping ? Ot.flipRequired : Ot.flipNotRequired, c3)
                  return c3;
              }
              A2(e2.first);
              for (let e3 = E2 + 1; e3 < E2 + C2 - 1; e3++) {
                const t3 = Xt(y2 * l2.getoffsetX(e3), b2, w2, o2, d2, _2, S2, T2, R2, c2, a2, p2, f2, false, false, g2, v2, x2);
                if (!t3)
                  return h2.length -= 4 * (e3 - E2), { notEnoughRoom: true };
                A2(t3);
              }
              A2(e2.last);
            } else {
              if (r2 && !o2) {
                const i4 = Ut(_2.x, _2.y, 0, s2), o3 = T2 + S2 + 1, r3 = new e.P(c2.getx(o3), c2.gety(o3)), a3 = Ut(r3.x, r3.y, 0, s2), n3 = a3[3] > 0 ? a3 : $t(_2, r3, i4, 1, s2, void 0, g2, v2.canonical), l3 = Zt(I2, D2, (n3[0] - i4[0]) * m2, n3[1] - i4[1]);
                if (t2.flipState = l3 && l3.needsFlipping ? Ot.flipRequired : Ot.flipNotRequired, l3)
                  return l3;
              }
              const i3 = Xt(y2 * l2.getoffsetX(E2), b2, w2, o2, d2, _2, S2, T2, R2, c2, a2, p2, f2, false, false, g2, v2, x2);
              if (!i3)
                return { notEnoughRoom: true };
              A2(i3);
            }
            return {};
          }
          function Wt(e2, t2, i2, o2, r2) {
            const { x: s2, y: a2, z: n2 } = o2.projectTilePoint(e2.x, e2.y, t2);
            if (!r2)
              return Ut(s2, a2, n2, i2);
            const [l2, c2, h2] = r2(e2);
            return Ut(s2 + l2, a2 + c2, n2 + h2, i2);
          }
          function $t(t2, i2, o2, r2, s2, a2, n2, l2) {
            const c2 = Wt(t2.sub(i2)._unit()._add(t2), l2, s2, n2, a2);
            return e.a6.vec3.sub(c2, o2, c2), e.a6.vec3.normalize(c2, c2), e.a6.vec3.scaleAndAdd(c2, o2, c2, r2);
          }
          function Xt(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2) {
            const x2 = r2 ? t2 - i2 : t2 + i2;
            let y2 = x2 > 0 ? 1 : -1, b2 = 0;
            r2 && (y2 *= -1, b2 = Math.PI), y2 < 0 && (b2 += Math.PI);
            let w2 = l2 + n2 + (y2 > 0 ? 0 : 1) | 0, T2 = s2, E2 = s2, C2 = 0, S2 = 0;
            const I2 = Math.abs(x2), D2 = [], R2 = [];
            let A2 = a2, L2 = A2;
            const P2 = () => $t(L2, A2, E2, I2 - C2 + 1, u2, _2, f2, g2.canonical);
            for (; C2 + S2 <= I2; ) {
              if (w2 += y2, w2 < l2 || w2 >= c2)
                return null;
              if (E2 = T2, L2 = A2, D2.push(E2), p2 && R2.push(L2), A2 = new e.P(h2.getx(w2), h2.gety(w2)), T2 = d2[w2], !T2) {
                const e2 = Wt(A2, g2.canonical, u2, f2, _2);
                T2 = e2[3] > 0 ? d2[w2] = e2 : P2();
              }
              C2 += S2, S2 = e.a6.vec3.distance(E2, T2);
            }
            m2 && _2 && (d2[w2] && (T2 = P2(), S2 = e.a6.vec3.distance(E2, T2)), d2[w2] = T2);
            const M2 = (I2 - C2) / S2, z2 = A2.sub(L2)._mult(M2)._add(L2), O2 = e.a6.vec3.sub([], T2, E2), F2 = e.a6.vec3.scaleAndAdd([], E2, O2, M2);
            let k2 = [0, 0, 1], B2 = O2[0], N2 = O2[1];
            if (v2 && (k2 = f2.upVector(g2.canonical, z2.x, z2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
              const t3 = [k2[2], 0, -k2[0]], i3 = e.a6.vec3.cross([], k2, t3);
              e.a6.vec3.normalize(t3, t3), e.a6.vec3.normalize(i3, i3), B2 = e.a6.vec3.dot(O2, t3), N2 = e.a6.vec3.dot(O2, i3);
            }
            if (o2) {
              const t3 = e.a6.vec3.cross([], k2, O2);
              e.a6.vec3.normalize(t3, t3), e.a6.vec3.scaleAndAdd(F2, F2, t3, o2 * y2);
            }
            const U2 = b2 + Math.atan2(N2, B2);
            return D2.push(F2), p2 && R2.push(z2), { point: F2, angle: U2, path: D2, tilePath: R2, up: k2 };
          }
          function Yt(e2, t2) {
            const i2 = t2.length, o2 = i2 + 4 * e2;
            t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
          }
          function Kt(e2, t2, i2) {
            const o2 = t2[0], r2 = t2[1];
            return e2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], e2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], e2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], e2;
          }
          const Jt = 100;
          class Qt {
            constructor(e2, t2, i2 = new zt(e2.width + 200, e2.height + 200, 25), o2 = new zt(e2.width + 200, e2.height + 200, 25)) {
              this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + Jt, this.screenBottomBoundary = e2.height + Jt, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
            }
            placeCollisionBox(e2, t2, i2, o2, r2, s2, a2, n2) {
              let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h2 = i2.projectedAnchorZ;
              const u2 = i2.elevation, d2 = i2.tileID, _2 = e2.getProjection();
              if (u2 && d2) {
                const [e3, t3, o3] = _2.upVector(d2.canonical, i2.tileAnchorX, i2.tileAnchorY), r3 = _2.upVectorScale(d2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                l2 += e3 * u2 * r3, c2 += t3 * u2 * r3, h2 += o3 * u2 * r3;
              }
              const p2 = this.projectAndGetPerspectiveRatio(a2, l2, c2, h2, i2.tileID, "globe" === _2.name || !!u2 || this.transform.pitch > 0, _2), m2 = s2 * p2.perspectiveRatio, f2 = (i2.x1 * t2 + o2.x - i2.padding) * m2 + p2.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * m2 + p2.point.y, v2 = (i2.x2 * t2 + o2.x + i2.padding) * m2 + p2.point.x, x2 = (i2.y2 * t2 + o2.y + i2.padding) * m2 + p2.point.y, y2 = p2.perspectiveRatio <= 0.55 || p2.occluded;
              return !this.isInsideGrid(f2, g2, v2, x2) || !r2 && this.grid.hitTest(f2, g2, v2, x2, n2) || y2 ? { box: [], offscreen: false, occluded: p2.occluded } : { box: [f2, g2, v2, x2], offscreen: this.isOffscreen(f2, g2, v2, x2), occluded: false };
            }
            placeCollisionCircles(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2) {
              const f2 = [], g2 = this.transform.elevation, v2 = t2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, v2) : null, y2 = new e.P(o2.tileAnchorX, o2.tileAnchorY);
              let { x: b2, y: w2, z: T2 } = v2.projectTilePoint(y2.x, y2.y, m2.canonical);
              if (x2) {
                const [e2, t3, i3] = x2(y2);
                b2 += e2, w2 += t3, T2 += i3;
              }
              const E2 = "globe" === v2.name, C2 = this.projectAndGetPerspectiveRatio(n2, b2, w2, T2, m2, E2 || !!g2 || this.transform.pitch > 0, v2), { perspectiveRatio: S2 } = C2, I2 = (u2 ? a2 / S2 : a2 * S2) / e.bq, D2 = Ut(b2, w2, T2, l2), R2 = C2.signedDistanceFromCamera > 0 ? qt(I2, s2, o2.lineOffsetX * I2, o2.lineOffsetY * I2, false, D2, y2, o2, r2, l2, {}, g2 && !u2 ? x2 : null, u2 && !!g2, v2, m2, u2) : null;
              let A2 = false, L2 = false, P2 = true;
              if (R2 && !C2.occluded) {
                const t3 = 0.5 * _2 * S2 + p2, o3 = new e.P(-100, -100), r3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), s3 = new Mt(), { first: a3, last: n3 } = R2, l3 = a3.path.length;
                let u3 = [];
                for (let e2 = l3 - 1; e2 >= 1; e2--)
                  u3.push(a3.path[e2]);
                for (let e2 = 1; e2 < n3.path.length; e2++)
                  u3.push(n3.path[e2]);
                const m3 = 2.5 * t3;
                c2 && (u3 = u3.map(([e2, t4, i3], o4) => (x2 && !E2 && (i3 = x2(o4 < l3 - 1 ? a3.tilePath[l3 - 1 - o4] : n3.tilePath[o4 - l3 + 2])[2]), Ut(e2, t4, i3, c2))), u3.some((e2) => e2[3] <= 0) && (u3 = []));
                let g3 = [];
                if (u3.length > 0) {
                  let t4 = 1 / 0, i3 = -1 / 0, s4 = 1 / 0, a4 = -1 / 0;
                  for (const e2 of u3)
                    t4 = Math.min(t4, e2[0]), s4 = Math.min(s4, e2[1]), i3 = Math.max(i3, e2[0]), a4 = Math.max(a4, e2[1]);
                  i3 >= o3.x && t4 <= r3.x && a4 >= o3.y && s4 <= r3.y && (g3 = [u3.map((t5) => new e.P(t5[0], t5[1]))], (t4 < o3.x || i3 > r3.x || s4 < o3.y || a4 > r3.y) && (g3 = e.bo(g3, o3.x, o3.y, r3.x, r3.y)));
                }
                for (const e2 of g3) {
                  s3.reset(e2, 0.25 * t3);
                  let o4 = 0;
                  o4 = s3.length <= 0.5 * t3 ? 1 : Math.ceil(s3.paddedLength / m3) + 1;
                  for (let e3 = 0; e3 < o4; e3++) {
                    const r4 = e3 / Math.max(o4 - 1, 1), a4 = s3.lerp(r4), n4 = a4.x + Jt, l4 = a4.y + Jt;
                    f2.push(n4, l4, t3, 0);
                    const c3 = n4 - t3, u4 = l4 - t3, _3 = n4 + t3, p3 = l4 + t3;
                    if (P2 = P2 && this.isOffscreen(c3, u4, _3, p3), L2 = L2 || this.isInsideGrid(c3, u4, _3, p3), !i2 && this.grid.hitTestCircle(n4, l4, t3, d2) && (A2 = true, !h2))
                      return { circles: [], offscreen: false, collisionDetected: A2, occluded: false };
                  }
                }
              }
              return { circles: !h2 && A2 || !L2 ? [] : f2, offscreen: P2, collisionDetected: A2, occluded: C2.occluded };
            }
            queryRenderedSymbols(t2) {
              if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                return {};
              const i2 = [];
              let o2 = 1 / 0, r2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
              for (const n3 of t2) {
                const t3 = new e.P(n3.x + Jt, n3.y + Jt);
                o2 = Math.min(o2, t3.x), r2 = Math.min(r2, t3.y), s2 = Math.max(s2, t3.x), a2 = Math.max(a2, t3.y), i2.push(t3);
              }
              const n2 = this.grid.query(o2, r2, s2, a2).concat(this.ignoredGrid.query(o2, r2, s2, a2)), l2 = {}, c2 = {};
              for (const t3 of n2) {
                const o3 = t3.key;
                if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                  continue;
                const r3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
                e.bp(i2, r3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(e2, t2, i2, o2, r2) {
              (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, e2[0], e2[1], e2[2], e2[3]);
            }
            insertCollisionCircles(e2, t2, i2, o2, r2) {
              const s2 = t2 ? this.ignoredGrid : this.grid, a2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 };
              for (let t3 = 0; t3 < e2.length; t3 += 4)
                s2.insertCircle(a2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
            }
            projectAndGetPerspectiveRatio(t2, i2, o2, r2, s2, a2, n2) {
              const l2 = [i2, o2, r2, 1];
              let c2 = false;
              if (r2 || this.transform.pitch > 0) {
                if (e.a6.vec4.transformMat4(l2, l2, t2), this.fogState && s2 && "globe" !== n2.name) {
                  const t3 = function(t4, i3, o3, r3, s3, a3) {
                    const n3 = a3.calculateFogTileMatrix(s3), l3 = [i3, o3, r3];
                    return e.a6.vec3.transformMat4(l3, l3, n3), Fe(t4, e.a6.vec3.length(l3), a3.pitch, a3._fov);
                  }(this.fogState, i2, o2, r2, s2.toUnwrapped(), this.transform);
                  c2 = t3 > 0.9;
                }
              } else
                Kt(l2, l2, t2);
              const h2 = l2[3];
              return { point: new e.P((l2[0] / h2 + 1) / 2 * this.transform.width + Jt, (-l2[1] / h2 + 1) / 2 * this.transform.height + Jt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(n2) / h2 * 0.5, 1.5), signedDistanceFromCamera: h2, occluded: a2 && l2[2] > h2 || c2 };
            }
            isOffscreen(e2, t2, i2, o2) {
              return i2 < Jt || e2 >= this.screenRightBoundary || o2 < Jt || t2 > this.screenBottomBoundary;
            }
            isInsideGrid(e2, t2, i2, o2) {
              return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const t2 = e.a6.mat4.identity([]);
              return e.a6.mat4.translate(t2, t2, [-100, -100, 0]), t2;
            }
          }
          function ei(t2, i2, o2) {
            const r2 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
            return e.a6.mat4.multiply(new Float32Array(16), t2.projMatrix, r2);
          }
          function ti(e2, t2, i2) {
            if (t2.projection.name === i2.projection.name)
              return e2.projMatrix;
            const o2 = i2.clone();
            return o2.setProjection(t2.projection), ei(o2, t2.getProjection(), e2);
          }
          function ii(e2, t2, i2) {
            return t2.name === i2.projection.name ? e2.projMatrix : ei(i2, t2, e2);
          }
          class oi {
            constructor(e2, t2, i2, o2) {
              this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class ri {
            constructor(e2, t2, i2, o2, r2, s2 = false) {
              this.text = new oi(e2 ? e2.text : null, t2, i2, r2), this.icon = new oi(e2 ? e2.icon : null, t2, o2, r2), this.clipped = s2;
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class si {
            constructor(e2, t2, i2, o2 = false) {
              this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
            }
          }
          class ai {
            constructor() {
              this.invProjMatrix = e.a6.mat4.create(), this.viewportMatrix = e.a6.mat4.create(), this.circles = [];
            }
          }
          class ni {
            constructor(e2, t2, i2, o2, r2) {
              this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
            }
          }
          class li {
            constructor(e2) {
              this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e2) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[e2]) {
                const t2 = ++this.maxGroupID;
                this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
              }
              return this.collisionGroups[e2];
            }
          }
          function ci(t2, i2, o2, r2, s2) {
            const { horizontalAlign: a2, verticalAlign: n2 } = e.bx(t2), l2 = -(a2 - 0.5) * i2, c2 = -(n2 - 0.5) * o2, h2 = e.bw(t2, r2);
            return new e.P(l2 + h2[0] * s2, c2 + h2[1] * s2);
          }
          function hi(t2, i2, o2, r2, s2) {
            const a2 = new e.P(t2, i2);
            return o2 && a2._rotate(r2 ? s2 : -s2), a2;
          }
          class ui {
            constructor(e2, t2, i2, o2, r2, s2) {
              this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new Qt(this.transform, r2), this.buildingIndex = s2, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new li(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t2, i2, o2, r2) {
              const s2 = o2.getBucket(i2), a2 = o2.latestFeatureIndex;
              if (!s2 || !a2 || i2.fqid !== s2.layerIds[0])
                return;
              const n2 = s2.layers[0].layout, l2 = s2.layers[0].paint, c2 = o2.collisionBoxArray, h2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u2 = o2.tileSize / e.ab, d2 = o2.tileID.toUnwrapped();
              this.transform.setProjection(s2.projection);
              const _2 = (p2 = o2.tileID, m2 = s2.getProjection(), f2 = this.transform, m2.name === this.projection ? f2.calculateProjMatrix(p2.toUnwrapped()) : ei(f2, m2, p2));
              var p2, m2, f2;
              const g2 = "map" === n2.get("text-pitch-alignment"), v2 = "map" === n2.get("text-rotation-alignment");
              i2.compileFilter();
              const x2 = i2.dynamicFilter(), y2 = i2.dynamicFilterNeedsFeature(), b2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), w2 = Bt(_2, o2.tileID.canonical, g2, v2, this.transform, s2.getProjection(), b2);
              let T2 = null;
              if (g2) {
                const t3 = Nt(_2, o2.tileID.canonical, g2, v2, this.transform, s2.getProjection(), b2);
                T2 = e.a6.mat4.multiply([], this.transform.labelPlaneMatrix, t3);
              }
              let E2 = null;
              x2 && o2.latestFeatureIndex && (E2 = { unwrappedTileID: d2, dynamicFilter: x2, dynamicFilterNeedsFeature: y2 }), this.retainedQueryData[s2.bucketInstanceId] = new ni(s2.bucketInstanceId, a2, s2.sourceLayerIndex, s2.index, o2.tileID);
              const C2 = { bucket: s2, layout: n2, paint: l2, posMatrix: _2, textLabelPlaneMatrix: w2, labelToScreenMatrix: T2, clippingData: E2, scale: h2, textPixelRatio: u2, holdingForFade: o2.holdingForFade(), collisionBoxArray: c2, partiallyEvaluatedTextSize: e.bj(s2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.bj(s2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s2.sourceID), latestFeatureIndex: o2.latestFeatureIndex };
              if (r2)
                for (const e2 of s2.sortKeyRanges) {
                  const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3 } = e2;
                  t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3, parameters: C2 });
                }
              else
                t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: s2.symbolInstances.length, parameters: C2 });
            }
            attemptAnchorPlacement(e2, t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2) {
              const { textOffset0: v2, textOffset1: x2, crossTileID: y2 } = u2, b2 = [v2, x2], w2 = ci(e2, i2, o2, b2, r2), T2 = this.collisionIndex.placeCollisionBox(_2, r2, t2, hi(w2.x, w2.y, s2, a2, this.transform.angle), h2, n2, l2, c2.predicate);
              if (m2) {
                const e3 = _2.getSymbolInstanceIconSize(g2, this.transform.zoom, u2.placedIconSymbolIndex);
                if (0 === this.collisionIndex.placeCollisionBox(_2, e3, m2, hi(w2.x, w2.y, s2, a2, this.transform.angle), h2, n2, l2, c2.predicate).box.length)
                  return;
              }
              if (T2.box.length > 0) {
                let t3;
                return this.prevPlacement && this.prevPlacement.variableOffsets[y2] && this.prevPlacement.placements[y2] && this.prevPlacement.placements[y2].text && (t3 = this.prevPlacement.variableOffsets[y2].anchor), this.variableOffsets[y2] = { textOffset: b2, width: i2, height: o2, anchor: e2, textScale: r2, prevAnchor: t3 }, this.markUsedJustification(_2, e2, u2, p2), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p2, u2), this.placedOrientations[y2] = p2), { shift: w2, placedGlyphBoxes: T2 };
              }
            }
            placeLayerBucketPart(t2, i2, o2, r2) {
              const { bucket: s2, layout: a2, paint: n2, posMatrix: l2, textLabelPlaneMatrix: c2, labelToScreenMatrix: h2, clippingData: u2, textPixelRatio: d2, holdingForFade: _2, collisionBoxArray: p2, partiallyEvaluatedTextSize: m2, partiallyEvaluatedIconSize: f2, collisionGroup: g2, latestFeatureIndex: v2 } = t2.parameters, x2 = a2.get("text-optional"), y2 = a2.get("icon-optional"), b2 = a2.get("text-allow-overlap"), w2 = a2.get("icon-allow-overlap"), T2 = "map" === a2.get("text-rotation-alignment"), E2 = "map" === a2.get("text-pitch-alignment"), C2 = a2.get("symbol-z-elevate"), S2 = n2.get("symbol-z-offset"), I2 = "sea" === n2.get("symbol-elevation-reference");
              this.transform.setProjection(s2.projection);
              let D2 = b2 && (w2 || !s2.hasIconData() || y2), R2 = w2 && (b2 || !s2.hasTextData() || x2);
              const A2 = !S2.isConstant();
              !s2.collisionArrays && p2 && s2.deserializeCollisionBoxes(p2), o2 && r2 && s2.updateCollisionDebugBuffers(this.transform.zoom, p2);
              const L2 = (t3, r3, n3) => {
                const { crossTileID: p3, numVerticalGlyphVertices: C3 } = t3;
                let L3 = null;
                if (u2 && u2.dynamicFilterNeedsFeature || A2) {
                  const e2 = this.retainedQueryData[s2.bucketInstanceId];
                  L3 = v2.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (u2 && !(0, u2.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, L3, this.retainedQueryData[s2.bucketInstanceId].tileID.canonical, new e.P(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(u2.unwrappedTileID)))
                  return this.placements[p3] = new si(false, false, false, true), void i2.add(p3);
                const P2 = S2.evaluate(L3, {});
                if (i2.has(p3))
                  return;
                if (_2)
                  return void (this.placements[p3] = new si(false, false, false));
                let M2 = false, z2 = false, O2 = true, F2 = false, k2 = false, B2 = null, N2 = { box: null, offscreen: null, occluded: null }, U2 = { box: null, offscreen: null, occluded: null }, G2 = null, j2 = null, V2 = null, q2 = 0, Z2 = 0, H2 = 0;
                n3.textFeatureIndex ? q2 = n3.textFeatureIndex : t3.useRuntimeCollisionCircles && (q2 = t3.featureIndex), n3.verticalTextFeatureIndex && (Z2 = n3.verticalTextFeatureIndex);
                const W2 = (e2) => {
                  e2.tileID = this.retainedQueryData[s2.bucketInstanceId].tileID;
                  const i3 = this.transform.elevation;
                  e2.elevation = I2 ? P2 : P2 + (i3 ? i3.getAtTileOffset(e2.tileID, e2.tileAnchorX, e2.tileAnchorY) : 0), e2.elevation += t3.zOffset;
                }, $2 = n3.textBox;
                if ($2) {
                  W2($2);
                  const i3 = (i4) => {
                    let o4 = e.bk.horizontal;
                    if (s2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const e2 = this.prevPlacement.placedOrientations[p3];
                      e2 && (this.placedOrientations[p3] = e2, o4 = e2, this.markUsedOrientation(s2, o4, t3));
                    }
                    return o4;
                  }, o3 = (t4, i4) => {
                    if (s2.allowVerticalPlacement && C3 > 0 && n3.verticalTextBox) {
                      for (const o4 of s2.writingModes)
                        if (o4 === e.bk.vertical ? (N2 = i4(), U2 = N2) : N2 = t4(), N2 && N2.box && N2.box.length)
                          break;
                    } else
                      N2 = t4();
                  };
                  if (a2.get("text-variable-anchor")) {
                    let c3 = a2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[p3]) {
                      const e2 = this.prevPlacement.variableOffsets[p3];
                      c3.indexOf(e2.anchor) > 0 && (c3 = c3.filter((t4) => t4 !== e2.anchor), c3.unshift(e2.anchor));
                    }
                    const h3 = (e2, i4, o4) => {
                      const a3 = s2.getSymbolInstanceTextSize(m2, t3, this.transform.zoom, r3), n4 = (e2.x2 - e2.x1) * a3 + 2 * e2.padding, h4 = (e2.y2 - e2.y1) * a3 + 2 * e2.padding, u4 = t3.hasIconTextFit && !w2 ? i4 : null;
                      u4 && W2(u4);
                      let _3 = { box: [], offscreen: false, occluded: false };
                      const p4 = b2 ? 2 * c3.length : c3.length;
                      for (let i5 = 0; i5 < p4; ++i5) {
                        const p5 = this.attemptAnchorPlacement(c3[i5 % c3.length], e2, n4, h4, a3, T2, E2, d2, l2, g2, i5 >= c3.length, t3, r3, s2, o4, u4, m2, f2);
                        if (p5 && (_3 = p5.placedGlyphBoxes, _3 && _3.box && _3.box.length)) {
                          M2 = true, B2 = p5.shift;
                          break;
                        }
                      }
                      return _3;
                    };
                    o3(() => h3($2, n3.iconBox, e.bk.horizontal), () => {
                      const t4 = n3.verticalTextBox;
                      return t4 && W2(t4), s2.allowVerticalPlacement && !(N2 && N2.box && N2.box.length) && C3 > 0 && t4 ? h3(t4, n3.verticalIconBox, e.bk.vertical) : { box: null, offscreen: null, occluded: null };
                    }), N2 && (M2 = N2.box, O2 = N2.offscreen, F2 = N2.occluded);
                    const u3 = i3(!(!N2 || !N2.box));
                    if (!M2 && this.prevPlacement) {
                      const e2 = this.prevPlacement.variableOffsets[p3];
                      e2 && (this.variableOffsets[p3] = e2, this.markUsedJustification(s2, e2.anchor, t3, u3));
                    }
                  } else {
                    const a3 = (i4, o4) => {
                      const a4 = s2.getSymbolInstanceTextSize(m2, t3, this.transform.zoom, r3), n4 = this.collisionIndex.placeCollisionBox(s2, a4, i4, new e.P(0, 0), b2, d2, l2, g2.predicate);
                      return n4 && n4.box && n4.box.length && (this.markUsedOrientation(s2, o4, t3), this.placedOrientations[p3] = o4), n4;
                    };
                    o3(() => a3($2, e.bk.horizontal), () => {
                      const t4 = n3.verticalTextBox;
                      return s2.allowVerticalPlacement && C3 > 0 && t4 ? (W2(t4), a3(t4, e.bk.vertical)) : { box: null, offscreen: null, occluded: null };
                    }), i3(!!(N2 && N2.box && N2.box.length));
                  }
                }
                if (G2 = N2, M2 = G2 && G2.box && G2.box.length > 0, O2 = G2 && G2.offscreen, F2 = G2 && G2.occluded, t3.useRuntimeCollisionCircles) {
                  const i3 = s2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r4 = e.bl(s2.textSizeData, m2, i3), n4 = a2.get("text-padding");
                  j2 = this.collisionIndex.placeCollisionCircles(s2, b2, i3, s2.lineVertexArray, s2.glyphOffsetArray, r4, l2, c2, h2, o2, E2, g2.predicate, t3.collisionCircleDiameter * r4 / e.bq, n4, this.retainedQueryData[s2.bucketInstanceId].tileID), M2 = b2 || j2.circles.length > 0 && !j2.collisionDetected, O2 = O2 && j2.offscreen, F2 = j2.occluded;
                }
                if (n3.iconFeatureIndex && (H2 = n3.iconFeatureIndex), n3.iconBox) {
                  const i3 = (i4) => {
                    W2(i4);
                    const o3 = t3.hasIconTextFit && B2 ? hi(B2.x, B2.y, T2, E2, this.transform.angle) : new e.P(0, 0), r4 = s2.getSymbolInstanceIconSize(f2, this.transform.zoom, t3.placedIconSymbolIndex);
                    return this.collisionIndex.placeCollisionBox(s2, r4, i4, o3, w2, d2, l2, g2.predicate);
                  };
                  U2 && U2.box && U2.box.length && n3.verticalIconBox ? (V2 = i3(n3.verticalIconBox), z2 = V2.box.length > 0) : (V2 = i3(n3.iconBox), z2 = V2.box.length > 0), O2 = O2 && V2.offscreen, k2 = V2.occluded;
                }
                const X2 = x2 || 0 === t3.numHorizontalGlyphVertices && 0 === C3, Y2 = y2 || 0 === t3.numIconVertices;
                if (X2 || Y2 ? Y2 ? X2 || (z2 = z2 && M2) : M2 = z2 && M2 : z2 = M2 = z2 && M2, M2 && G2 && G2.box && this.collisionIndex.insertCollisionBox(G2.box, a2.get("text-ignore-placement"), s2.bucketInstanceId, U2 && U2.box && Z2 ? Z2 : q2, g2.ID), z2 && V2 && this.collisionIndex.insertCollisionBox(V2.box, a2.get("icon-ignore-placement"), s2.bucketInstanceId, H2, g2.ID), j2 && (M2 && this.collisionIndex.insertCollisionCircles(j2.circles, a2.get("text-ignore-placement"), s2.bucketInstanceId, q2, g2.ID), o2)) {
                  const e2 = s2.bucketInstanceId;
                  let t4 = this.collisionCircleArrays[e2];
                  void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new ai());
                  for (let e3 = 0; e3 < j2.circles.length; e3 += 4)
                    t4.circles.push(j2.circles[e3 + 0]), t4.circles.push(j2.circles[e3 + 1]), t4.circles.push(j2.circles[e3 + 2]), t4.circles.push(j2.collisionDetected ? 1 : 0);
                }
                const K2 = "globe" !== s2.projection.name;
                D2 = D2 && (K2 || !F2), R2 = R2 && (K2 || !k2), this.placements[p3] = new si(M2 || D2, z2 || R2, O2 || s2.justReloaded), i2.add(p3);
              };
              if (C2 && this.buildingIndex && (this.buildingIndex.updateZOffset(s2, this.retainedQueryData[s2.bucketInstanceId].tileID), s2.updateZOffset()), s2.sortFeaturesByY) {
                const t3 = s2.getSortedSymbolIndexes(this.transform.angle);
                for (let e2 = t3.length - 1; e2 >= 0; --e2) {
                  const i3 = t3[e2];
                  L2(s2.symbolInstances.get(i3), i3, s2.collisionArrays[i3]);
                }
                s2.hasAnyZOffset && e.w(`${s2.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
              } else if (s2.hasAnyZOffset) {
                const e2 = s2.getSortedIndexesByZOffset();
                for (let t3 = 0; t3 < e2.length; ++t3) {
                  const i3 = e2[t3];
                  L2(s2.symbolInstances.get(i3), i3, s2.collisionArrays[i3]);
                }
              } else
                for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++)
                  L2(s2.symbolInstances.get(e2), e2, s2.collisionArrays[e2]);
              if (o2 && s2.bucketInstanceId in this.collisionCircleArrays) {
                const t3 = this.collisionCircleArrays[s2.bucketInstanceId];
                e.a6.mat4.invert(t3.invProjMatrix, l2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              s2.justReloaded = false;
            }
            markUsedJustification(t2, i2, o2, r2) {
              const { leftJustifiedTextSymbolIndex: s2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: n2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h2 = e.bv(i2), u2 = r2 === e.bk.vertical ? l2 : "left" === h2 ? s2 : "center" === h2 ? a2 : "right" === h2 ? n2 : -1;
              s2 >= 0 && (t2.text.placedSymbolArray.get(s2).crossTileID = u2 >= 0 && s2 !== u2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = u2 >= 0 && a2 !== u2 ? 0 : c2), n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = u2 >= 0 && n2 !== u2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = u2 >= 0 && l2 !== u2 ? 0 : c2);
            }
            markUsedOrientation(t2, i2, o2) {
              const r2 = i2 === e.bk.horizontal || i2 === e.bk.horizontalOnly ? i2 : 0, s2 = i2 === e.bk.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: a2, centerJustifiedTextSymbolIndex: n2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h2 = t2.text.placedSymbolArray;
              a2 >= 0 && (h2.get(a2).placedOrientation = r2), n2 >= 0 && (h2.get(n2).placedOrientation = r2), l2 >= 0 && (h2.get(l2).placedOrientation = r2), c2 >= 0 && (h2.get(c2).placedOrientation = s2);
            }
            commit(e2) {
              this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const t2 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
              const o2 = t2 ? t2.symbolFadeChange(e2) : 1, r2 = t2 ? t2.opacities : {}, s2 = t2 ? t2.variableOffsets : {}, a2 = t2 ? t2.placedOrientations : {};
              for (const e3 in this.placements) {
                const t3 = this.placements[e3], s3 = r2[e3];
                s3 ? (this.opacities[e3] = new ri(s3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== s3.text.placed || t3.icon !== s3.icon.placed) : (this.opacities[e3] = new ri(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
              }
              for (const e3 in r2) {
                const t3 = r2[e3];
                if (!this.opacities[e3]) {
                  const r3 = new ri(t3, o2, false, false);
                  r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
                }
              }
              for (const e3 in s2)
                this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = s2[e3]);
              for (const e3 in a2)
                this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = a2[e3]);
              i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
            }
            updateLayerOpacities(e2, t2, i2, o2) {
              const r2 = /* @__PURE__ */ new Set();
              for (const s2 of t2) {
                const t3 = s2.getBucket(e2);
                t3 && s2.latestFeatureIndex && e2.fqid === t3.layerIds[0] && (this.updateBucketOpacities(t3, r2, s2, s2.collisionBoxArray, i2, o2, s2.tileID, e2.scope), t3.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t3, s2.tileID), t3.updateZOffset()));
              }
            }
            updateBucketOpacities(t2, i2, o2, r2, s2, a2, n2, l2) {
              t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
              const c2 = t2.layers[0].layout, h2 = t2.layers[0].paint, u2 = !!t2.layers[0].dynamicFilter(), d2 = new ri(null, 0, false, false, true), _2 = c2.get("text-allow-overlap"), p2 = c2.get("icon-allow-overlap"), m2 = c2.get("text-variable-anchor"), f2 = "map" === c2.get("text-rotation-alignment"), g2 = "map" === c2.get("text-pitch-alignment"), v2 = h2.get("symbol-z-offset"), x2 = "sea" === h2.get("symbol-elevation-reference"), y2 = !v2.isConstant(), b2 = new ri(null, 0, _2 && (p2 || !t2.hasIconData() || c2.get("icon-optional")), p2 && (_2 || !t2.hasTextData() || c2.get("text-optional")), true);
              !t2.collisionArrays && r2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(r2);
              const w2 = (e2, t3, i3) => {
                for (let o3 = 0; o3 < t3 / 4; o3++)
                  e2.opacityVertexArray.emplaceBack(i3);
              };
              let T2 = 0;
              a2 && t2.updateReplacement(n2, a2);
              for (let r3 = 0; r3 < t2.symbolInstances.length; r3++) {
                const c3 = t2.symbolInstances.get(r3), { numHorizontalGlyphVertices: h3, numVerticalGlyphVertices: _3, crossTileID: p3, numIconVertices: E2, tileAnchorX: C2, tileAnchorY: S2 } = c3;
                let I2 = null;
                if (c3 && y2) {
                  const e2 = this.retainedQueryData[t2.bucketInstanceId];
                  I2 = o2.latestFeatureIndex.loadFeature({ featureIndex: c3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                const D2 = v2.evaluate(I2, {}), R2 = i2.has(p3);
                let A2 = this.opacities[p3];
                R2 ? A2 = d2 : A2 || (A2 = b2, this.opacities[p3] = A2), i2.add(p3);
                const L2 = h3 > 0 || _3 > 0, P2 = E2 > 0, M2 = this.placedOrientations[p3], z2 = M2 === e.bk.vertical, O2 = M2 === e.bk.horizontal || M2 === e.bk.horizontalOnly;
                !L2 && !P2 || A2.isHidden() || T2++;
                let F2 = false;
                if ((L2 || P2) && a2)
                  for (const i3 of t2.activeReplacements) {
                    if (e.br(i3, s2, e.bs.Symbol, l2))
                      continue;
                    if (i3.min.x > C2 || C2 > i3.max.x || i3.min.y > S2 || S2 > i3.max.y)
                      continue;
                    const t3 = e.bt(C2, S2, n2.canonical, i3.footprintTileId.canonical);
                    if (F2 = e.bu(t3, i3.footprint), F2)
                      break;
                  }
                if (L2) {
                  const e2 = F2 ? bi : yi(A2.text);
                  w2(t2.text, h3, z2 ? bi : e2), w2(t2.text, _3, O2 ? bi : e2);
                  const i3 = A2.text.isHidden(), { leftJustifiedTextSymbolIndex: o3, centerJustifiedTextSymbolIndex: r4, rightJustifiedTextSymbolIndex: s3, verticalPlacedTextSymbolIndex: a3 } = c3, n3 = t2.text.placedSymbolArray, l3 = i3 || z2 ? 1 : 0;
                  o3 >= 0 && (n3.get(o3).hidden = l3), r4 >= 0 && (n3.get(r4).hidden = l3), s3 >= 0 && (n3.get(s3).hidden = l3), a3 >= 0 && (n3.get(a3).hidden = i3 || O2 ? 1 : 0);
                  const u3 = this.variableOffsets[p3];
                  u3 && this.markUsedJustification(t2, u3.anchor, c3, M2);
                  const d3 = this.placedOrientations[p3];
                  d3 && (this.markUsedJustification(t2, "left", c3, d3), this.markUsedOrientation(t2, d3, c3));
                }
                if (P2) {
                  const e2 = F2 ? bi : yi(A2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o3 } = c3, r4 = t2.icon.placedSymbolArray, s3 = A2.icon.isHidden() ? 1 : 0;
                  i3 >= 0 && (w2(t2.icon, E2, z2 ? bi : e2), r4.get(i3).hidden = s3), o3 >= 0 && (w2(t2.icon, c3.numVerticalIconVertices, O2 ? bi : e2), r4.get(o3).hidden = s3);
                }
                if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                  const i3 = t2.collisionArrays[r3];
                  if (i3) {
                    let o3 = new e.P(0, 0), r4 = true;
                    if (i3.textBox || i3.verticalTextBox) {
                      if (m2) {
                        const e2 = this.variableOffsets[p3];
                        e2 ? (o3 = ci(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), f2 && o3._rotate(g2 ? this.transform.angle : -this.transform.angle)) : r4 = false;
                      }
                      u2 && (r4 = !A2.clipped), i3.textBox && di(t2.textCollisionBox.collisionVertexArray, A2.text.placed, !r4 || z2, D2, x2, o3.x, o3.y), i3.verticalTextBox && di(t2.textCollisionBox.collisionVertexArray, A2.text.placed, !r4 || O2, D2, x2, o3.x, o3.y);
                    }
                    const s3 = r4 && Boolean(!O2 && i3.verticalIconBox);
                    i3.iconBox && di(t2.iconCollisionBox.collisionVertexArray, A2.icon.placed, s3, D2, x2, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0), i3.verticalIconBox && di(t2.iconCollisionBox.collisionVertexArray, A2.icon.placed, !s3, D2, x2, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0);
                  }
                }
              }
              if (t2.fullyClipped = 0 === T2, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
                const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
                t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
              }
            }
            symbolFadeChange(e2) {
              return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e2) {
              return Math.max(0, (this.transform.zoom - e2) / 1.5);
            }
            hasTransitions(e2) {
              return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e2, t2) {
              const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
              return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function di(e2, t2, i2, o2, r2, s2, a2) {
            e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0, o2, r2 ? 1 : 0);
          }
          const _i2 = Math.pow(2, 25), pi = Math.pow(2, 24), mi = Math.pow(2, 17), fi = Math.pow(2, 16), gi = Math.pow(2, 9), vi = Math.pow(2, 8), xi = Math.pow(2, 1);
          function yi(e2) {
            if (0 === e2.opacity && !e2.placed)
              return 0;
            if (1 === e2.opacity && e2.placed)
              return 4294967295;
            const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
            return i2 * _i2 + t2 * pi + i2 * mi + t2 * fi + i2 * gi + t2 * vi + i2 * xi + t2;
          }
          const bi = 0;
          class wi {
            constructor(e2) {
              this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
            }
            continuePlacement(e2, t2, i2, o2, r2) {
              const s2 = this._bucketParts;
              for (; this._currentTileIndex < e2.length; )
                if (t2.getBucketParts(s2, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < s2.length; ) {
                const e3 = s2[this._currentPartIndex];
                if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r2())
                  return true;
              }
              return false;
            }
          }
          class Ti {
            constructor(e2, t2, i2, o2, r2, s2, a2, n2, l2) {
              this.placement = new ui(e2, r2, s2, a2, n2, l2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(t2, i2, o2, r2) {
              const s2 = e.q.now(), a2 = () => {
                const t3 = e.q.now() - s2;
                return !this._forceFullPlacement && t3 > 2;
              };
              for (; this._currentPlacementIndex >= 0; ) {
                const s3 = i2[t2[this._currentPlacementIndex]], n2 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === s3.type && (!s3.minzoom || s3.minzoom <= n2) && (!s3.maxzoom || s3.maxzoom > n2)) {
                  const t3 = s3, i3 = t3.layout.get("symbol-z-elevate"), n3 = void 0 !== t3.layout.get("symbol-sort-key").constantOr(1), l2 = t3.layout.get("symbol-z-order"), c2 = "viewport-y" === l2 || "auto" === l2 && !("viewport-y" !== l2 && n3), h2 = t3.layout.get("text-allow-overlap") || t3.layout.get("icon-allow-overlap") || t3.layout.get("text-ignore-placement") || t3.layout.get("icon-ignore-placement"), u2 = c2 && h2, d2 = this._inProgressLayer = this._inProgressLayer || new wi(t3), _2 = e.av(s3.source, s3.scope);
                  if (d2.continuePlacement(i3 || u2 ? r2[_2] : o2[_2], this.placement, this._showCollisionBoxes, s3, a2))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(e2) {
              return this.placement.commit(e2), this.placement;
            }
          }
          const Ei = 512 / e.ab / 2;
          class Ci {
            constructor(t2, i2, o2) {
              this.tileID = t2, this.bucketInstanceId = o2, this.index = new e.by(i2.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
              const r2 = t2.canonical.x * e.ab, s2 = t2.canonical.y * e.ab;
              for (let e2 = 0; e2 < i2.length; e2++) {
                const { key: t3, crossTileID: o3, tileAnchorX: a2, tileAnchorY: n2 } = i2.get(e2), l2 = Math.floor((r2 + a2) * Ei), c2 = Math.floor((s2 + n2) * Ei);
                this.index.add(l2, c2), this.keys.push(t3), this.crossTileIDs.push(o3);
              }
              this.index.finish();
            }
            findMatches(t2, i2, o2) {
              const r2 = this.tileID.canonical.z < i2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i2.canonical.z), s2 = Ei / Math.pow(2, i2.canonical.z - this.tileID.canonical.z), a2 = i2.canonical.x * e.ab, n2 = i2.canonical.y * e.ab;
              for (let e2 = 0; e2 < t2.length; e2++) {
                const i3 = t2.get(e2);
                if (i3.crossTileID)
                  continue;
                const { key: l2, tileAnchorX: c2, tileAnchorY: h2 } = i3, u2 = Math.floor((a2 + c2) * s2), d2 = Math.floor((n2 + h2) * s2), _2 = this.index.range(u2 - r2, d2 - r2, u2 + r2, d2 + r2);
                for (const e3 of _2) {
                  const t3 = this.crossTileIDs[e3];
                  if (this.keys[e3] === l2 && !o2.has(t3)) {
                    o2.add(t3), i3.crossTileID = t3;
                    break;
                  }
                }
              }
            }
          }
          class Si {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class Ii {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - this.lng) / 360);
              if (0 !== t2)
                for (const e3 in this.indexes) {
                  const i2 = this.indexes[e3], o2 = {};
                  for (const e4 in i2) {
                    const r2 = i2[e4];
                    r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), o2[r2.tileID.key] = r2;
                  }
                  this.indexes[e3] = o2;
                }
              this.lng = e2;
            }
            addBucket(e2, t2, i2) {
              if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
                if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
                t2.symbolInstances.get(e3).crossTileID = 0;
              this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = /* @__PURE__ */ new Set());
              const o2 = this.usedCrossTileIDs[e2.overscaledZ];
              for (const i3 in this.indexes) {
                const r2 = this.indexes[i3];
                if (Number(i3) > e2.overscaledZ)
                  for (const i4 in r2) {
                    const s2 = r2[i4];
                    s2.tileID.isChildOf(e2) && s2.findMatches(t2.symbolInstances, e2, o2);
                  }
                else {
                  const s2 = r2[e2.scaledTo(Number(i3)).key];
                  s2 && s2.findMatches(t2.symbolInstances, e2, o2);
                }
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
                const r2 = t2.symbolInstances.get(e3);
                r2.crossTileID || (r2.crossTileID = i2.generate(), o2.add(r2.crossTileID));
              }
              return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Ci(e2, t2.symbolInstances, t2.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(e2, t2) {
              for (const i2 of t2.crossTileIDs)
                this.usedCrossTileIDs[e2].delete(i2);
            }
            removeStaleBuckets(e2) {
              let t2 = false;
              for (const i2 in this.indexes) {
                const o2 = this.indexes[i2];
                for (const r2 in o2)
                  e2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], t2 = true);
              }
              return t2;
            }
          }
          class Di {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Si(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e2, t2, i2, o2) {
              let r2 = this.layerIndexes[e2.fqid];
              void 0 === r2 && (r2 = this.layerIndexes[e2.fqid] = new Ii());
              let s2 = false;
              const a2 = {};
              "globe" !== o2.name && r2.handleWrapJump(i2);
              for (const i3 of t2) {
                const t3 = i3.getBucket(e2);
                t3 && e2.fqid === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r2.addBucket(i3.tileID, t3, this.crossTileIDs) && (s2 = true), a2[t3.bucketInstanceId] = true);
              }
              return r2.removeStaleBuckets(a2) && (s2 = true), s2;
            }
            pruneUnusedLayers(e2) {
              const t2 = {};
              e2.forEach((e3) => {
                t2[e3] = true;
              });
              for (const e3 in this.layerIndexes)
                t2[e3] || delete this.layerIndexes[e3];
            }
          }
          const Ri = 771;
          class Ai {
            constructor(e2, t2, i2, o2) {
              this.blendFunction = e2, this.blendColor = t2, this.mask = i2, this.blendEquation = o2;
            }
          }
          Ai.Replace = [1, 0, 1, 0], Ai.disabled = new Ai(Ai.Replace, e.bz.transparent, [false, false, false, false]), Ai.unblended = new Ai(Ai.Replace, e.bz.transparent, [true, true, true, true]), Ai.alphaBlended = new Ai([1, Ri, 1, Ri], e.bz.transparent, [true, true, true, true]), Ai.alphaBlendedNonPremultiplied = new Ai([770, Ri, 770, Ri], e.bz.transparent, [true, true, true, true]), Ai.multiply = new Ai([774, 0, 774, 0], e.bz.transparent, [true, true, true, true]);
          class Li {
            constructor(e2, t2, i2) {
              this.func = e2, this.mask = t2, this.range = i2;
            }
          }
          Li.ReadOnly = false, Li.ReadWrite = true, Li.disabled = new Li(519, Li.ReadOnly, [0, 1]);
          const Pi = 7680;
          class Mi {
            constructor(e2, t2, i2, o2, r2, s2) {
              this.test = e2, this.ref = t2, this.mask = i2, this.fail = o2, this.depthFail = r2, this.pass = s2;
            }
          }
          Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, Pi, Pi, Pi);
          const zi = 1029, Oi = 2305;
          class Fi {
            constructor(e2, t2, i2) {
              this.enable = e2, this.mode = t2, this.frontFace = i2;
            }
          }
          function ki(t2, i2) {
            const o2 = e.bC(t2, 3);
            e.a6.mat4.fromQuat(t2, i2), e.bE(t2, 3, o2);
          }
          function Bi(t2, i2) {
            const o2 = e.a6.quat.identity([]);
            return e.a6.quat.rotateZ(o2, o2, -i2), e.a6.quat.rotateX(o2, o2, -t2), o2;
          }
          function Ni(t2, i2) {
            const o2 = [t2[0], t2[1], 0], r2 = [i2[0], i2[1], 0];
            if (e.a6.vec3.length(o2) >= 1e-15) {
              const t3 = e.a6.vec3.normalize([], o2);
              e.a6.vec3.scale(r2, t3, e.a6.vec3.dot(r2, t3)), i2[0] = r2[0], i2[1] = r2[1];
            }
            const s2 = e.a6.vec3.cross([], i2, t2);
            if (e.a6.vec3.len(s2) < 1e-15)
              return null;
            const a2 = Math.atan2(-s2[1], s2[0]);
            return Bi(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), a2);
          }
          Fi.disabled = new Fi(false, zi, Oi), Fi.backCCW = new Fi(true, zi, Oi), Fi.backCW = new Fi(true, zi, 2304), Fi.frontCW = new Fi(true, 1028, 2304), Fi.frontCCW = new Fi(true, 1028, Oi);
          class Ui {
            constructor(e2, t2) {
              this.position = e2, this.orientation = t2;
            }
            get position() {
              return this._position;
            }
            set position(t2) {
              if (t2) {
                const i2 = t2 instanceof e.a5 ? t2 : new e.a5(t2[0], t2[1], t2[2]);
                this._renderWorldCopies && (i2.x = e.bA(i2.x, 0, 1)), this._position = i2;
              } else
                this._position = null;
            }
            lookAtPoint(t2, i2) {
              if (this.orientation = null, !this.position)
                return;
              const o2 = this.position, r2 = this._elevation ? this._elevation.getAtPointOrZero(e.a5.fromLngLat(t2)) : 0, s2 = e.a5.fromLngLat(t2, r2), a2 = [s2.x - o2.x, s2.y - o2.y, s2.z - o2.z];
              i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = Ni(a2, i2);
            }
            setPitchBearing(t2, i2) {
              this.orientation = Bi(e.bB(t2), e.bB(-i2));
            }
          }
          class Gi {
            constructor(t2, i2) {
              this._transform = e.a6.mat4.identity([]), this.orientation = i2, this.position = t2;
            }
            get mercatorPosition() {
              const t2 = this.position;
              return new e.a5(t2[0], t2[1], t2[2]);
            }
            get position() {
              const t2 = e.bC(this._transform, 3);
              return [t2[0], t2[1], t2[2]];
            }
            set position(t2) {
              var i2;
              t2 && e.bE(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
            }
            get orientation() {
              return this._orientation;
            }
            set orientation(t2) {
              this._orientation = t2 || e.a6.quat.identity([]), t2 && ki(this._transform, this._orientation);
            }
            getPitchBearing() {
              const e2 = this.forward(), t2 = this.right();
              return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
            }
            setPitchBearing(e2, t2) {
              this._orientation = Bi(e2, t2), ki(this._transform, this._orientation);
            }
            forward() {
              const t2 = e.bC(this._transform, 2);
              return [-t2[0], -t2[1], -t2[2]];
            }
            up() {
              const t2 = e.bC(this._transform, 1);
              return [-t2[0], -t2[1], -t2[2]];
            }
            right() {
              const t2 = e.bC(this._transform, 0);
              return [t2[0], t2[1], t2[2]];
            }
            getCameraToWorld(t2, i2) {
              const o2 = new Float64Array(16);
              return e.a6.mat4.invert(o2, this.getWorldToCamera(t2, i2)), o2;
            }
            getCameraToWorldMercator() {
              return this._transform;
            }
            getWorldToCameraPosition(t2, i2, o2) {
              const r2 = this.position;
              e.a6.vec3.scale(r2, r2, -t2);
              const s2 = new Float64Array(16);
              return e.a6.mat4.fromScaling(s2, [o2, o2, o2]), e.a6.mat4.translate(s2, s2, r2), s2[10] *= i2, s2;
            }
            getWorldToCamera(t2, i2) {
              const o2 = new Float64Array(16), r2 = new Float64Array(4), s2 = this.position;
              return e.a6.quat.conjugate(r2, this._orientation), e.a6.vec3.scale(s2, s2, -t2), e.a6.mat4.fromQuat(o2, r2), e.a6.mat4.translate(o2, o2, s2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
            }
            getCameraToClipPerspective(t2, i2, o2, r2) {
              const s2 = new Float64Array(16);
              return e.a6.mat4.perspective(s2, t2, i2, o2, r2), s2;
            }
            getCameraToClipOrthographic(t2, i2, o2, r2, s2, a2) {
              const n2 = new Float64Array(16);
              return e.a6.mat4.ortho(n2, t2, i2, o2, r2, s2, a2), n2;
            }
            getDistanceToElevation(t2, i2 = false) {
              const o2 = 0 === t2 ? 0 : e.bD(t2, i2 ? e.aM(this.position[1]) : this.position[1]), r2 = this.forward();
              return (o2 - this.position[2]) / r2[2];
            }
            clone() {
              return new Gi([...this.position], [...this.orientation]);
            }
          }
          const ji = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
          class Vi {
            constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
              if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
            }
            interpolate(t2, i2, o2) {
              return null != i2.top && null != t2.top && (this.top = e.aa(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.aa(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.aa(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.aa(t2.right, i2.right, o2)), this;
            }
            getCenter(t2, i2) {
              const o2 = e.ap((this.left + t2 - this.right) / 2, 0, t2), r2 = e.ap((this.top + i2 - this.bottom) / 2, 0, i2);
              return new e.P(o2, r2);
            }
            equals(e2) {
              return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
            }
            clone() {
              return new Vi(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          const qi = (e2, t2, i2) => (1 - i2) * e2 + i2 * t2, Zi = (e2) => e2 * e2 * e2 * e2 * e2;
          class Hi {
            constructor(t2, i2, o2, r2, s2, a2, n2) {
              this.tileSize = 512, this._renderWorldCopies = void 0 === s2 || s2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 ?? 0, this._maxPitch = r2 ?? 60, this.setProjection(a2), this.setMaxBounds(n2), this.width = 0, this.height = 0, this._center = new e.bK(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Vi(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Gi(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false;
            }
            clone() {
              const e2 = new Hi(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
              return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2;
            }
            get isOrthographic() {
              return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(e2) {
              this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            get depthOcclusionForSymbolsAndCircles() {
              return "globe" !== this.projection.name && !this.isOrthographic;
            }
            updateElevation(e2, t2 = false) {
              const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
              (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
            }
            getProjection() {
              return e.ar(this.projection, ["name", "center", "parallels"]);
            }
            setProjection(t2) {
              this.projectionOptions = t2 || { name: "mercator" };
              const i2 = this.projection ? this.getProjection() : void 0;
              this.projection = e.bL(this.projectionOptions);
              const o2 = this.getProjection(), r2 = !e.bh(i2, o2);
              return r2 && this._calcMatrices(), this.mercatorFromTransition = false, r2;
            }
            setOrthographicProjectionAtLowPitch(e2) {
              return this._orthographicProjectionAtLowPitch !== e2 && (this._orthographicProjectionAtLowPitch = e2, this._calcMatrices(), true);
            }
            setMercatorFromTransition() {
              const t2 = this.projection.name;
              this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.bL({ name: "mercator" });
              const i2 = t2 !== this.projection.name;
              return i2 && this._calcMatrices(), i2;
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(e2) {
              this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(e2) {
              this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(e2) {
              this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(e2) {
              this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e2) {
              void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
              const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
            }
            get cameraWorldSize() {
              const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
            }
            get pixelsPerMeter() {
              return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
              return e.bD(1, this.center.lat) * this.cameraWorldSizeForFog;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new e.P(this.width, this.height);
            }
            get bearing() {
              return e.bA(this.rotation, -180, 180);
            }
            set bearing(e2) {
              this.rotation = e2;
            }
            get rotation() {
              return -this.angle / Math.PI * 180;
            }
            set rotation(t2) {
              const i2 = -t2 * Math.PI / 180;
              this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = e.a6.mat2.create(), e.a6.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(t2) {
              const i2 = e.ap(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
            }
            get aspect() {
              return this.width / this.height;
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            get fovX() {
              return this._fov;
            }
            get fovY() {
              const e2 = 1 / Math.tan(0.5 * this.fovX);
              return 2 * Math.atan(1 / this.aspect / e2);
            }
            set fov(t2) {
              t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.bB(t2), this._calcMatrices());
            }
            get averageElevation() {
              return this._averageElevation;
            }
            set averageElevation(e2) {
              this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(e2) {
              const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
              this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e2) {
              this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
            }
            get tileCoverLift() {
              return this._tileCoverLift;
            }
            set tileCoverLift(e2) {
              this._tileCoverLift !== e2 && (this._tileCoverLift = e2);
            }
            _updateCameraOnTerrain() {
              const e2 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t2 = this.elevation && e2 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
              if (!this._elevation || e2 === Number.NEGATIVE_INFINITY && (!t2 || !this._centerAltitude))
                return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
              const i2 = this._elevation;
              t2 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i2.exaggeration() && this._centerAltitudeValidForExaggeration !== i2.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i2.exaggeration(), this._centerAltitudeValidForExaggeration = i2.exaggeration()) : (this._centerAltitude = e2 || 0, this._centerAltitudeValidForExaggeration = i2.exaggeration()), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
              void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
              if (!this._elevation)
                return 0;
              const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
              let r2 = 0, s2 = 0;
              for (let a2 = 0; a2 < i2.length; a2++) {
                const n2 = new e.P(i2[a2][0] * this.width, o2 + i2[a2][1] * (this.height - o2)), l2 = t2.pointCoordinate(n2);
                if (!l2)
                  continue;
                const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
                r2 += l2[3] * c2, s2 += c2;
              }
              return 0 === s2 ? NaN : r2 / s2;
            }
            get center() {
              return this._center;
            }
            set center(e2) {
              e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
              if (null == this._seaLevelZoom || !this._elevation)
                return;
              const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), r2 = this._mercatorZfromZoom(this._maxZoom), s2 = Math.max(o2 - i2, r2);
              this._setZoom(this._zoomFromMercatorZ(s2));
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(e2) {
              this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t2) {
              const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
              let o2;
              o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
              const r2 = e.a6.vec3.length(e.a6.vec3.sub([], this._camera.position, o2));
              return e.ap(this._zoomFromMercatorZ(r2), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t2) {
              if (!this.height)
                return;
              if (!t2.position && !t2.orientation)
                return;
              this._updateCameraState();
              let i2 = false;
              if (t2.orientation && !e.a6.quat.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
                const o2 = [t2.position.x, t2.position.y, t2.position.z];
                e.a6.vec3.exactEquals(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
              }
              i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
              this._updateCameraState();
              const t2 = this._camera.position, i2 = new Ui();
              return i2.position = new e.a5(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
            }
            _setCameraOrientation(t2) {
              if (!e.a6.quat.length(t2))
                return false;
              e.a6.quat.normalize(t2, t2);
              const i2 = e.a6.vec3.transformQuat([], [0, 0, -1], t2), o2 = e.a6.vec3.transformQuat([], [0, -1, 0], t2);
              if (o2[2] < 0)
                return false;
              const r2 = Ni(i2, o2);
              return !!r2 && (this._camera.orientation = r2, true);
            }
            _setCameraPosition(t2) {
              const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r2 = this.cameraToCenterDistance;
              t2[2] = e.ap(t2[2], r2 / o2, r2 / i2), this._camera.position = t2;
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
              return this._fov * (0.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e2) {
              return this._edgeInsets.equals(e2);
            }
            interpolatePadding(e2, t2, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e2) {
              const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
              return Math.max(0, t2);
            }
            getVisibleUnwrappedCoordinates(t2) {
              const i2 = [new e.bM(0, t2)];
              if (this.renderWorldCopies) {
                const o2 = this.pointCoordinate(new e.P(0, 0)), r2 = this.pointCoordinate(new e.P(this.width, 0)), s2 = this.pointCoordinate(new e.P(this.width, this.height)), a2 = this.pointCoordinate(new e.P(0, this.height)), n2 = Math.floor(Math.min(o2.x, r2.x, s2.x, a2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, s2.x, a2.x)), c2 = 1;
                for (let o3 = n2 - c2; o3 <= l2 + c2; o3++)
                  0 !== o3 && i2.push(new e.bM(o3, t2));
              }
              return i2;
            }
            isLODDisabled(e2) {
              return (!e2 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
            }
            extendTileCover(t2, i2, o2) {
              let r2 = [];
              const s2 = void 0 !== o2, a2 = !s2;
              if (a2 && this.zoom < i2)
                return r2;
              if (s2 && 0 === o2[0] && 0 === o2[1])
                return r2;
              const n2 = /* @__PURE__ */ new Set(), l2 = (t3, i3, o3, s3, a3) => {
                const l3 = e.c1(i3, t3, o3, s3, a3);
                n2.has(l3) || (r2.push(new e.aA(t3, i3, o3, s3, a3)), n2.add(l3));
              };
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r3 = t2[e2];
                if (a2 && r3.canonical.z !== i2)
                  continue;
                const n3 = r3.canonical, c3 = r3.overscaledZ, h2 = r3.wrap, u2 = 1 << n3.z, d2 = n3.x + 1 < u2, _2 = n3.x > 0, p2 = n3.y + 1 < u2, m2 = n3.y > 0, f2 = r3.wrap - (_2 ? 0 : 1), g2 = r3.wrap + (d2 ? 0 : 1), v2 = _2 ? n3.x - 1 : u2 - 1, x2 = d2 ? n3.x + 1 : 0;
                if (s2)
                  o2[0] < 0 ? (l2(c3, g2, n3.z, x2, n3.y), o2[1] < 0 && p2 && (l2(c3, h2, n3.z, n3.x, n3.y + 1), l2(c3, g2, n3.z, x2, n3.y + 1)), o2[1] > 0 && m2 && (l2(c3, h2, n3.z, n3.x, n3.y - 1), l2(c3, g2, n3.z, x2, n3.y - 1))) : o2[0] > 0 ? (l2(c3, f2, n3.z, v2, n3.y), o2[1] < 0 && p2 && (l2(c3, h2, n3.z, n3.x, n3.y + 1), l2(c3, f2, n3.z, v2, n3.y + 1)), o2[1] > 0 && m2 && (l2(c3, h2, n3.z, n3.x, n3.y - 1), l2(c3, f2, n3.z, v2, n3.y - 1))) : o2[1] < 0 && p2 ? l2(c3, h2, n3.z, n3.x, n3.y + 1) : m2 && l2(c3, h2, n3.z, n3.x, n3.y - 1);
                else {
                  const e3 = r3.visibleQuadrants;
                  1 & e3 && (l2(c3, f2, n3.z, v2, n3.y), m2 && (l2(c3, h2, n3.z, n3.x, n3.y - 1), l2(c3, f2, n3.z, v2, n3.y - 1))), 2 & e3 && (l2(c3, g2, n3.z, x2, n3.y), m2 && (l2(c3, h2, n3.z, n3.x, n3.y - 1), l2(c3, g2, n3.z, x2, n3.y - 1))), 4 & e3 && (l2(c3, f2, n3.z, v2, n3.y), p2 && (l2(c3, h2, n3.z, n3.x, n3.y + 1), l2(c3, f2, n3.z, v2, n3.y + 1))), 8 & e3 && (l2(c3, g2, n3.z, x2, n3.y), p2 && (l2(c3, h2, n3.z, n3.x, n3.y + 1), l2(c3, g2, n3.z, x2, n3.y + 1)));
                }
              }
              const c2 = [];
              for (const e2 of r2)
                r2.some((t3) => e2.isChildOf(t3)) || c2.push(e2);
              if (r2 = c2.filter((e2) => !t2.some((t3) => !!(e2.overscaledZ < i2 && t3.isChildOf(e2)) || e2.equals(t3) || e2.isChildOf(t3))), a2) {
                const e2 = 1 << i2, t3 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o3 = [e2 * t3.x, e2 * t3.y], s3 = 4, a3 = s3 * s3;
                r2 = r2.filter((e3) => {
                  const t4 = e3.canonical.x + 0.5 - o3[0], i3 = e3.canonical.y + 0.5 - o3[1];
                  return t4 * t4 + i3 * i3 < a3;
                });
              }
              return r2;
            }
            coveringTiles(t2) {
              let i2 = this.coveringZoomLevel(t2);
              const o2 = i2, r2 = this.elevation && this.elevation.exaggeration(), s2 = r2 && !t2.isTerrainDEM, a2 = "mercator" === this.projection.name;
              if (void 0 !== t2.minzoom && i2 < t2.minzoom)
                return [];
              void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
              const n2 = this.locationCoordinate(this.center), l2 = this.center.lat, c2 = 1 << i2, h2 = [c2 * n2.x, c2 * n2.y, 0], u2 = "globe" === this.projection.name, d2 = !u2, _2 = e.bN.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, d2), p2 = u2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), m2 = c2 * e.bD(1, this.center.lat), f2 = this._camera.position[2] / e.bD(1, this.center.lat), g2 = [c2 * p2.x, c2 * p2.y, f2 * (d2 ? 1 : m2)], v2 = u2 || r2, x2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), y2 = this.isLODDisabled(true) ? i2 : 0;
              let b2;
              if (this._elevation && t2.isTerrainDEM)
                b2 = 1e4 * this._elevation.exaggeration();
              else if (this._elevation) {
                const e2 = this._elevation.getMinMaxForVisibleTiles();
                b2 = e2 ? e2.max : this._centerAltitude;
              } else
                b2 = this._centerAltitude;
              const w2 = t2.isTerrainDEM ? -b2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T2 = this.projection.isReprojectedInTileSpace ? e.bO(this) : 1, E2 = (t3) => {
                const i3 = 1 / 4e4, o3 = new e.a5(t3.x + i3, t3.y, t3.z), r3 = new e.a5(t3.x, t3.y + i3, t3.z), s3 = t3.toLngLat(), a3 = o3.toLngLat(), n3 = r3.toLngLat(), l3 = this.locationCoordinate(s3), c3 = this.locationCoordinate(a3), h3 = this.locationCoordinate(n3), u3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), d3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
                return Math.sqrt(u3 * d3) * T2 / i3;
              }, C2 = (t3) => {
                const i3 = b2, o3 = w2;
                return { aabb: e.bR(this, c2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
              }, S2 = [];
              let I2 = [];
              const D2 = i2, R2 = t2.reparseOverscaled ? o2 : i2, A2 = (f2 - this._centerAltitude) * m2, L2 = (e2) => {
                if (!this._elevation || !e2.tileID || !a2)
                  return;
                const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
                t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = M2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
              }, P2 = (e2, t3) => {
                if (0.707 * t3 < e2)
                  return 1;
                const i3 = t3 / e2;
                return i3 / (1.4144271570014144 + (Math.pow(1.1, i3 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              }, M2 = (t3) => {
                if (t3.zoom < y2)
                  return true;
                if (t3.zoom === D2)
                  return false;
                if (null != t3.shouldSplit)
                  return t3.shouldSplit;
                const i3 = t3.aabb.distanceX(g2), r3 = t3.aabb.distanceY(g2);
                let n3 = A2, c3 = 1;
                if (u2) {
                  n3 = t3.aabb.distanceZ(g2);
                  const i4 = Math.pow(2, t3.zoom), o3 = e.aM((t3.y + 1) / i4), r4 = e.aM(t3.y / i4), s3 = Math.min(Math.max(l2, o3), r4), a3 = e.c5(s3) / e.c5(l2);
                  if (c3 = s3 === l2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, a3 / this._mercatorScaleRatio), this.zoom <= e.c2 && t3.zoom === D2 - 1 && a3 >= 0.9)
                    return true;
                } else if (s2 && (n3 = t3.aabb.distanceZ(g2) * m2), this.projection.isReprojectedInTileSpace && o2 <= 5) {
                  const i4 = Math.pow(2, t3.zoom), o3 = E2(new e.a5((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
                  c3 = o3 > 0.85 ? 1 : o3;
                }
                if (!a2) {
                  const e2 = Math.sqrt(i3 * i3 + r3 * r3 + n3 * n3);
                  let o3 = (1 << D2 - t3.zoom) * x2 * c3;
                  return o3 *= P2(Math.max(n3, A2), e2), e2 < o3;
                }
                let d3 = Number.MAX_VALUE, _3 = 0;
                const p3 = t3.aabb.getCorners(), f3 = [];
                for (const t4 of p3) {
                  e.a6.vec3.sub(f3, t4, g2), u2 || (s2 ? f3[2] *= m2 : f3[2] = A2);
                  const i4 = e.a6.vec3.dot(f3, this._camera.forward());
                  i4 < d3 && (d3 = i4, _3 = Math.abs(f3[2]));
                }
                let v3 = (1 << D2 - t3.zoom) * x2 * c3;
                if (v3 *= P2(Math.max(_3, A2), d3), d3 < v3)
                  return true;
                const b3 = t3.aabb.closestPoint(h2);
                return b3[0] === h2[0] && b3[1] === h2[1];
              };
              if (this.renderWorldCopies)
                for (let e2 = 1; e2 <= 3; e2++)
                  S2.push(C2(-e2)), S2.push(C2(e2));
              for (S2.push(C2(0)); S2.length > 0; ) {
                const o3 = S2.pop(), r3 = o3.x, n3 = o3.y;
                let l3 = o3.fullyVisible;
                const d3 = () => "globe" === this.projection.name && (0 === o3.y || o3.y === (1 << o3.zoom) - 1);
                if (!l3) {
                  let t3 = v2 ? o3.aabb.intersects(_2) : o3.aabb.intersectsFlat(_2);
                  if (0 === t3 && d3()) {
                    const i3 = new e.bP(o3.zoom, r3, n3);
                    t3 = e.bQ(this, c2, i3, true).intersects(_2);
                  }
                  if (0 === t3)
                    continue;
                  l3 = 2 === t3;
                }
                if (o3.zoom !== D2 && M2(o3))
                  for (let t3 = 0; t3 < 4; t3++) {
                    const i3 = (r3 << 1) + t3 % 2, h3 = (n3 << 1) + (t3 >> 1), d4 = { aabb: a2 ? o3.aabb.quadrant(t3) : e.bR(this, c2, o3.zoom + 1, i3, h3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: h3, wrap: o3.wrap, fullyVisible: l3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                    s2 && !u2 && (d4.tileID = new e.aA(o3.zoom + 1 === D2 ? R2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, h3), L2(d4)), S2.push(d4);
                  }
                else {
                  const s3 = o3.zoom === D2 ? R2 : o3.zoom;
                  if (t2.minzoom && t2.minzoom > s3)
                    continue;
                  let a3 = 0;
                  if (!l3) {
                    let i3 = v2 ? o3.aabb.intersectsPrecise(_2) : o3.aabb.intersectsPreciseFlat(_2);
                    if (0 === i3 && d3()) {
                      const t3 = new e.bP(o3.zoom, r3, n3);
                      i3 = e.bQ(this, c2, t3, true).intersectsPrecise(_2);
                    }
                    if (0 === i3)
                      continue;
                    if (t2.calculateQuadrantVisibility)
                      if (_2.containsPoint(o3.aabb.center))
                        a3 = 15;
                      else
                        for (let e2 = 0; e2 < 4; e2++)
                          0 !== o3.aabb.quadrant(e2).intersects(_2) && (a3 |= 1 << e2);
                  }
                  const u3 = h2[0] - (0.5 + r3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), p3 = h2[1] - 0.5 - n3, m3 = o3.tileID ? o3.tileID : new e.aA(s3, o3.wrap, o3.zoom, r3, n3);
                  t2.calculateQuadrantVisibility && (m3.visibleQuadrants = a3), I2.push({ tileID: m3, distanceSq: u3 * u3 + p3 * p3 });
                }
              }
              if (this.fogCullDistSq) {
                const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
                I2 = I2.filter((r3) => {
                  const s3 = [0, 0, 0, 1], a3 = [e.ab, e.ab, 0, 1], n3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
                  e.a6.vec4.transformMat4(s3, s3, n3), e.a6.vec4.transformMat4(a3, a3, n3);
                  const l3 = e.a6.vec4.min([], s3, a3), c3 = e.a6.vec4.max([], s3, a3), h3 = e.bS(l3, c3);
                  if (0 === h3)
                    return true;
                  let u3 = false;
                  const d3 = this._elevation;
                  if (d3 && h3 > i3 && 0 !== o3) {
                    const i4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                    let s4;
                    t2.isTerrainDEM || (s4 = d3.getMinMaxForTile(r3.tileID)), s4 || (s4 = { min: w2, max: b2 });
                    const a4 = e.c3(this.rotation), n4 = [a4[0] * e.ab, a4[1] * e.ab, s4.max];
                    e.a6.vec3.transformMat4(n4, n4, i4), u3 = (1 - n4[1]) * this.height * 0.5 < o3;
                  }
                  return h3 < i3 || u3;
                });
              }
              return I2.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
            }
            resize(e2, t2) {
              this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(e2) {
              return Math.pow(2, e2);
            }
            scaleZoom(e2) {
              return Math.log(e2) / Math.LN2;
            }
            project(t2) {
              const i2 = e.ap(t2.lat, -e.bT, e.bT), o2 = this.projection.project(t2.lng, i2);
              return new e.P(o2.x * this.worldSize, o2.y * this.worldSize);
            }
            unproject(e2) {
              return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
            }
            get point() {
              return this.project(this.center);
            }
            get pointMerc() {
              return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
              return this.pixelsPerMeter / e.bD(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t2, i2) {
              let o2, r2;
              const s2 = this.centerPoint;
              if ("globe" === this.projection.name) {
                const e2 = this.worldSize;
                o2 = (i2.x - s2.x) / e2, r2 = (i2.y - s2.y) / e2;
              } else {
                const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(s2);
                o2 = e2.x - t3.x, r2 = e2.y - t3.y;
              }
              const a2 = this.locationCoordinate(t2);
              this.setLocation(new e.a5(a2.x - o2, a2.y - r2));
            }
            setLocation(e2) {
              this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e2) {
              return this.projection.locationPoint(this, e2);
            }
            locationPoint3D(e2) {
              return this.projection.locationPoint(this, e2, true);
            }
            pointLocation(e2) {
              return this.coordinateLocation(this.pointCoordinate(e2));
            }
            pointLocation3D(e2) {
              return this.coordinateLocation(this.pointCoordinate3D(e2));
            }
            locationCoordinate(t2, i2) {
              const o2 = i2 ? e.bD(i2, t2.lat) : void 0, r2 = this.projection.project(t2.lng, t2.lat);
              return new e.a5(r2.x, r2.y, o2);
            }
            coordinateLocation(e2) {
              return this.projection.unproject(e2.x, e2.y);
            }
            pointRayIntersection(t2, i2) {
              const o2 = null != i2 ? i2 : this._centerAltitude, r2 = [t2.x, t2.y, 0, 1], s2 = [t2.x, t2.y, 1, 1];
              e.a6.vec4.transformMat4(r2, r2, this.pixelMatrixInverse), e.a6.vec4.transformMat4(s2, s2, this.pixelMatrixInverse);
              const a2 = s2[3];
              e.a6.vec4.scale(r2, r2, 1 / r2[3]), e.a6.vec4.scale(s2, s2, 1 / a2);
              const n2 = r2[2], l2 = s2[2];
              return { p0: r2, p1: s2, t: n2 === l2 ? 0 : (o2 - n2) / (l2 - n2) };
            }
            screenPointToMercatorRay(t2) {
              const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
              return e.a6.vec4.transformMat4(i2, i2, this.pixelMatrixInverse), e.a6.vec4.transformMat4(o2, o2, this.pixelMatrixInverse), e.a6.vec4.scale(i2, i2, 1 / i2[3]), e.a6.vec4.scale(o2, o2, 1 / o2[3]), i2[2] = e.bD(i2[2], this._center.lat) * this.worldSize, o2[2] = e.bD(o2[2], this._center.lat) * this.worldSize, e.a6.vec4.scale(i2, i2, 1 / this.worldSize), e.a6.vec4.scale(o2, o2, 1 / this.worldSize), new e.aj([i2[0], i2[1], i2[2]], e.a6.vec3.normalize([], e.a6.vec3.sub([], o2, i2)));
            }
            rayIntersectionCoordinate(t2) {
              const { p0: i2, p1: o2, t: r2 } = t2, s2 = e.bD(i2[2], this._center.lat), a2 = e.bD(o2[2], this._center.lat);
              return new e.a5(e.aa(i2[0], o2[0], r2) / this.worldSize, e.aa(i2[1], o2[1], r2) / this.worldSize, e.aa(s2, a2, r2));
            }
            pointCoordinate(e2, t2 = this._centerAltitude) {
              return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
            }
            pointCoordinate3D(t2) {
              if (!this.elevation)
                return this.pointCoordinate(t2);
              let i2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
              if (i2)
                return new e.a5(i2[0], i2[1], i2[2]);
              let o2 = 0, r2 = this.horizonLineFromTop();
              if (t2.y > r2)
                return this.pointCoordinate(t2);
              const s2 = 0.02 * r2, a2 = t2.clone();
              for (let t3 = 0; t3 < 10 && r2 - o2 > s2; t3++) {
                a2.y = e.aa(o2, r2, 0.66);
                const t4 = this.projection.pointCoordinate3D(this, a2.x, a2.y);
                t4 ? (r2 = a2.y, i2 = t4) : o2 = a2.y;
              }
              return i2 ? new e.a5(i2[0], i2[1], i2[2]) : this.pointCoordinate(t2);
            }
            isPointAboveHorizon(e2) {
              return this.projection.isPointAboveHorizon(this, e2);
            }
            isPointOnSurface(t2) {
              if (t2.y < 0 || t2.y > this.height || t2.x < 0 || t2.x > this.width)
                return false;
              if (this.elevation || this.zoom >= e.bU)
                return !this.isPointAboveHorizon(t2);
              const i2 = this.pointCoordinate(t2);
              return i2.y >= 0 && i2.y <= 1;
            }
            _coordinatePoint(t2, i2) {
              const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
              return e.a6.vec4.transformMat4(r2, r2, this.pixelMatrix), r2[3] > 0 ? new e.P(r2[0] / r2[3], r2[1] / r2[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
              const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r2 = this.width - this._edgeInsets.right, s2 = this.pointLocation3D(new e.P(i2, t2)), a2 = this.pointLocation3D(new e.P(r2, t2)), n2 = this.pointLocation3D(new e.P(r2, o2)), l2 = this.pointLocation3D(new e.P(i2, o2));
              let c2 = Math.min(s2.lng, a2.lng, n2.lng, l2.lng), h2 = Math.max(s2.lng, a2.lng, n2.lng, l2.lng), u2 = Math.min(s2.lat, a2.lat, n2.lat, l2.lat), d2 = Math.max(s2.lat, a2.lat, n2.lat, l2.lat);
              const _2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = "globe" === this.projection.name ? 1 : 4, m2 = (t3, i3, o3, r3, s3) => {
                const a3 = (t3 + o3) / 2, n3 = (i3 + r3) / 2, l3 = new e.P(a3, n3), { lng: f2, lat: g2 } = this.pointLocation3D(l3), v2 = Math.max(0, c2 - f2, u2 - g2, f2 - h2, g2 - d2);
                c2 = Math.min(c2, f2), h2 = Math.max(h2, f2), u2 = Math.min(u2, g2), d2 = Math.max(d2, g2), (s3 < p2 || v2 > _2) && (m2(t3, i3, a3, n3, s3 + 1), m2(a3, n3, o3, r3, s3 + 1));
              };
              if (m2(i2, t2, r2, t2, 1), m2(r2, t2, r2, o2, 1), m2(r2, o2, i2, o2, 1), m2(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
                const [t3, i3] = e.bV(this);
                t3 ? (d2 = 90, h2 = 180, c2 = -180) : i3 && (u2 = -90, h2 = 180, c2 = -180);
              }
              return new e.as(new e.bK(c2, u2), new e.bK(h2, d2));
            }
            _getBoundsRectangular(t2, i2) {
              const { top: o2, left: r2 } = this._edgeInsets, s2 = this.height - this._edgeInsets.bottom, a2 = this.width - this._edgeInsets.right, n2 = new e.P(r2, o2), l2 = new e.P(a2, o2), c2 = new e.P(a2, s2), h2 = new e.P(r2, s2);
              let u2 = this.pointCoordinate(n2, t2), d2 = this.pointCoordinate(l2, t2);
              const _2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h2, i2), m2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
              return u2.y > 1 && d2.y >= 0 ? u2 = new e.a5((1 - p2.y) / m2(p2, u2) + p2.x, 1) : u2.y < 0 && d2.y <= 1 && (u2 = new e.a5(-p2.y / m2(p2, u2) + p2.x, 0)), d2.y > 1 && u2.y >= 0 ? d2 = new e.a5((1 - _2.y) / m2(_2, d2) + _2.x, 1) : d2.y < 0 && u2.y <= 1 && (d2 = new e.a5(-_2.y / m2(_2, d2) + _2.x, 0)), new e.as().extend(this.coordinateLocation(u2)).extend(this.coordinateLocation(d2)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(_2));
            }
            _getBoundsRectangularTerrain() {
              const e2 = this.elevation;
              if (!e2.visibleDemTiles.length || e2.isUsingMockSource())
                return this._getBoundsRectangular(0, 0);
              const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
                if (t3.dem) {
                  const i2 = t3.dem.tree;
                  e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
                }
                return e3;
              }, { min: Number.MAX_VALUE, max: 0 });
              return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
            }
            getBounds() {
              return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e2 = true) {
              const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
              return e2 ? Math.max(0, i2) : i2;
            }
            getMaxBounds() {
              return this.maxBounds;
            }
            setMaxBounds(t2) {
              this.maxBounds = t2, this.minLat = -e.bT, this.maxLat = e.bT, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.am(this.minLng) * this.tileSize, this.worldMaxX = e.am(this.maxLng) * this.tileSize, this.worldMinY = e.at(this.maxLat) * this.tileSize, this.worldMaxY = e.at(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e2, t2) {
              return this.projection.createTileMatrix(this, t2, e2);
            }
            calculateDistanceTileData(t2) {
              const i2 = t2.key, o2 = this._distanceTileDataCache;
              if (o2[i2])
                return o2[i2];
              const r2 = t2.canonical, s2 = 1 / this.height, a2 = this.cameraWorldSize, n2 = a2 / this.zoomScale(r2.z), l2 = (r2.x + Math.pow(2, r2.z) * t2.wrap) * n2, c2 = r2.y * n2, h2 = this.point;
              h2.x *= a2 / this.worldSize, h2.y *= a2 / this.worldSize;
              const u2 = this.angle, d2 = Math.sin(-u2), _2 = -Math.cos(-u2);
              return o2[i2] = { bearing: [d2, _2], center: [(h2.x - l2) * s2, (h2.y - c2) * s2], scale: n2 / e.ab * s2 }, o2[i2];
            }
            calculateFogTileMatrix(t2) {
              const i2 = t2.key, o2 = this._fogTileMatrixCache;
              if (o2[i2])
                return o2[i2];
              const r2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
              return e.a6.mat4.multiply(r2, this.worldToFogMatrix, r2), o2[i2] = new Float32Array(r2), o2[i2];
            }
            calculateProjMatrix(t2, i2 = false, o2 = false) {
              const r2 = t2.key;
              let s2;
              if (s2 = o2 ? this._expandedProjMatrixCache : i2 ? this._alignedProjMatrixCache : this._projMatrixCache, s2[r2])
                return s2[r2];
              const a2 = this.calculatePosMatrix(t2, this.worldSize);
              let n2;
              return n2 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o2 ? this.expandedFarZProjMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, e.a6.mat4.multiply(a2, n2, a2), s2[r2] = new Float32Array(a2), s2[r2];
            }
            calculatePixelsToTileUnitsMatrix(t2) {
              const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
              if (o2[i2])
                return o2[i2];
              const r2 = e.bW(t2, this);
              return o2[i2] = r2, o2[i2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
              if ("globe" === this.projection.name) {
                const t2 = 1 / this.worldSize, i2 = e.a6.mat4.fromScaling([], [t2, t2, t2]);
                return e.a6.mat4.multiply(i2, i2, this.globeMatrix), i2;
              }
            }
            recenterOnTerrain() {
              if (!this._elevation || "globe" === this.projection.name)
                return;
              const t2 = this._elevation;
              this._updateCameraState();
              const i2 = e.bD(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r2 = this._camera.forward(), s2 = e.bD(1, this._center.lat);
              o2[2] /= s2, r2[2] /= s2, e.a6.vec3.normalize(r2, r2);
              const a2 = t2.raycast(o2, r2, t2.exaggeration());
              if (a2) {
                const t3 = e.a6.vec3.scaleAndAdd([], o2, r2, a2), i3 = new e.a5(t3[0], t3[1], e.bD(t3[2], e.aM(t3[1]))), n2 = (i3.z + e.a6.vec3.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * s2])) * this._pixelsPerMercatorPixel;
                this._seaLevelZoom = this._zoomFromMercatorZ(n2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
              }
            }
            _constrainCamera(t2 = false) {
              if (!this._elevation)
                return;
              const i2 = this._elevation, o2 = e.bD(1, this._center.lat) * this.worldSize, r2 = this._computeCameraPosition(o2), s2 = i2.getAtPointOrZero(new e.a5(...r2)), a2 = this.pixelsPerMeter / this.worldSize * s2, n2 = this._minimumHeightOverTerrain(), l2 = r2[2] - a2;
              if (l2 <= n2)
                if (l2 < 0 || t2) {
                  const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r2[0], r2[1], t3.z - r2[2]], o3 = e.a6.vec3.length(i3);
                  i3[2] -= (n2 - l2) / this._pixelsPerMercatorPixel;
                  const s3 = e.a6.vec3.length(i3);
                  if (0 === s3)
                    return;
                  e.a6.vec3.scale(i3, i3, o3 / s3 * this._pixelsPerMercatorPixel), this._camera.position = [r2[0], r2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
                } else
                  this._isCameraConstrained = true;
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
              if (this.projection.isReprojectedInTileSpace || t2) {
                const i3 = this.center;
                return i3.lat = e.ap(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.ap(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
              }
              const i2 = this._unmodified, { x: o2, y: r2 } = this.point;
              let s2 = 0, a2 = o2, n2 = r2;
              const l2 = this.width / 2, c2 = this.height / 2, h2 = this.worldMinY * this.scale, u2 = this.worldMaxY * this.scale;
              if (r2 - c2 < h2 && (n2 = h2 + c2), r2 + c2 > u2 && (n2 = u2 - c2), u2 - h2 < this.height && (s2 = Math.max(s2, this.height / (u2 - h2)), n2 = (u2 + h2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
                a2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, a2 - l2 < e2 && (a2 = e2 + l2), a2 + l2 > t3 && (a2 = t3 - l2), t3 - e2 < this.width && (s2 = Math.max(s2, this.width / (t3 - e2)), a2 = (t3 + e2) / 2);
              }
              a2 === o2 && n2 === r2 || (this.center = this.unproject(new e.P(a2, n2))), s2 && (this.zoom += this.scaleZoom(s2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
            }
            _minZoomForBounds() {
              let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
              return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
            }
            _maxCameraBoundsDistance() {
              return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const t2 = this.centerOffset, i2 = "globe" === this.projection.name, o2 = this.pixelsPerMeter;
              "globe" === this.projection.name && (this._mercatorScaleRatio = e.bD(1, this.center.lat) / e.bD(1, e.c4));
              const r2 = e.bX(this.projection, this.zoom, this.width, this.height, 1024);
              this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
              const s2 = "meters" === this.projection.zAxisUnit ? o2 : 1, a2 = this._camera.getWorldToCamera(this.worldSize, s2);
              let n2;
              const l2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
              if (l2[8] = 2 * -t2.x / this.width, l2[9] = 2 * t2.y / this.height, this.isOrthographic) {
                let e2 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), i3 = e2 * this.aspect, o3 = -i3, r3 = -e2;
                i3 -= t2.x, o3 -= t2.x, e2 += t2.y, r3 += t2.y, n2 = this._camera.getCameraToClipOrthographic(o3, i3, r3, e2, this._nearZ, this._farZ), ((e3, t3, i4, o4) => {
                  for (let r4 = 0; r4 < 16; r4++)
                    e3[r4] = qi(t3[r4], i4[r4], o4);
                })(n2, n2, l2, Zi(this.pitch >= 15 ? 1 : this.pitch / 15));
              } else
                n2 = l2;
              const c2 = e.a6.mat4.mul([], l2, a2);
              let h2 = e.a6.mat4.mul([], n2, a2);
              if (this.projection.isReprojectedInTileSpace) {
                const t3 = this.locationCoordinate(this.center), i3 = e.a6.mat4.identity([]);
                e.a6.mat4.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.a6.mat4.multiply(i3, i3, e.bY(this)), e.a6.mat4.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.a6.mat4.multiply(h2, h2, i3), e.a6.mat4.multiply(c2, c2, i3), this.inverseAdjustmentMatrix = e.bZ(this);
              } else
                this.inverseAdjustmentMatrix = [1, 0, 0, 1];
              if (this.mercatorMatrix = e.a6.mat4.scale([], h2, [this.worldSize, this.worldSize, this.worldSize / s2, 1]), this.projMatrix = h2, this.invProjMatrix = e.a6.mat4.invert(new Float64Array(16), this.projMatrix), i2) {
                const i3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                i3[8] = 2 * -t2.x / this.width, i3[9] = 2 * t2.y / this.height, this.expandedFarZProjMatrix = e.a6.mat4.mul([], i3, a2);
              } else
                this.expandedFarZProjMatrix = this.projMatrix;
              const u2 = e.a6.mat4.invert([], n2);
              this.frustumCorners = e.b_.fromInvProjectionMatrix(u2, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.bN.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i2);
              const d2 = new Float32Array(16);
              e.a6.mat4.identity(d2), e.a6.mat4.scale(d2, d2, [1, -1, 1]), e.a6.mat4.rotateX(d2, d2, this._pitch), e.a6.mat4.rotateZ(d2, d2, this.angle);
              const _2 = e.a6.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
              this.starsProjMatrix = e.a6.mat4.clone(_2);
              const p2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
              _2[8] = 2 * -t2.x / this.width, _2[9] = 2 * (t2.y + p2) / this.height, this.skyboxMatrix = e.a6.mat4.multiply(d2, _2, d2);
              const m2 = this.point, f2 = m2.x, g2 = m2.y, v2 = this.width % 2 / 2, x2 = this.height % 2 / 2, y2 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = f2 - Math.round(f2) + y2 * v2 + b2 * x2, T2 = g2 - Math.round(g2) + y2 * x2 + b2 * v2, E2 = new Float64Array(h2);
              if (e.a6.mat4.translate(E2, E2, [w2 > 0.5 ? w2 - 1 : w2, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = E2, h2 = e.a6.mat4.create(), e.a6.mat4.scale(h2, h2, [this.width / 2, -this.height / 2, 1]), e.a6.mat4.translate(h2, h2, [1, -1, 0]), this.labelPlaneMatrix = h2, h2 = e.a6.mat4.create(), e.a6.mat4.scale(h2, h2, [1, -1, 1]), e.a6.mat4.translate(h2, h2, [-1, -1, 0]), e.a6.mat4.scale(h2, h2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h2, this.pixelMatrix = e.a6.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, c2), this._calcFogMatrices(), this._distanceTileDataCache = {}, h2 = e.a6.mat4.invert(new Float64Array(16), this.pixelMatrix), !h2)
                throw new Error("failed to invert matrix");
              if (this.pixelMatrixInverse = h2, "globe" === this.projection.name || this.mercatorFromTransition) {
                this.globeMatrix = e.b$(this);
                const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                this.globeCenterInViewSpace = e.a6.vec3.transformMat4(t3, t3, a2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
              } else
                this.globeMatrix = h2;
              this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
            }
            _calcFogMatrices() {
              this._fogTileMatrixCache = {};
              const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r2 = 1 / this.height / this._pixelsPerMercatorPixel, s2 = [t2, t2, i2];
              e.a6.vec3.scale(s2, s2, r2), e.a6.vec3.scale(o2, o2, -1), e.a6.vec3.multiply(o2, o2, s2);
              const a2 = e.a6.mat4.create();
              e.a6.mat4.translate(a2, a2, o2), e.a6.mat4.scale(a2, a2, s2), this.mercatorFogMatrix = a2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r2);
            }
            _computeCameraPosition(e2) {
              const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
              return [o2.x / this.worldSize - i2[0] * r2, o2.y / this.worldSize - i2[1] * r2, e2 / this.worldSize * this._centerAltitude - i2[2] * r2];
            }
            _updateCameraState() {
              this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t2) {
              const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r2 = t2[2];
              let s2 = 1;
              this.projection.wrap && (this.center = this.center.wrap()), r2 > 0 && (s2 = Math.min((i2 - o2) / r2, 1)), this._camera.position = e.a6.vec3.scaleAndAdd([], this._camera.position, t2, s2), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
              const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r2 } = this._camera.getPitchBearing(), s2 = e.bD(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, a2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.bB(this._maxPitch)), n2 = Math.max((t2[2] - s2) / Math.cos(o2), a2), l2 = this._zoomFromMercatorZ(n2);
              e.a6.vec3.scaleAndAdd(t2, t2, i2, n2), this._pitch = e.ap(o2, e.bB(this.minPitch), e.bB(this.maxPitch)), this.angle = e.bA(r2, -Math.PI, Math.PI), this._setZoom(e.ap(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.a5(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e2) {
              return Math.pow(2, e2) * this.tileSize;
            }
            _mercatorZfromZoom(e2) {
              return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
            }
            _minimumHeightOverTerrain() {
              const e2 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
              return this._mercatorZfromZoom(e2);
            }
            _zoomFromMercatorZ(e2) {
              return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t2) {
              let i2 = 0, o2 = e.bU, r2 = 0, s2 = 1 / 0;
              for (; o2 - i2 > 1e-6 && o2 > i2; ) {
                const e2 = i2 + 0.5 * (o2 - i2), a2 = this.tileSize * Math.pow(2, e2), n2 = this.getCameraToCenterDistance(this.projection, e2, a2), l2 = this.scaleZoom(n2 / (t2 * this.tileSize)), c2 = Math.abs(e2 - l2);
                c2 < s2 && (s2 = c2, r2 = e2), e2 < l2 ? i2 = e2 : o2 = e2;
              }
              return r2;
            }
            _terrainEnabled() {
              return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t2, i2) {
              const o2 = Math.min(t2.x, i2.x), r2 = Math.max(t2.x, i2.x), s2 = Math.min(t2.y, i2.y), a2 = Math.max(t2.y, i2.y);
              if (s2 < this.horizonLineFromTop(false))
                return true;
              if ("mercator" !== this.projection.name)
                return false;
              const n2 = [new e.P(o2, s2), new e.P(r2, a2), new e.P(o2, a2), new e.P(r2, s2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
              for (const e2 of n2) {
                const t3 = this.pointRayIntersection(e2);
                if (t3.t < 0)
                  return true;
                const i3 = this.rayIntersectionCoordinate(t3);
                if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1)
                  return true;
              }
              return false;
            }
            isHorizonVisible() {
              return this.pitch + e.c0(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
            }
            zoomDeltaToMovement(t2, i2) {
              const o2 = e.a6.vec3.length(e.a6.vec3.sub([], this._camera.position, t2)), r2 = this._zoomFromMercatorZ(o2) + i2;
              return o2 - this._mercatorZfromZoom(r2);
            }
            getCameraPoint() {
              if ("globe" === this.projection.name) {
                const t2 = function([t3, i2, o2], r2) {
                  const s2 = [t3, i2, o2, 1];
                  e.a6.vec4.transformMat4(s2, s2, r2);
                  const a2 = s2[3] = Math.max(s2[3], 1e-6);
                  return s2[0] /= a2, s2[1] /= a2, s2[2] /= a2, s2;
                }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                return new e.P(t2[0], t2[1]);
              }
              {
                const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                return this.centerPoint.add(new e.P(0, t2));
              }
            }
            getCameraToCenterDistance(t2, i2 = this.zoom, o2 = this.worldSize) {
              const r2 = e.bX(t2, i2, this.width, this.height, 1024), s2 = t2.pixelSpaceConversion(this.center.lat, o2, r2);
              let a2 = 0.5 / Math.tan(0.5 * this._fov) * this.height * s2;
              return this.isOrthographic && (a2 = qi(1, a2, Zi(this.pitch >= 15 ? 1 : this.pitch / 15))), a2;
            }
            getWorldToCameraMatrix() {
              const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
              return "globe" === this.projection.name && e.a6.mat4.multiply(t2, t2, this.globeMatrix), t2;
            }
            getFrustum(t2) {
              return e.bN.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t2, "meters" === this.projection.zAxisUnit);
            }
          }
          const Wi = (t2, i2) => {
            if (i2 > 0 && t2.terrain && e.w("Cutoff is currently disabled on terrain"), i2 <= 0 || t2.terrain)
              return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
            const o2 = t2.transform, r2 = Math.max(Math.abs(o2._zoom - (t2.minCutoffZoom - 1)), 1), s2 = o2.isLODDisabled(false) ? e.a7(60, 45, o2.pitch) : e.a7(30, 15, o2.pitch), a2 = o2._farZ - o2._nearZ, n2 = i2 * o2.height, l2 = ((1 - (c2 = s2)) * o2.cameraToCenterDistance + c2 * (o2._farZ + n2)) * r2;
            var c2;
            return { shouldRenderCutoff: s2 < 1, uniformValues: { u_cutoff_params: [o2._nearZ, o2._farZ, (l2 - o2._nearZ) / a2, (l2 - n2 - o2._nearZ) / a2] } };
          }, $i = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
          class Xi {
            constructor(e2, t2) {
              this.aabb = e2, this.lastCascade = t2;
            }
          }
          class Yi {
            add(e2, t2) {
              const i2 = this.receivers[e2.key];
              void 0 !== i2 ? (i2.aabb.min[0] = Math.min(i2.aabb.min[0], t2.min[0]), i2.aabb.min[1] = Math.min(i2.aabb.min[1], t2.min[1]), i2.aabb.min[2] = Math.min(i2.aabb.min[2], t2.min[2]), i2.aabb.max[0] = Math.max(i2.aabb.max[0], t2.max[0]), i2.aabb.max[1] = Math.max(i2.aabb.max[1], t2.max[1]), i2.aabb.max[2] = Math.max(i2.aabb.max[2], t2.max[2])) : this.receivers[e2.key] = new Xi(t2, null);
            }
            clear() {
              this.receivers = {};
            }
            get(e2) {
              return this.receivers[e2.key];
            }
            computeRequiredCascades(t2, i2, o2) {
              const r2 = e.c9.fromPoints(t2.points);
              let s2 = 0;
              for (const t3 in this.receivers) {
                const a2 = this.receivers[t3];
                if (!a2)
                  continue;
                if (!r2.intersectsAabb(a2.aabb))
                  continue;
                a2.aabb.min = r2.closestPoint(a2.aabb.min), a2.aabb.max = r2.closestPoint(a2.aabb.max);
                const n2 = a2.aabb.getCorners();
                for (let t4 = 0; t4 < o2.length; t4++) {
                  let r3 = true;
                  for (const s3 of n2) {
                    const a3 = [s3[0] * i2, s3[1] * i2, s3[2]];
                    if (e.a6.vec3.transformMat4(a3, a3, o2[t4].matrix), a3[0] < -1 || a3[0] > 1 || a3[1] < -1 || a3[1] > 1) {
                      r3 = false;
                      break;
                    }
                  }
                  if (a2.lastCascade = t4, s2 = Math.max(s2, t4), r3)
                    break;
                }
              }
              return s2 + 1;
            }
          }
          class Ki {
            constructor(e2) {
              this.painter = e2, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new Yi(), this._depthMode = new Li(e2.context.gl.LEQUAL, Li.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false, e2.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
                this.painter.style.map.triggerRepaint();
              }), e2.tp.registerParameter($i, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), e2.tp.registerParameter($i, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), e2.tp.registerParameter($i, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), e2.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: true, label: "numCascadesToRender" });
            }
            destroy() {
              for (const e2 of this._cascades)
                e2.texture.destroy(), e2.framebuffer.destroy();
              this._cascades = [];
            }
            updateShadowParameters(t2, i2) {
              const o2 = this.painter;
              if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i2 || !i2.properties)
                return;
              const r2 = i2.properties.get("shadow-intensity");
              if (!i2.shadowsEnabled() || r2 <= 0)
                return;
              if (this._shadowLayerCount = o2.style.order.reduce((e2, i3) => {
                const r3 = o2.style._mergedLayers[i3];
                return e2 + (r3.hasShadowPass() && !r3.isHidden(t2.zoom) ? 1 : 0);
              }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled)
                return;
              const s2 = o2.context, a2 = $i.shadowMapResolution, n2 = $i.shadowMapResolution;
              if (0 === this._cascades.length || $i.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                this._cascades = [];
                for (let t3 = 0; t3 < $i.cascadeCount; ++t3) {
                  const t4 = o2._shadowMapDebug, i3 = s2.gl, r3 = s2.createFramebuffer(a2, n2, t4, "texture"), l3 = new e.T(s2, { width: a2, height: n2, data: null }, i3.DEPTH_COMPONENT16);
                  if (r3.depthAttachment.set(l3.texture), t4) {
                    const t5 = new e.T(s2, { width: a2, height: n2, data: null }, i3.RGBA8);
                    r3.colorAttachment.set(t5.texture);
                  }
                  this._cascades.push({ framebuffer: r3, texture: l3, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e.bN(), scale: 0 });
                }
              }
              this.shadowDirection = Qi(i2);
              let l2 = 0;
              if (t2.elevation) {
                const e2 = t2.elevation, i3 = [1e4, -1e4];
                e2.visibleDemTiles.filter((e3) => e3.dem).forEach((e3) => {
                  const t3 = e3.dem.tree;
                  i3[0] = Math.min(i3[0], t3.minimums[0]), i3[1] = Math.max(i3[1], t3.maximums[0]);
                }), 1e4 !== i3[0] && (l2 = (i3[1] - i3[0]) * e2.exaggeration());
              }
              const c2 = 1.5 * t2.cameraToCenterDistance, h2 = 3 * c2, u2 = new Float64Array(16);
              for (let i3 = 0; i3 < this._cascades.length; ++i3) {
                const o3 = this._cascades[i3];
                let r3 = t2.height / 50, s3 = 1;
                1 === $i.cascadeCount ? s3 = h2 : 0 === i3 ? s3 = c2 : (r3 = c2, s3 = h2);
                const [a3, n3] = to(t2, this.shadowDirection, r3, s3, $i.shadowMapResolution, l2);
                o3.scale = t2.scale, o3.matrix = a3, o3.boundingSphereRadius = n3, e.a6.mat4.invert(u2, o3.matrix), o3.frustum = e.bN.fromInvProjectionMatrix(u2, 1, 0, true), o3.far = s3;
              }
              const d2 = this._cascades.length - 1;
              this._uniformValues.u_fade_range = [0.75 * this._cascades[d2].far, this._cascades[d2].far], this._uniformValues.u_shadow_intensity = r2, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / $i.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = $i.shadowMapResolution, this._uniformValues.u_shadowmap_0 = ji.ShadowMap0, this._uniformValues.u_shadowmap_1 = ji.ShadowMap0 + 1, this._groundShadowTiles = o2.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
              const _2 = o2.transform.elevation;
              for (const e2 of this._groundShadowTiles) {
                let t3 = { min: 0, max: 0 };
                if (_2) {
                  const i3 = _2.getMinMaxForTile(e2);
                  i3 && (t3 = i3);
                }
                this.addShadowReceiver(e2.toUnwrapped(), t3.min, t3.max);
              }
            }
            get enabled() {
              return this._enabled && !this._forceDisable;
            }
            set enabled(e2) {
              this._enabled = e2;
            }
            drawShadowPass(t2, i2) {
              if (!this.enabled)
                return;
              const o2 = this.painter, r2 = o2.context;
              this._numCascadesToRender = this._receivers.computeRequiredCascades(o2.transform.getFrustum(0), o2.transform.worldSize, this._cascades), r2.viewport.set([0, 0, $i.shadowMapResolution, $i.shadowMapResolution]);
              for (let s2 = 0; s2 < this._numCascadesToRender; ++s2) {
                o2.currentShadowCascade = s2, r2.bindFramebuffer.set(this._cascades[s2].framebuffer.framebuffer), r2.clear({ color: e.bz.white, depth: 1 });
                for (const e2 of t2.order) {
                  const r3 = t2._mergedLayers[e2];
                  if (!r3.hasShadowPass() || r3.isHidden(o2.transform.zoom))
                    continue;
                  const s3 = t2.getLayerSourceCache(r3), a2 = s3 ? i2[s3.id] : void 0;
                  ("model" === r3.type || a2 && a2.length) && o2.renderLayer(o2, s3, r3, a2);
                }
              }
              o2.currentShadowCascade = 0;
            }
            drawGroundShadows() {
              if (!this.enabled)
                return;
              const e2 = this.painter, t2 = e2.style, i2 = e2.context, o2 = t2.directionalLight, r2 = t2.ambientLight;
              if (!o2 || !r2)
                return;
              const s2 = [], a2 = Wi(e2, e2.longestCutoffRange);
              a2.shouldRenderCutoff && s2.push("RENDER_CUTOFF");
              const n2 = eo(t2, o2, r2), l2 = new Li(i2.gl.LEQUAL, Li.ReadOnly, e2.depthRangeFor3D);
              for (const t3 of this._groundShadowTiles) {
                const o3 = t3.toUnwrapped(), r3 = e2.isTileAffectedByFog(t3), c2 = e2.getOrCreateProgram("groundShadow", { defines: s2, overrideFog: r3 });
                this.setupShadows(o3, c2), e2.uploadCommonUniforms(i2, c2, o3, null, a2);
                const h2 = { u_matrix: e2.transform.calculateProjMatrix(o3), u_ground_shadow_factor: n2 };
                c2.draw(e2, i2.gl.TRIANGLES, l2, Mi.disabled, Ai.multiply, Fi.disabled, h2, "ground_shadow", e2.tileExtentBuffer, e2.quadTriangleIndexBuffer, e2.tileExtentSegments, {}, e2.transform.zoom, null, null);
              }
            }
            getShadowPassColorMode() {
              return this.painter._shadowMapDebug ? Ai.unblended : Ai.disabled;
            }
            getShadowPassDepthMode() {
              return this._depthMode;
            }
            getShadowCastingLayerCount() {
              return this._shadowLayerCount;
            }
            calculateShadowPassMatrixFromTile(t2) {
              const i2 = this.painter.transform, o2 = i2.calculatePosMatrix(t2, i2.worldSize);
              return e.a6.mat4.multiply(o2, this._cascades[this.painter.currentShadowCascade].matrix, o2), Float32Array.from(o2);
            }
            calculateShadowPassMatrixFromMatrix(t2) {
              return e.a6.mat4.multiply(t2, this._cascades[this.painter.currentShadowCascade].matrix, t2), Float32Array.from(t2);
            }
            setupShadows(t2, i2, o2, r2 = 0) {
              if (!this.enabled)
                return;
              const s2 = this.painter.transform, a2 = this.painter.context, n2 = a2.gl, l2 = this._uniformValues, c2 = new Float64Array(16), h2 = s2.calculatePosMatrix(t2, s2.worldSize);
              for (let t3 = 0; t3 < this._cascades.length; t3++)
                e.a6.mat4.multiply(c2, this._cascades[t3].matrix, h2), l2[0 === t3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c2), a2.activeTexture.set(n2.TEXTURE0 + ji.ShadowMap0 + t3), this._cascades[t3].texture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE);
              if (this.useNormalOffset = !!o2, this.useNormalOffset) {
                const i3 = e.c8(t2.canonical), a3 = 2 / s2.tileSize * e.ab / $i.shadowMapResolution, n3 = a3 * this._cascades[0].boundingSphereRadius, c3 = a3 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h3 = ("vector-tile" === o2 ? 1 : 3) / Math.pow(2, r2 - t2.canonical.z - (1 - s2.zoom + Math.floor(s2.zoom)));
                l2.u_shadow_normal_offset = [i3, n3 * h3, c3 * h3], l2.u_shadow_bias = [6e-5, 12e-4, 0.012];
              } else
                l2.u_shadow_bias = [36e-5, 12e-4, 0.012];
              i2.setShadowUniformValues(a2, l2);
            }
            setupShadowsFromMatrix(t2, i2, o2 = false) {
              if (!this.enabled)
                return;
              const r2 = this.painter.context, s2 = r2.gl, a2 = this._uniformValues, n2 = new Float64Array(16);
              for (let i3 = 0; i3 < $i.cascadeCount; i3++)
                e.a6.mat4.multiply(n2, this._cascades[i3].matrix, t2), a2[0 === i3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(n2), r2.activeTexture.set(s2.TEXTURE0 + ji.ShadowMap0 + i3), this._cascades[i3].texture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE);
              if (this.useNormalOffset = o2, o2) {
                const e2 = $i.normalOffset;
                a2.u_shadow_normal_offset = [1, e2, e2], a2.u_shadow_bias = [6e-5, 12e-4, 0.012];
              } else
                a2.u_shadow_bias = [36e-5, 12e-4, 0.012];
              i2.setShadowUniformValues(r2, a2);
            }
            getShadowUniformValues() {
              return this._uniformValues;
            }
            getCurrentCascadeFrustum() {
              return this._cascades[this.painter.currentShadowCascade].frustum;
            }
            computeSimplifiedTileShadowVolume(t2, i2, o2, r2) {
              if (r2[2] >= 0)
                return {};
              const s2 = function(t3, i3, o3) {
                const r3 = o3 / (1 << t3.canonical.z);
                return new e.c9([t3.canonical.x * r3 + t3.wrap * o3, t3.canonical.y * r3 + t3.wrap * o3, 0], [(t3.canonical.x + 1) * r3 + t3.wrap * o3, (t3.canonical.y + 1) * r3 + t3.wrap * o3, i3]);
              }(t2, i2, o2).getCorners(), a2 = i2 / -r2[2];
              r2[0] < 0 ? (e.a6.vec3.add(s2[0], s2[0], [r2[0] * a2, 0, 0]), e.a6.vec3.add(s2[3], s2[3], [r2[0] * a2, 0, 0])) : r2[0] > 0 && (e.a6.vec3.add(s2[1], s2[1], [r2[0] * a2, 0, 0]), e.a6.vec3.add(s2[2], s2[2], [r2[0] * a2, 0, 0])), r2[1] < 0 ? (e.a6.vec3.add(s2[0], s2[0], [0, r2[1] * a2, 0]), e.a6.vec3.add(s2[1], s2[1], [0, r2[1] * a2, 0])) : r2[1] > 0 && (e.a6.vec3.add(s2[2], s2[2], [0, r2[1] * a2, 0]), e.a6.vec3.add(s2[3], s2[3], [0, r2[1] * a2, 0]));
              const n2 = {};
              return n2.vertices = s2, n2.planes = [Ji(s2[1], s2[0], s2[4]), Ji(s2[2], s2[1], s2[5]), Ji(s2[3], s2[2], s2[6]), Ji(s2[0], s2[3], s2[7])], n2;
            }
            addShadowReceiver(t2, i2, o2) {
              this._receivers.add(t2, e.c9.fromTileIdAndHeight(t2, i2, o2));
            }
            getMaxCascadeForTile(e2) {
              const t2 = this._receivers.get(e2);
              return t2 && t2.lastCascade ? t2.lastCascade : 0;
            }
          }
          function Ji(t2, i2, o2) {
            const r2 = e.a6.vec3.sub([], o2, i2), s2 = e.a6.vec3.sub([], t2, i2), a2 = e.a6.vec3.cross([], r2, s2), n2 = e.a6.vec3.length(a2);
            return 0 === n2 ? [0, 0, 1, 0] : (e.a6.vec3.scale(a2, a2, 1 / n2), [a2[0], a2[1], a2[2], -e.a6.vec3.dot(a2, i2)]);
          }
          function Qi(t2) {
            const i2 = t2.properties.get("direction"), o2 = e.c7(i2.x, i2.y, i2.z);
            o2[2] = e.ap(o2[2], 0, 75);
            const r2 = e.ca([o2[0], o2[1], o2[2]]);
            return e.a6.vec3.fromValues(r2.x, r2.y, r2.z);
          }
          function eo(t2, i2, o2) {
            const r2 = i2.properties.get("color"), s2 = i2.properties.get("intensity"), a2 = i2.properties.get("direction"), n2 = [a2.x, a2.y, a2.z], l2 = o2.properties.get("color"), c2 = o2.properties.get("intensity"), h2 = Math.max(e.a6.vec3.dot([0, 0, 1], n2), 0), u2 = [0, 0, 0];
            e.a6.vec3.scale(u2, l2.toRenderColor(t2.getLut(i2.scope)).toArray01Linear().slice(0, 3), c2);
            const d2 = [0, 0, 0];
            return e.a6.vec3.scale(d2, r2.toRenderColor(t2.getLut(o2.scope)).toArray01Linear().slice(0, 3), h2 * s2), e.cb([u2[0] > 0 ? u2[0] / (u2[0] + d2[0]) : 0, u2[1] > 0 ? u2[1] / (u2[1] + d2[1]) : 0, u2[2] > 0 ? u2[2] / (u2[2] + d2[2]) : 0]);
          }
          function to(t2, i2, o2, r2, s2, a2) {
            const n2 = t2.zoom, l2 = t2.scale, c2 = t2.worldSize, h2 = 1 / c2, u2 = t2.aspect, d2 = Math.sqrt(1 + u2 * u2) * Math.tan(0.5 * t2.fovX), _2 = d2 * d2, p2 = r2 - o2, m2 = r2 + o2;
            let f2, g2;
            _2 > p2 / m2 ? (f2 = r2, g2 = r2 * d2) : (f2 = 0.5 * m2 * (1 + _2), g2 = 0.5 * Math.sqrt(p2 * p2 + 2 * (r2 * r2 + o2 * o2) * _2 + m2 * m2 * _2 * _2));
            const v2 = t2.projection.pixelsPerMeter(t2.center.lat, c2), x2 = t2._camera.getCameraToWorldMercator(), y2 = [0, 0, -f2 * h2];
            e.a6.vec3.transformMat4(y2, y2, x2);
            let b2 = g2 * h2;
            const w2 = t2._edgeInsets;
            if (!(0 === w2.left && 0 === w2.top && 0 === w2.right && 0 === w2.bottom || w2.left === w2.right && w2.top === w2.bottom)) {
              const i3 = t2._camera.getWorldToCamera(t2.worldSize, "meters" === t2.projection.zAxisUnit ? v2 : 1), s3 = t2._camera.getCameraToClipPerspective(t2._fov, t2.width / t2.height, o2, r2);
              s3[8] = 2 * -t2.centerOffset.x / t2.width, s3[9] = 2 * t2.centerOffset.y / t2.height;
              const a3 = new Float64Array(16);
              e.a6.mat4.mul(a3, s3, i3);
              const h3 = new Float64Array(16);
              e.a6.mat4.invert(h3, a3);
              const u3 = e.bN.fromInvProjectionMatrix(h3, c2, n2, true);
              for (const i4 of u3.points) {
                const o3 = ((T2 = i4)[0] /= l2, T2[1] /= l2, T2[2] = e.bD(T2[2], t2._center.lat), T2);
                b2 = Math.max(b2, e.a6.vec3.len(e.a6.vec3.subtract([], y2, o3)));
              }
            }
            var T2;
            b2 *= s2 / (s2 - 1);
            const E2 = Math.acos(i2[2]), C2 = Math.atan2(-i2[0], -i2[1]), S2 = new Gi();
            S2.position = y2, S2.setPitchBearing(E2, C2);
            const I2 = S2.getWorldToCamera(c2, v2), D2 = b2 * c2, R2 = Math.min(t2._mercatorZfromZoom(17) * c2 * -2, -2 * D2), A2 = S2.getCameraToClipOrthographic(-D2, D2, -D2, D2, R2, (D2 + a2 * v2) / i2[2]), L2 = new Float64Array(16);
            e.a6.mat4.multiply(L2, A2, I2);
            const P2 = e.a6.vec3.fromValues(Math.floor(1e6 * y2[0]) / 1e6 * c2, Math.floor(1e6 * y2[1]) / 1e6 * c2, 0), M2 = 0.5 * s2, z2 = [0, 0, 0];
            e.a6.vec3.transformMat4(z2, P2, L2), e.a6.vec3.scale(z2, z2, M2);
            const O2 = [Math.floor(z2[0]), Math.floor(z2[1]), Math.floor(z2[2])], F2 = [0, 0, 0];
            e.a6.vec3.sub(F2, z2, O2), e.a6.vec3.scale(F2, F2, -1 / M2);
            const k2 = new Float64Array(16);
            return e.a6.mat4.identity(k2), e.a6.mat4.translate(k2, k2, F2), e.a6.mat4.multiply(L2, k2, L2), [L2, D2];
          }
          class io extends e.E {
            constructor(e2) {
              super(), this.requestManager = e2, this.models = { "": {} }, this.numModelsLoading = {};
            }
            loadModel(t2, i2) {
              return e.aG(this.requestManager.transformRequest(i2, e.R.Model).url).then((i3) => {
                if (!i3)
                  return;
                const o2 = e.aH(i3), r2 = new e.aI(t2, void 0, void 0, o2);
                return r2.computeBoundsAndApplyParent(), r2;
              }).catch((o2) => {
                if (o2 && 404 === o2.status)
                  return null;
                this.fire(new e.t(new Error(`Could not load model ${t2} from ${i2}: ${o2.message}`)));
              });
            }
            load(t2, i2) {
              this.models[i2] || (this.models[i2] = {});
              const o2 = Object.keys(t2);
              this.numModelsLoading[i2] = (this.numModelsLoading[i2] || 0) + o2.length;
              const r2 = [];
              for (const e2 of o2)
                r2.push(this.loadModel(e2, t2[e2]));
              Promise.allSettled(r2).then((t3) => {
                for (let e2 = 0; e2 < t3.length; e2++) {
                  const { status: r3, value: s2 } = t3[e2];
                  "fulfilled" === r3 && s2 && (this.models[i2][o2[e2]] = { model: s2, numReferences: 1 });
                }
                this.numModelsLoading[i2] -= o2.length, this.fire(new e.x("data", { dataType: "style" }));
              }).catch((t3) => {
                this.fire(new e.t(new Error(`Could not load models: ${t3.message}`)));
              });
            }
            isLoaded() {
              for (const e2 in this.numModelsLoading)
                if (this.numModelsLoading[e2] > 0)
                  return false;
              return true;
            }
            hasModel(e2, t2) {
              return !!this.getModel(e2, t2);
            }
            getModel(e2, t2) {
              return this.models[t2] || (this.models[t2] = {}), this.models[t2][e2] ? this.models[t2][e2].model : void 0;
            }
            addModel(e2, t2, i2) {
              this.models[i2] || (this.models[i2] = {}), this.hasModel(e2, i2) && this.models[i2][e2].numReferences++, this.load({ [e2]: this.requestManager.normalizeModelURL(t2) }, i2);
            }
            addModels(e2, t2) {
              this.models[t2] || (this.models[t2] = {});
              const i2 = {};
              for (const o2 in e2)
                this.models[t2][o2] = {}, i2[o2] = this.requestManager.normalizeModelURL(e2[o2]);
              this.load(i2, t2);
            }
            addModelsFromBucket(e2, t2) {
              this.models[t2] || (this.models[t2] = {});
              const i2 = {};
              for (const o2 of e2)
                this.hasModel(o2, t2) ? this.models[t2][o2].numReferences++ : i2[o2] = this.requestManager.normalizeModelURL(o2);
              this.load(i2, t2);
            }
            removeModel(e2, t2) {
              if (this.models[t2] && this.models[t2][e2] && (this.models[t2][e2].numReferences--, 0 === this.models[t2][e2].numReferences)) {
                const i2 = this.models[t2][e2].model;
                delete this.models[t2][e2], i2.destroy();
              }
            }
            listModels(e2) {
              return this.models[e2] || (this.models[e2] = {}), Object.keys(this.models[e2]);
            }
            upload(e2, t2) {
              this.models[t2] || (this.models[t2] = {});
              for (const i2 in this.models[t2])
                this.models[t2][i2].model && this.models[t2][i2].model.upload(e2.context);
            }
          }
          const oo = new e.a0({ data: new e.a1(e._.colorTheme.data) }), ro = (e2, t2) => De(e2, t2 && t2.filter((e3) => "source.canvas" !== e3.identifier)), so = e.ar(Ct, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), ao = e.ar(Ct, ["setCenter", "setZoom", "setBearing", "setPitch"]), no = { version: 8, layers: [], sources: {} }, lo = { duration: 300, delay: 0 };
          class co extends e.E {
            constructor(t2, i2 = {}) {
              super(), this.map = t2, this.scope = i2.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i2.importDepth || 0, this.importsCache = i2.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i2.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e.l({}, lo), this._buildingIndex = new wt(this), this.crossTileSymbolIndex = new Di(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = false, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i2.styleChanges || new j(), this.dispatcher = i2.dispatcher ? i2.dispatcher : new e.cd(e.ce(), this), i2.imageManager ? this.imageManager = i2.imageManager : (this.imageManager = new q(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i2.glyphManager ? i2.glyphManager : new e.cf(t2._requestManager, i2.localFontFamily ? e.cg.all : i2.localIdeographFontFamily ? e.cg.ideographs : e.cg.none, i2.localFontFamily || i2.localIdeographFontFamily), i2.modelManager ? this.modelManager = i2.modelManager : (this.modelManager = new io(t2._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._order = [], this._markersNeedUpdate = false, this._styleColorTheme = { lut: null, lutLoading: false, lutLoadingCorrelationID: 0, colorTheme: null }, this._styleColorThemeForScope = {}, this.options = i2.configOptions ? i2.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i2.configDependentLayers ? i2.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i2.config, this._initialConfig = i2.initialConfig, this.dispatcher.broadcast("setReferrer", e.ch());
              const o2 = this;
              this._rtlTextPluginCallback = co.registerForPluginStateChange((t3) => {
                o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
                  if (e.ci(t4), i3 && i3.every((e2) => e2))
                    for (const e2 in o2._sourceCaches) {
                      const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                      "vector" !== i4 && "geojson" !== i4 || t5.reload();
                    }
                });
              }), this.on("data", (e2) => {
                if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType)
                  return;
                const t3 = this.getOwnSource(e2.sourceId);
                if (t3 && t3.vectorLayerIds)
                  for (const e3 in this._layers) {
                    const i3 = this._layers[e3];
                    i3.source === t3.id && this._validateLayer(i3);
                  }
              });
            }
            load(e2) {
              return e2 ? ("string" == typeof e2 ? this.loadURL(e2) : this.loadJSON(e2), this) : this;
            }
            _getGlobalId(t2) {
              if (!t2)
                return null;
              if ("string" == typeof t2) {
                if (e.f(t2))
                  return t2;
                const i2 = e.cj(t2);
                if (!i2.startsWith("http"))
                  try {
                    return new URL(i2, location.href).toString();
                  } catch (e2) {
                    return i2;
                  }
                return i2;
              }
              return `json://${e.ck(JSON.stringify(t2))}`;
            }
            _diffStyle(t2, i2, o2) {
              this.globalId = this._getGlobalId(t2);
              const r2 = (e2, t3) => {
                try {
                  t3(null, this.setState(e2, o2));
                } catch (e3) {
                  t3(e3, false);
                }
              };
              if ("string" == typeof t2) {
                const o3 = this.map._requestManager.normalizeStyleURL(t2), s2 = this.map._requestManager.transformRequest(o3, e.R.Style);
                e.n(s2, (t3, o4) => {
                  t3 ? this.fire(new e.t(t3)) : o4 && r2(o4, i2);
                });
              } else
                "object" == typeof t2 && r2(t2, i2);
            }
            loadURL(t2, i2 = {}) {
              this.fire(new e.x("dataloading", { dataType: "style" }));
              const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.f(t2);
              this.globalId = this._getGlobalId(t2), t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken), this.resolvedImports.add(t2);
              const r2 = this.importsCache.get(t2);
              if (r2)
                return this._load(r2, o2);
              const s2 = this.map._requestManager.transformRequest(t2, e.R.Style);
              this._request = e.n(s2, (i3, r3) => {
                if (this._request = null, i3)
                  this.fire(new e.t(i3));
                else if (r3)
                  return this.importsCache.set(t2, r3), this._load(r3, o2);
              });
            }
            loadJSON(t2, i2 = {}) {
              this.fire(new e.x("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t2), this._request = e.q.frame(() => {
                this._request = null, this._load(t2, false !== i2.validate);
              });
            }
            loadEmpty() {
              this.fire(new e.x("dataloading", { dataType: "style" })), this._load(no, false);
            }
            _loadImports(t2, i2, o2) {
              if (this.importDepth >= 4)
                return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
              const r2 = [];
              for (const e2 of t2) {
                const t3 = this._createFragmentStyle(e2), s2 = new Promise((e3) => {
                  t3.once("style.import.load", e3), t3.once("error", e3);
                }).then(() => this.mergeAll());
                if (r2.push(s2), this.resolvedImports.has(e2.url)) {
                  t3.loadEmpty();
                  continue;
                }
                const a2 = e2.data || this.importsCache.get(e2.url);
                a2 ? (t3.loadJSON(a2, { validate: i2 }), this._isInternalStyle(a2) && (t3.globalId = null)) : e2.url ? t3.loadURL(e2.url, { validate: i2 }) : t3.loadEmpty();
                const n2 = { style: t3, id: e2.id, config: e2.config };
                if (o2) {
                  const e3 = this.fragments.findIndex(({ id: e4 }) => e4 === o2);
                  this.fragments = this.fragments.slice(0, e3).concat(n2).concat(this.fragments.slice(e3));
                } else
                  this.fragments.push(n2);
              }
              return Promise.allSettled(r2);
            }
            getImportGlobalIds(e2 = this, t2 = /* @__PURE__ */ new Set()) {
              for (const i2 of e2.fragments)
                i2.style.globalId && t2.add(i2.style.globalId), this.getImportGlobalIds(i2.style, t2);
              return [...t2.values()];
            }
            _createFragmentStyle(t2) {
              const i2 = this.scope ? e.av(t2.id, this.scope) : t2.id;
              let o2;
              const r2 = this._initialConfig && this._initialConfig[i2];
              (t2.config || r2) && (o2 = e.l({}, t2.config, r2));
              const s2 = new co(this.map, { scope: i2, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o2, configOptions: this.options, configDependentLayers: this._configDependentLayers });
              return s2.setEventedParent(this.map, { style: s2 }), s2;
            }
            _reloadImports() {
              this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
            }
            _isInternalStyle(e2) {
              return this.isRootStyle() && (e2.fragment || !!e2.schema && false !== e2.fragment);
            }
            _load(t2, i2) {
              const o2 = t2.schema;
              if (this._isInternalStyle(t2)) {
                const o3 = e.l({}, no, { imports: [{ id: "basemap", data: t2, url: "" }] });
                return void this._load(o3, i2);
              }
              if (this.updateConfig(this._config, o2), i2 && ro(this, fe(t2)))
                return;
              this._loaded = true, this.stylesheet = e.cl(t2);
              const r2 = () => {
                for (const e2 in t2.sources)
                  this.addSource(e2, t2.sources[e2], { validate: false, isInitialLoad: true });
                t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.glyphManager.setURL(t2.glyphs, this.scope);
                const o3 = Et(this.stylesheet.layers);
                if (this._order = o3.map((e2) => e2.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
                  if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                    const e2 = this.stylesheet.lights[0];
                    this.light = new Ae(e2.properties, e2.id);
                  } else
                    this.setLights(this.stylesheet.lights);
                this.light || (this.light = new Ae(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
                for (const t3 of o3) {
                  const i3 = e.cq(t3, this.scope, this._styleColorTheme.lut, this.options);
                  0 !== i3.configDependencies.size && this._configDependentLayers.add(i3.fqid), i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3, this._serializedLayers[i3.id] = i3.serialize();
                  const o4 = this.getOwnLayerSourceCache(i3), r4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                  o4 && i3.canCastShadows() && r4 && (o4.castsShadows = true);
                }
                this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
                const r3 = this.stylesheet.terrain;
                r3 && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(r3, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.x("data", { dataType: "style" }));
                const s3 = this.isRootStyle();
                t2.imports ? this._loadImports(t2.imports, i2).then(() => {
                  this._reloadImports(), this.fire(new e.x(s3 ? "style.load" : "style.import.load"));
                }) : (this._reloadImports(), this.fire(new e.x(s3 ? "style.load" : "style.import.load")));
              }, s2 = this.stylesheet["color-theme"];
              if (this._styleColorTheme.colorTheme = s2, s2) {
                const t3 = this._evaluateColorThemeData(s2);
                this._loadColorTheme(t3).then(() => {
                  r2();
                }).catch((t4) => {
                  e.w(`Couldn't load color theme from the stylesheet: ${t4}`), r2();
                });
              } else
                this._styleColorTheme.lut = null, r2();
            }
            isRootStyle() {
              return 0 === this.importDepth;
            }
            mergeAll() {
              let t2, i2, o2, r2, s2, a2, n2, l2;
              const c2 = {};
              this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e2) => {
                if (e2.stylesheet) {
                  if (null != e2.light && (t2 = e2.light), e2.stylesheet.lights)
                    for (const t3 of e2.stylesheet.lights)
                      "ambient" === t3.type && null != e2.ambientLight && (i2 = e2.ambientLight), "directional" === t3.type && null != e2.directionalLight && (o2 = e2.directionalLight);
                  r2 = this._prioritizeTerrain(r2, e2.terrain, e2.stylesheet.terrain), e2.stylesheet.fog && null != e2.fog && (s2 = e2.fog), null != e2.stylesheet.camera && (l2 = e2.stylesheet.camera), null != e2.stylesheet.projection && (a2 = e2.stylesheet.projection), null != e2.stylesheet.transition && (n2 = e2.stylesheet.transition), c2[e2.scope] = e2._styleColorTheme;
                }
              }), this.light = t2, this.ambientLight = i2, this.directionalLight = o2, this.fog = s2, this._styleColorThemeForScope = c2, null === r2 ? delete this.terrain : this.terrain = r2, this.camera = l2 || { "camera-projection": "perspective" }, this.projection = a2 || { name: "mercator" }, this.transition = e.l({}, lo, n2), this.mergeSources(), this.mergeLayers();
            }
            forEachFragmentStyle(e2) {
              const t2 = (i2) => {
                for (const e3 of i2.fragments)
                  t2(e3.style);
                e2(i2);
              };
              t2(this);
            }
            _prioritizeTerrain(e2, t2, i2) {
              const o2 = e2 && 0 === e2.drapeRenderMode;
              return null === i2 ? t2 && 0 === t2.drapeRenderMode ? t2 : o2 ? e2 : null : null != t2 && (!e2 || o2 || t2 && 1 === t2.drapeRenderMode) ? t2 : e2;
            }
            mergeTerrain() {
              let e2;
              this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t2) => {
                e2 = this._prioritizeTerrain(e2, t2.terrain, t2.stylesheet.terrain);
              }), null === e2 ? delete this.terrain : this.terrain = e2;
            }
            mergeProjection() {
              let e2;
              this.forEachFragmentStyle((t2) => {
                null != t2.stylesheet.projection && (e2 = t2.stylesheet.projection);
              }), this.projection = e2 || { name: "mercator" };
            }
            mergeSources() {
              const t2 = {}, i2 = {}, o2 = {};
              this.forEachFragmentStyle((r2) => {
                for (const i3 in r2._sourceCaches) {
                  const o3 = e.av(i3, r2.scope);
                  t2[o3] = r2._sourceCaches[i3];
                }
                for (const t3 in r2._otherSourceCaches) {
                  const o3 = e.av(t3, r2.scope);
                  i2[o3] = r2._otherSourceCaches[t3];
                }
                for (const t3 in r2._symbolSourceCaches) {
                  const i3 = e.av(t3, r2.scope);
                  o2[i3] = r2._symbolSourceCaches[t3];
                }
              }), this._mergedSourceCaches = t2, this._mergedOtherSourceCaches = i2, this._mergedSymbolSourceCaches = o2;
            }
            mergeLayers() {
              const t2 = {}, i2 = [], o2 = {};
              this._mergedSlots = [], this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o3) => {
                for (const r3 of o3._order) {
                  const s2 = o3._layers[r3];
                  if ("slot" === s2.type) {
                    const i3 = e.cm(r3);
                    if (t2[i3])
                      continue;
                    t2[i3] = [];
                  }
                  s2.slot && t2[s2.slot] ? t2[s2.slot].push(s2) : i2.push(s2);
                }
              }), this._mergedOrder = [];
              const r2 = (i3 = []) => {
                for (const s2 of i3)
                  if ("slot" === s2.type) {
                    const i4 = e.cm(s2.id);
                    t2[i4] && r2(t2[i4]), this._mergedSlots.push(i4);
                  } else {
                    const t3 = e.av(s2.id, s2.scope);
                    this._mergedOrder.push(t3), o2[t3] = s2, s2.is3D() && (this._has3DLayers = true), "circle" === s2.type && (this._hasCircleLayers = true), "symbol" === s2.type && (this._hasSymbolLayers = true), "clip" === s2.type && (this._clipLayerPresent = true);
                  }
              };
              r2(i2), this._mergedOrder.sort((e2, t3) => {
                const i3 = o2[e2], r3 = o2[t3];
                return i3.hasInitialOcclusionOpacityProperties ? r3.is3D() ? 1 : 0 : i3.is3D() && r3.hasInitialOcclusionOpacityProperties ? -1 : 0;
              }), this._mergedLayers = o2, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
            }
            terrainSetForDrapingOnly() {
              return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            getCamera() {
              return this.stylesheet.camera;
            }
            setCamera(t2) {
              return this.stylesheet.camera = e.l({}, this.stylesheet.camera, t2), this.camera = this.stylesheet.camera, this;
            }
            _evaluateColorThemeData(t2) {
              return t2.data ? function(t3, i2, o2) {
                const r2 = e.l({}, i2);
                for (const t4 of Object.keys(e._.colorTheme))
                  void 0 === r2[t4] && (r2[t4] = e._.colorTheme[t4].default);
                const s2 = new e.$(oo, t3, new Map(o2));
                return s2.setTransitionOrValue(r2, o2), s2.untransitioned().possiblyEvaluate(new e.a3(0));
              }(this.scope, t2, this.options).get("data") : null;
            }
            _loadColorTheme(t2) {
              this._styleColorTheme.lutLoading = true, this._styleColorTheme.lutLoadingCorrelationID += 1;
              const i2 = this._styleColorTheme.lutLoadingCorrelationID;
              return new Promise((o2, r2) => {
                const s2 = "data:image/png;base64,";
                if (!t2 || 0 === t2.length)
                  return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = false, void o2();
                let a2 = t2;
                a2.startsWith(s2) || (a2 = s2 + a2);
                const n2 = "mapbox-reserved-lut", l2 = new Image();
                l2.src = a2, l2.onerror = () => {
                  this._styleColorTheme.lutLoading = false, r2(new Error("Failed to load image data"));
                }, l2.onload = () => {
                  if (this._styleColorTheme.lutLoadingCorrelationID !== i2)
                    return void o2();
                  this._styleColorTheme.lutLoading = false;
                  const { width: s3, height: a3, data: c2 } = e.q.getImageData(l2);
                  if (a3 > 32)
                    return void r2(new Error("The height of the image must be less than or equal to 32 pixels."));
                  if (s3 !== a3 * a3)
                    return void r2(new Error("The width of the image must be equal to the height squared."));
                  this.getImage(n2) && this.removeImage(n2), this.addImage(n2, { data: new e.r({ width: s3, height: a3 }, c2), pixelRatio: 1, sdf: false, version: 0 });
                  const h2 = this.imageManager.getImage(n2, this.scope);
                  h2 ? (this._styleColorTheme.lut = { image: h2.data, data: t2 }, o2()) : r2(new Error("Missing LUT image."));
                };
              });
            }
            getLut(e2) {
              const t2 = this._styleColorThemeForScope[e2];
              return t2 ? t2.lut : null;
            }
            setProjection(e2) {
              e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
            }
            applyProjectionUpdate() {
              this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
            }
            _updateMapProjection() {
              this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
            }
            _loadSprite(t2) {
              this._spriteRequest = function(t3, i2, o2) {
                let r2, s2, a2;
                const n2 = e.q.devicePixelRatio > 1 ? "@2x" : "";
                let l2 = e.n(i2.transformRequest(i2.normalizeSpriteURL(t3, n2, ".json"), e.R.SpriteJSON), (e2, t4) => {
                  l2 = null, a2 || (a2 = e2, r2 = t4, h2());
                }), c2 = e.o(i2.transformRequest(i2.normalizeSpriteURL(t3, n2, ".png"), e.R.SpriteImage), (e2, t4) => {
                  c2 = null, a2 || (a2 = e2, s2 = t4, h2());
                });
                function h2() {
                  if (a2)
                    o2(a2);
                  else if (r2 && s2) {
                    const t4 = e.q.getImageData(s2), i3 = {};
                    for (const o3 in r2) {
                      const { width: s3, height: a3, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u2, stretchY: d2, content: _2 } = r2[o3], p2 = new e.r({ width: s3, height: a3 });
                      e.r.copy(t4, p2, { x: n3, y: l3 }, { x: 0, y: 0 }, { width: s3, height: a3 }, null), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: u2, stretchY: d2, content: _2 };
                    }
                    o2(null, i3);
                  }
                }
                return { cancel() {
                  l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
                } };
              }(t2, this.map._requestManager, (t3, i2) => {
                if (this._spriteRequest = null, t3)
                  this.fire(new e.t(t3));
                else if (i2)
                  for (const e2 in i2)
                    this.imageManager.addImage(e2, this.scope, i2[e2]);
                this.imageManager.setLoaded(true, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e.x("data", { dataType: "style" }));
              });
            }
            _validateLayer(t2) {
              const i2 = this.getOwnSource(t2.source);
              if (!i2)
                return;
              const o2 = t2.sourceLayer;
              o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.t(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._changes.getUpdatedSourceCaches()).length)
                return false;
              for (const e2 in this._sourceCaches)
                if (!this._sourceCaches[e2].loaded())
                  return false;
              if (!this.imageManager.isLoaded())
                return false;
              if (!this.modelManager.isLoaded())
                return false;
              if (this._styleColorTheme.lutLoading)
                return false;
              for (const { style: e2 } of this.fragments)
                if (!e2.loaded())
                  return false;
              return true;
            }
            _serializeImports() {
              if (this.stylesheet.imports)
                return this.stylesheet.imports.map((e2, t2) => {
                  const i2 = this.fragments[t2];
                  return i2 && i2.style && (e2.data = i2.style.serialize()), e2;
                });
            }
            _serializeSources() {
              const e2 = {};
              for (const t2 in this._sourceCaches) {
                const i2 = this._sourceCaches[t2].getSource();
                e2[i2.id] || (e2[i2.id] = i2.serialize());
              }
              return e2;
            }
            _serializeLayers(e2) {
              const t2 = [];
              for (const i2 of e2) {
                const e3 = this._layers[i2];
                e3 && "custom" !== e3.type && t2.push(e3.serialize());
              }
              return t2;
            }
            hasLightTransitions() {
              return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
            }
            hasFogTransition() {
              return !!this.fog && this.fog.hasTransition();
            }
            hasTransitions() {
              if (this.hasLightTransitions())
                return true;
              if (this.hasFogTransition())
                return true;
              for (const e2 in this._sourceCaches)
                if (this._sourceCaches[e2].hasTransition())
                  return true;
              for (const e2 in this._layers)
                if (this._layers[e2].hasTransition())
                  return true;
              return false;
            }
            get order() {
              return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
            }
            isLayerDraped(e2) {
              return !!this.terrain && e2.isDraped(this.getLayerSourceCache(e2));
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading");
            }
            _checkLayer(t2) {
              const i2 = this.getOwnLayer(t2);
              if (i2)
                return i2;
              this.fire(new e.t(new Error(`The layer '${t2}' does not exist in the map's style.`)));
            }
            _checkSource(t2) {
              const i2 = this.getOwnSource(t2);
              if (i2)
                return i2;
              this.fire(new e.t(new Error(`The source '${t2}' does not exist in the map's style.`)));
            }
            precompilePrograms(e2, t2) {
              const i2 = this.map.painter;
              if (i2)
                for (let o2 = e2.minzoom || 0; o2 < (e2.maxzoom || 25.5); o2++) {
                  const o3 = e2.getProgramIds();
                  if (o3)
                    for (const r2 of o3) {
                      const o4 = e2.getDefaultProgramParams(r2, t2.zoom, this._styleColorTheme.lut);
                      o4 && (i2.style = this, this.fog && (i2._fogVisible = true, o4.overrideFog = true, i2.getOrCreateProgram(r2, o4)), i2._fogVisible = false, o4.overrideFog = false, i2.getOrCreateProgram(r2, o4), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o4.overrideRtt = true, i2.getOrCreateProgram(r2, o4)));
                    }
                }
            }
            update(t2) {
              if (!this._loaded)
                return;
              this.ambientLight && this.ambientLight.recalculate(t2), this.directionalLight && this.directionalLight.recalculate(t2);
              const i2 = this.calculateLightsBrightness();
              t2.brightness = i2 || 0, i2 !== this._brightness && (this._brightness = i2, this.dispatcher.broadcast("setBrightness", i2));
              const o2 = this._changes.isDirty();
              let r2 = false;
              if (this._changes.isDirty()) {
                const e2 = this._changes.getLayerUpdatesByScope();
                for (const t3 in e2) {
                  const { updatedIds: i3, removedIds: o3 } = e2[t3];
                  (i3 || o3) && (this._updateWorkerLayers(t3, i3, o3), r2 = true);
                }
                this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t2), this.light && this.light.updateTransitions(t2), this.ambientLight && this.ambientLight.updateTransitions(t2), this.directionalLight && this.directionalLight.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._changes.reset();
              }
              const s2 = {};
              for (const e2 in this._mergedSourceCaches) {
                const t3 = this._mergedSourceCaches[e2];
                s2[e2] = t3.used, t3.used = false, t3.tileCoverLift = 0;
              }
              for (const e2 of this._mergedOrder) {
                const i3 = this._mergedLayers[e2];
                if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
                  const e3 = this.getLayerSourceCache(i3);
                  e3 && (e3.used = true, e3.tileCoverLift = Math.max(e3.tileCoverLift, i3.tileCoverLift()));
                }
                !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
                  this.precompilePrograms(i3, t2);
                }) : this.precompilePrograms(i3, t2));
              }
              this._shouldPrecompile && (this._precompileDone = true), this.terrain && r2 && this.mergeLayers();
              for (const t3 in s2) {
                const i3 = this._mergedSourceCaches[t3];
                s2[t3] !== i3.used && i3.getSource().fire(new e.x("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
              }
              this.light && this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), o2 && this.fire(new e.x("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const e2 = this._changes.getUpdatedImages();
              if (e2.length) {
                for (const t2 in this._sourceCaches)
                  this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
                this._changes.resetUpdatedImages();
              }
            }
            _updateWorkerLayers(e2, t2, i2) {
              const o2 = this.getFragmentStyle(e2);
              o2 && this.dispatcher.broadcast("updateLayers", { layers: t2 ? o2._serializeLayers(t2) : [], scope: e2, removedIds: i2 || [], options: o2.options });
            }
            setState(t2, i2) {
              if (this._checkLoaded(), ro(this, fe(t2)))
                return false;
              (t2 = e.cl(t2)).layers = Et(t2.layers);
              const o2 = function(t3, i3) {
                if (!t3)
                  return [{ command: Ct.setStyle, args: [i3] }];
                let o3 = [];
                try {
                  if (!e.bh(t3.version, i3.version))
                    return [{ command: Ct.setStyle, args: [i3] }];
                  if (e.bh(t3.center, i3.center) || o3.push({ command: Ct.setCenter, args: [i3.center] }), e.bh(t3.zoom, i3.zoom) || o3.push({ command: Ct.setZoom, args: [i3.zoom] }), e.bh(t3.bearing, i3.bearing) || o3.push({ command: Ct.setBearing, args: [i3.bearing] }), e.bh(t3.pitch, i3.pitch) || o3.push({ command: Ct.setPitch, args: [i3.pitch] }), e.bh(t3.sprite, i3.sprite) || o3.push({ command: Ct.setSprite, args: [i3.sprite] }), e.bh(t3.glyphs, i3.glyphs) || o3.push({ command: Ct.setGlyphs, args: [i3.glyphs] }), e.bh(t3.imports, i3.imports) || function(t4 = [], i4 = [], o4) {
                    i4 = i4 || [];
                    const r4 = (t4 = t4 || []).map(Lt), s4 = i4.map(Lt), a3 = t4.reduce(Pt, {}), n3 = i4.reduce(Pt, {}), l2 = r4.slice();
                    let c2, h2, u2, d2;
                    for (c2 = 0, h2 = 0; c2 < r4.length; c2++)
                      u2 = r4[c2], n3.hasOwnProperty(u2) ? h2++ : (o4.push({ command: Ct.removeImport, args: [u2] }), l2.splice(l2.indexOf(u2, h2), 1));
                    for (c2 = 0, h2 = 0; c2 < s4.length; c2++)
                      u2 = s4[s4.length - 1 - c2], l2[l2.length - 1 - c2] !== u2 && (a3.hasOwnProperty(u2) ? (o4.push({ command: Ct.removeImport, args: [u2] }), l2.splice(l2.lastIndexOf(u2, l2.length - h2), 1)) : h2++, d2 = l2[l2.length - c2], o4.push({ command: Ct.addImport, args: [n3[u2], d2] }), l2.splice(l2.length - c2, 0, u2));
                    for (const t5 of i4) {
                      const i5 = a3[t5.id];
                      i5 && !e.bh(i5, t5) && o4.push({ command: Ct.updateImport, args: [t5.id, t5] });
                    }
                  }(t3.imports, i3.imports, o3), e.bh(t3.transition, i3.transition) || o3.push({ command: Ct.setTransition, args: [i3.transition] }), e.bh(t3.light, i3.light) || o3.push({ command: Ct.setLight, args: [i3.light] }), e.bh(t3.fog, i3.fog) || o3.push({ command: Ct.setFog, args: [i3.fog] }), e.bh(t3.projection, i3.projection) || o3.push({ command: Ct.setProjection, args: [i3.projection] }), e.bh(t3.lights, i3.lights) || o3.push({ command: Ct.setLights, args: [i3.lights] }), e.bh(t3.camera, i3.camera) || o3.push({ command: Ct.setCamera, args: [i3.camera] }), !e.bh(t3["color-theme"], i3["color-theme"]))
                    return [{ command: Ct.setStyle, args: [i3] }];
                  const r3 = {}, s3 = [];
                  !function(t4, i4, o4, r4) {
                    let s4;
                    for (s4 in i4 = i4 || {}, t4 = t4 || {})
                      t4.hasOwnProperty(s4) && (i4.hasOwnProperty(s4) || It(s4, o4, r4));
                    for (s4 in i4) {
                      if (!i4.hasOwnProperty(s4))
                        continue;
                      const a3 = i4[s4];
                      t4.hasOwnProperty(s4) ? e.bh(t4[s4], a3) || ("geojson" === t4[s4].type && "geojson" === a3.type && Rt(t4, i4, s4) ? o4.push({ command: Ct.setGeoJSONSourceData, args: [s4, a3.data] }) : Dt(s4, i4, o4, r4)) : St(s4, i4, o4);
                    }
                  }(t3.sources, i3.sources, s3, r3);
                  const a2 = [];
                  t3.layers && t3.layers.forEach((e2) => {
                    e2.source && r3[e2.source] ? o3.push({ command: Ct.removeLayer, args: [e2.id] }) : a2.push(e2);
                  });
                  let n2 = t3.terrain;
                  n2 && r3[n2.source] && (o3.push({ command: Ct.setTerrain, args: [void 0] }), n2 = void 0), o3 = o3.concat(s3), e.bh(n2, i3.terrain) || o3.push({ command: Ct.setTerrain, args: [i3.terrain] }), function(t4, i4, o4) {
                    i4 = i4 || [];
                    const r4 = (t4 = t4 || []).map(Lt), s4 = i4.map(Lt), a3 = t4.reduce(Pt, {}), n3 = i4.reduce(Pt, {}), l2 = r4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                    let h2, u2, d2, _2, p2, m2, f2;
                    for (h2 = 0, u2 = 0; h2 < r4.length; h2++)
                      d2 = r4[h2], n3.hasOwnProperty(d2) ? u2++ : (o4.push({ command: Ct.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, u2), 1));
                    for (h2 = 0, u2 = 0; h2 < s4.length; h2++)
                      d2 = s4[s4.length - 1 - h2], l2[l2.length - 1 - h2] !== d2 && (a3.hasOwnProperty(d2) ? (o4.push({ command: Ct.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - u2), 1)) : u2++, m2 = l2[l2.length - h2], o4.push({ command: Ct.addLayer, args: [n3[d2], m2] }), l2.splice(l2.length - h2, 0, d2), c2[d2] = true);
                    for (h2 = 0; h2 < s4.length; h2++)
                      if (d2 = s4[h2], _2 = a3[d2], p2 = n3[d2], !c2[d2] && !e.bh(_2, p2))
                        if (e.bh(_2.source, p2.source) && e.bh(_2["source-layer"], p2["source-layer"]) && e.bh(_2.type, p2.type)) {
                          for (f2 in At(_2.layout, p2.layout, o4, d2, null, Ct.setLayoutProperty), At(_2.paint, p2.paint, o4, d2, null, Ct.setPaintProperty), e.bh(_2.slot, p2.slot) || o4.push({ command: Ct.setSlot, args: [d2, p2.slot] }), e.bh(_2.filter, p2.filter) || o4.push({ command: Ct.setFilter, args: [d2, p2.filter] }), e.bh(_2.minzoom, p2.minzoom) && e.bh(_2.maxzoom, p2.maxzoom) || o4.push({ command: Ct.setLayerZoomRange, args: [d2, p2.minzoom, p2.maxzoom] }), _2)
                            _2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && "slot" !== f2 && (0 === f2.indexOf("paint.") ? At(_2[f2], p2[f2], o4, d2, f2.slice(6), Ct.setPaintProperty) : e.bh(_2[f2], p2[f2]) || o4.push({ command: Ct.setLayerProperty, args: [d2, f2, p2[f2]] }));
                          for (f2 in p2)
                            p2.hasOwnProperty(f2) && !_2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && "slot" !== f2 && (0 === f2.indexOf("paint.") ? At(_2[f2], p2[f2], o4, d2, f2.slice(6), Ct.setPaintProperty) : e.bh(_2[f2], p2[f2]) || o4.push({ command: Ct.setLayerProperty, args: [d2, f2, p2[f2]] }));
                        } else
                          o4.push({ command: Ct.removeLayer, args: [d2] }), m2 = l2[l2.lastIndexOf(d2) + 1], o4.push({ command: Ct.addLayer, args: [p2, m2] });
                  }(a2, i3.layers, o3);
                } catch (e2) {
                  console.warn("Unable to compute style diff:", e2), o3 = [{ command: Ct.setStyle, args: [i3] }];
                }
                return o3;
              }(this.serialize(), t2).filter((e2) => !(e2.command in ao));
              if (0 === o2.length)
                return false;
              const r2 = o2.filter((e2) => !(e2.command in so));
              if (r2.length > 0)
                throw new Error(`Unimplemented: ${r2.map((e2) => e2.command).join(", ")}.`);
              const s2 = [];
              return o2.forEach((e2) => {
                s2.push(this[e2.command].apply(this, e2.args));
              }), i2 && Promise.all(s2).then(i2), this.stylesheet = t2, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
            }
            addImage(t2, i2) {
              return this.getImage(t2) ? this.fire(new e.t(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t2, this.scope, i2), this._afterImageUpdated(t2), this);
            }
            updateImage(e2, t2) {
              this.imageManager.updateImage(e2, this.scope, t2);
            }
            getImage(e2) {
              return this.imageManager.getImage(e2, this.scope);
            }
            removeImage(t2) {
              return this.getImage(t2) ? (this.imageManager.removeImage(t2, this.scope), this._afterImageUpdated(t2), this) : this.fire(new e.t(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t2) {
              this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t2), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new e.x("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this._availableImages.slice();
            }
            addModel(e2, t2, i2 = {}) {
              return this._checkLoaded(), this._validate(Se, `models.${e2}`, t2, null, i2) || (this.modelManager.addModel(e2, t2, this.scope), this._changes.setDirty()), this;
            }
            hasModel(e2) {
              return this.modelManager.hasModel(e2, this.scope);
            }
            removeModel(t2) {
              return this.hasModel(t2) ? (this.modelManager.removeModel(t2, this.scope), this) : this.fire(new e.t(new Error("No model with this ID exists.")));
            }
            listModels() {
              return this._checkLoaded(), this.modelManager.listModels(this.scope);
            }
            addSource(t2, i2, o2 = {}) {
              if (this._checkLoaded(), void 0 !== this.getOwnSource(t2))
                throw new Error(`There is already a source with ID "${t2}".`);
              if (!i2.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(ge, `sources.${t2}`, i2, null, o2))
                return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const r2 = tt(t2, i2, this.dispatcher, this);
              r2.scope = this.scope, r2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r2.id), source: r2.serialize(), sourceId: r2.id }));
              const s2 = (t3) => {
                const i3 = (t3 ? "symbol:" : "other:") + r2.id, o3 = e.av(i3, this.scope), s3 = this._sourceCaches[i3] = new vt(o3, r2, t3);
                (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[r2.id] = s3, s3.onAdd(this.map);
              };
              s2(false), "vector" !== i2.type && "geojson" !== i2.type || s2(true), r2.onAdd && r2.onAdd(this.map), o2.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
            }
            removeSource(t2) {
              this._checkLoaded();
              const i2 = this.getOwnSource(t2);
              if (!i2)
                throw new Error("There is no source with this ID");
              for (const i3 in this._layers)
                if (this._layers[i3].source === t2)
                  return this.fire(new e.t(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
              if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t2)
                return this.fire(new e.t(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
              const o2 = this.getOwnSourceCaches(t2);
              for (const t3 of o2) {
                const i3 = e.cm(t3.id);
                delete this._sourceCaches[i3], this._changes.discardSourceCacheUpdate(t3.id), t3.fire(new e.x("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
              }
              return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], this.mergeSources(), i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changes.setDirty(), this;
            }
            setGeoJSONSourceData(e2, t2) {
              this._checkLoaded(), this.getOwnSource(e2).setData(t2), this._changes.setDirty();
            }
            getOwnSource(e2) {
              const t2 = this.getOwnSourceCache(e2);
              return t2 && t2.getSource();
            }
            getOwnSources() {
              const e2 = [];
              for (const t2 in this._otherSourceCaches) {
                const i2 = this.getOwnSourceCache(t2);
                i2 && e2.push(i2.getSource());
              }
              return e2;
            }
            areTilesLoaded() {
              const e2 = this._mergedSourceCaches;
              for (const t2 in e2) {
                const i2 = e2[t2]._tiles;
                for (const e3 in i2) {
                  const t3 = i2[e3];
                  if ("loaded" !== t3.state && "errored" !== t3.state)
                    return false;
                }
              }
              return true;
            }
            setLights(t2) {
              if (this._checkLoaded(), !t2)
                return delete this.ambientLight, void delete this.directionalLight;
              const i2 = this._getTransitionParameters();
              for (const o3 of t2) {
                if (this._validate(xe, "lights", o3))
                  return;
                switch (o3.type) {
                  case "ambient":
                    if (this.ambientLight) {
                      const e2 = this.ambientLight;
                      e2.set(o3), e2.updateTransitions(i2);
                    } else
                      this.ambientLight = new je(o3, Ve || (Ve = new e.a0({ color: new e.a1(e._.properties_light_ambient.color), intensity: new e.a1(e._.properties_light_ambient.intensity) })), this.scope, this.options);
                    break;
                  case "directional":
                    if (this.directionalLight) {
                      const e2 = this.directionalLight;
                      e2.set(o3), e2.updateTransitions(i2);
                    } else
                      this.directionalLight = new je(o3, qe || (qe = new e.a0({ direction: new e.ad(e._.properties_light_directional.direction), color: new e.a1(e._.properties_light_directional.color), intensity: new e.a1(e._.properties_light_directional.intensity), "cast-shadows": new e.a1(e._.properties_light_directional["cast-shadows"]), "shadow-intensity": new e.a1(e._.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
                }
              }
              const o2 = new e.a3(this.z || 0, i2);
              this.ambientLight && this.ambientLight.recalculate(o2), this.directionalLight && this.directionalLight.recalculate(o2), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
            }
            calculateLightsBrightness() {
              const t2 = this.directionalLight, i2 = this.ambientLight;
              if (!t2 || !i2)
                return;
              const o2 = (e2) => 0.2126 * (e2[0] <= 0.03928 ? e2[0] / 12.92 : Math.pow((e2[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e2[1] <= 0.03928 ? e2[1] / 12.92 : Math.pow((e2[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e2[2] <= 0.03928 ? e2[2] / 12.92 : Math.pow((e2[2] + 0.055) / 1.055, 2.4)), r2 = t2.properties.get("color").toRenderColor(null).toArray01(), s2 = t2.properties.get("intensity"), a2 = t2.properties.get("direction"), n2 = 1 - e.c7(a2.x, a2.y, a2.z)[2] / 90, l2 = o2(r2) * s2 * n2, c2 = i2.properties.get("color").toRenderColor(null).toArray01(), h2 = i2.properties.get("intensity");
              return (l2 + o2(c2) * h2) / 2;
            }
            getBrightness() {
              return this._brightness;
            }
            getLights() {
              if (!this.enable3dLights())
                return null;
              const e2 = [];
              return this.directionalLight && e2.push(this.directionalLight.get()), this.ambientLight && e2.push(this.ambientLight.get()), e2;
            }
            enable3dLights() {
              return !!this.ambientLight && !!this.directionalLight;
            }
            getFragmentStyle(t2) {
              if (!t2)
                return this;
              if (e.cn(t2)) {
                const i2 = e.co(t2), o2 = this.fragments.find(({ id: e2 }) => e2 === i2);
                if (!o2)
                  throw new Error(`Style import not found: ${t2}`);
                const r2 = e.cm(t2);
                return o2.style.getFragmentStyle(r2);
              }
              {
                const e2 = this.fragments.find(({ id: e3 }) => e3 === t2);
                if (!e2)
                  throw new Error(`Style import not found: ${t2}`);
                return e2.style;
              }
            }
            getConfigProperty(t2, i2) {
              const o2 = this.getFragmentStyle(t2);
              if (!o2)
                return null;
              const r2 = e.av(i2, o2.scope), s2 = o2.options.get(r2), a2 = s2 ? s2.value || s2.default : null;
              return a2 ? a2.serialize() : null;
            }
            setConfigProperty(t2, i2, o2) {
              const r2 = this.getFragmentStyle(t2);
              if (!r2)
                return;
              const s2 = r2.stylesheet.schema;
              if (!s2 || !s2[i2])
                return;
              const a2 = e.M(o2);
              if ("success" !== a2.result)
                return void ro(this, a2.value);
              const n2 = a2.value.expression, l2 = e.av(i2, r2.scope), c2 = r2.options.get(l2);
              if (!c2)
                return;
              let h2;
              const { minValue: u2, maxValue: d2, stepValue: _2, type: p2, values: m2 } = s2[i2], f2 = e.M(s2[i2].default);
              "success" === f2.result && (h2 = f2.value.expression), h2 ? (this.options.set(l2, { ...c2, value: n2, default: h2, minValue: u2, maxValue: d2, stepValue: _2, type: p2, values: m2 }), this.updateConfigDependencies(i2)) : this.fire(new e.t(new Error(`No schema defined for the config option "${i2}" in the "${t2}" fragment.`)));
            }
            getConfig(t2) {
              const i2 = this.getFragmentStyle(t2);
              if (!i2)
                return null;
              const o2 = i2.stylesheet.schema;
              if (!o2)
                return null;
              const r2 = {};
              for (const t3 in o2) {
                const o3 = e.av(t3, i2.scope), s2 = i2.options.get(o3), a2 = s2 ? s2.value || s2.default : null;
                r2[t3] = a2 ? a2.serialize() : null;
              }
              return r2;
            }
            setConfig(e2, t2) {
              const i2 = this.getFragmentStyle(e2);
              i2 && (i2.updateConfig(t2, i2.stylesheet.schema), this.updateConfigDependencies());
            }
            getSchema(e2) {
              const t2 = this.getFragmentStyle(e2);
              return t2 ? t2.stylesheet.schema : null;
            }
            setSchema(e2, t2) {
              const i2 = this.getFragmentStyle(e2);
              i2 && (i2.stylesheet.schema = t2, i2.updateConfig(i2._config, t2), this.updateConfigDependencies());
            }
            updateConfig(t2, i2) {
              if (this._config = t2, t2 || i2)
                if (i2)
                  for (const o2 in i2) {
                    let r2, s2;
                    const a2 = e.M(i2[o2].default);
                    if ("success" === a2.result && (r2 = a2.value.expression), t2 && void 0 !== t2[o2]) {
                      const i3 = e.M(t2[o2]);
                      "success" === i3.result && (s2 = i3.value.expression);
                    }
                    const { minValue: n2, maxValue: l2, stepValue: c2, type: h2, values: u2 } = i2[o2];
                    if (r2) {
                      const t3 = e.av(o2, this.scope);
                      this.options.set(t3, { default: r2, value: s2, minValue: n2, maxValue: l2, stepValue: c2, type: h2, values: u2 });
                    } else
                      this.fire(new e.t(new Error(`No schema defined for config option "${o2}".`)));
                  }
                else
                  this.fire(new e.t(new Error("Attempting to set config for a style without schema.")));
            }
            updateConfigDependencies(e2) {
              for (const t2 of this._configDependentLayers) {
                const i2 = this.getLayer(t2);
                if (i2) {
                  if (e2 && !i2.configDependencies.has(e2))
                    continue;
                  i2.possiblyEvaluateVisibility(), this._updateLayer(i2);
                }
              }
              this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.forEachFragmentStyle((e3) => {
                if (e3._styleColorTheme.colorTheme) {
                  const t2 = e3._evaluateColorThemeData(e3._styleColorTheme.colorTheme);
                  (!e3._styleColorTheme.lut && "" !== t2 || e3._styleColorTheme.lut && t2 !== e3._styleColorTheme.lut.data) && e3.setColorTheme(e3._styleColorTheme.colorTheme);
                }
              }), this._changes.setDirty();
            }
            addLayer(t2, i2, o2 = {}) {
              this._checkLoaded();
              const r2 = t2.id;
              if (this._layers[r2])
                return void this.fire(new e.t(new Error(`Layer with id "${r2}" already exists on this map`)));
              let s2;
              if ("custom" === t2.type) {
                if (ro(this, e.cp(t2)))
                  return;
                s2 = e.cq(t2, this.scope, this._styleColorTheme.lut, this.options);
              } else {
                if ("object" == typeof t2.source && (this.addSource(r2, t2.source), t2 = e.cl(t2), t2 = e.l(t2, { source: r2 })), this._validate(we, `layers.${r2}`, t2, { arrayIndex: -1 }, o2))
                  return;
                s2 = e.cq(t2, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(s2), s2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[s2.id] = s2.serialize();
              }
              0 !== s2.configDependencies.size && this._configDependentLayers.add(s2.fqid);
              let a2 = this._order.length;
              if (i2) {
                const t3 = this._order.indexOf(i2);
                if (-1 === t3)
                  return void this.fire(new e.t(new Error(`Layer with id "${i2}" does not exist on this map.`)));
                s2.slot === this._layers[i2].slot ? a2 = t3 : e.w(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`);
              }
              this._order.splice(a2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = s2;
              const n2 = this.getOwnLayerSourceCache(s2), l2 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              n2 && s2.canCastShadows() && l2 && (n2.castsShadows = true);
              const c2 = this._changes.getRemovedLayer(s2);
              if (c2 && s2.source && n2 && "custom" !== s2.type) {
                this._changes.discardLayerRemoval(s2);
                const t3 = e.av(s2.source, s2.scope);
                c2.type !== s2.type ? this._changes.updateSourceCache(t3, "clear") : (this._changes.updateSourceCache(t3, "reload"), n2.pause());
              }
              this._updateLayer(s2), s2.onAdd && s2.onAdd(this.map), s2.scope = this.scope, this.mergeLayers();
            }
            moveLayer(t2, i2) {
              this._checkLoaded();
              const o2 = this._checkLayer(t2);
              if (!o2)
                return;
              if (t2 === i2)
                return;
              const r2 = this._order.indexOf(t2);
              this._order.splice(r2, 1);
              let s2 = this._order.length;
              if (i2) {
                const t3 = this._order.indexOf(i2);
                if (-1 === t3)
                  return void this.fire(new e.t(new Error(`Layer with id "${i2}" does not exist on this map.`)));
                o2.slot === this._layers[i2].slot ? s2 = t3 : e.w(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`);
              }
              this._order.splice(s2, 0, t2), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
            }
            removeLayer(e2) {
              this._checkLoaded();
              const t2 = this._checkLayer(e2);
              if (!t2)
                return;
              t2.setEventedParent(null);
              const i2 = this._order.indexOf(e2);
              this._order.splice(i2, 1), delete this._layers[e2], delete this._serializedLayers[e2], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t2.fqid), this._changes.removeLayer(t2);
              const o2 = this.getOwnLayerSourceCache(t2);
              if (o2 && o2.castsShadows) {
                let e3 = false;
                for (const i3 in this._layers)
                  if (this._layers[i3].source === t2.source && this._layers[i3].canCastShadows()) {
                    e3 = true;
                    break;
                  }
                o2.castsShadows = e3;
              }
              t2.onRemove && t2.onRemove(this.map), this.mergeLayers();
            }
            getOwnLayer(e2) {
              return this._layers[e2];
            }
            hasLayer(e2) {
              return e2 in this._mergedLayers;
            }
            hasLayerType(e2) {
              for (const t2 in this._layers)
                if (this._layers[t2].type === e2)
                  return true;
              return false;
            }
            setLayerZoomRange(e2, t2, i2) {
              this._checkLoaded();
              const o2 = this._checkLayer(e2);
              o2 && (o2.minzoom === t2 && o2.maxzoom === i2 || (null != t2 && (o2.minzoom = t2), null != i2 && (o2.maxzoom = i2), this._updateLayer(o2)));
            }
            getSlots() {
              return this._checkLoaded(), this._mergedSlots;
            }
            setSlot(e2, t2) {
              this._checkLoaded();
              const i2 = this._checkLayer(e2);
              i2 && i2.slot !== t2 && (i2.slot = t2, this._updateLayer(i2));
            }
            setFilter(t2, i2, o2 = {}) {
              this._checkLoaded();
              const r2 = this._checkLayer(t2);
              if (r2 && !e.bh(r2.filter, i2))
                return null == i2 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(Te, `layers.${r2.id}.filter`, i2, { layerType: r2.type }, o2) || (r2.filter = e.cl(i2), this._updateLayer(r2)));
            }
            getFilter(t2) {
              const i2 = this._checkLayer(t2);
              if (i2)
                return e.cl(i2.filter);
            }
            setLayoutProperty(t2, i2, o2, r2 = {}) {
              this._checkLoaded();
              const s2 = this._checkLayer(t2);
              if (s2 && !e.bh(s2.getLayoutProperty(i2), o2)) {
                if (null != o2 && (!r2 || false !== r2.validate) && ro(s2, Ce.call(fe, { key: `layers.${t2}.layout.${i2}`, layerType: s2.type, objectKey: i2, value: o2, styleSpec: e._, style: { glyphs: true, sprite: true } })))
                  return;
                s2.setLayoutProperty(i2, o2), 0 !== s2.configDependencies.size && this._configDependentLayers.add(s2.fqid), this._updateLayer(s2);
              }
            }
            getLayoutProperty(e2, t2) {
              const i2 = this._checkLayer(e2);
              if (i2)
                return i2.getLayoutProperty(t2);
            }
            setPaintProperty(t2, i2, o2, r2 = {}) {
              this._checkLoaded();
              const s2 = this._checkLayer(t2);
              if (!s2)
                return;
              if (e.bh(s2.getPaintProperty(i2), o2))
                return;
              if (null != o2 && (!r2 || false !== r2.validate) && ro(s2, Ee.call(fe, { key: `layers.${t2}.paint.${i2}`, layerType: s2.type, objectKey: i2, value: o2, styleSpec: e._ })))
                return;
              const a2 = s2.setPaintProperty(i2, o2);
              0 !== s2.configDependencies.size && this._configDependentLayers.add(s2.fqid), a2 && this._updateLayer(s2), this._changes.updatePaintProperties(s2);
            }
            getPaintProperty(e2, t2) {
              const i2 = this._checkLayer(e2);
              if (i2)
                return i2.getPaintProperty(t2);
            }
            setFeatureState(t2, i2) {
              this._checkLoaded();
              const o2 = t2.source, r2 = t2.sourceLayer, s2 = this._checkSource(o2);
              if (!s2)
                return;
              const a2 = s2.type;
              if ("geojson" === a2 && r2)
                return void this.fire(new e.t(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
              if ("vector" === a2 && !r2)
                return void this.fire(new e.t(new Error("The sourceLayer parameter must be provided for vector source types.")));
              void 0 === t2.id && this.fire(new e.t(new Error("The feature id parameter must be provided.")));
              const n2 = this.getOwnSourceCaches(o2);
              for (const e2 of n2)
                e2.setFeatureState(r2, t2.id, i2);
            }
            removeFeatureState(t2, i2) {
              this._checkLoaded();
              const o2 = t2.source, r2 = this._checkSource(o2);
              if (!r2)
                return;
              const s2 = r2.type, a2 = "vector" === s2 ? t2.sourceLayer : void 0;
              if ("vector" === s2 && !a2)
                return void this.fire(new e.t(new Error("The sourceLayer parameter must be provided for vector source types.")));
              if (i2 && "string" != typeof t2.id && "number" != typeof t2.id)
                return void this.fire(new e.t(new Error("A feature id is required to remove its specific state property.")));
              const n2 = this.getOwnSourceCaches(o2);
              for (const e2 of n2)
                e2.removeFeatureState(a2, t2.id, i2);
            }
            getFeatureState(t2) {
              this._checkLoaded();
              const i2 = t2.source, o2 = t2.sourceLayer, r2 = this._checkSource(i2);
              if (r2) {
                if ("vector" !== r2.type || o2)
                  return void 0 === t2.id && this.fire(new e.t(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i2)[0].getFeatureState(o2, t2.id);
                this.fire(new e.t(new Error("The sourceLayer parameter must be provided for vector source types.")));
              }
            }
            setTransition(t2) {
              return this.stylesheet.transition = e.l({}, this.stylesheet.transition, t2), this.transition = this.stylesheet.transition, this;
            }
            getTransition() {
              return e.l({}, this.stylesheet.transition);
            }
            serialize() {
              this._checkLoaded();
              const t2 = this.getTerrain(), i2 = t2 && this.terrain && this.terrain.scope === this.scope ? t2 : this.stylesheet.terrain;
              return e.cr({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i2, fog: this.stylesheet.fog, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
            }
            _updateLayer(t2) {
              this._changes.updateLayer(t2);
              const i2 = this.getLayerSourceCache(t2), o2 = e.av(t2.source, t2.scope), r2 = this._changes.getUpdatedSourceCaches();
              t2.source && !r2[o2] && i2 && "raster" !== i2.getSource().type && (this._changes.updateSourceCache(o2, "reload"), i2.pause()), t2.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e2) {
              const t2 = (e3) => this._mergedLayers[e3].is3D(), i2 = this.order, o2 = {}, r2 = [];
              for (let s3 = i2.length - 1; s3 >= 0; s3--) {
                const a2 = i2[s3];
                if (t2(a2)) {
                  o2[a2] = s3;
                  for (const t3 of e2) {
                    const e3 = t3[a2];
                    if (e3)
                      for (const t4 of e3)
                        r2.push(t4);
                  }
                }
              }
              r2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
              const s2 = [];
              for (let a2 = i2.length - 1; a2 >= 0; a2--) {
                const n2 = i2[a2];
                if (t2(n2))
                  for (let e3 = r2.length - 1; e3 >= 0; e3--) {
                    const t3 = r2[e3].feature;
                    if (t3.layer && o2[t3.layer.id] < a2)
                      break;
                    s2.push(t3), r2.pop();
                  }
                else
                  for (const t3 of e2) {
                    const e3 = t3[n2];
                    if (e3)
                      for (const t4 of e3)
                        s2.push(t4.feature);
                  }
              }
              return s2;
            }
            queryRenderedFeatures(t2, i2, o2) {
              i2 && i2.filter && this._validate(Te, "queryRenderedFeatures.filter", i2.filter, null, i2), i2.scope = this.scope, i2.availableImages = this._availableImages, i2.serializedLayers = this._serializedLayers;
              const r2 = {};
              if (i2 && i2.layers) {
                if (!Array.isArray(i2.layers))
                  return this.fire(new e.t(new Error("parameters.layers must be an Array."))), [];
                for (const t3 of i2.layers) {
                  const i3 = this._mergedLayers[t3];
                  if (!i3)
                    return this.fire(new e.t(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                  r2[i3.source] = true;
                }
              }
              const s2 = [], a2 = i2.serializedLayers || {}, n2 = i2 && i2.layers ? i2.layers.some((e2) => {
                const t3 = this.getLayer(e2);
                return t3 && t3.is3D();
              }) : this.has3DLayers(), l2 = Ze.createFromScreenPoints(t2, o2);
              for (const e2 in this._mergedSourceCaches) {
                const t3 = this._mergedSourceCaches[e2].getSource();
                if (!t3 || t3.scope !== i2.scope)
                  continue;
                const c2 = this._mergedSourceCaches[e2].getSource().id;
                i2.layers && !r2[c2] || s2.push(ot(this._mergedSourceCaches[e2], this._mergedLayers, a2, l2, i2, o2, n2, !!this.map._showQueryGeometry));
              }
              return this.placement && s2.push(function(e2, t3, i3, o3, r3, s3, a3) {
                const n3 = {}, l3 = s3.queryRenderedSymbols(o3), c2 = [];
                for (const e3 of Object.keys(l3).map(Number))
                  c2.push(a3[e3]);
                c2.sort(st);
                for (const i4 of c2) {
                  const o4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, e2);
                  for (const e3 in o4) {
                    const t4 = n3[e3] = n3[e3] || [], r4 = o4[e3];
                    r4.sort((e4, t5) => {
                      const o5 = i4.featureSortOrder;
                      if (o5) {
                        const i5 = o5.indexOf(e4.featureIndex);
                        return o5.indexOf(t5.featureIndex) - i5;
                      }
                      return t5.featureIndex - e4.featureIndex;
                    });
                    for (const e4 of r4)
                      t4.push(e4);
                  }
                }
                for (const t4 in n3)
                  n3[t4].forEach((o4) => {
                    const r4 = o4.feature, s4 = i3(e2[t4]);
                    if (!s4)
                      return;
                    const a4 = s4.getFeatureState(r4.layer["source-layer"], r4.id);
                    r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = a4;
                  });
                return n3;
              }(this._mergedLayers, a2, this.getLayerSourceCache.bind(this), l2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s2);
            }
            querySourceFeatures(e2, t2) {
              t2 && t2.filter && this._validate(Te, "querySourceFeatures.filter", t2.filter, null, t2);
              const i2 = this.getOwnSourceCaches(e2);
              let o2 = [];
              for (const e3 of i2)
                o2 = o2.concat(rt(e3, t2));
              return o2;
            }
            addSourceType(e2, t2, i2) {
              return co.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (co.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
            }
            getFlatLight() {
              return this.light.getLight();
            }
            setFlatLight(t2, i2, o2 = {}) {
              this._checkLoaded();
              const r2 = this.light.getLight();
              let s2 = false;
              for (const i3 in t2)
                if (!e.bh(t2[i3], r2[i3])) {
                  s2 = true;
                  break;
                }
              if (!s2)
                return;
              const a2 = this._getTransitionParameters();
              this.light.setLight(t2, i2, o2), this.light.updateTransitions(a2);
            }
            getTerrain() {
              return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
              this.setTerrain({ source: "", exaggeration: 0 }, 0);
            }
            checkCanvasFingerprintNoise() {
              void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
            }
            setTerrain(t2, i2 = 1) {
              if (this._checkLoaded(), !t2)
                return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i2 && delete this.terrain, null === t2 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
              this.checkCanvasFingerprintNoise();
              let o2 = t2;
              const r2 = null == t2.source;
              if (1 === i2) {
                if (this.disableElevatedTerrain)
                  return;
                if ("object" == typeof o2.source) {
                  const t4 = "terrain-dem-src";
                  this.addSource(t4, o2.source), o2 = e.cl(o2), o2 = e.l(o2, { source: t4 });
                }
                const t3 = e.l({}, o2), i3 = {};
                if (this.terrain && r2) {
                  t3.source = this.terrain.get().source;
                  const e2 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                  e2 && (i3.style = e2.serialize());
                }
                if (this._validate(ye, "terrain", t3, i3))
                  return;
              }
              if (!this.terrain || this.terrain.scope !== this.scope && !r2 || this.terrain && i2 !== this.terrain.drapeRenderMode) {
                if (!o2)
                  return;
                this._createTerrain(o2, i2), this.fire(new e.x("data", { dataType: "style" }));
              } else {
                const i3 = this.terrain, r3 = i3.get();
                for (const t3 of Object.keys(e._.terrain))
                  !o2.hasOwnProperty(t3) && e._.terrain[t3].default && (o2[t3] = e._.terrain[t3].default);
                for (const o3 in t2)
                  if (!e.bh(t2[o3], r3[o3])) {
                    i3.set(t2, this.options), this.stylesheet.terrain = t2;
                    const o4 = this._getTransitionParameters({ duration: 0 });
                    i3.updateTransitions(o4), this.fire(new e.x("data", { dataType: "style" }));
                    break;
                  }
              }
              this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
            }
            _createFog(e2) {
              const t2 = this.fog = new Ge(e2, this.map.transform, this.scope, this.options);
              this.stylesheet.fog = t2.get();
              const i2 = this._getTransitionParameters({ duration: 0 });
              t2.updateTransitions(i2);
            }
            _updateMarkersOpacity() {
              0 !== this.map._markers.length && this.map._requestDomTask(() => {
                for (const e2 of this.map._markers)
                  e2._evaluateOpacity();
              });
            }
            getFog() {
              return this.fog ? this.fog.get() : null;
            }
            setFog(t2) {
              if (this._checkLoaded(), !t2)
                return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
              if (this.fog) {
                const i2 = this.fog;
                if (!e.bh(i2.get(), t2)) {
                  i2.set(t2, this.options), this.stylesheet.fog = i2.get();
                  const e2 = this._getTransitionParameters({ duration: 0 });
                  i2.updateTransitions(e2);
                }
              } else
                this._createFog(t2);
              this._markersNeedUpdate = true;
            }
            setColorTheme(t2) {
              this._checkLoaded();
              const i2 = () => {
                for (const e2 in this._layers)
                  this._layers[e2].lut = this._styleColorTheme.lut;
                for (const e2 in this._sourceCaches)
                  this._sourceCaches[e2].clearTiles();
              };
              if (this._styleColorTheme.colorTheme = t2, !t2)
                return this._styleColorTheme.lut = null, void i2();
              const o2 = this._evaluateColorThemeData(t2);
              this._loadColorTheme(o2).then(() => {
                this.fire(new e.x("colorthemeset")), i2();
              }).catch((t3) => {
                e.w(`Couldn't set color theme: ${t3}`);
              });
            }
            _getTransitionParameters(t2) {
              return { now: e.q.now(), transition: e.l(this.transition, t2) };
            }
            updateDrapeFirstLayers() {
              if (!this.terrain)
                return;
              const e2 = [], t2 = [];
              for (const i2 of this._mergedOrder)
                this.isLayerDraped(this._mergedLayers[i2]) ? e2.push(i2) : t2.push(i2);
              this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
            }
            _createTerrain(e2, t2) {
              const i2 = this.terrain = new Pe(e2, t2, this.scope, this.options);
              1 === t2 && (this.stylesheet.terrain = e2), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
              const o2 = this._getTransitionParameters({ duration: 0 });
              i2.updateTransitions(o2);
            }
            _force3DLayerUpdate() {
              for (const e2 in this._layers) {
                const t2 = this._layers[e2];
                "fill-extrusion" === t2.type && this._updateLayer(t2);
              }
            }
            _forceSymbolLayerUpdate() {
              for (const e2 in this._layers) {
                const t2 = this._layers[e2];
                "symbol" === t2.type && this._updateLayer(t2);
              }
            }
            _validate(t2, i2, o2, r2, s2 = {}) {
              if (s2 && false === s2.validate)
                return false;
              const a2 = e.l({}, this.serialize());
              return ro(this, t2.call(fe, e.l({ key: i2, style: a2, value: o2, styleSpec: e._ }, r2)));
            }
            _remove() {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.cs.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const e2 in this._mergedLayers)
                this._mergedLayers[e2].setEventedParent(null);
              for (const e2 in this._mergedSourceCaches)
                this._mergedSourceCaches[e2].clearTiles(), this._mergedSourceCaches[e2].setEventedParent(null);
              this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
            }
            clearSource(e2) {
              const t2 = this.getSourceCaches(e2);
              for (const e3 of t2)
                e3.clearTiles();
            }
            clearSources() {
              for (const e2 in this._mergedSourceCaches)
                this._mergedSourceCaches[e2].clearTiles();
            }
            reloadSource(e2) {
              const t2 = this.getSourceCaches(e2);
              for (const e3 of t2)
                e3.resume(), e3.reload();
            }
            reloadSources() {
              for (const e2 of this.getSources())
                e2.reload && e2.reload();
            }
            updateSources(e2) {
              let t2;
              this.directionalLight && (t2 = Qi(this.directionalLight));
              for (const i2 in this._mergedSourceCaches)
                this._mergedSourceCaches[i2].update(e2, void 0, void 0, t2);
            }
            _generateCollisionBoxes() {
              for (const e2 in this._sourceCaches) {
                const t2 = this._sourceCaches[e2];
                t2.resume(), t2.reload();
              }
            }
            _updatePlacement(t2, i2, o2, r2, s2, a2, n2 = false) {
              let l2 = false, c2 = false;
              const h2 = {}, u2 = {};
              for (const t3 of this._mergedOrder) {
                const o3 = this._mergedLayers[t3];
                if ("symbol" !== o3.type)
                  continue;
                const r3 = e.av(o3.source, o3.scope);
                let s3 = h2[r3];
                if (!s3) {
                  const e2 = this.getLayerSourceCache(o3);
                  if (!e2)
                    continue;
                  const t4 = e2.getRenderableIds(true).map((t5) => e2.getTileByID(t5));
                  u2[r3] = t4.slice(), s3 = h2[r3] = t4.sort((e3, t5) => t5.tileID.overscaledZ - e3.tileID.overscaledZ || (e3.tileID.isLessThan(t5.tileID) ? -1 : 1));
                }
                const a3 = this.crossTileSymbolIndex.addLayer(o3, s3, i2.center.lng, i2.projection);
                l2 = l2 || a3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), n2 = n2 || this._layerOrderChanged || 0 === r2, this._layerOrderChanged && this.fire(new e.x("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.q.now(), i2.zoom)) && (this.pauseablePlacement = new Ti(i2, this._mergedOrder, n2, o2, r2, s2, this.placement, this.fog && i2.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h2, u2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.q.now()), c2 = true), l2 && this.pauseablePlacement.placement.setStale()), c2 || l2) {
                this._buildingIndex.onNewFrame(i2.zoom);
                for (let t3 = 0; t3 < this._mergedOrder.length; t3++) {
                  const i3 = this._mergedLayers[this._mergedOrder[t3]];
                  if ("symbol" !== i3.type)
                    continue;
                  const o3 = this.isLayerClipped(i3);
                  this.placement.updateLayerOpacities(i3, h2[e.av(i3.source, i3.scope)], t3, o3 ? a2 : null);
                }
              }
              return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.q.now()) };
            }
            _releaseSymbolFadeTiles() {
              for (const e2 in this._sourceCaches)
                this._sourceCaches[e2].releaseSymbolFadeTiles();
            }
            addImport(t2, i2) {
              this._checkLoaded();
              const o2 = this.stylesheet.imports = this.stylesheet.imports || [];
              if (-1 !== o2.findIndex(({ id: e2 }) => e2 === t2.id))
                return void this.fire(new e.t(new Error(`Import with id '${t2.id}' already exists in the map's style.`)));
              if (!i2)
                return o2.push(t2), this._loadImports([t2], true);
              const r2 = o2.findIndex(({ id: e2 }) => e2 === i2);
              return -1 === r2 && this.fire(new e.t(new Error(`Import with id "${i2}" does not exist on this map.`))), this.stylesheet.imports = o2.slice(0, r2).concat(t2).concat(o2.slice(r2)), this._loadImports([t2], true, i2);
            }
            updateImport(t2, i2) {
              this._checkLoaded();
              const o2 = this.stylesheet.imports || [], r2 = this.getImportIndex(t2);
              return -1 === r2 ? this : "string" == typeof i2 ? (this.setImportUrl(t2, i2), this) : (i2.url && i2.url !== o2[r2].url && this.setImportUrl(t2, i2.url), e.bh(i2.config, o2[r2].config) || this.setImportConfig(t2, i2.config), e.bh(i2.data, o2[r2].data) || this.setImportData(t2, i2.data), this);
            }
            moveImport(e2, t2) {
              this._checkLoaded();
              let i2 = this.stylesheet.imports || [];
              const o2 = this.getImportIndex(e2);
              if (-1 === o2)
                return this;
              const r2 = this.getImportIndex(t2);
              if (-1 === r2)
                return this;
              const s2 = i2[o2], a2 = this.fragments[o2];
              return i2 = i2.filter(({ id: t3 }) => t3 !== e2), this.fragments = this.fragments.filter(({ id: t3 }) => t3 !== e2), this.stylesheet.imports = i2.slice(0, r2).concat(s2).concat(i2.slice(r2)), this.fragments = this.fragments.slice(0, r2).concat(a2).concat(this.fragments.slice(r2)), this.mergeLayers(), this;
            }
            setImportUrl(e2, t2) {
              this._checkLoaded();
              const i2 = this.stylesheet.imports || [], o2 = this.getImportIndex(e2);
              if (-1 === o2)
                return this;
              i2[o2].url = t2;
              const r2 = this.fragments[o2];
              return r2.style = this._createFragmentStyle(i2[o2]), r2.style.on("style.import.load", () => this.mergeAll()), r2.style.loadURL(t2), this;
            }
            setImportData(e2, t2) {
              this._checkLoaded();
              const i2 = this.getImportIndex(e2), o2 = this.stylesheet.imports || [];
              return -1 === i2 ? this : t2 ? (this.fragments[i2].style.setState(t2), this._reloadImports(), this) : (delete o2[i2].data, this.setImportUrl(e2, o2[i2].url));
            }
            setImportConfig(e2, t2) {
              this._checkLoaded();
              const i2 = this.getImportIndex(e2), o2 = this.stylesheet.imports || [];
              if (-1 === i2)
                return this;
              t2 ? o2[i2].config = t2 : delete o2[i2].config;
              const r2 = this.fragments[i2], s2 = r2.style.stylesheet && r2.style.stylesheet.schema;
              return r2.config = t2, r2.style.updateConfig(t2, s2), this.updateConfigDependencies(), this;
            }
            removeImport(e2) {
              this._checkLoaded();
              const t2 = this.stylesheet.imports || [], i2 = this.getImportIndex(e2);
              -1 !== i2 && (t2.splice(i2, 1), this.fragments[i2].style._remove(), this.fragments.splice(i2, 1), this._reloadImports());
            }
            getImportIndex(t2) {
              const i2 = (this.stylesheet.imports || []).findIndex((e2) => e2.id === t2);
              return -1 === i2 && this.fire(new e.t(new Error(`Import '${t2}' does not exist in the map's style and cannot be updated.`))), i2;
            }
            getLayer(e2) {
              return this._mergedLayers[e2];
            }
            getSources() {
              const e2 = [];
              for (const t2 in this._mergedOtherSourceCaches) {
                const i2 = this._mergedOtherSourceCaches[t2];
                i2 && e2.push(i2.getSource());
              }
              return e2;
            }
            getSource(e2, t2) {
              const i2 = this.getSourceCache(e2, t2);
              return i2 && i2.getSource();
            }
            getLayerSource(e2) {
              const t2 = this.getLayerSourceCache(e2);
              return t2 && t2.getSource();
            }
            getSourceCache(t2, i2) {
              const o2 = e.av(t2, i2);
              return this._mergedOtherSourceCaches[o2];
            }
            getLayerSourceCache(t2) {
              const i2 = e.av(t2.source, t2.scope);
              return "symbol" === t2.type ? this._mergedSymbolSourceCaches[i2] : this._mergedOtherSourceCaches[i2];
            }
            getSourceCaches(e2) {
              if (null == e2)
                return Object.values(this._mergedSourceCaches);
              const t2 = [];
              return this._mergedOtherSourceCaches[e2] && t2.push(this._mergedOtherSourceCaches[e2]), this._mergedSymbolSourceCaches[e2] && t2.push(this._mergedSymbolSourceCaches[e2]), t2;
            }
            updateSourceCaches() {
              const e2 = this._changes.getUpdatedSourceCaches();
              for (const t2 in e2) {
                const i2 = e2[t2];
                "reload" === i2 ? this.reloadSource(t2) : "clear" === i2 && this.clearSource(t2);
              }
            }
            updateLayers(e2) {
              const t2 = this._changes.getUpdatedPaintProperties();
              for (const i2 of t2) {
                const t3 = this.getLayer(i2);
                t3 && t3.updateTransitions(e2);
              }
            }
            getImages(e2, t2, i2) {
              this.imageManager.getImages(t2.icons, t2.scope, i2), this._updateTilesForChangedImages();
              const o2 = (e3) => {
                e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
              };
              o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
            }
            getGlyphs(e2, t2, i2) {
              this.glyphManager.getGlyphs(t2.stacks, t2.scope, i2);
            }
            getResource(t2, i2, o2) {
              return e.ct(i2, o2);
            }
            getOwnSourceCache(e2) {
              return this._otherSourceCaches[e2];
            }
            getOwnLayerSourceCache(e2) {
              return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
            }
            getOwnSourceCaches(e2) {
              const t2 = [];
              return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
            }
            _isSourceCacheLoaded(t2) {
              const i2 = this.getOwnSourceCaches(t2);
              return 0 === i2.length ? (this.fire(new e.t(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
            }
            has3DLayers() {
              return this._has3DLayers;
            }
            hasSymbolLayers() {
              return this._hasSymbolLayers;
            }
            hasCircleLayers() {
              return this._hasCircleLayers;
            }
            isLayerClipped(e2, t2) {
              if (!this._clipLayerPresent && "fill-extrusion" !== e2.type)
                return false;
              const i2 = "fill-extrusion" === e2.type && "building" === e2.sourceLayer;
              if (e2.is3D()) {
                if (i2 || t2 && "batched-model" === t2.type)
                  return true;
                if ("model" === e2.type)
                  return true;
              } else if ("symbol" === e2.type)
                return true;
              return false;
            }
            _clearWorkerCaches() {
              this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
              this._clearWorkerCaches(), this.fragments.forEach((e2) => {
                e2.style._remove();
              }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
          }
          co.getSourceType = function(e2) {
            return et[e2];
          }, co.setSourceType = function(e2, t2) {
            et[e2] = t2;
          }, co.registerForPluginStateChange = e.cc;
          var ho = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", uo = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", _o = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", po = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", mo = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION", fo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", go = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", vo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", xo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", yo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", bo = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
          const wo = [];
          Do(ho, wo), Do(_o, wo), Do(uo, wo);
          const To = { "_prelude_fog.vertex.glsl": fo, "_prelude_terrain.vertex.glsl": mo, "_prelude_shadow.vertex.glsl": yo, "_prelude_fog.fragment.glsl": go, "_prelude_shadow.fragment.glsl": bo, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": vo, "_prelude_raster_particle.glsl": xo }, Eo = {};
          Ro("", mo), Ro(go, fo), Ro(bo, yo), Ro(vo, ""), Ro(xo, "");
          const Co = Ro(uo, _o), So = ho;
          var Io = { background: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), circle: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float opacity_t=smoothstep((1.0-blur_positive)*antialiased_blur,blur_positive*antialiased_blur,extrude_length-1.0)-smoothstep(0.0,antialiasblur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: Ro("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ro('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: Ro("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Ro("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: Ro("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ro("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), fill: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutline: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: Ro("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: Ro('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: Ro("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: Ro("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=out_color.a;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trim_alpha,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin float a_z_offset;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\n#ifdef ELEVATED_ROADS\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 halfCellProgress=normal.yx*32.0;float ele0=elevation(pos);float ele_line=max(ele0,max(elevation(pos+halfCellProgress),elevation(pos-halfCellProgress)));float ele1=elevation(pos+offsetTile);float ele2=elevation(pos-offsetTile);float ele_max=max(ele_line,0.5*(ele1+ele2));float ele=ele_max-ele0+ele1+a_z_offset ;gl_Position=u_matrix*vec4(pos+offsetTile,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*0.1*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), linePattern: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\n#endif\n#ifdef LINE_JOIN_NONE\nfloat pattern_len=pattern_size/aspect;float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin float a_z_offset;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\n#ifdef ELEVATED_ROADS\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 halfCellProgress=normal.yx*32.0;float ele0=elevation(pos);float ele_line=max(ele0,max(elevation(pos+halfCellProgress),elevation(pos-halfCellProgress)));float ele1=elevation(pos+offsetTile);float ele2=elevation(pos-offsetTile);float ele_max=max(ele_line,0.5*(ele1+ele2));float ele=ele_max-ele0+ele1+a_z_offset ;gl_Position=u_matrix*vec4(pos+offsetTile,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*0.1*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef LINE_JOIN_NONE\nv_width=floorwidth+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), raster: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: Ro("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: Ro("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Ro('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Ro('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#else\nz+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n}'), terrainRaster: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: Ro("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: Ro('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', po), skyboxGradient: Ro('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', po), skyboxCapture: Ro("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: Ro('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: Ro('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: Ro("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: Ro("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"), occlusion: Ro("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}') };
          function Do(e2, t2) {
            const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e3 of i2)
              if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
                e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i3 = e3.split(" ");
                for (const e4 of i3)
                  t2.includes(e4) || t2.push(e4);
              }
          }
          function Ro(e2, t2) {
            const i2 = /#include\s+"([^"]+)"/g, o2 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
            let r2 = t2.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
            r2 && (r2 = r2.map((e3) => {
              const t3 = e3.split(" ");
              return t3[t3.length - 1];
            }), r2 = [...new Set(r2)]);
            const s2 = {}, a2 = [], n2 = [];
            if (e2 = e2.replace(i2, (e3, t3) => (n2.push(t3), "")), (t2 = t2.replace(i2, (e3, t3) => (a2.push(t3), ""))).includes("flat out"))
              return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
            let l2 = [...wo];
            Do(e2, l2), Do(t2, l2);
            for (const e3 of [...a2, ...n2])
              To[e3] || console.error(`Undefined include: ${e3}`), Eo[e3] || (Eo[e3] = [], Do(To[e3], Eo[e3])), l2 = [...l2, ...Eo[e3]];
            return { fragmentSource: e2 = e2.replace(o2, (e3, t3, i3, o3, r3) => (s2[r3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
in ${i3} ${o3} ${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "initialize" === t3 ? `
#ifdef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    in ${i3} ${o3} ${r3};
#endif
` : "initialize-attribute" === t3 ? "" : void 0)), vertexSource: t2 = t2.replace(o2, (e3, t3, i3, o3, r3) => {
              const a3 = "float" === o3 ? "vec2" : o3, n3 = r3.match(/color/) ? "color" : a3;
              return "define-attribute-vertex-shader-only" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
in ${i3} ${o3} a_${r3};
#endif
` : s2[r3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${a3} a_${r3};
out ${i3} ${o3} ${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "initialize" === t3 ? "vec4" === n3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = a_${r3};
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = unpack_mix_${n3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    in ${i3} ${o3} a_${r3};
    out ${i3} ${o3} ${r3};
#endif
` : "initialize-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    ${r3} = a_${r3};
#endif
` : void 0 : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${a3} a_${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "define-instanced" === t3 ? "mat4" === n3 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${r3}0;
in vec4 a_${r3}1;
in vec4 a_${r3}2;
in vec4 a_${r3}3;
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i3} ${a3} a_${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "initialize-attribute-custom" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    ${i3} ${o3} ${r3} = a_${r3};
#endif
` : "vec4" === n3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = a_${r3};
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = unpack_mix_${n3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
`;
            }), staticAttributes: r2, usedDefines: l2, vertexIncludes: a2, fragmentIncludes: n2 };
          }
          class Ao {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e2, t2, i2, o2, r2, s2, a2, n2) {
              this.context = e2;
              let l2 = this.boundPaintVertexBuffers.length !== o2.length;
              for (let e3 = 0; !l2 && e3 < o2.length; e3++)
                this.boundPaintVertexBuffers[e3] !== o2[e3] && (l2 = true);
              let c2 = this.boundDynamicVertexBuffers.length !== a2.length;
              for (let e3 = 0; !c2 && e3 < a2.length; e3++)
                this.boundDynamicVertexBuffers[e3] !== a2[e3] && (c2 = true);
              if (!this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || l2 || c2 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== s2)
                this.freshBind(t2, i2, o2, r2, s2, a2, n2);
              else {
                e2.bindVertexArrayOES.set(this.vao);
                for (const i3 of a2)
                  i3 && (i3.bind(), n2 && i3.instanceCount && i3.setVertexAttribDivisor(e2.gl, t2, n2));
                r2 && r2.dynamicDraw && r2.bind();
              }
            }
            freshBind(e2, t2, i2, o2, r2, s2, a2) {
              const n2 = e2.numAttributes, l2 = this.context, c2 = l2.gl;
              this.vao && this.destroy(), this.vao = l2.gl.createVertexArray(), l2.bindVertexArrayOES.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffers = s2, t2.enableAttributes(c2, e2), t2.bind(), t2.setVertexAttribPointers(c2, e2, r2);
              for (const t3 of i2)
                t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r2);
              for (const t3 of s2)
                t3 && (t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, r2), a2 && t3.instanceCount && t3.setVertexAttribDivisor(c2, e2, a2));
              o2 && o2.bind(), l2.currentNumAttributes = n2;
            }
            destroy() {
              this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
            }
          }
          function Lo(t2, i2) {
            const o2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
            return [new e.a5(0, r2 / o2).toLngLat().lat, new e.a5(0, (r2 + 1) / o2).toLngLat().lat];
          }
          function Po(t2, i2, o2, r2, s2, a2, n2) {
            const l2 = t2.context, c2 = l2.gl, h2 = o2.hillshadeFBO;
            if (!h2)
              return;
            t2.prepareDrawTile();
            const u2 = t2.isTileAffectedByFog(i2), d2 = t2.getOrCreateProgram("hillshade", { overrideFog: u2 });
            l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment.get());
            const _2 = ((t3, i3, o3, r3) => {
              const s3 = o3.paint.get("hillshade-shadow-color"), a3 = o3.paint.get("hillshade-highlight-color"), n3 = o3.paint.get("hillshade-accent-color"), l3 = o3.paint.get("hillshade-emissive-strength");
              let c3 = e.bB(o3.paint.get("hillshade-illumination-direction"));
              if ("viewport" === o3.paint.get("hillshade-illumination-anchor"))
                c3 -= t3.transform.angle;
              else if (t3.style && t3.style.enable3dLights() && t3.style.directionalLight) {
                const i4 = t3.style.directionalLight.properties.get("direction"), o4 = e.c7(i4.x, i4.y, i4.z);
                c3 = e.bB(o4[1]);
              }
              const h3 = !t3.options.moving;
              return { u_matrix: r3 || t3.transform.calculateProjMatrix(i3.tileID.toUnwrapped(), h3), u_image: 0, u_latrange: Lo(0, i3.tileID), u_light: [o3.paint.get("hillshade-exaggeration"), c3], u_shadow: s3.toRenderColor(o3.lut), u_highlight: a3.toRenderColor(o3.lut), u_emissive_strength: l3, u_accent: n3.toRenderColor(o3.lut) };
            })(t2, o2, r2, t2.terrain ? i2.projMatrix : null);
            t2.uploadCommonUniforms(l2, d2, i2.toUnwrapped());
            const { tileBoundsBuffer: p2, tileBoundsIndexBuffer: m2, tileBoundsSegments: f2 } = t2.getTileBoundsBuffers(o2);
            d2.draw(t2, c2.TRIANGLES, s2, a2, n2, Fi.disabled, _2, r2.id, p2, m2, f2);
          }
          function Mo(t2, i2, o2) {
            if (!i2.needsDEMTextureUpload)
              return;
            const r2 = t2.context, s2 = r2.gl;
            r2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
            const a2 = o2.getPixels();
            i2.demTexture ? i2.demTexture.update(a2, { premultiply: false }) : i2.demTexture = new e.T(r2, a2, s2.R32F, { premultiply: false }), i2.needsDEMTextureUpload = false;
          }
          function zo(t2, i2, o2) {
            const r2 = t2.context, s2 = r2.gl;
            if (!i2.dem)
              return;
            const a2 = i2.dem;
            if (r2.activeTexture.set(s2.TEXTURE1), Mo(t2, i2, a2), !i2.demTexture)
              return;
            i2.demTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE);
            const n2 = a2.dim;
            r2.activeTexture.set(s2.TEXTURE0);
            let l2 = i2.hillshadeFBO;
            if (!l2) {
              const t3 = new e.T(r2, { width: n2, height: n2, data: null }, s2.RGBA8);
              t3.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), l2 = i2.hillshadeFBO = r2.createFramebuffer(n2, n2, true, "renderbuffer"), l2.colorAttachment.set(t3.texture);
            }
            r2.bindFramebuffer.set(l2.framebuffer), r2.viewport.set([0, 0, n2, n2]);
            const { tileBoundsBuffer: c2, tileBoundsIndexBuffer: h2, tileBoundsSegments: u2 } = t2.getMercatorTileBoundsBuffers(), d2 = [];
            t2.linearFloatFilteringSupported() && d2.push("TERRAIN_DEM_FLOAT_FORMAT"), t2.getOrCreateProgram("hillshadePrepare", { defines: d2 }).draw(t2, s2.TRIANGLES, Li.disabled, Mi.disabled, Ai.unblended, Fi.disabled, ((t3, i3) => {
              const o3 = i3.stride, r3 = e.a6.mat4.create();
              return e.a6.mat4.ortho(r3, 0, e.ab, -e.ab, 0, 0, 1), e.a6.mat4.translate(r3, r3, [0, -e.ab, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ };
            })(i2.tileID, a2), o2.id, c2, h2, u2), i2.needsHillshadePrepare = false;
          }
          class Oo {
            constructor(e2) {
              this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(e2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class Fo extends Oo {
            getDefault() {
              return e.bz.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class ko extends Oo {
            getDefault() {
              return 1;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
            }
          }
          class Bo extends Oo {
            getDefault() {
              return 0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
            }
          }
          class No extends Oo {
            getDefault() {
              return [true, true, true, true];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class Uo extends Oo {
            getDefault() {
              return true;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class Go extends Oo {
            getDefault() {
              return 255;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class jo extends Oo {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(e2) {
              const t2 = this.current;
              (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
            }
          }
          class Vo extends Oo {
            getDefault() {
              const e2 = this.gl;
              return [e2.KEEP, e2.KEEP, e2.KEEP];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
            }
          }
          class qo extends Oo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
            }
          }
          class Zo extends Oo {
            getDefault() {
              return [0, 1];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
            }
          }
          class Ho extends Oo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
            }
          }
          class Wo extends Oo {
            getDefault() {
              return this.gl.LESS;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
            }
          }
          class $o extends Oo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
            }
          }
          class Xo extends Oo {
            getDefault() {
              const e2 = this.gl;
              return [e2.ONE, e2.ZERO, e2.ONE, e2.ZERO];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class Yo extends Oo {
            getDefault() {
              return e.bz.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class Ko extends Oo {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e2, e2), this.current = e2, this.dirty = false);
            }
          }
          class Jo extends Oo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
            }
          }
          class Qo extends Oo {
            getDefault() {
              return this.gl.BACK;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
            }
          }
          class er extends Oo {
            getDefault() {
              return this.gl.CCW;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
            }
          }
          let tr = class extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
            }
          };
          class ir extends Oo {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
            }
          }
          class or extends Oo {
            getDefault() {
              const e2 = this.gl;
              return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class rr extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class sr extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class ar extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
            }
          }
          class nr extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class lr extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              const t2 = this.gl;
              t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class cr extends Oo {
            getDefault() {
              return null;
            }
            set(e2) {
              this.gl && (e2 !== this.current || this.dirty) && (this.gl.bindVertexArray(e2), this.current = e2, this.dirty = false);
            }
          }
          class hr extends Oo {
            getDefault() {
              return 4;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
            }
          }
          class ur extends Oo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class dr extends Oo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class _r extends Oo {
            constructor(e2, t2) {
              super(e2), this.context = e2, this.parent = t2;
            }
            getDefault() {
              return null;
            }
          }
          class pr extends _r {
            setDirty() {
              this.dirty = true;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
            }
          }
          class mr extends _r {
            attachment() {
              return this.gl.DEPTH_ATTACHMENT;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class fr extends _r {
            attachment() {
              return this.gl.DEPTH_ATTACHMENT;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferTexture2D(t2.FRAMEBUFFER, this.attachment(), t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
            }
          }
          class gr extends mr {
            attachment() {
              return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
          }
          const vr = (e2, t2, i2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2, u_ground_shadow_factor: i2 }), xr = (e2, t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r2, u_merc_center: s2, u_image0: 0, u_frustum_tl: a2, u_frustum_tr: n2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h2, u_globe_radius: u2, u_viewport: d2, u_grid_matrix: m2 ? Float32Array.from(m2) : new Float32Array(9), u_skirt_height: _2, u_far_z_cutoff: p2 });
          function yr(e2, t2) {
            return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
          }
          const br = new class {
            constructor() {
              this.operations = {};
            }
            newMorphing(e2, t2, i2, o2, r2) {
              if (e2 in this.operations) {
                const t3 = this.operations[e2];
                t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
              } else
                this.operations[e2] = { startTime: o2, phase: 0, duration: r2, from: t2, to: i2, queued: null };
            }
            getMorphValuesForProxy(e2) {
              if (!(e2 in this.operations))
                return null;
              const t2 = this.operations[e2];
              return { from: t2.from, to: t2.to, phase: t2.phase };
            }
            update(e2) {
              for (const t2 in this.operations) {
                const i2 = this.operations[t2];
                for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
                  if (!this._nextOp(i2, e2)) {
                    delete this.operations[t2];
                    break;
                  }
              }
            }
            _nextOp(e2, t2) {
              return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
            }
            _validOp(e2) {
              return e2.from.hasData() && e2.to.hasData();
            }
          }(), wr = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
          function Tr(e2, t2, i2) {
            if (0 === t2)
              return 0;
            const o2 = t2 < 1 && 514 === i2 ? 0.25 / t2 : 1;
            return 6 * Math.pow(1.5, 22 - e2) * Math.max(t2, 1) * o2;
          }
          function Er(e2, t2) {
            const i2 = 1 << e2.z;
            return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
          }
          const Cr = (e2) => ({ u_matrix: e2 });
          function Sr(t2, i2, o2, r2, s2) {
            if (s2 > 0) {
              const a2 = e.q.now(), n2 = (a2 - t2.timeAdded) / s2, l2 = i2 ? (a2 - i2.timeAdded) / s2 : -1, c2 = o2.getSource(), h2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(t2.tileID.overscaledZ - h2), d2 = u2 && t2.refreshedUponExpiration ? 1 : e.ap(u2 ? n2 : 1 - l2, 0, 1);
              return t2.refreshedUponExpiration && n2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          class Ir extends vt {
            constructor(t2) {
              const i2 = { type: "raster-dem", maxzoom: t2.transform.maxZoom }, o2 = new e.cd(e.ce(), null), r2 = tt("mock-dem", i2, o2, t2.style);
              super("mock-dem", r2, false), r2.setEventedParent(this), this._sourceLoaded = true;
            }
            _loadTile(e2, t2) {
              e2.state = "loaded", t2(null);
            }
          }
          class Dr extends vt {
            constructor(t2) {
              const i2 = tt("proxy", { type: "geojson", maxzoom: t2.transform.maxZoom }, new e.cd(e.ce(), null), t2.style);
              super("proxy", i2, false), i2.setEventedParent(this), this.map = this.getSource().map = t2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(e2, t2, i2) {
              if (e2.freezeTileCoverage)
                return;
              this.transform = e2;
              const o2 = e2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t3, i3) => {
                if (t3[i3.key] = "", !this._tiles[i3.key]) {
                  const t4 = new pt(i3, this._source.tileSize * i3.overscaleFactor(), e2.tileZoom);
                  t4.state = "loaded", this._tiles[i3.key] = t4;
                }
                return t3;
              }, {});
              for (const e3 in this._tiles)
                e3 in o2 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
            }
            freeFBO(e2) {
              const t2 = this.proxyCachedFBO[e2];
              if (void 0 !== t2) {
                const i2 = Object.values(t2);
                this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
              }
            }
            deallocRenderCache() {
              this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
          }
          class Rr extends e.aA {
            constructor(e2, t2, i2) {
              super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
            }
          }
          class Ar extends e.cE {
            constructor(t2, i2) {
              super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t2.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
                this._style.map.triggerRepaint();
              }), t2.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
                this._style.map.triggerRepaint();
              }), t2.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
                this.invalidateRenderCache = true, this._style.map.triggerRepaint();
              }), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
              const [o2, r2, s2] = function(t3) {
                const i3 = new e.a_(), o3 = new e.aO(), r3 = 131;
                i3.reserve(17161), o3.reserve(33800);
                const s3 = e.ab / 128, a3 = e.ab + s3 / 2, n3 = a3 + s3;
                for (let t4 = -s3; t4 < n3; t4 += s3)
                  for (let o4 = -s3; o4 < n3; o4 += s3) {
                    const r4 = o4 < 0 || o4 > a3 || t4 < 0 || t4 > a3 ? 24575 : 0, s4 = e.ap(Math.round(o4), 0, e.ab), n4 = e.ap(Math.round(t4), 0, e.ab);
                    i3.emplaceBack(s4 + r4, n4);
                  }
                const l2 = (e2, t4) => {
                  const i4 = t4 * r3 + e2;
                  o3.emplaceBack(i4 + 1, i4, i4 + r3), o3.emplaceBack(i4 + r3, i4 + r3 + 1, i4 + 1);
                };
                for (let e2 = 1; e2 < 129; e2++)
                  for (let t4 = 1; t4 < 129; t4++)
                    l2(t4, e2);
                return [0, 129].forEach((e2) => {
                  for (let t4 = 0; t4 < 130; t4++)
                    l2(t4, e2), l2(e2, t4);
                }), [i3, o3, 32768];
              }(), a2 = t2.context;
              this.gridBuffer = a2.createVertexBuffer(o2, e.b0.members), this.gridIndexBuffer = a2.createIndexBuffer(r2), this.gridSegments = e.b1.simpleSegment(0, 0, o2.length, r2.length), this.gridNoSkirtSegments = e.b1.simpleSegment(0, 0, o2.length, s2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Dr(i2.map), this.orthoMatrix = e.a6.mat4.create(), e.a6.mat4.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.ab, 0, e.ab, 0, 1);
              const n2 = a2.gl;
              this._overlapStencilMode = new Mi({ func: n2.GEQUAL, mask: 255 }, 0, 255, n2.KEEP, n2.KEEP, n2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Ir(i2.map), this._pendingGroundEffectLayers = [];
            }
            set style(e2) {
              e2.on("data", this._onStyleDataEvent.bind(this)), this._style = e2, this._style.map.on("moveend", () => {
                this._clearLineLayersFromRenderCache();
              });
            }
            update(t2, i2, o2) {
              if (t2 && t2.terrain) {
                this._style !== t2 && (this.style = t2, this._evaluationZoom = void 0);
                const r2 = t2.terrain.properties, s2 = 0 === t2.terrain.drapeRenderMode, a2 = t2.terrain.isZoomDependent();
                this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.q.now();
                const n2 = t2.terrain && t2.terrain.scope, l2 = r2.get("source"), c2 = s2 ? this._mockSourceCache : t2.getSourceCache(l2, n2);
                if (!c2)
                  return void e.w(`Couldn't find terrain source "${l2}".`);
                if (this.sourceCache = c2, this._exaggeration = a2 ? this.calculateExaggeration(i2) : r2.get("exaggeration"), !i2.projection.requiresDraping && a2 && 0 === this._exaggeration)
                  return void this._disable();
                this.enabled = true;
                const h2 = () => {
                  this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                  const t3 = this.getScaledDemTileSize();
                  this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
                };
                this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h2(), this._initializing = true), h2(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true, this._previousZoom = i2.zoom;
              } else
                this._disable();
            }
            calculateExaggeration(t2) {
              const i2 = this._previousCameraAltitude, o2 = t2.getFreeCameraOptions().position.z / t2.pixelsPerMeter * t2.worldSize;
              this._previousCameraAltitude = o2;
              const r2 = null != i2 ? o2 - i2 : Number.MAX_VALUE;
              if (Math.abs(r2) < 2)
                return this._exaggeration;
              const s2 = t2.zoom, a2 = this._style.terrain;
              if (!this._previousUpdateTimestamp)
                return a2.getExaggeration(s2);
              let n2 = s2 - this._previousZoom;
              const l2 = this._previousUpdateTimestamp;
              let c2 = s2;
              null != this._evaluationZoom && (c2 = this._evaluationZoom, Math.abs(s2 - c2) > 0.5 && (n2 = 0.5 * (s2 - c2 + n2)), n2 * r2 < 0 && (c2 += n2)), this._evaluationZoom = c2;
              const h2 = a2.getExaggeration(c2), u2 = h2 === a2.getExaggeration(Math.max(0, c2 - 0.1));
              if (u2 && Math.abs(h2 - this._exaggeration) < 0.01)
                return h2;
              let d2 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l2));
              return (u2 || h2 < 0.1 || Math.abs(n2) < 1e-4) && (d2 = Math.min(0.2, 4 * d2)), e.aa(this._exaggeration, h2, d2);
            }
            resetTileLookupCache(e2) {
              this._findCoveringTileCache[e2] = {};
            }
            getScaledDemTileSize() {
              return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _onStyleDataEvent(e2) {
              e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
            }
            _disable() {
              if (this.enabled && (this.enabled = false, this._emptyDEMTextureDirty = true, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
                for (const e2 in this._style._mergedSourceCaches)
                  this._style._mergedSourceCaches[e2].usedForTerrain = false;
            }
            destroy() {
              this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
            }
            _source() {
              return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
              return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
              return this.enabled ? this._exaggeration : 0;
            }
            get visibleDemTiles() {
              return this._visibleDemTiles;
            }
            get drapeBufferSize() {
              const e2 = 2 * this.proxySourceCache.getSource().tileSize;
              return [e2, e2];
            }
            set useVertexMorphing(e2) {
              this._useVertexMorphing = e2;
            }
            updateTileBinding(t2) {
              if (!this.enabled)
                return;
              this.prevTerrainTileForTile = this.terrainTileForTile;
              const i2 = this.proxySourceCache, o2 = this.painter.transform;
              this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.a5.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
              const r2 = this.proxyCoords = i2.getIds().map((e2) => {
                const t3 = i2.getTileByID(e2).tileID;
                return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
              });
              !function(t3, i3) {
                const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r3 = new e.P(o3.x, o3.y);
                t3.sort((t4, i4) => {
                  if (i4.overscaledZ - t4.overscaledZ)
                    return i4.overscaledZ - t4.overscaledZ;
                  const o4 = new e.P(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), s3 = new e.P(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), a3 = r3.mult(1 << t4.canonical.z);
                  return a3.x -= 0.5, a3.y -= 0.5, a3.distSqr(o4) - a3.distSqr(s3);
                });
              }(r2, this.painter);
              const s2 = this.proxyToSource || {};
              this.proxyToSource = {}, r2.forEach((e2) => {
                this.proxyToSource[e2.key] = {};
              }), this.terrainTileForTile = {};
              const a2 = this._style._mergedSourceCaches;
              for (const e2 in a2) {
                const i3 = a2[e2];
                if (!i3.used)
                  continue;
                if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], s2), i3.usedForTerrain)
                  continue;
                const o3 = t2[e2];
                i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
              }
              this.proxiedCoords[i2.id] = r2.map((e2) => new Rr(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s2), this.renderingToTexture = false;
              const n2 = {};
              this._visibleDemTiles = [];
              for (const e2 of this.proxyCoords) {
                const t3 = this.terrainTileForTile[e2.key];
                if (!t3)
                  continue;
                const i3 = t3.tileID.key;
                i3 in n2 || (this._visibleDemTiles.push(t3), n2[i3] = i3);
              }
            }
            _assignTerrainTiles(e2) {
              this._initializing || e2.forEach((e3) => {
                if (this.terrainTileForTile[e3.key])
                  return;
                const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
                t2 && (this.terrainTileForTile[e3.key] = t2);
              });
            }
            _prepareDEMTextures() {
              const e2 = this.painter.context, t2 = e2.gl;
              for (const i2 in this.terrainTileForTile) {
                const o2 = this.terrainTileForTile[i2], r2 = o2.dem;
                !r2 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), Mo(this.painter, o2, r2));
              }
            }
            _prepareDemTileUniforms(e2, t2, i2, o2) {
              if (!t2 || null == t2.demTexture)
                return false;
              const r2 = e2.tileID.canonical, s2 = Math.pow(2, t2.tileID.canonical.z - r2.z), a2 = o2 || "";
              return i2[`u_dem_tl${a2}`] = [r2.x * s2 % 1, r2.y * s2 % 1], i2[`u_dem_scale${a2}`] = s2, true;
            }
            get emptyDEMTexture() {
              return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            _getLoadedAreaMinimum() {
              if (!this.enabled)
                return 0;
              let e2 = 0;
              const t2 = this._visibleDemTiles.reduce((t3, i2) => {
                if (!i2.dem)
                  return t3;
                const o2 = i2.dem.tree.minimums[0];
                return o2 > 0 && e2++, t3 + o2;
              }, 0);
              return e2 ? t2 / e2 : 0;
            }
            _updateEmptyDEMTexture() {
              const t2 = this.painter.context, i2 = t2.gl;
              t2.activeTexture.set(i2.TEXTURE2);
              const o2 = this._getLoadedAreaMinimum(), r2 = new e.cF({ width: 1, height: 1 }, new Float32Array([o2]));
              this._emptyDEMTextureDirty = false;
              let s2 = this._emptyDEMTexture;
              return s2 ? s2.update(r2, { premultiply: false }) : s2 = this._emptyDEMTexture = new e.T(t2, r2, i2.R32F, { premultiply: false }), s2;
            }
            setupElevationDraw(t2, i2, o2) {
              const r2 = this.painter.context, s2 = r2.gl, a2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
              a2.u_exaggeration = this.exaggeration();
              let n2 = null, l2 = null, c2 = 1;
              if (o2 && o2.morphing && this._useVertexMorphing) {
                const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
                c2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, a2, "_prev") && (l2 = e2), this._prepareDemTileUniforms(t2, i3, a2) && (n2 = i3));
              }
              const h2 = (e2) => e2 && e2.demTexture && this.painter.linearFloatFilteringSupported() ? s2.LINEAR : s2.NEAREST;
              let u2 = null;
              var d2;
              if (this.enabled ? l2 && n2 ? (u2 = n2.demTexture, r2.activeTexture.set(s2.TEXTURE4), l2.demTexture.bind(h2(l2), s2.CLAMP_TO_EDGE), a2.u_dem_lerp = c2) : (n2 = this.terrainTileForTile[t2.tileID.key], u2 = this._prepareDemTileUniforms(t2, n2, a2) ? n2.demTexture : this.emptyDEMTexture) : u2 = this.emptyDEMTexture, r2.activeTexture.set(s2.TEXTURE2), u2 && (a2.u_dem_size = 1 === (d2 = u2).size[0] ? 1 : d2.size[0] - 2, u2.bind(h2(n2), s2.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o2 && o2.useDepthForOcclusion, i2, a2), o2 && o2.useMeterToDem && n2) {
                const t3 = (1 << n2.tileID.canonical.z) * e.bD(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                a2.u_meter_to_dem = t3;
              }
              if (o2 && o2.labelPlaneMatrixInv && (a2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r2, a2), "globe" === this.painter.transform.projection.name) {
                const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
                i2.setGlobeUniformValues(r2, e2);
              }
            }
            globeUniformValues(t2, i2, o2) {
              const r2 = t2.projection;
              return { u_tile_tl_up: r2.upVector(i2, 0, 0), u_tile_tr_up: r2.upVector(i2, e.ab, 0), u_tile_br_up: r2.upVector(i2, e.ab, e.ab), u_tile_bl_up: r2.upVector(i2, 0, e.ab), u_tile_up_scale: o2 ? e.cG(1) : r2.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
            }
            renderToBackBuffer(t2) {
              const i2 = this.painter, o2 = this.painter.context;
              0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r2, s2) {
                if ("globe" === t3.transform.projection.name)
                  !function(t4, i4, o4, r3, s3) {
                    const a2 = t4.context, n2 = a2.gl;
                    let l2, c2;
                    const h2 = t4.transform, u2 = e.cx(t4, a2, h2), d2 = (e2, i5) => {
                      if (c2 === i5)
                        return;
                      const o5 = [wr[i5], "PROJECTION_GLOBE_VIEW"];
                      u2 && o5.push("CUSTOM_ANTIALIASING");
                      const r4 = t4.isTileAffectedByFog(e2);
                      l2 = t4.getOrCreateProgram("globeRaster", { defines: o5, overrideFog: r4 }), c2 = i5;
                    }, _2 = t4.colorModeForRenderPass(), p2 = new Li(n2.LEQUAL, Li.ReadWrite, t4.depthRangeFor3D);
                    br.update(s3);
                    const m2 = e.cy(h2), f2 = [e.am(h2.center.lng), e.at(h2.center.lat)], g2 = t4.globeSharedBuffers, v2 = [h2.width * e.q.devicePixelRatio, h2.height * e.q.devicePixelRatio], x2 = Float32Array.from(h2.globeMatrix), y2 = { useDenormalizedUpVectorScale: true };
                    {
                      const h3 = t4.transform, u3 = Tr(h3.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                      c2 = -1;
                      const b2 = n2.TRIANGLES;
                      for (const c3 of r3) {
                        const r4 = o4.getTile(c3), w2 = Mi.disabled, T2 = i4.prevTerrainTileForTile[c3.key], E2 = i4.terrainTileForTile[c3.key];
                        yr(T2, E2) && br.newMorphing(c3.key, T2, E2, s3, 250), a2.activeTexture.set(n2.TEXTURE0), r4.texture && r4.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE);
                        const C2 = br.getMorphValuesForProxy(c3.key), S2 = C2 ? 1 : 0;
                        C2 && e.C(y2, { morphing: { srcDemTile: C2.from, dstDemTile: C2.to, phase: e.cw(C2.phase) } });
                        const I2 = e.cz(c3.canonical), D2 = e.cA(I2.getCenter().lat), R2 = e.cB(c3.canonical, I2, D2, h3.worldSize / h3._pixelsPerMercatorPixel), A2 = e.b5(e.cC(c3.canonical)), L2 = xr(h3.expandedFarZProjMatrix, x2, m2, A2, e.a9(h3.zoom), f2, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v2, u3, h3._farZ, R2);
                        if (d2(c3, S2), l2 && (i4.setupElevationDraw(r4, l2, y2), t4.uploadCommonUniforms(a2, l2, c3.toUnwrapped()), g2)) {
                          const [e2, i5, o5] = g2.getGridBuffers(D2, 0 !== u3);
                          l2.draw(t4, b2, p2, w2, _2, Fi.backCCW, L2, "globe_raster", e2, i5, o5);
                        }
                      }
                    }
                    if (g2 && (t4.renderDefaultNorthPole || t4.renderDefaultSouthPole)) {
                      const s4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                      u2 && s4.push("CUSTOM_ANTIALIASING"), l2 = t4.getOrCreateProgram("globeRaster", { defines: s4 });
                      for (const s5 of r3) {
                        const { x: r4, y: c3, z: u3 } = s5.canonical, d3 = 0 === c3, m3 = c3 === (1 << u3) - 1, [x3, b2, w2, T2] = g2.getPoleBuffers(u3, false);
                        if (T2 && (d3 || m3)) {
                          const c4 = o4.getTile(s5);
                          a2.activeTexture.set(n2.TEXTURE0), c4.texture && c4.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE);
                          let g3 = e.cD(u3, r4, h2);
                          const E2 = e.b5(e.cC(s5.canonical)), C2 = (e2, i5) => e2.draw(t4, n2.TRIANGLES, p2, Mi.disabled, _2, Fi.disabled, xr(h2.expandedFarZProjMatrix, g3, g3, E2, 0, f2, h2.frustumCorners.TL, h2.frustumCorners.TR, h2.frustumCorners.BR, h2.frustumCorners.BL, h2.globeCenterInViewSpace, h2.globeRadius, v2, 0, h2._farZ), "globe_pole_raster", i5, w2, T2);
                          i4.setupElevationDraw(c4, l2, y2), t4.uploadCommonUniforms(a2, l2, s5.toUnwrapped()), d3 && t4.renderDefaultNorthPole && C2(l2, x3), m3 && t4.renderDefaultSouthPole && (g3 = e.a6.mat4.scale(e.a6.mat4.create(), g3, [1, -1, 1]), C2(l2, b2));
                        }
                      }
                    }
                  }(t3, i3, o3, r2, s2);
                else {
                  const a2 = t3.context, n2 = a2.gl;
                  let l2, c2;
                  const h2 = t3.shadowRenderer, u2 = Wi(t3, t3.longestCutoffRange), d2 = (e2) => {
                    if (c2 === e2)
                      return;
                    const i4 = [];
                    i4.push(wr[e2]), u2.shouldRenderCutoff && i4.push("RENDER_CUTOFF"), l2 = t3.getOrCreateProgram("terrainRaster", { defines: i4 }), c2 = e2;
                  }, _2 = t3.colorModeForRenderPass(), p2 = new Li(n2.LEQUAL, Li.ReadWrite, t3.depthRangeFor3D);
                  br.update(s2);
                  const m2 = t3.transform, f2 = Tr(m2.zoom, i3.exaggeration(), i3.sourceCache._source.tileSize);
                  let g2 = [0, 0, 0];
                  if (h2) {
                    const e2 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                    e2 && i4 && (g2 = eo(t3.style, e2, i4));
                  }
                  {
                    c2 = -1;
                    const v2 = n2.TRIANGLES, [x2, y2] = [i3.gridIndexBuffer, i3.gridSegments];
                    for (const c3 of r2) {
                      const r3 = o3.getTile(c3), b2 = Mi.disabled, w2 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                      yr(w2, T2) && br.newMorphing(c3.key, w2, T2, s2, 250), a2.activeTexture.set(n2.TEXTURE0), r3.texture && r3.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE);
                      const E2 = br.getMorphValuesForProxy(c3.key), C2 = E2 ? 1 : 0;
                      let S2;
                      E2 && (S2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: e.cw(E2.phase) } });
                      const I2 = vr(c3.projMatrix, Er(c3.canonical, m2.renderWorldCopies) ? f2 / 10 : f2, g2);
                      if (d2(C2), !l2)
                        continue;
                      i3.setupElevationDraw(r3, l2, S2);
                      const D2 = c3.toUnwrapped();
                      h2 && h2.setupShadows(D2, l2), t3.uploadCommonUniforms(a2, l2, D2, null, u2), l2.draw(t3, v2, p2, b2, _2, Fi.backCCW, I2, "terrain_raster", i3.gridBuffer, x2, y2);
                    }
                  }
                }
              }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
            }
            renderBatch(t2) {
              if (0 === this._drapedRenderBatches.length)
                return t2 + 1;
              this.renderingToTexture = true;
              const i2 = this.painter, o2 = this.painter.context, r2 = this.proxySourceCache, s2 = this.proxiedCoords[r2.id], a2 = this._drapedRenderBatches.shift(), n2 = i2.style.order, l2 = [];
              let c2 = 0;
              for (const h2 of s2) {
                const s3 = r2.getTileByID(h2.proxyTileKey), u2 = r2.proxyCachedFBO[h2.key] ? r2.proxyCachedFBO[h2.key][t2] : void 0, d2 = void 0 !== u2 ? r2.renderCache[u2] : this.pool[c2++], _2 = void 0 !== u2;
                if (s3.texture = d2.tex, _2 && !d2.dirty) {
                  l2.push(s3.tileID);
                  continue;
                }
                let p2;
                o2.bindFramebuffer.set(d2.fb.framebuffer), this.renderedToTile = false, d2.dirty && (o2.clear({ color: e.bz.transparent, stencil: 0 }), d2.dirty = false);
                for (let e2 = a2.start; e2 <= a2.end; ++e2) {
                  const t3 = i2.style._mergedLayers[n2[e2]];
                  if (t3.isHidden(i2.transform.zoom))
                    continue;
                  const r3 = i2.style.getLayerSourceCache(t3), s4 = r3 ? this.proxyToSource[h2.key][r3.id] : [h2];
                  if (!s4)
                    continue;
                  const a3 = s4;
                  o2.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p2 !== (r3 ? r3.id : null) && (this._setupStencil(d2, s4, t3, r3), p2 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, a3);
                }
                if (0 === this._drapedRenderBatches.length)
                  for (const e2 of this._pendingGroundEffectLayers) {
                    const t3 = i2.style._mergedLayers[n2[e2]];
                    if (t3.isHidden(i2.transform.zoom))
                      continue;
                    const r3 = i2.style.getLayerSourceCache(t3), s4 = r3 ? this.proxyToSource[h2.key][r3.id] : [h2];
                    if (!s4)
                      continue;
                    const a3 = s4;
                    o2.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p2 !== (r3 ? r3.id : null) && (this._setupStencil(d2, s4, t3, r3), p2 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, a3);
                  }
                this.renderedToTile ? (d2.dirty = true, l2.push(s3.tileID)) : _2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(l2));
              }
              return this.renderToBackBuffer(l2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), a2.end + 1;
            }
            postRender() {
            }
            isLayerOrderingCorrect(e2) {
              const t2 = e2.order.length;
              let i2 = -1, o2 = t2;
              for (let r2 = 0; r2 < t2; ++r2)
                this._style.isLayerDraped(e2._mergedLayers[e2.order[r2]]) ? i2 = Math.max(i2, r2) : o2 = Math.min(o2, r2);
              return o2 > i2;
            }
            getMinElevationBelowMSL() {
              let e2 = 0;
              return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
                e2 = Math.min(e2, t2.dem.tree.minimums[0]);
              }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
            }
            raycast(e2, t2, i2) {
              if (!this._visibleDemTiles)
                return null;
              const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
                const r2 = o3.tileID, s2 = 1 << r2.overscaledZ, { x: a2, y: n2 } = r2.canonical, l2 = a2 / s2, c2 = (a2 + 1) / s2, h2 = n2 / s2, u2 = (n2 + 1) / s2;
                return { minx: l2, miny: h2, maxx: c2, maxy: u2, t: o3.dem.tree.raycastRoot(l2, h2, c2, u2, e2, t2, i2), tile: o3 };
              });
              o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
              for (const r2 of o2) {
                if (null == r2.t)
                  return null;
                const o3 = r2.tile.dem.tree.raycast(r2.minx, r2.miny, r2.maxx, r2.maxy, e2, t2, i2);
                if (null != o3)
                  return o3;
              }
              return null;
            }
            _createFBO() {
              const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
              t2.activeTexture.set(i2.TEXTURE0);
              const r2 = new e.T(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA8);
              r2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
              const s2 = t2.createFramebuffer(o2[0], o2[1], true, null);
              return s2.colorAttachment.set(r2.texture), s2.depthAttachment = new gr(t2, s2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, s2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : s2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: s2, tex: r2, dirty: false };
            }
            _initFBOPool() {
              for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
              if (this._debugParams.disableRenderCache)
                return true;
              if (this._style.hasLightTransitions())
                return true;
              for (const e2 in this._style._mergedSourceCaches)
                if (this._style._mergedSourceCaches[e2].hasTransition())
                  return true;
              return this._style.order.some((e2) => {
                const t2 = this._style._mergedLayers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
                return "hillshade" === t2.type || "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
              });
            }
            _clearLineLayersFromRenderCache() {
              let t2 = false;
              for (const e2 of this._style.getSources())
                if (e2 instanceof Ke) {
                  t2 = true;
                  break;
                }
              if (!t2)
                return;
              const i2 = {};
              for (let t3 = 0; t3 < this._style.order.length; ++t3) {
                const o2 = this._style._mergedLayers[this._style.order[t3]], r2 = this._style.getLayerSourceCache(o2);
                if (r2 && !i2[r2.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e.a4) {
                  i2[r2.id] = true;
                  for (const e2 of this.proxyCoords) {
                    const t4 = this.proxyToSource[e2.key][r2.id];
                    if (t4)
                      for (const e3 of t4)
                        this._clearRenderCacheForTile(r2.id, e3);
                  }
                }
              }
            }
            _clearRasterLayersFromRenderCache() {
              let e2 = false;
              for (const t3 in this._style._mergedSourceCaches)
                if (this._style._mergedSourceCaches[t3]._source instanceof Je) {
                  e2 = true;
                  break;
                }
              if (!e2)
                return;
              const t2 = {};
              for (let e3 = 0; e3 < this._style.order.length; ++e3) {
                const i2 = this._style._mergedLayers[this._style.order[e3]], o2 = this._style.getLayerSourceCache(i2);
                if (!o2 || t2[o2.id])
                  continue;
                if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type)
                  continue;
                const r2 = i2.paint.get("raster-fade-duration");
                for (const e4 of this.proxyCoords) {
                  const t3 = this.proxyToSource[e4.key][o2.id];
                  if (t3)
                    for (const e5 of t3) {
                      const t4 = Sr(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r2);
                      (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                    }
                }
              }
            }
            _setupDrapedRenderBatches() {
              const t2 = this._style.order, i2 = t2.length;
              if (0 === i2)
                return;
              const o2 = [];
              this._pendingGroundEffectLayers = [];
              let r2, s2 = 0, a2 = this._style._mergedLayers[t2[s2]];
              for (; !this._style.isLayerDraped(a2) && a2.isHidden(this.painter.transform.zoom) && ++s2 < i2; )
                a2 = this._style._mergedLayers[t2[s2]];
              for (; s2 < i2; ++s2) {
                const e2 = this._style._mergedLayers[t2[s2]];
                e2.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e2) ? void 0 === r2 && (r2 = s2) : ("fill-extrusion" === e2.type && this._pendingGroundEffectLayers.push(s2), void 0 !== r2 && (o2.push({ start: r2, end: s2 - 1 }), r2 = void 0)));
              }
              if (void 0 !== r2 && o2.push({ start: r2, end: s2 - 1 }), 0 !== o2.length) {
                const t3 = o2[o2.length - 1];
                this._pendingGroundEffectLayers.every((e2) => e2 > t3.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
              }
              this._drapedRenderBatches = o2;
            }
            _setupRenderCache(e2) {
              const t2 = this.proxySourceCache;
              if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                if (this.invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
                  const e3 = Object.values(t2.proxyCachedFBO);
                  t2.proxyCachedFBO = {};
                  for (let i3 = 0; i3 < e3.length; ++i3) {
                    const o3 = Object.values(e3[i3]);
                    t2.renderCachePool.push(...o3);
                  }
                }
                return;
              }
              this._clearRasterLayersFromRenderCache();
              const i2 = this.proxyCoords, o2 = this._tilesDirty;
              for (let r3 = i2.length - 1; r3 >= 0; r3--) {
                const s2 = i2[r3];
                if (t2.getTileByID(s2.key), void 0 !== t2.proxyCachedFBO[s2.key]) {
                  const i3 = e2[s2.key], r4 = this.proxyToSource[s2.key];
                  let a2 = 0;
                  for (const e3 in r4) {
                    const t3 = r4[e3], s3 = i3[e3];
                    if (!s3 || s3.length !== t3.length || t3.some((t4, i4) => t4 !== s3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                      a2 = -1;
                      break;
                    }
                    ++a2;
                  }
                  for (const e3 in t2.proxyCachedFBO[s2.key])
                    t2.renderCache[t2.proxyCachedFBO[s2.key][e3]].dirty = a2 < 0 || a2 !== Object.values(i3).length;
                }
              }
              const r2 = [...this._drapedRenderBatches];
              r2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
              for (const e3 of r2)
                for (const o3 of i2) {
                  if (t2.proxyCachedFBO[o3.key])
                    continue;
                  let i3 = t2.renderCachePool.pop();
                  void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
                }
              this._tilesDirty = {};
            }
            _setupStencil(e2, t2, i2, o2) {
              if (!o2 || !this._sourceTilesOverlap[o2.id])
                return void (this._overlapStencilType && (this._overlapStencilType = false));
              const r2 = this.painter.context, s2 = r2.gl;
              if (t2.length <= 1)
                return void (this._overlapStencilType = false);
              let a2;
              if (i2.isTileClipped())
                a2 = t2.length, this._overlapStencilMode.test = { func: s2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
              else {
                if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
                  return void (this._overlapStencilType = false);
                a2 = 1, this._overlapStencilMode.test = { func: s2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
              }
              this._stencilRef + a2 > 255 && (r2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += a2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
              return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(e2) {
              return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e2.key]), this._overlapStencilMode) : Mi.disabled;
            }
            _renderTileClippingMasks(e2, t2) {
              const i2 = this.painter, o2 = this.painter.context, r2 = o2.gl;
              i2._tileClippingMaskIDs = {}, o2.setColorMode(Ai.disabled), o2.setDepthMode(Li.disabled);
              const s2 = i2.getOrCreateProgram("clippingMask");
              for (const o3 of e2) {
                const e3 = i2._tileClippingMaskIDs[o3.key] = --t2;
                s2.draw(i2, r2.TRIANGLES, Li.disabled, new Mi({ func: r2.ALWAYS, mask: 0 }, e3, 255, r2.KEEP, r2.KEEP, r2.REPLACE), Ai.disabled, Fi.disabled, Cr(o3.projMatrix), "$clipping", i2.tileExtentBuffer, i2.quadTriangleIndexBuffer, i2.tileExtentSegments);
              }
            }
            pointCoordinate(t2) {
              const i2 = this.painter.transform;
              if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height)
                return null;
              const o2 = [t2.x, t2.y, 1, 1];
              e.a6.vec4.transformMat4(o2, o2, i2.pixelMatrixInverse), e.a6.vec4.scale(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
              const r2 = i2._camera.position, s2 = e.bD(1, i2.center.lat), a2 = [r2[0], r2[1], r2[2] / s2, 0], n2 = e.a6.vec3.subtract([], o2.slice(0, 3), a2);
              e.a6.vec3.normalize(n2, n2);
              const l2 = this.raycast(a2, n2, this._exaggeration);
              return null !== l2 && l2 ? (e.a6.vec3.scaleAndAdd(a2, a2, n2, l2), a2[3] = a2[2], a2[2] *= s2, a2) : null;
            }
            _setupProxiedCoordsForOrtho(t2, i2, o2) {
              if (t2.getSource() instanceof e.aD)
                return this._setupProxiedCoordsForImageSource(t2, i2, o2);
              this._findCoveringTileCache[t2.id] = this._findCoveringTileCache[t2.id] || {};
              const r2 = this.proxiedCoords[t2.id] = [], s2 = this.proxyCoords;
              for (let e2 = 0; e2 < s2.length; e2++) {
                const i3 = s2[e2], a3 = this._findTileCoveringTileID(i3, t2);
                if (a3) {
                  const e3 = this._createProxiedId(i3, a3, o2[i3.key] && o2[i3.key][t2.id]);
                  r2.push(e3), this.proxyToSource[i3.key][t2.id] = [e3];
                }
              }
              let a2 = false;
              const n2 = /* @__PURE__ */ new Set();
              for (let e2 = 0; e2 < i2.length; e2++) {
                const s3 = t2.getTile(i2[e2]);
                if (!s3 || !s3.hasData())
                  continue;
                const l2 = this._findTileCoveringTileID(s3.tileID, this.proxySourceCache);
                if (l2 && l2.tileID.canonical.z !== s3.tileID.canonical.z) {
                  const e3 = this.proxyToSource[l2.tileID.key][t2.id], i3 = this._createProxiedId(l2.tileID, s3, o2[l2.tileID.key] && o2[l2.tileID.key][t2.id]);
                  e3 ? e3.splice(e3.length - 1, 0, i3) : this.proxyToSource[l2.tileID.key][t2.id] = [i3];
                  const c2 = this.proxyToSource[l2.tileID.key][t2.id];
                  n2.has(c2) || n2.add(c2), r2.push(i3), a2 = true;
                }
              }
              if (this._sourceTilesOverlap[t2.id] = a2, a2 && this._debugParams.sortTilesHiZFirst)
                for (const e2 of n2)
                  e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ);
            }
            _setupProxiedCoordsForImageSource(t2, i2, o2) {
              if (!t2.getSource().loaded())
                return;
              const r2 = this.proxiedCoords[t2.id] = [], s2 = this.proxyCoords, a2 = t2.getSource(), n2 = a2.tileID;
              if (!n2)
                return;
              const l2 = new e.P(n2.x, n2.y)._div(1 << n2.z), c2 = a2.coordinates.map(e.a5.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - l2.x), e2.min.y = Math.min(e2.min.y, t3.y - l2.y), e2.max.x = Math.max(e2.max.x, t3.x - l2.x), e2.max.y = Math.max(e2.max.y, t3.y - l2.y), e2), { min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h2 = (t3, i3) => {
                const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r3 = t3.canonical.y / (1 << t3.canonical.z), s3 = e.ab / (1 << t3.canonical.z), a3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), n3 = i3.canonical.y / (1 << i3.canonical.z);
                return o3 + s3 < a3 + c2.min.x || o3 > a3 + c2.max.x || r3 + s3 < n3 + c2.min.y || r3 > n3 + c2.max.y;
              };
              for (let e2 = 0; e2 < s2.length; e2++) {
                const a3 = s2[e2];
                for (let e3 = 0; e3 < i2.length; e3++) {
                  const s3 = t2.getTile(i2[e3]);
                  if (!s3 || !s3.hasData())
                    continue;
                  if (h2(a3, s3.tileID))
                    continue;
                  const n3 = this._createProxiedId(a3, s3, o2[a3.key] && o2[a3.key][t2.id]), l3 = this.proxyToSource[a3.key][t2.id];
                  l3 ? l3.push(n3) : this.proxyToSource[a3.key][t2.id] = [n3], r2.push(n3);
                }
              }
            }
            _createProxiedId(t2, i2, o2) {
              let r2 = this.orthoMatrix;
              if (o2) {
                const e2 = o2.find((e3) => e3.key === i2.tileID.key);
                if (e2)
                  return e2;
              }
              if (i2.tileID.key !== t2.key) {
                const o3 = t2.canonical.z - i2.tileID.canonical.z;
                let s2, a2, n2;
                r2 = e.a6.mat4.create();
                const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
                o3 > 0 ? (s2 = e.ab >> o3, a2 = s2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), n2 = s2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (s2 = e.ab << -o3, a2 = e.ab * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), n2 = e.ab * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.a6.mat4.ortho(r2, 0, s2, 0, s2, 0, 1), e.a6.mat4.translate(r2, r2, [a2, n2, 0]);
              }
              return new Rr(i2.tileID, t2.key, r2);
            }
            _findTileCoveringTileID(t2, i2) {
              let o2 = i2.getTile(t2);
              if (o2 && o2.hasData())
                return o2;
              const r2 = this._findCoveringTileCache[i2.id], s2 = r2[t2.key];
              if (o2 = s2 ? i2.getTileByID(s2) : null, o2 && o2.hasData() || null === s2)
                return o2;
              let a2 = o2 ? o2.tileID : t2, n2 = a2.overscaledZ;
              const l2 = i2.getSource().minzoom, c2 = [];
              if (!s2) {
                const r3 = i2.getSource().maxzoom;
                if (t2.canonical.z >= r3) {
                  const o3 = t2.canonical.z - r3;
                  i2.getSource().reparseOverscaled ? (n2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), a2 = new e.aA(n2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (n2 = r3, a2 = new e.aA(n2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3));
                }
                a2.key !== t2.key && (c2.push(a2.key), o2 = i2.getTile(a2));
              }
              const h2 = (e2) => {
                c2.forEach((t3) => {
                  r2[t3] = e2;
                }), c2.length = 0;
              };
              for (n2 -= 1; n2 >= l2 && (!o2 || !o2.hasData()); n2--) {
                o2 && h2(o2.tileID.key);
                const e2 = a2.calculateScaledKey(n2);
                if (o2 = i2.getTileByID(e2), o2 && o2.hasData())
                  break;
                const t3 = r2[e2];
                if (null === t3)
                  break;
                void 0 === t3 ? c2.push(e2) : o2 = i2.getTileByID(t3);
              }
              return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
            }
            findDEMTileFor(e2) {
              return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
            }
            prepareDrawTile() {
              this.renderedToTile = true;
            }
            _clearRenderCacheForTile(e2, t2) {
              let i2 = this._tilesDirty[e2];
              i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
            }
          }
          function Lr(t2, i2, o2) {
            const r2 = function(t3, i3, o3) {
              const r3 = e.a6.vec3.dot(i3, t3), s3 = e.a6.vec3.dot(o3, [0.2126, 0.7152, 0.0722]), a3 = (e2, t4, i4) => (1 - i4) * e2 + i4 * t4, n3 = a3(1 - 0.3 * Math.min(s3, 1), 1, Math.min(r3 + 1, 1));
              return a3(0.92, 1, Math.asin(e.ap(i3[2], -1, 1)) / Math.PI + 0.5) * n3;
            }(t2, [0, 0, 1], i2), s2 = [0, 0, 0];
            e.a6.vec3.scale(s2, o2.slice(0, 3), r2);
            const a2 = [0, 0, 0];
            e.a6.vec3.scale(a2, i2.slice(0, 3), t2[2]);
            const n2 = [0, 0, 0];
            return e.a6.vec3.add(n2, s2, a2), e.cb(n2);
          }
          const Pr = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Mr = ["stars", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
          class zr {
            static cacheKey(e2, t2, i2, o2) {
              let r2 = `${t2}${o2 ? o2.cacheKey : ""}`;
              for (const t3 of i2)
                e2.usedDefines.includes(t3) && (r2 += `/${t3}`);
              return r2;
            }
            constructor(t2, i2, o2, r2, s2, a2) {
              const n2 = t2.gl;
              this.program = n2.createProgram(), this.configuration = r2, this.name = i2, this.fixedDefines = [...a2];
              const l2 = r2 ? r2.getBinderAttributes() : [], c2 = (o2.staticAttributes || []).concat(l2);
              let h2 = r2 ? r2.defines() : [];
              h2 = h2.concat(a2.map((e2) => `#define ${e2}`));
              const u2 = "#version 300 es\n";
              let d2 = u2 + h2.concat("precision mediump float;", So, Co.fragmentSource).join("\n");
              for (const e2 of o2.fragmentIncludes)
                d2 += `
${To[e2]}`;
              d2 += `
${o2.fragmentSource}`;
              let _2 = u2 + h2.concat("precision highp float;", So, Co.vertexSource).join("\n");
              for (const e2 of o2.vertexIncludes)
                _2 += `
${To[e2]}`;
              _2 += `
${o2.vertexSource}`;
              const p2 = n2.createShader(n2.FRAGMENT_SHADER);
              if (n2.isContextLost())
                return void (this.failedToCreate = true);
              n2.shaderSource(p2, d2), n2.compileShader(p2), n2.attachShader(this.program, p2);
              const m2 = n2.createShader(n2.VERTEX_SHADER);
              if (n2.isContextLost())
                this.failedToCreate = true;
              else {
                n2.shaderSource(m2, _2), n2.compileShader(m2), n2.attachShader(this.program, m2), this.attributes = {}, this.numAttributes = c2.length;
                for (let e2 = 0; e2 < this.numAttributes; e2++)
                  if (c2[e2]) {
                    const t3 = c2[e2].startsWith("a_") ? c2[e2] : `a_${c2[e2]}`;
                    n2.bindAttribLocation(this.program, e2, t3), this.attributes[t3] = e2;
                  }
                n2.linkProgram(this.program), n2.deleteShader(m2), n2.deleteShader(p2), this.fixedUniforms = s2(t2), this.binderUniforms = r2 ? r2.getUniforms(t2) : [], (a2.includes("TERRAIN") || -1 !== i2.indexOf("symbol") || -1 !== i2.indexOf("circle")) && (this.terrainUniforms = ((t3) => ({ u_dem: new e.bJ(t3), u_dem_prev: new e.bJ(t3), u_dem_tl: new e.bG(t3), u_dem_scale: new e.bI(t3), u_dem_tl_prev: new e.bG(t3), u_dem_scale_prev: new e.bI(t3), u_dem_size: new e.bI(t3), u_dem_lerp: new e.bI(t3), u_exaggeration: new e.bI(t3), u_depth: new e.bJ(t3), u_depth_size_inv: new e.bG(t3), u_depth_range_unpack: new e.bG(t3), u_occluder_half_size: new e.bI(t3), u_occlusion_depth_offset: new e.bI(t3), u_meter_to_dem: new e.bI(t3), u_label_plane_matrix_inv: new e.bF(t3) }))(t2)), a2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.bH(t3), u_tile_tr_up: new e.bH(t3), u_tile_br_up: new e.bH(t3), u_tile_bl_up: new e.bH(t3), u_tile_up_scale: new e.bI(t3) }))(t2)), a2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.bF(t3), u_fog_range: new e.bG(t3), u_fog_color: new e.c6(t3), u_fog_horizon_blend: new e.bI(t3), u_fog_vertical_limit: new e.bG(t3), u_fog_temporal_offset: new e.bI(t3), u_frustum_tl: new e.bH(t3), u_frustum_tr: new e.bH(t3), u_frustum_br: new e.bH(t3), u_frustum_bl: new e.bH(t3), u_globe_pos: new e.bH(t3), u_globe_radius: new e.bI(t3), u_globe_transition: new e.bI(t3), u_is_globe: new e.bJ(t3), u_viewport: new e.bG(t3) }))(t2)), a2.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t3) => ({ u_cutoff_params: new e.c6(t3) }))(t2)), a2.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t3) => ({ u_lighting_ambient_color: new e.bH(t3), u_lighting_directional_dir: new e.bH(t3), u_lighting_directional_color: new e.bH(t3), u_ground_radiance: new e.bH(t3) }))(t2)), a2.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t3) => ({ u_light_matrix_0: new e.bF(t3), u_light_matrix_1: new e.bF(t3), u_fade_range: new e.bG(t3), u_shadow_normal_offset: new e.bH(t3), u_shadow_intensity: new e.bI(t3), u_shadow_texel_size: new e.bI(t3), u_shadow_map_resolution: new e.bI(t3), u_shadow_direction: new e.bH(t3), u_shadow_bias: new e.bH(t3), u_shadowmap_0: new e.bJ(t3), u_shadowmap_1: new e.bJ(t3) }))(t2));
              }
            }
            setTerrainUniformValues(e2, t2) {
              if (!this.terrainUniforms)
                return;
              const i2 = this.terrainUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setGlobeUniformValues(e2, t2) {
              if (!this.globeUniforms)
                return;
              const i2 = this.globeUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setFogUniformValues(e2, t2) {
              if (!this.fogUniforms)
                return;
              const i2 = this.fogUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setCutoffUniformValues(e2, t2) {
              if (!this.cutoffUniforms)
                return;
              const i2 = this.cutoffUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setLightsUniformValues(e2, t2) {
              if (!this.lightsUniforms)
                return;
              const i2 = this.lightsUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2)
                  i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setShadowUniformValues(e2, t2) {
              if (this.failedToCreate || !this.shadowUniforms)
                return;
              const i2 = this.shadowUniforms;
              e2.program.set(this.program);
              for (const e3 in t2)
                i2[e3].set(this.program, e3, t2[e3]);
            }
            _drawDebugWireframe(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2) {
              const u2 = t2.options.wireframe;
              if (false === u2.terrain && false === u2.layers2D && false === u2.layers3D)
                return;
              const d2 = t2.context;
              if (!(() => !(!u2.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!u2.layers2D || t2._terrain && t2._terrain.renderingToTexture || !Pr.includes(this.name)) || !(!u2.layers3D || !Mr.includes(this.name)))())
                return;
              const _2 = d2.gl, p2 = t2.wireframeDebugCache.getLinesFromTrianglesBuffer(t2.frameCounter, s2, d2);
              if (!p2)
                return;
              const m2 = [...this.fixedDefines];
              m2.push("DEBUG_WIREFRAME");
              const f2 = t2.getOrCreateProgram(this.name, { config: this.configuration, defines: m2 });
              d2.program.set(f2.program);
              const g2 = (e2, t3, i3) => {
                if (t3[e2] && i3[e2])
                  for (const o3 in t3[e2])
                    i3[e2][o3] && i3[e2][o3].set(i3.program, o3, t3[e2][o3].current);
              };
              c2 && c2.setUniforms(f2.program, d2, f2.binderUniforms, n2, { zoom: l2 }), g2("fixedUniforms", this, f2), g2("terrainUniforms", this, f2), g2("globeUniforms", this, f2), g2("fogUniforms", this, f2), g2("lightsUniforms", this, f2), g2("shadowUniforms", this, f2), p2.bind(), d2.setColorMode(new Ai([_2.ONE, _2.ONE_MINUS_SRC_ALPHA, _2.ZERO, _2.ONE], e.bz.transparent, [true, true, true, false])), d2.setDepthMode(new Li(i2.func === _2.LESS ? _2.LEQUAL : i2.func, Li.ReadOnly, i2.range)), d2.setStencilMode(Mi.disabled);
              const v2 = 3 * a2.primitiveLength * 2, x2 = 3 * a2.primitiveOffset * 2 * 2;
              h2 && h2 > 1 ? _2.drawElementsInstanced(_2.LINES, v2, _2.UNSIGNED_SHORT, x2, h2) : _2.drawElements(_2.LINES, v2, _2.UNSIGNED_SHORT, x2), s2.bind(), d2.program.set(this.program), d2.setDepthMode(i2), d2.setStencilMode(o2), d2.setColorMode(r2);
            }
            draw(e2, t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2) {
              const f2 = e2.context, g2 = f2.gl;
              if (this.failedToCreate)
                return;
              f2.program.set(this.program), f2.setDepthMode(i2), f2.setStencilMode(o2), f2.setColorMode(r2), f2.setCullFace(s2);
              for (const e3 of Object.keys(this.fixedUniforms))
                this.fixedUniforms[e3].set(this.program, e3, a2[e3]);
              _2 && _2.setUniforms(this.program, f2, this.binderUniforms, u2, { zoom: d2 });
              const v2 = { [g2.POINTS]: 1, [g2.LINES]: 2, [g2.TRIANGLES]: 3, [g2.LINE_STRIP]: 1 }[t2], x2 = m2 && m2 > 0 ? 1 : void 0;
              for (const s3 of h2.get()) {
                const a3 = s3.vaos || (s3.vaos = {});
                (a3[n2] || (a3[n2] = new Ao())).bind(f2, this, l2, _2 ? _2.getPaintVertexBuffers() : [], c2, s3.vertexOffset, p2 || [], x2), m2 && m2 > 1 ? g2.drawElementsInstanced(t2, s3.primitiveLength * v2, g2.UNSIGNED_SHORT, s3.primitiveOffset * v2 * 2, m2) : c2 ? g2.drawElements(t2, s3.primitiveLength * v2, g2.UNSIGNED_SHORT, s3.primitiveOffset * v2 * 2) : g2.drawArrays(t2, s3.vertexOffset, s3.vertexLength), t2 === g2.TRIANGLES && c2 && this._drawDebugWireframe(e2, i2, o2, r2, c2, s3, u2, d2, _2, m2);
              }
            }
          }
          function Or(t2, i2) {
            const o2 = Math.pow(2, i2.tileID.overscaledZ), r2 = i2.tileSize * Math.pow(2, t2.transform.tileZoom) / o2, s2 = r2 * (i2.tileID.canonical.x + i2.tileID.wrap * o2), a2 = r2 * i2.tileID.canonical.y;
            return { u_image: 0, u_texsize: i2.imageAtlasTexture ? i2.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e.ak(i2, 1, t2.transform.tileZoom), u_pixel_coord_upper: [s2 >> 16, a2 >> 16], u_pixel_coord_lower: [65535 & s2, 65535 & a2] };
          }
          const Fr = e.a6.mat4.create(), kr = (t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2) => {
            const g2 = i2.style.light, v2 = g2.properties.get("position"), x2 = [v2.x, v2.y, v2.z], y2 = e.a6.mat3.create();
            "viewport" === g2.properties.get("anchor") && (e.a6.mat3.fromRotation(y2, -i2.transform.angle), e.a6.vec3.transformMat3(x2, x2, y2));
            const b2 = g2.properties.get("color"), w2 = i2.transform, T2 = { u_matrix: t2, u_lightpos: x2, u_lightintensity: g2.properties.get("intensity"), u_lightcolor: [b2.r, b2.g, b2.b], u_vertical_gradient: +o2, u_opacity: r2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Fr, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: s2, u_edge_radius: a2, u_width_scale: n2, u_flood_light_color: _2, u_vertical_scale: p2, u_flood_light_intensity: m2, u_ground_shadow_factor: f2 };
            return "globe" === w2.projection.name && (T2.u_tile_id = [l2.canonical.x, l2.canonical.y, 1 << l2.canonical.z], T2.u_zoom_transition = h2, T2.u_inv_rot_matrix = d2, T2.u_merc_center = u2, T2.u_up_dir = w2.projection.upVector(new e.bP(0, 0, 0), u2[0] * e.ab, u2[1] * e.ab), T2.u_height_lift = c2), T2;
          }, Br = (e2, t2, i2, o2) => ({ u_matrix: e2, u_edge_radius: t2, u_width_scale: i2, u_vertical_scale: o2 }), Nr = (t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2) => {
            const f2 = kr(t2, i2, o2, r2, s2, a2, n2, l2, h2, u2, d2, _2, p2, m2, 1, [0, 0, 0]), g2 = { u_height_factor: -Math.pow(2, l2.overscaledZ) / c2.tileSize / 8 };
            return e.l(f2, Or(i2, c2), g2);
          }, Ur = (e2, t2) => ({ u_matrix: e2, u_emissive_strength: t2 }), Gr = (t2, i2, o2, r2) => e.l(Ur(t2, i2), Or(o2, r2)), jr = (e2, t2, i2) => ({ u_matrix: e2, u_world: i2, u_emissive_strength: t2 }), Vr = (t2, i2, o2, r2, s2) => e.l(Gr(t2, i2, o2, r2), { u_world: s2 }), qr = (t2, i2, o2, r2) => {
            const s2 = e.ab / o2.tileSize;
            return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(r2), u_extrude_scale: [i2.pixelsToGLUnits[0] / s2, i2.pixelsToGLUnits[1] / s2] };
          }, Zr = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2.toRenderColor(null), u_overlay: 0, u_overlay_scale: i2 }), Hr = e.a6.mat4.create(), Wr = (t2, i2, o2, r2, s2, a2, n2) => {
            const l2 = t2.transform, c2 = "globe" === l2.projection.name, h2 = c2 ? e.cI(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : e.ak(o2, 1, a2), u2 = { u_matrix: i2.projMatrix, u_extrude_scale: h2, u_intensity: n2, u_inv_rot_matrix: Hr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
            if (c2) {
              u2.u_inv_rot_matrix = r2, u2.u_merc_center = s2, u2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], u2.u_zoom_transition = e.a9(l2.zoom);
              const t3 = s2[0] * e.ab, o3 = s2[1] * e.ab;
              u2.u_up_dir = l2.projection.upVector(new e.bP(0, 0, 0), t3, o3);
            }
            return u2;
          };
          function $r(e2, [t2, i2, o2, r2], [s2, a2]) {
            if (s2 === a2)
              return [0, 0, 0, 0];
            const n2 = 255 * (e2 - 1) / (e2 * (a2 - s2));
            return [t2 * n2, i2 * n2, o2 * n2, r2 * n2];
          }
          function Xr(e2, t2, [i2, o2]) {
            return i2 === o2 ? 0 : 0.5 / e2 + (t2 - i2) * (e2 - 1) / (e2 * (o2 - i2));
          }
          const Yr = (t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2, x2, y2, b2) => ({ u_matrix: t2, u_normalize_matrix: i2, u_globe_matrix: o2, u_merc_matrix: r2, u_grid_matrix: s2, u_tl_parent: a2, u_scale_parent: h2, u_fade_t: u2.mix, u_opacity: u2.opacity * d2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d2.paint.get("raster-brightness-min"), u_brightness_high: d2.paint.get("raster-brightness-max"), u_saturation_factor: e.cJ(d2.paint.get("raster-saturation")), u_contrast_factor: e.cK(d2.paint.get("raster-contrast")), u_spin_weights: Kr(d2.paint.get("raster-hue-rotate")), u_perspective_transform: _2, u_raster_elevation: p2, u_zoom_transition: n2, u_merc_center: l2, u_cutoff_params: c2, u_colorization_mix: $r(e.cL, f2, v2), u_colorization_offset: Xr(e.cL, g2, v2), u_color_ramp: m2, u_texture_offset: [y2 / (x2 + 2 * y2), x2 / (x2 + 2 * y2)], u_texture_res: [x2 + 2 * y2, x2 + 2 * y2], u_emissive_strength: b2 });
          function Kr(e2) {
            e2 *= Math.PI / 180;
            const t2 = Math.sin(e2), i2 = Math.cos(e2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
          }
          const Jr = 0.05, Qr = (e2, t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2) => ({ u_matrix: e2, u_normalize_matrix: t2, u_globe_matrix: i2, u_merc_matrix: o2, u_grid_matrix: r2, u_tl_parent: s2, u_scale_parent: c2, u_fade_t: h2.mix, u_opacity: h2.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: u2, u_zoom_transition: a2, u_merc_center: n2, u_cutoff_params: l2 }), es = (e2, t2, i2, o2, r2, s2, a2, n2, l2, c2) => ({ u_particle_texture: e2, u_particle_texture_side_len: t2, u_tile_offset: i2, u_velocity: o2, u_color_ramp: s2, u_velocity_res: r2, u_max_speed: a2, u_uv_offset: n2, u_data_scale: [255 * l2[0], 255 * l2[1]], u_data_offset: c2, u_particle_pos_scale: 1.1, u_particle_pos_offset: [Jr, Jr] }), ts = (e2, t2, i2, o2, r2, s2, a2, n2, l2, c2) => ({ u_particle_texture: e2, u_particle_texture_side_len: t2, u_velocity: i2, u_velocity_res: o2, u_max_speed: r2, u_speed_factor: s2, u_reset_rate: a2, u_rand_seed: Math.random(), u_uv_offset: n2, u_data_scale: [255 * l2[0], 255 * l2[1]], u_data_offset: c2, u_particle_pos_scale: 1.1, u_particle_pos_offset: [Jr, Jr] }), is = e.a6.mat4.create(), os = (t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2, x2, y2, b2) => {
            const w2 = s2.transform, T2 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: w2.getCameraToCenterDistance(x2), u_rotate_symbol: +o2, u_aspect_ratio: w2.width / w2.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n2, u_coord_matrix: l2, u_is_text: +h2, u_elevation_from_sea: c2 ? 1 : 0, u_pitch_with_map: +r2, u_texsize: u2, u_texsize_icon: d2, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: is, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: is, u_up_vector: [0, -1, 0], u_color_adj_mat: y2, u_icon_transition: b2 || 0, u_gamma_scale: r2 ? s2.transform.getCameraToCenterDistance(x2) * Math.cos(s2.terrain ? 0 : s2.transform._pitch) : 1, u_device_pixel_ratio: e.q.devicePixelRatio, u_is_halo: +_2 };
            return "globe" === x2.name && (T2.u_tile_id = [p2.canonical.x, p2.canonical.y, 1 << p2.canonical.z], T2.u_zoom_transition = m2, T2.u_inv_rot_matrix = g2, T2.u_merc_center = f2, T2.u_camera_forward = w2._camera.forward(), T2.u_ecef_origin = e.cM(w2.globeMatrix, p2.toUnwrapped()), T2.u_tile_matrix = Float32Array.from(w2.globeMatrix), T2.u_up_vector = v2), T2;
          }, rs = (e2, t2, i2, o2) => ({ u_matrix: e2, u_emissive_strength: t2, u_opacity: i2, u_color: o2 }), ss2 = (t2, i2, o2, r2, s2, a2, n2, l2, c2) => e.l(function(t3, i3, o3, r3, s3, a3) {
            const { width: n3, height: l3 } = r3.imageManager.getPixelSize(i3), c3 = Math.pow(2, a3.tileID.overscaledZ), h2 = a3.tileSize * Math.pow(2, r3.transform.tileZoom) / c3, u2 = h2 * (a3.tileID.canonical.x + a3.tileID.wrap * c3), d2 = h2 * a3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [n3, l3], u_pattern_size: o3.displaySize, u_pattern_units_to_pixels: s3 ? [r3.transform.width, -1 * r3.transform.height] : [1 / e.ak(a3, 1, r3.transform.tileZoom), 1 / e.ak(a3, 1, r3.transform.tileZoom)], u_pixel_coord_upper: [u2 >> 16, d2 >> 16], u_pixel_coord_lower: [65535 & u2, 65535 & d2] };
          }(0, a2, n2, r2, l2, c2), { u_matrix: t2, u_emissive_strength: i2, u_opacity: o2 }), as = new Float32Array(e.a6.mat4.identity([])), ns = (t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2 = [0, 0, 0], m2) => {
            const f2 = s2.style.light, g2 = f2.properties.get("position"), v2 = [-g2.x, -g2.y, g2.z], x2 = e.a6.mat3.create();
            "viewport" === f2.properties.get("anchor") && (e.a6.mat3.fromRotation(x2, -s2.transform.angle), e.a6.vec3.transformMat3(v2, v2, x2));
            const y2 = "MASK" === u2.alphaMode, b2 = f2.properties.get("color").toRenderColor(null), w2 = _2.paint.get("model-ambient-occlusion-intensity"), T2 = _2.paint.get("model-color").constantOr(e.bz.white).toRenderColor(null), E2 = _2.paint.get("model-color-mix-intensity").constantOr(0);
            return { u_matrix: t2, u_lighting_matrix: i2, u_normal_matrix: o2, u_node_matrix: r2 || as, u_lightpos: v2, u_lightintensity: f2.properties.get("intensity"), u_lightcolor: [b2.r, b2.g, b2.b], u_camera_pos: p2, u_opacity: a2, u_baseTextureIsAlpha: 0, u_alphaMask: +y2, u_alphaCutoff: u2.alphaCutoff, u_baseColorFactor: [n2.r, n2.g, n2.b, n2.a], u_emissiveFactor: [l2[0], l2[1], l2[2], 1], u_metallicFactor: c2, u_roughnessFactor: h2, u_baseColorTexture: ji.BaseColor, u_metallicRoughnessTexture: ji.MetallicRoughness, u_normalTexture: ji.Normal, u_occlusionTexture: ji.Occlusion, u_emissionTexture: ji.Emission, u_lutTexture: ji.LUT, u_color_mix: [T2.r, T2.g, T2.b, E2], u_aoIntensity: w2, u_emissive_strength: d2, u_occlusionTextureTransform: m2 || [0, 0, 0, 0] };
          }, ls = (e2, t2 = as, i2 = as) => ({ u_matrix: e2, u_instance: t2, u_node_matrix: i2 }), cs = { fillExtrusion: (t2) => ({ u_matrix: new e.bF(t2), u_lightpos: new e.bH(t2), u_lightintensity: new e.bI(t2), u_lightcolor: new e.bH(t2), u_vertical_gradient: new e.bI(t2), u_opacity: new e.bI(t2), u_edge_radius: new e.bI(t2), u_width_scale: new e.bI(t2), u_ao: new e.bG(t2), u_tile_id: new e.bH(t2), u_zoom_transition: new e.bI(t2), u_inv_rot_matrix: new e.bF(t2), u_merc_center: new e.bG(t2), u_up_dir: new e.bH(t2), u_height_lift: new e.bI(t2), u_flood_light_color: new e.bH(t2), u_vertical_scale: new e.bI(t2), u_flood_light_intensity: new e.bI(t2), u_ground_shadow_factor: new e.bH(t2) }), fillExtrusionDepth: (t2) => ({ u_matrix: new e.bF(t2), u_edge_radius: new e.bI(t2), u_width_scale: new e.bI(t2), u_vertical_scale: new e.bI(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.bF(t2), u_lightpos: new e.bH(t2), u_lightintensity: new e.bI(t2), u_lightcolor: new e.bH(t2), u_vertical_gradient: new e.bI(t2), u_height_factor: new e.bI(t2), u_edge_radius: new e.bI(t2), u_width_scale: new e.bI(t2), u_ao: new e.bG(t2), u_tile_id: new e.bH(t2), u_zoom_transition: new e.bI(t2), u_inv_rot_matrix: new e.bF(t2), u_merc_center: new e.bG(t2), u_up_dir: new e.bH(t2), u_height_lift: new e.bI(t2), u_image: new e.bJ(t2), u_texsize: new e.bG(t2), u_pixel_coord_upper: new e.bG(t2), u_pixel_coord_lower: new e.bG(t2), u_tile_units_to_pixels: new e.bI(t2), u_opacity: new e.bI(t2) }), fillExtrusionGroundEffect: (t2) => ({ u_matrix: new e.bF(t2), u_opacity: new e.bI(t2), u_ao_pass: new e.bI(t2), u_meter_to_tile: new e.bI(t2), u_ao: new e.bG(t2), u_flood_light_intensity: new e.bI(t2), u_flood_light_color: new e.bH(t2), u_attenuation: new e.bI(t2), u_edge_radius: new e.bI(t2), u_fb: new e.bJ(t2), u_fb_size: new e.bI(t2), u_dynamic_offset: new e.bI(t2) }), fill: (t2) => ({ u_matrix: new e.bF(t2), u_emissive_strength: new e.bI(t2) }), fillPattern: (t2) => ({ u_matrix: new e.bF(t2), u_emissive_strength: new e.bI(t2), u_image: new e.bJ(t2), u_texsize: new e.bG(t2), u_pixel_coord_upper: new e.bG(t2), u_pixel_coord_lower: new e.bG(t2), u_tile_units_to_pixels: new e.bI(t2) }), fillOutline: (t2) => ({ u_matrix: new e.bF(t2), u_emissive_strength: new e.bI(t2), u_world: new e.bG(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.bF(t2), u_emissive_strength: new e.bI(t2), u_world: new e.bG(t2), u_image: new e.bJ(t2), u_texsize: new e.bG(t2), u_pixel_coord_upper: new e.bG(t2), u_pixel_coord_lower: new e.bG(t2), u_tile_units_to_pixels: new e.bI(t2) }), circle: e.cN, collisionBox: (t2) => ({ u_matrix: new e.bF(t2), u_camera_to_center_distance: new e.bI(t2), u_extrude_scale: new e.bG(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.bF(t2), u_inv_matrix: new e.bF(t2), u_camera_to_center_distance: new e.bI(t2), u_viewport_size: new e.bG(t2) }), debug: (t2) => ({ u_color: new e.cu(t2), u_matrix: new e.bF(t2), u_overlay: new e.bJ(t2), u_overlay_scale: new e.bI(t2) }), clippingMask: (t2) => ({ u_matrix: new e.bF(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.bI(t2), u_intensity: new e.bI(t2), u_matrix: new e.bF(t2), u_inv_rot_matrix: new e.bF(t2), u_merc_center: new e.bG(t2), u_tile_id: new e.bH(t2), u_zoom_transition: new e.bI(t2), u_up_dir: new e.bH(t2) }), heatmapTexture: (t2) => ({ u_image: new e.bJ(t2), u_color_ramp: new e.bJ(t2), u_opacity: new e.bI(t2) }), hillshade: (t2) => ({ u_matrix: new e.bF(t2), u_image: new e.bJ(t2), u_latrange: new e.bG(t2), u_light: new e.bG(t2), u_shadow: new e.cu(t2), u_highlight: new e.cu(t2), u_emissive_strength: new e.bI(t2), u_accent: new e.cu(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.bF(t2), u_image: new e.bJ(t2), u_dimension: new e.bG(t2), u_zoom: new e.bI(t2) }), line: e.cO, linePattern: e.cP, raster: (t2) => ({ u_matrix: new e.bF(t2), u_normalize_matrix: new e.bF(t2), u_globe_matrix: new e.bF(t2), u_merc_matrix: new e.bF(t2), u_grid_matrix: new e.cv(t2), u_tl_parent: new e.bG(t2), u_scale_parent: new e.bI(t2), u_fade_t: new e.bI(t2), u_opacity: new e.bI(t2), u_image0: new e.bJ(t2), u_image1: new e.bJ(t2), u_brightness_low: new e.bI(t2), u_brightness_high: new e.bI(t2), u_saturation_factor: new e.bI(t2), u_contrast_factor: new e.bI(t2), u_spin_weights: new e.bH(t2), u_perspective_transform: new e.bG(t2), u_raster_elevation: new e.bI(t2), u_zoom_transition: new e.bI(t2), u_merc_center: new e.bG(t2), u_cutoff_params: new e.c6(t2), u_colorization_mix: new e.c6(t2), u_colorization_offset: new e.bI(t2), u_color_ramp: new e.bJ(t2), u_texture_offset: new e.bG(t2), u_texture_res: new e.bG(t2), u_emissive_strength: new e.bI(t2) }), rasterParticle: (t2) => ({ u_matrix: new e.bF(t2), u_normalize_matrix: new e.bF(t2), u_globe_matrix: new e.bF(t2), u_merc_matrix: new e.bF(t2), u_grid_matrix: new e.cv(t2), u_tl_parent: new e.bG(t2), u_scale_parent: new e.bI(t2), u_fade_t: new e.bI(t2), u_opacity: new e.bI(t2), u_image0: new e.bJ(t2), u_image1: new e.bJ(t2), u_raster_elevation: new e.bI(t2), u_zoom_transition: new e.bI(t2), u_merc_center: new e.bG(t2), u_cutoff_params: new e.c6(t2) }), rasterParticleTexture: (t2) => ({ u_texture: new e.bJ(t2), u_opacity: new e.bI(t2) }), rasterParticleDraw: (t2) => ({ u_particle_texture: new e.bJ(t2), u_particle_texture_side_len: new e.bI(t2), u_tile_offset: new e.bG(t2), u_velocity: new e.bJ(t2), u_color_ramp: new e.bJ(t2), u_velocity_res: new e.bG(t2), u_max_speed: new e.bI(t2), u_uv_offset: new e.bG(t2), u_data_scale: new e.bG(t2), u_data_offset: new e.bI(t2), u_particle_pos_scale: new e.bI(t2), u_particle_pos_offset: new e.bG(t2) }), rasterParticleUpdate: (t2) => ({ u_particle_texture: new e.bJ(t2), u_particle_texture_side_len: new e.bI(t2), u_velocity: new e.bJ(t2), u_velocity_res: new e.bG(t2), u_max_speed: new e.bI(t2), u_speed_factor: new e.bI(t2), u_reset_rate: new e.bI(t2), u_rand_seed: new e.bI(t2), u_uv_offset: new e.bG(t2), u_data_scale: new e.bG(t2), u_data_offset: new e.bI(t2), u_particle_pos_scale: new e.bI(t2), u_particle_pos_offset: new e.bG(t2) }), symbol: (t2) => ({ u_is_size_zoom_constant: new e.bJ(t2), u_is_size_feature_constant: new e.bJ(t2), u_size_t: new e.bI(t2), u_size: new e.bI(t2), u_camera_to_center_distance: new e.bI(t2), u_rotate_symbol: new e.bJ(t2), u_aspect_ratio: new e.bI(t2), u_fade_change: new e.bI(t2), u_matrix: new e.bF(t2), u_label_plane_matrix: new e.bF(t2), u_coord_matrix: new e.bF(t2), u_is_text: new e.bJ(t2), u_elevation_from_sea: new e.bJ(t2), u_pitch_with_map: new e.bJ(t2), u_texsize: new e.bG(t2), u_texsize_icon: new e.bG(t2), u_texture: new e.bJ(t2), u_texture_icon: new e.bJ(t2), u_gamma_scale: new e.bI(t2), u_device_pixel_ratio: new e.bI(t2), u_tile_id: new e.bH(t2), u_zoom_transition: new e.bI(t2), u_inv_rot_matrix: new e.bF(t2), u_merc_center: new e.bG(t2), u_camera_forward: new e.bH(t2), u_tile_matrix: new e.bF(t2), u_up_vector: new e.bH(t2), u_ecef_origin: new e.bH(t2), u_is_halo: new e.bJ(t2), u_icon_transition: new e.bI(t2), u_color_adj_mat: new e.bF(t2) }), background: (t2) => ({ u_matrix: new e.bF(t2), u_emissive_strength: new e.bI(t2), u_opacity: new e.bI(t2), u_color: new e.cu(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.bF(t2), u_emissive_strength: new e.bI(t2), u_opacity: new e.bI(t2), u_image: new e.bJ(t2), u_pattern_tl: new e.bG(t2), u_pattern_br: new e.bG(t2), u_texsize: new e.bG(t2), u_pattern_size: new e.bG(t2), u_pixel_coord_upper: new e.bG(t2), u_pixel_coord_lower: new e.bG(t2), u_pattern_units_to_pixels: new e.bG(t2) }), terrainRaster: (t2) => ({ u_matrix: new e.bF(t2), u_image0: new e.bJ(t2), u_skirt_height: new e.bI(t2), u_ground_shadow_factor: new e.bH(t2) }), skybox: (t2) => ({ u_matrix: new e.bF(t2), u_sun_direction: new e.bH(t2), u_cubemap: new e.bJ(t2), u_opacity: new e.bI(t2), u_temporal_offset: new e.bI(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.bF(t2), u_color_ramp: new e.bJ(t2), u_center_direction: new e.bH(t2), u_radius: new e.bI(t2), u_opacity: new e.bI(t2), u_temporal_offset: new e.bI(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.cv(t2), u_sun_direction: new e.bH(t2), u_sun_intensity: new e.bI(t2), u_color_tint_r: new e.c6(t2), u_color_tint_m: new e.c6(t2), u_luminance: new e.bI(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.bF(t2), u_globe_matrix: new e.bF(t2), u_normalize_matrix: new e.bF(t2), u_merc_matrix: new e.bF(t2), u_zoom_transition: new e.bI(t2), u_merc_center: new e.bG(t2), u_image0: new e.bJ(t2), u_grid_matrix: new e.cv(t2), u_skirt_height: new e.bI(t2), u_far_z_cutoff: new e.bI(t2), u_frustum_tl: new e.bH(t2), u_frustum_tr: new e.bH(t2), u_frustum_br: new e.bH(t2), u_frustum_bl: new e.bH(t2), u_globe_pos: new e.bH(t2), u_globe_radius: new e.bI(t2), u_viewport: new e.bG(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.bH(t2), u_frustum_tr: new e.bH(t2), u_frustum_br: new e.bH(t2), u_frustum_bl: new e.bH(t2), u_horizon: new e.bI(t2), u_transition: new e.bI(t2), u_fadeout_range: new e.bI(t2), u_color: new e.c6(t2), u_high_color: new e.c6(t2), u_space_color: new e.c6(t2), u_temporal_offset: new e.bI(t2), u_horizon_angle: new e.bI(t2) }), model: (t2) => ({ u_matrix: new e.bF(t2), u_lighting_matrix: new e.bF(t2), u_normal_matrix: new e.bF(t2), u_node_matrix: new e.bF(t2), u_lightpos: new e.bH(t2), u_lightintensity: new e.bI(t2), u_lightcolor: new e.bH(t2), u_camera_pos: new e.bH(t2), u_opacity: new e.bI(t2), u_baseColorFactor: new e.c6(t2), u_emissiveFactor: new e.c6(t2), u_metallicFactor: new e.bI(t2), u_roughnessFactor: new e.bI(t2), u_baseTextureIsAlpha: new e.bJ(t2), u_alphaMask: new e.bJ(t2), u_alphaCutoff: new e.bI(t2), u_baseColorTexture: new e.bJ(t2), u_metallicRoughnessTexture: new e.bJ(t2), u_normalTexture: new e.bJ(t2), u_occlusionTexture: new e.bJ(t2), u_emissionTexture: new e.bJ(t2), u_lutTexture: new e.bJ(t2), u_color_mix: new e.c6(t2), u_aoIntensity: new e.bI(t2), u_emissive_strength: new e.bI(t2), u_occlusionTextureTransform: new e.c6(t2) }), modelDepth: (t2) => ({ u_matrix: new e.bF(t2), u_instance: new e.bF(t2), u_node_matrix: new e.bF(t2) }), groundShadow: (t2) => ({ u_matrix: new e.bF(t2), u_ground_shadow_factor: new e.bH(t2) }), stars: (t2) => ({ u_matrix: new e.bF(t2), u_up: new e.bH(t2), u_right: new e.bH(t2), u_intensity_multiplier: new e.bI(t2) }), occlusion: (t2) => ({ u_matrix: new e.bF(t2), u_anchorPos: new e.bH(t2), u_screenSizePx: new e.bG(t2), u_occluderSizePx: new e.bG(t2), u_color: new e.c6(t2) }) };
          class hs {
            constructor(e2, t2, i2, o2) {
              this.id = hs.uniqueIdxCounter, hs.uniqueIdxCounter++, this.context = e2;
              const r2 = e2.gl;
              this.buffer = r2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), r2.bufferData(r2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || o2 || t2.destroy();
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e2) {
              this.id = hs.uniqueIdxCounter, hs.uniqueIdxCounter++;
              const t2 = this.context.gl;
              this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          hs.uniqueIdxCounter = 0;
          const us = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class ds {
            constructor(e2, t2, i2, o2, r2, s2) {
              this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.instanceCount = s2, this.context = e2;
              const a2 = e2.gl;
              this.buffer = a2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || r2 || t2.destroy();
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e2) {
              const t2 = this.context.gl;
              this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            enableAttributes(e2, t2) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const o2 = t2.attributes[this.attributes[i2].name];
                void 0 !== o2 && e2.enableVertexAttribArray(o2);
              }
            }
            setVertexAttribPointers(e2, t2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const r2 = this.attributes[o2], s2 = t2.attributes[r2.name];
                void 0 !== s2 && e2.vertexAttribPointer(s2, r2.components, e2[us[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
              }
            }
            setVertexAttribDivisor(e2, t2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const r2 = t2.attributes[this.attributes[o2].name];
                void 0 !== r2 && this.instanceCount && this.instanceCount > 0 && e2.vertexAttribDivisor(r2, i2);
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class _s {
            constructor(e2, t2, i2, o2, r2) {
              this.context = e2, this.width = t2, this.height = i2;
              const s2 = this.framebuffer = e2.gl.createFramebuffer();
              o2 && (this.colorAttachment = new pr(e2, s2)), r2 && (this.depthAttachmentType = r2, this.depthAttachment = "renderbuffer" === r2 ? new mr(e2, s2) : new fr(e2, s2));
            }
            destroy() {
              const e2 = this.context.gl;
              if (this.colorAttachment) {
                const t2 = this.colorAttachment.get();
                t2 && e2.deleteTexture(t2);
              }
              if (this.depthAttachment && this.depthAttachmentType)
                if ("renderbuffer" === this.depthAttachmentType) {
                  const t2 = this.depthAttachment.get();
                  t2 && e2.deleteRenderbuffer(t2);
                } else {
                  const t2 = this.depthAttachment.get();
                  t2 && e2.deleteTexture(t2);
                }
              e2.deleteFramebuffer(this.framebuffer);
            }
          }
          class ps {
            constructor(e2, t2) {
              this.gl = e2, this.clearColor = new Fo(this), this.clearDepth = new ko(this), this.clearStencil = new Bo(this), this.colorMask = new No(this), this.depthMask = new Uo(this), this.stencilMask = new Go(this), this.stencilFunc = new jo(this), this.stencilOp = new Vo(this), this.stencilTest = new qo(this), this.depthRange = new Zo(this), this.depthTest = new Ho(this), this.depthFunc = new Wo(this), this.blend = new $o(this), this.blendFunc = new Xo(this), this.blendColor = new Yo(this), this.blendEquation = new Ko(this), this.cullFace = new Jo(this), this.cullFaceSide = new Qo(this), this.frontFace = new er(this), this.program = new tr(this), this.activeTexture = new ir(this), this.viewport = new or(this), this.bindFramebuffer = new rr(this), this.bindRenderbuffer = new sr(this), this.bindTexture = new ar(this), this.bindVertexBuffer = new nr(this), this.bindElementBuffer = new lr(this), this.bindVertexArrayOES = new cr(this), this.pixelStoreUnpack = new hr(this), this.pixelStoreUnpackPremultiplyAlpha = new ur(this), this.pixelStoreUnpackFlipY = new dr(this), this.options = t2 ? { ...t2 } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e2.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.maxPointSize = e2.getParameter(e2.ALIASED_POINT_SIZE_RANGE)[1];
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(e2, t2, i2) {
              return new hs(this, e2, t2, i2);
            }
            createVertexBuffer(e2, t2, i2, o2, r2) {
              return new ds(this, e2, t2, i2, o2, r2);
            }
            createRenderbuffer(e2, t2, i2) {
              const o2 = this.gl, r2 = o2.createRenderbuffer();
              return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r2;
            }
            createFramebuffer(e2, t2, i2, o2) {
              return new _s(this, e2, t2, i2, o2);
            }
            clear({ color: e2, depth: t2, stencil: i2, colorMask: o2 }) {
              const r2 = this.gl;
              let s2 = 0;
              e2 && (s2 |= r2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set(o2 || [true, true, true, true])), void 0 !== t2 && (s2 |= r2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (s2 |= r2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), r2.clear(s2);
            }
            setCullFace(e2) {
              false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
            }
            setDepthMode(e2) {
              e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
            }
            setStencilMode(e2) {
              e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(t2) {
              e.bh(t2.blendFunction, Ai.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor), t2.blendEquation ? this.blendEquation.set(t2.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t2.mask);
            }
            unbindVAO() {
              this.bindVertexArrayOES.set(null);
            }
          }
          let ms;
          function fs(t2, i2, o2, r2, s2, a2, n2) {
            const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, u2 = t2.getOrCreateProgram("collisionBox"), d2 = [];
            let _2 = 0, p2 = 0;
            for (let l3 = 0; l3 < r2.length; l3++) {
              const m3 = r2[l3], f3 = i2.getTile(m3), g3 = f3.getBucket(o2);
              if (!g3)
                continue;
              const v3 = ti(m3, g3, h2);
              let x3 = v3;
              0 === s2[0] && 0 === s2[1] || (x3 = t2.translatePosMatrix(v3, f3, s2, a2));
              const y3 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, b2 = g3.collisionCircleArray;
              if (b2.length > 0) {
                const t3 = e.a6.mat4.create(), i3 = x3;
                e.a6.mat4.mul(t3, g3.placementInvProjMatrix, h2.glCoordMatrix), e.a6.mat4.mul(t3, t3, g3.placementViewportMatrix), d2.push({ circleArray: b2, circleOffset: p2, transform: i3, invTransform: t3, projection: g3.getProjection() }), _2 += b2.length / 4, p2 = _2;
              }
              y3 && (t2.terrain && t2.terrain.setupElevationDraw(f3, u2), u2.draw(t2, c2.LINES, Li.disabled, Mi.disabled, t2.colorModeForRenderPass(), Fi.disabled, qr(x3, h2, f3, g3.getProjection()), o2.id, y3.layoutVertexBuffer, y3.indexBuffer, y3.segments, null, h2.zoom, null, [y3.collisionVertexBuffer, y3.collisionVertexBufferExt]));
            }
            if (!n2 || !d2.length)
              return;
            const m2 = t2.getOrCreateProgram("collisionCircle"), f2 = new e.cQ();
            f2.resize(4 * _2), f2._trim();
            let g2 = 0;
            for (const e2 of d2)
              for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
                const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], r3 = e2.circleArray[i3 + 1], s3 = e2.circleArray[i3 + 2], a3 = e2.circleArray[i3 + 3];
                f2.emplace(g2++, o3, r3, s3, a3, 0), f2.emplace(g2++, o3, r3, s3, a3, 1), f2.emplace(g2++, o3, r3, s3, a3, 2), f2.emplace(g2++, o3, r3, s3, a3, 3);
              }
            (!ms || ms.length < 2 * _2) && (ms = function(t3) {
              const i3 = 2 * t3, o3 = new e.aO();
              o3.resize(i3), o3._trim();
              for (let e2 = 0; e2 < i3; e2++) {
                const t4 = 6 * e2;
                o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
              }
              return o3;
            }(_2));
            const v2 = l2.createIndexBuffer(ms, true), x2 = l2.createVertexBuffer(f2, e.cR.members, true);
            for (const i3 of d2) {
              const r3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y2 = h2).getCameraToCenterDistance(i3.projection), u_viewport_size: [y2.width, y2.height] };
              m2.draw(t2, c2.TRIANGLES, Li.disabled, Mi.disabled, t2.colorModeForRenderPass(), Fi.disabled, r3, o2.id, x2, v2, e.b1.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h2.zoom);
            }
            var y2;
            x2.destroy(), v2.destroy();
          }
          const gs = e.a6.mat4.create();
          function vs(t2) {
            const i2 = t2._camera.getWorldToCamera(t2.worldSize, 1), o2 = e.a6.mat4.multiply([], i2, t2.globeMatrix);
            e.a6.mat4.invert(o2, o2);
            const r2 = [0, 0, 0], s2 = [0, 1, 0, 0];
            return e.a6.vec4.transformMat4(s2, s2, o2), r2[0] = s2[0], r2[1] = s2[1], r2[2] = s2[2], e.a6.vec3.normalize(r2, r2), r2;
          }
          function xs({ width: t2, height: i2, anchor: o2, textOffset: r2, textScale: s2 }, a2) {
            const { horizontalAlign: n2, verticalAlign: l2 } = e.bx(o2), c2 = -(n2 - 0.5) * t2, h2 = -(l2 - 0.5) * i2, u2 = e.bw(o2, r2);
            return new e.P((c2 / s2 + u2[0]) * a2, (h2 / s2 + u2[1]) * a2);
          }
          function ys(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2) {
            const d2 = t2.text.placedSymbolArray, _2 = t2.text.dynamicLayoutVertexArray, p2 = t2.icon.dynamicLayoutVertexArray, m2 = {}, f2 = t2.getProjection(), g2 = ii(l2, f2, a2), v2 = a2.elevation, x2 = f2.upVectorScale(l2.canonical, a2.center.lat, a2.worldSize).metersToTile;
            _2.clear();
            for (let p3 = 0; p3 < d2.length; p3++) {
              const y2 = d2.get(p3), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y2, E2 = y2.hidden || !y2.crossTileID || t2.allowVerticalPlacement && !y2.placedOrientation ? null : r2[y2.crossTileID];
              if (E2) {
                let r3 = 0, d3 = 0, p4 = 0;
                if (v2) {
                  const e2 = v2 ? v2.getAtTileOffset(l2, b2, w2) : 0, [t3, i3, o3] = f2.upVector(l2.canonical, b2, w2);
                  r3 = e2 * t3 * x2, d3 = e2 * i3 * x2, p4 = e2 * o3 * x2;
                }
                let [C2, S2, I2, D2] = Ut(y2.projectedAnchorX + r3, y2.projectedAnchorY + d3, y2.projectedAnchorZ + p4, o2 ? g2 : n2);
                const R2 = Gt(a2.getCameraToCenterDistance(f2), D2);
                let A2 = s2.evaluateSizeForFeature(t2.textSizeData, h2, y2) * R2 / e.bq;
                o2 && (A2 *= t2.tilePixelRatio / c2);
                const L2 = xs(E2, A2);
                o2 ? ({ x: C2, y: S2, z: I2 } = f2.projectTilePoint(b2 + L2.x, w2 + L2.y, l2.canonical), [C2, S2, I2] = Ut(C2 + r3, S2 + d3, I2 + p4, n2)) : (i2 && L2._rotate(-a2.angle), C2 += L2.x, S2 += L2.y, I2 = 0);
                const P2 = t2.allowVerticalPlacement && y2.placedOrientation === e.bk.vertical ? Math.PI / 2 : 0;
                for (let t3 = 0; t3 < T2; t3++)
                  e.bn(_2, C2, S2, I2, P2);
                u2 && y2.associatedIconIndex >= 0 && (m2[y2.associatedIconIndex] = { x: C2, y: S2, z: I2, angle: P2 });
              } else
                Yt(T2, _2);
            }
            if (u2) {
              p2.clear();
              const i3 = t2.icon.placedSymbolArray;
              for (let t3 = 0; t3 < i3.length; t3++) {
                const o3 = i3.get(t3), { numGlyphs: r3 } = o3, s3 = m2[t3];
                if (o3.hidden || !s3)
                  Yt(r3, p2);
                else {
                  const { x: t4, y: i4, z: o4, angle: a3 } = s3;
                  for (let s4 = 0; s4 < r3; s4++)
                    e.bn(p2, t4, i4, o4, a3);
                }
              }
              t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
            }
            t2.text.dynamicLayoutVertexBuffer.updateData(_2);
          }
          function bs(t2, i2, o2, r2, s2, a2, n2 = {}) {
            const l2 = o2.paint.get("icon-translate"), c2 = o2.paint.get("text-translate"), h2 = o2.paint.get("icon-translate-anchor"), u2 = o2.paint.get("text-translate-anchor"), d2 = o2.layout.get("icon-rotation-alignment"), _2 = o2.layout.get("text-rotation-alignment"), p2 = o2.layout.get("icon-pitch-alignment"), m2 = o2.layout.get("text-pitch-alignment"), f2 = o2.layout.get("icon-keep-upright"), g2 = o2.layout.get("text-keep-upright"), v2 = o2.paint.get("icon-color-saturation"), x2 = o2.paint.get("icon-color-contrast"), y2 = o2.paint.get("icon-color-brightness-min"), b2 = o2.paint.get("icon-color-brightness-max"), w2 = "sea" === o2.paint.get("symbol-elevation-reference"), T2 = o2.paint.get("text-occlusion-opacity").constantOr(0), E2 = t2.context, C2 = E2.gl, S2 = t2.transform, I2 = "map" === d2, D2 = "map" === _2, R2 = "map" === p2, A2 = "map" === m2, L2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
            let P2 = false;
            const M2 = t2.depthModeForSublayer(0, Li.ReadOnly), z2 = [e.am(S2.center.lng), e.at(S2.center.lat)], O2 = o2.layout.get("text-variable-anchor"), F2 = "globe" === S2.projection.name, k2 = [], B2 = [0, -1, 0];
            for (const s3 of r2) {
              const r3 = i2.getTile(s3), a3 = r3.getBucket(o2);
              if (!a3)
                continue;
              if ("mercator" === a3.projection.name && F2)
                continue;
              if (a3.fullyClipped)
                continue;
              const d3 = "globe" === a3.projection.name, _3 = d3 ? e.a9(S2.zoom) : 0, p3 = ii(s3, a3.getProjection(), S2), m3 = S2.calculatePixelsToTileUnitsMatrix(r3), E3 = O2 && a3.hasTextData(), M3 = a3.hasIconTextFit() && E3 && a3.hasIconData(), N2 = a3.getProjection().createInversionMatrix(S2, s3.canonical), U2 = (e2) => {
                S2.depthOcclusionForSymbolsAndCircles && (o2.hasInitialOcclusionOpacityProperties || t2.terrain) && (e2.push("DEPTH_D24"), e2.push("DEPTH_OCCLUSION"));
              }, G2 = () => {
                const i3 = I2 && "point" !== o2.layout.get("symbol-placement"), n3 = [];
                U2(n3);
                const c3 = i3 || M3, u3 = o2.paint.get("icon-image-cross-fade").constantOr(0);
                t2.terrainRenderModeElevated() && R2 && n3.push("PITCH_WITH_MAP_TERRAIN"), d3 && (n3.push("PROJECTION_GLOBE_VIEW"), c3 && n3.push("PROJECTED_POS_ON_VIEWPORT")), u3 > 0 && n3.push("ICON_TRANSITION"), a3.icon.zOffsetVertexBuffer && n3.push("Z_OFFSET"), 0 === v2 && 0 === x2 && 0 === y2 && 1 === b2 || n3.push("COLOR_ADJUSTMENT"), a3.sdfIcons && n3.push("RENDER_SDF");
                const g3 = a3.icon.programConfigurations.get(o2.id), T3 = t2.getOrCreateProgram("symbol", { config: g3, defines: n3 }), E4 = r3.imageAtlasTexture ? r3.imageAtlasTexture.size : [0, 0], D3 = a3.iconSizeData, A3 = e.bj(D3, S2.zoom), L3 = R2 || 0 !== S2.pitch, P3 = kt(p3, r3.tileID.canonical, R2, I2, S2, a3.getProjection(), m3), O3 = Nt(p3, r3.tileID.canonical, R2, I2, S2, a3.getProjection(), m3), k3 = t2.translatePosMatrix(O3, r3, l2, h2, true), G3 = t2.translatePosMatrix(p3, r3, l2, h2), j3 = c3 ? gs : P3, V3 = I2 && !R2 && !i3;
                let q3 = B2;
                !F2 && !S2.mercatorFromTransition || I2 || (q3 = vs(S2));
                const Z3 = d3 ? q3 : B2, H3 = o2.getColorAdjustmentMatrix(v2, x2, y2, b2), W3 = os(D3.kind, A3, V3, R2, t2, G3, j3, k3, w2, false, E4, [0, 0], true, s3, _3, z2, N2, Z3, a3.getProjection(), H3, u3), $3 = r3.imageAtlasTexture ? r3.imageAtlasTexture : null, X2 = 1 !== o2.layout.get("icon-size").constantOr(0) || a3.iconsNeedLinear, Y2 = a3.sdfIcons || t2.options.rotating || t2.options.zooming || X2 || L3 ? C2.LINEAR : C2.NEAREST, K2 = a3.sdfIcons && 0 !== o2.paint.get("icon-halo-width").constantOr(1), J2 = t2.terrain && R2 && i3 ? e.a6.mat4.invert(e.a6.mat4.create(), P3) : gs;
                if (i3 && a3.icon) {
                  const e2 = S2.elevation, i4 = e2 ? e2.getAtTileOffsetFunc(s3, S2.center.lat, S2.worldSize, a3.getProjection()) : null, o3 = Bt(p3, r3.tileID.canonical, R2, I2, S2, a3.getProjection(), m3);
                  Vt(a3, p3, t2, false, o3, O3, R2, f2, i4, s3);
                }
                return { program: T3, buffers: a3.icon, uniformValues: W3, atlasTexture: $3, atlasTextureIcon: null, atlasInterpolation: Y2, atlasInterpolationIcon: null, isSDF: a3.sdfIcons, hasHalo: K2, tile: r3, labelPlaneMatrixInv: J2 };
              }, j2 = () => {
                const i3 = D2 && "point" !== o2.layout.get("symbol-placement"), n3 = [], l3 = i3 || O2 || M3;
                t2.terrainRenderModeElevated() && A2 && n3.push("PITCH_WITH_MAP_TERRAIN"), d3 && (n3.push("PROJECTION_GLOBE_VIEW"), l3 && n3.push("PROJECTED_POS_ON_VIEWPORT")), a3.text.zOffsetVertexBuffer && n3.push("Z_OFFSET"), a3.iconsInText && n3.push("RENDER_TEXT_AND_SYMBOL"), n3.push("RENDER_SDF"), U2(n3);
                const h3 = a3.text.programConfigurations.get(o2.id), f3 = t2.getOrCreateProgram("symbol", { config: h3, defines: n3 });
                let v3, x3 = [0, 0], y3 = null;
                const b3 = a3.textSizeData;
                a3.iconsInText && (x3 = r3.imageAtlasTexture ? r3.imageAtlasTexture.size : [0, 0], y3 = r3.imageAtlasTexture ? r3.imageAtlasTexture : null, v3 = A2 || 0 !== S2.pitch || t2.options.rotating || t2.options.zooming || "composite" === b3.kind || "camera" === b3.kind ? C2.LINEAR : C2.NEAREST);
                const E4 = r3.glyphAtlasTexture ? r3.glyphAtlasTexture.size : [0, 0], I3 = e.bj(b3, S2.zoom), R3 = kt(p3, r3.tileID.canonical, A2, D2, S2, a3.getProjection(), m3), L3 = Nt(p3, r3.tileID.canonical, A2, D2, S2, a3.getProjection(), m3), P3 = t2.translatePosMatrix(L3, r3, c2, u2, true), k3 = t2.translatePosMatrix(p3, r3, c2, u2), G3 = l3 ? gs : R3, j3 = D2 && !A2 && !i3;
                let V3 = B2;
                !F2 && !S2.mercatorFromTransition || D2 || (V3 = vs(S2));
                const q3 = os(b3.kind, I3, j3, A2, t2, k3, G3, P3, w2, true, E4, x3, true, s3, _3, z2, N2, d3 ? V3 : B2, a3.getProjection(), T2), Z3 = r3.glyphAtlasTexture ? r3.glyphAtlasTexture : null, H3 = C2.LINEAR, W3 = 0 !== o2.paint.get("text-halo-width").constantOr(1), $3 = t2.terrain && A2 && i3 ? e.a6.mat4.invert(e.a6.mat4.create(), R3) : gs;
                if (i3 && a3.text) {
                  const e2 = S2.elevation, i4 = e2 ? e2.getAtTileOffsetFunc(s3, S2.center.lat, S2.worldSize, a3.getProjection()) : null, o3 = Bt(p3, r3.tileID.canonical, A2, D2, S2, a3.getProjection(), m3);
                  Vt(a3, p3, t2, true, o3, L3, A2, g2, i4, s3);
                }
                return { program: f3, buffers: a3.text, uniformValues: q3, atlasTexture: Z3, atlasTextureIcon: y3, atlasInterpolation: H3, atlasInterpolationIcon: v3, isSDF: true, hasHalo: W3, tile: r3, labelPlaneMatrixInv: $3 };
              }, V2 = a3.icon.segments.get().length, q2 = a3.text.segments.get().length, Z2 = V2 && !n2.onlyText ? G2() : null, H2 = q2 && !n2.onlyIcons ? j2() : null, W2 = o2.paint.get("icon-opacity").constantOr(1), $2 = o2.paint.get("text-opacity").constantOr(1);
              if (L2 && a3.canOverlap) {
                P2 = true;
                const t3 = W2 && !n2.onlyText ? a3.icon.segments.get() : [], i3 = $2 && !n2.onlyIcons ? a3.text.segments.get() : [];
                for (const i4 of t3)
                  k2.push({ segments: new e.b1([i4]), sortKey: i4.sortKey, state: Z2 });
                for (const t4 of i3)
                  k2.push({ segments: new e.b1([t4]), sortKey: t4.sortKey, state: H2 });
              } else
                n2.onlyText || k2.push({ segments: W2 ? a3.icon.segments : new e.b1([]), sortKey: 0, state: Z2 }), n2.onlyIcons || k2.push({ segments: $2 ? a3.text.segments : new e.b1([]), sortKey: 0, state: H2 });
            }
            P2 && k2.sort((e2, t3) => e2.sortKey - t3.sortKey);
            for (const e2 of k2) {
              const i3 = e2.state;
              if (i3)
                if (t2.terrain ? t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: S2.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }) : t2.setupDepthForOcclusion(S2.depthOcclusionForSymbolsAndCircles, i3.program), E2.activeTexture.set(C2.TEXTURE0), i3.atlasTexture && i3.atlasTexture.bind(i3.atlasInterpolation, C2.CLAMP_TO_EDGE, true), i3.atlasTextureIcon && (E2.activeTexture.set(C2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, C2.CLAMP_TO_EDGE, true)), t2.uploadCommonLightUniforms(t2.context, i3.program), i3.hasHalo) {
                  const r3 = i3.uniformValues;
                  r3.u_is_halo = 1, ws(i3.buffers, e2.segments, o2, t2, i3.program, M2, s2, a2, r3, 2), r3.u_is_halo = 0;
                } else {
                  if (i3.isSDF) {
                    const r3 = i3.uniformValues;
                    i3.hasHalo && (r3.u_is_halo = 1, ws(i3.buffers, e2.segments, o2, t2, i3.program, M2, s2, a2, r3, 1)), r3.u_is_halo = 0;
                  }
                  ws(i3.buffers, e2.segments, o2, t2, i3.program, M2, s2, a2, i3.uniformValues, 1);
                }
            }
          }
          function ws(e2, t2, i2, o2, r2, s2, a2, n2, l2, c2) {
            const h2 = [e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer, e2.iconTransitioningVertexBuffer, e2.globeExtVertexBuffer, e2.zOffsetVertexBuffer];
            r2.draw(o2, o2.context.gl.TRIANGLES, s2, a2, n2, Fi.disabled, l2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, o2.transform.zoom, e2.programConfigurations.get(i2.id), h2, c2);
          }
          function Ts(e2, t2, i2, o2, r2, s2, a2) {
            const n2 = e2.context.gl, l2 = i2.paint.get("fill-pattern"), c2 = i2.is3D(), h2 = c2 ? e2.stencilModeFor3D() : Mi.disabled, u2 = l2 && l2.constantOr(1);
            let d2, _2, p2, m2, f2;
            a2 ? (_2 = u2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n2.LINES) : (_2 = u2 ? "fillPattern" : "fill", d2 = n2.TRIANGLES);
            for (const g2 of o2) {
              const o3 = t2.getTile(g2);
              if (u2 && !o3.patternsLoaded())
                continue;
              const v2 = o3.getBucket(i2);
              if (!v2)
                continue;
              e2.prepareDrawTile();
              const x2 = v2.programConfigurations.get(i2.id), y2 = e2.isTileAffectedByFog(g2), b2 = e2.getOrCreateProgram(_2, { config: x2, overrideFog: y2 });
              u2 && (e2.context.activeTexture.set(n2.TEXTURE0), o3.imageAtlasTexture && o3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers());
              const w2 = l2.constantOr(null);
              if (w2 && o3.imageAtlas) {
                const e3 = o3.imageAtlas.patternPositions[w2.toString()];
                e3 && x2.setConstantPatternPositions(e3);
              }
              const T2 = e2.translatePosMatrix(g2.projMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor")), E2 = i2.paint.get("fill-emissive-strength");
              if (a2) {
                m2 = v2.indexBuffer2, f2 = v2.segments2;
                const t3 = e2.terrain && e2.terrain.renderingToTexture ? e2.terrain.drapeBufferSize : [n2.drawingBufferWidth, n2.drawingBufferHeight];
                p2 = "fillOutlinePattern" === _2 && u2 ? Vr(T2, E2, e2, o3, t3) : jr(T2, E2, t3);
              } else
                m2 = v2.indexBuffer, f2 = v2.segments, p2 = u2 ? Gr(T2, E2, e2, o3) : Ur(T2, E2);
              e2.uploadCommonUniforms(e2.context, b2, g2.toUnwrapped()), b2.draw(e2, d2, r2, c2 ? h2 : e2.stencilModeForClipping(g2), s2, Fi.disabled, p2, i2.id, v2.layoutVertexBuffer, m2, f2, i2.paint, e2.transform.zoom, x2, void 0);
            }
          }
          function Es(t2, i2, o2, r2, s2, a2, n2, l2) {
            o2.resetLayerRenderingStats(t2);
            const c2 = t2.context, h2 = c2.gl, u2 = t2.transform, d2 = o2.paint.get("fill-extrusion-pattern"), _2 = d2.constantOr(1), p2 = o2.paint.get("fill-extrusion-opacity"), m2 = t2.style.enable3dLights(), f2 = o2.paint.get(m2 && !_2 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), f2], v2 = o2.layout.get("fill-extrusion-edge-radius"), x2 = v2 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), y2 = x2 ? 0 : v2, b2 = "globe" === u2.projection.name ? e.c_() : 0, w2 = "globe" === u2.projection.name, T2 = w2 ? e.a9(u2.zoom) : 0, E2 = [e.am(u2.center.lng), e.at(u2.center.lat)], C2 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(o2.lut).toArray01().slice(0, 3), S2 = o2.paint.get("fill-extrusion-flood-light-intensity"), I2 = o2.paint.get("fill-extrusion-vertical-scale"), D2 = 0 !== o2.paint.get("fill-extrusion-line-width").constantOr(1), R2 = Wi(t2, o2.paint.get("fill-extrusion-cutoff-fade-range")), A2 = [];
            let L2;
            w2 && A2.push("PROJECTION_GLOBE_VIEW"), g2[0] > 0 && A2.push("FAUX_AO"), x2 && A2.push("ZERO_ROOF_RADIUS"), l2 && A2.push("HAS_CENTROID"), S2 > 0 && A2.push("FLOOD_LIGHT"), R2.shouldRenderCutoff && A2.push("RENDER_CUTOFF"), D2 && A2.push("RENDER_WALL_MODE");
            const P2 = "shadow" === t2.renderPass, M2 = t2.shadowRenderer, z2 = P2 && !!M2;
            t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = true);
            let O2 = [0, 0, 0];
            if (M2) {
              const e2 = t2.style.directionalLight, i3 = t2.style.ambientLight;
              e2 && i3 && (O2 = eo(t2.style, e2, i3)), L2 = A2.concat(["SHADOWS_SINGLE_CASCADE"]);
            }
            const F2 = z2 ? "fillExtrusionDepth" : _2 ? "fillExtrusionPattern" : "fillExtrusion", k2 = o2.getLayerRenderingStats();
            for (const e2 of r2) {
              const r3 = i2.getTile(e2), m3 = r3.getBucket(o2);
              if (!m3 || m3.projection.name !== u2.projection.name)
                continue;
              let f3 = false;
              M2 && (f3 = 0 === M2.getMaxCascadeForTile(e2.toUnwrapped()));
              const v3 = t2.isTileAffectedByFog(e2), x3 = m3.programConfigurations.get(o2.id), z3 = t2.getOrCreateProgram(F2, { config: x3, defines: f3 ? L2 : A2, overrideFog: v3 });
              if (t2.terrain && t2.terrain.setupElevationDraw(r3, z3, { useMeterToDem: true }), !m3.centroidVertexBuffer) {
                const e3 = z3.attributes.a_centroid_pos;
                void 0 !== e3 && h2.vertexAttrib2f(e3, 0, 0);
              }
              !P2 && M2 && M2.setupShadows(r3.tileID.toUnwrapped(), z3, "vector-tile", r3.tileID.overscaledZ), _2 && (t2.context.activeTexture.set(h2.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), x3.updatePaintBuffers());
              const B2 = d2.constantOr(null);
              if (B2 && r3.imageAtlas) {
                const e3 = r3.imageAtlas.patternPositions[B2.toString()];
                e3 && x3.setConstantPatternPositions(e3);
              }
              const N2 = o2.paint.get("fill-extrusion-vertical-gradient"), U2 = 1 / m3.tileToMeter;
              let G2;
              if (P2 && M2) {
                if (As(r3.tileID, m3, t2))
                  continue;
                const e3 = M2.calculateShadowPassMatrixFromTile(r3.tileID.toUnwrapped());
                G2 = Br(e3, y2, U2, I2);
              } else {
                const i3 = t2.translatePosMatrix(e2.expandedProjMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), s3 = u2.projection.createInversionMatrix(u2, e2.canonical);
                G2 = _2 ? Nr(i3, t2, N2, p2, g2, y2, U2, e2, r3, b2, T2, E2, s3, C2, I2) : kr(i3, t2, N2, p2, g2, y2, U2, e2, b2, T2, E2, s3, C2, I2, S2, O2);
              }
              t2.uploadCommonUniforms(c2, z3, e2.toUnwrapped(), null, R2);
              let j2 = m3.segments;
              if ("mercator" === u2.projection.name && !P2 && (j2 = m3.getVisibleSegments(r3.tileID, t2.terrain, t2.transform.getFrustum(0)), !j2.get().length))
                continue;
              if (k2)
                if (P2)
                  for (const e3 of j2.get())
                    k2.numRenderedVerticesInShadowPass += e3.primitiveLength;
                else
                  for (const e3 of j2.get())
                    k2.numRenderedVerticesInTransparentPass += e3.primitiveLength;
              const V2 = [];
              (t2.terrain || l2) && V2.push(m3.centroidVertexBuffer), w2 && V2.push(m3.layoutVertexExtBuffer), D2 && V2.push(m3.wallVertexBuffer), z3.draw(t2, c2.gl.TRIANGLES, s2, a2, n2, Fi.backCCW, G2, o2.id, m3.layoutVertexBuffer, m3.indexBuffer, j2, o2.paint, t2.transform.zoom, x3, V2);
            }
            t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = false);
          }
          function Cs(t2, i2, o2, r2, s2, a2, n2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2, v2, x2) {
            const y2 = t2.context, b2 = y2.gl, w2 = t2.transform, T2 = t2.transform.zoom, E2 = [], C2 = Wi(t2, o2.paint.get("fill-extrusion-cutoff-fade-range"));
            "clear" === h2 ? (E2.push("CLEAR_SUBPASS"), x2 && (E2.push("CLEAR_FROM_TEXTURE"), y2.activeTexture.set(b2.TEXTURE0), x2.bind(b2.LINEAR, b2.CLAMP_TO_EDGE))) : "sdf" === h2 && E2.push("SDF_SUBPASS"), g2 && E2.push("HAS_CENTROID"), C2.shouldRenderCutoff && E2.push("RENDER_CUTOFF");
            const S2 = o2.layout.get("fill-extrusion-edge-radius"), I2 = (e2, i3, r3, h3, v3) => {
              const b3 = i3.programConfigurations.get(o2.id), w3 = t2.isTileAffectedByFog(e2), I3 = t2.getOrCreateProgram("fillExtrusionGroundEffect", { config: b3, defines: E2, overrideFog: w3 }), D2 = /* @__PURE__ */ ((e3, t3, i4, o3, r4, s3, a3, n3, l3, c3, h4) => ({ u_matrix: t3, u_opacity: i4, u_ao_pass: o3 ? 1 : 0, u_meter_to_tile: r4, u_ao: s3, u_flood_light_intensity: a3, u_flood_light_color: n3, u_attenuation: l3, u_edge_radius: c3, u_fb: 0, u_fb_size: h4, u_dynamic_offset: 1 }))(0, h3, u2, c2, v3, [d2, _2 * v3], p2, m2, f2, T2 >= 17 ? 0 : S2 * v3, x2 ? x2.size[0] : 0), R2 = [];
              g2 && R2.push(i3.hiddenByLandmarkVertexBuffer), t2.uploadCommonUniforms(y2, I3, e2.toUnwrapped(), null, C2), I3.draw(t2, y2.gl.TRIANGLES, s2, a2, n2, l2, D2, o2.id, i3.vertexBuffer, i3.indexBuffer, r3, o2.paint, T2, b3, R2);
            };
            for (const s3 of r2) {
              const r3 = i2.getTile(s3), a3 = r3.getBucket(o2);
              if (!a3 || a3.projection.name !== w2.projection.name || !a3.groundEffect || a3.groundEffect && !a3.groundEffect.hasData())
                continue;
              const n3 = a3.groundEffect, l3 = 1 / a3.tileToMeter;
              {
                const e2 = t2.translatePosMatrix(s3.projMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = n3.getDefaultSegment();
                I2(s3, n3, i3, e2, l3);
              }
              if (v2)
                for (let a4 = 0; a4 < 4; a4++) {
                  const n4 = e.c$[a4](s3), c3 = i2.getTile(n4);
                  if (!c3)
                    continue;
                  const h3 = c3.getBucket(o2);
                  if (!h3 || h3.projection.name !== w2.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData())
                    continue;
                  const u3 = h3.groundEffect;
                  let d3, _3;
                  0 === a4 ? (d3 = [-e.ab, 0, 0], _3 = 1) : 1 === a4 ? (d3 = [e.ab, 0, 0], _3 = 0) : 2 === a4 ? (d3 = [0, -e.ab, 0], _3 = 3) : (d3 = [0, e.ab, 0], _3 = 2);
                  const p3 = u3.regionSegments[_3];
                  if (!p3)
                    continue;
                  const m3 = new Float32Array(16);
                  e.a6.mat4.translate(m3, s3.projMatrix, d3), I2(s3, u3, p3, t2.translatePosMatrix(m3, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), l3);
                }
            }
          }
          function Ss(t2, i2, o2, r2, s2, a2, n2) {
            0 === r2.centroidVertexArray.length && r2.createCentroidsBuffer();
            const l2 = a2 ? a2.findDEMTileFor(o2) : null;
            if (!(l2 && l2.dem || n2))
              return;
            const c2 = (t3) => new e.P(Math.ceil((t3 + e.d2) * e.d3), 0), h2 = (e2) => {
              const t3 = i2.getSource().minzoom, o3 = (e3) => {
                const t4 = i2.getTileByID(e3);
                if (t4 && t4.hasData())
                  return t4.getBucket(s2);
              }, r3 = [0, -1, 1];
              for (const i3 of r3) {
                if (e2.overscaledZ + i3 < t3)
                  continue;
                const r4 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
                if (r4)
                  return r4;
              }
            }, u2 = [0, 0, 0], d2 = (t3, i3) => (u2[0] = Math.min(t3.min.y, i3.min.y), u2[1] = Math.max(t3.max.y, i3.max.y), u2[2] = e.ab - i3.min.x > t3.max.x ? i3.min.x - e.ab : t3.max.x, u2), _2 = (t3, i3) => (u2[0] = Math.min(t3.min.x, i3.min.x), u2[1] = Math.max(t3.max.x, i3.max.x), u2[2] = e.ab - i3.min.y > t3.max.y ? i3.min.y - e.ab : t3.max.y, u2), p2 = [(e2, t3) => d2(e2, t3), (e2, t3) => d2(t3, e2), (e2, t3) => _2(e2, t3), (e2, t3) => _2(t3, e2)], m2 = (t3, i3, r3, s3, n3, c3, h3) => {
              if (!a2)
                return 0;
              const u3 = [[c3 ? r3 : t3, c3 ? t3 : r3, 0], [c3 ? r3 : i3, c3 ? i3 : r3, 0]], d3 = h3 < 0 ? e.ab + h3 : h3, _3 = [c3 ? d3 : (t3 + i3) / 2, c3 ? (t3 + i3) / 2 : d3, 0];
              return 0 === r3 && h3 < 0 || 0 !== r3 && h3 > 0 ? a2.getForTilePoints(n3, [_3], true, s3) : u3.push(_3), a2.getForTilePoints(o2, u3, true, l2), Math.max(u3[0][2], u3[1][2], _3[2]) / a2.exaggeration();
            };
            for (let t3 = 0; t3 < 4; t3++) {
              const i3 = r2.borderFeatureIndices[t3];
              if (0 === i3.length)
                continue;
              const s3 = e.c$[t3](o2), l3 = h2(s3);
              if (!(l3 && l3 instanceof e.d0))
                continue;
              if (r2.borderDoneWithNeighborZ[t3] === l3.canonical.z)
                continue;
              0 === l3.centroidVertexArray.length && l3.createCentroidsBuffer();
              const u3 = a2 ? a2.findDEMTileFor(s3) : null;
              if (!(u3 && u3.dem || n2))
                continue;
              const d3 = (t3 < 2 ? 1 : 5) - t3, _3 = l3.borderDoneWithNeighborZ[d3] !== r2.canonical.z, v2 = l3.borderFeatureIndices[d3];
              let x2 = 0;
              if (r2.canonical.z !== l3.canonical.z) {
                for (const e2 of i3)
                  r2.showCentroid(r2.featuresOnBorder[e2]);
                if (_3)
                  for (const e2 of v2)
                    l3.showCentroid(l3.featuresOnBorder[e2]);
                r2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[d3] = r2.canonical.z;
              }
              for (const o3 of i3) {
                const i4 = r2.featuresOnBorder[o3], a3 = r2.centroidData[i4.centroidDataIndex], h3 = i4.borders[t3];
                let _4;
                for (; x2 < v2.length; ) {
                  _4 = l3.featuresOnBorder[v2[x2]];
                  const e2 = _4.borders[d3];
                  if (e2[1] > h3[0] + 3 || e2[0] > h3[0] - 3)
                    break;
                  l3.showCentroid(_4), x2++;
                }
                if (_4 && x2 < v2.length) {
                  const o4 = x2;
                  let y2 = 0;
                  for (; !(_4.borders[d3][0] > h3[1] - 3) && (y2++, ++x2 !== v2.length); )
                    _4 = l3.featuresOnBorder[v2[x2]];
                  _4 = l3.featuresOnBorder[v2[o4]];
                  let b2 = false;
                  if (y2 >= 1) {
                    const e2 = _4.borders[d3];
                    Math.abs(h3[0] - e2[0]) < 3 && Math.abs(h3[1] - e2[1]) < 3 && (y2 = 1, b2 = true, x2 = o4 + 1);
                  } else if (0 === y2) {
                    r2.showCentroid(i4);
                    continue;
                  }
                  const w2 = l3.centroidData[_4.centroidDataIndex];
                  n2 && b2 && (((f2 = a3).flags | (g2 = w2).flags) & e.d1 ? (f2.flags |= e.d1, g2.flags |= e.d1) : (f2.flags &= ~e.d1, g2.flags &= ~e.d1));
                  const T2 = i4.intersectsCount() > 1 || _4.intersectsCount() > 1;
                  if (y2 > 1)
                    x2 = o4, a3.centroidXY = w2.centroidXY = new e.P(0, 0);
                  else if (u3 && u3.dem && !T2) {
                    const i5 = p2[t3](a3, w2), o5 = t3 % 2 ? e.ab - 1 : 0, r3 = m2(i5[0], Math.min(e.ab - 1, i5[1]), o5, u3, s3, t3 < 2, i5[2]);
                    a3.centroidXY = w2.centroidXY = c2(r3);
                  } else
                    T2 ? a3.centroidXY = w2.centroidXY = new e.P(0, 0) : (a3.centroidXY = r2.encodeBorderCentroid(i4), w2.centroidXY = l3.encodeBorderCentroid(_4));
                  r2.writeCentroidToBuffer(a3), l3.writeCentroidToBuffer(w2);
                } else
                  r2.showCentroid(i4);
              }
              r2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[d3] = r2.canonical.z;
            }
            var f2, g2;
            (r2.needsCentroidUpdate || !r2.centroidVertexBuffer && 0 !== r2.centroidVertexArray.length) && r2.uploadCentroid(t2);
          }
          const Is = [1, 0, 0], Ds = [0, 1, 0], Rs = [0, 0, 1];
          function As(t2, i2, o2) {
            const r2 = o2.transform, s2 = o2.shadowRenderer;
            if (!s2)
              return true;
            const a2 = t2.toUnwrapped(), n2 = r2.tileSize * s2._cascades[o2.currentShadowCascade].scale;
            let l2 = i2.maxHeight;
            if (r2.elevation) {
              const e2 = r2.elevation.getMinMaxForTile(t2);
              e2 && (l2 += e2.max);
            }
            const c2 = [...s2.shadowDirection];
            c2[2] = -c2[2];
            const h2 = s2.computeSimplifiedTileShadowVolume(a2, l2, n2, c2);
            if (!h2)
              return false;
            const u2 = [Is, Ds, Rs, c2, [c2[0], 0, c2[2]], [0, c2[1], c2[2]]], d2 = "globe" === r2.projection.name, _2 = r2.scaleZoom(n2), p2 = e.bN.fromInvProjectionMatrix(r2.invProjMatrix, r2.worldSize, _2, !d2), m2 = s2.getCurrentCascadeFrustum();
            return 0 === p2.intersectsPrecise(h2.vertices, h2.planes, u2) || 0 === m2.intersectsPrecise(h2.vertices, h2.planes, u2);
          }
          function Ls(t2) {
            return [t2[0] * e.d4, t2[1] * e.d4, t2[2] * e.d4, 0];
          }
          function Ps(t2, i2, o2, r2, s2, a2, n2, l2, c2) {
            const h2 = r2.getSource(), u2 = o2.globeSharedBuffers;
            if (!u2)
              return;
            let d2, _2, p2;
            if (i2 && (d2 = r2.getTile(i2)), h2 instanceof e.aD ? (_2 = h2.texture, p2 = e.cD(0, 0, o2.transform)) : d2 && i2 && (_2 = d2.texture, p2 = e.cD(i2.canonical.z, i2.canonical.x, o2.transform)), !_2 || !p2)
              return;
            t2 || (p2 = e.a6.mat4.scale(e.a6.mat4.create(), p2, [1, -1, 1]));
            const m2 = o2.context, f2 = m2.gl, g2 = "nearest" === s2.paint.get("raster-resampling") ? f2.NEAREST : f2.LINEAR, v2 = o2.colorModeForDrapableLayerRenderPass(a2), x2 = n2.defines;
            x2.push("GLOBE_POLES");
            const y2 = new Li(f2.LEQUAL, Li.ReadWrite, o2.depthRangeFor3D), b2 = Float32Array.from(o2.transform.expandedFarZProjMatrix), w2 = Float32Array.from(e.b5(e.cC(new e.bP(0, 0, 0))));
            o2.terrain && o2.terrain.prepareDrawTile(), m2.activeTexture.set(f2.TEXTURE0), _2.bind(g2, f2.CLAMP_TO_EDGE), m2.activeTexture.set(f2.TEXTURE1), _2.bind(g2, f2.CLAMP_TO_EDGE), _2.useMipmap && m2.extTextureFilterAnisotropic && o2.transform.pitch > 20 && f2.texParameterf(f2.TEXTURE_2D, m2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, m2.extTextureFilterAnisotropicMax);
            const [T2, E2, C2, S2] = i2 ? u2.getPoleBuffers(i2.canonical.z, false) : u2.getPoleBuffers(0, true), I2 = s2.paint.get("raster-elevation");
            let D2;
            t2 ? (D2 = T2, o2.renderDefaultNorthPole = 0 !== I2) : (D2 = E2, o2.renderDefaultSouthPole = 0 !== I2);
            const R2 = Ls(n2.mix), A2 = ((e2, t3, i3, o3, r3, s3, a3, n3, l3, c3, h3, u3, d3) => Yr(e2, t3, i3, new Float32Array(16), new Float32Array(9), [0, 0], o3, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, s3, [0, 0], n3, 2, c3, h3, u3, 1, 0, d3))(b2, w2, p2, e.a9(o2.transform.zoom), 0, s2, 0, I2, 0, R2, n2.offset, n2.range, a2), L2 = o2.getOrCreateProgram("raster", { defines: x2 });
            o2.uploadCommonUniforms(m2, L2, null), L2.draw(o2, f2.TRIANGLES, y2, c2, v2, l2, A2, s2.id, D2, C2, S2);
          }
          function Ms(e2) {
            const t2 = e2._nearZ, i2 = e2.projection.farthestPixelDistance(e2), o2 = i2 - t2, r2 = 0.2 * e2.height, s2 = t2 + r2;
            return [t2, i2, (s2 - r2 - t2) / o2, (s2 - t2) / o2];
          }
          function zs(e2, t2, i2, o2) {
            if (e2)
              return t2 instanceof Qe && e2 instanceof mt ? t2.getTextureDescriptor(e2, i2, true) : { texture: e2.texture, mix: Ls(o2.mix), offset: o2.offset, buffer: 0, tileSize: 1 };
          }
          var Os = e.d5([{ name: "a_index", type: "Int16", components: 1 }]);
          class Fs {
            constructor(t2, i2, o2, r2) {
              const s2 = { width: o2[0], height: o2[1], data: null }, a2 = t2.gl;
              this.targetColorTexture = new e.T(t2, s2, a2.RGBA8, { useMipmap: false }), this.backgroundColorTexture = new e.T(t2, s2, a2.RGBA8, { useMipmap: false }), this.context = t2, this.updateParticleTexture(i2, r2), this.lastInvalidatedAt = 0;
            }
            updateParticleTexture(t2, i2) {
              if (this.particleTextureDimension === i2.width)
                return;
              (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
              const o2 = this.context.gl, r2 = i2.width * i2.height;
              this.particleTexture0 = new e.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false });
              const s2 = new e.d6();
              s2.reserve(r2);
              for (let e2 = 0; e2 < r2; e2++)
                s2.emplaceBack(e2);
              this.particleIndexBuffer = this.context.createVertexBuffer(s2, Os.members, true), this.particleSegment = e.b1.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i2.width;
            }
            update(t2) {
              return !(this.lastInvalidatedAt < t2 && (this.lastInvalidatedAt = e.q.now(), 1));
            }
            destroy() {
              this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
            }
          }
          function ks(t2, i2, o2) {
            if (!t2)
              return null;
            const r2 = i2.getTextureDescriptor(t2, o2, true);
            if (!r2)
              return null;
            let { texture: s2, mix: a2, offset: n2, tileSize: l2, buffer: c2, format: h2 } = r2;
            if (!s2 || !h2)
              return null;
            let u2 = false;
            return "uint32" === h2 && (u2 = true, a2[3] = 0, a2 = $r(e.d7, a2, [0, o2.paint.get("raster-particle-max-speed")]), n2 = Xr(e.d7, n2, [0, o2.paint.get("raster-particle-max-speed")])), { texture: s2, textureOffset: [c2 / (l2 + 2 * c2), l2 / (l2 + 2 * c2)], tileSize: l2, scalarData: u2, scale: a2, offset: n2, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h2]] };
          }
          function Bs(e2) {
            const t2 = e2._nearZ, i2 = e2.projection.farthestPixelDistance(e2), o2 = i2 - t2, r2 = 0.2 * e2.height, s2 = t2 + r2;
            return [t2, i2, (s2 - r2 - t2) / o2, (s2 - t2) / o2];
          }
          const Ns = new e.bz(1, 0, 0, 1), Us = new e.bz(0, 1, 0, 1), Gs = new e.bz(0, 0, 1, 1), js = new e.bz(1, 0, 1, 1), Vs = new e.bz(0, 1, 1, 1);
          function qs(t2, i2, o2, r2, s2, a2, n2) {
            const l2 = t2.context, c2 = t2.transform, h2 = l2.gl, u2 = "globe" === c2.projection.name, d2 = u2 ? ["PROJECTION_GLOBE_VIEW"] : [];
            let _2 = e.a6.mat4.clone(o2.projMatrix);
            if (u2 && e.a9(c2.zoom) > 0) {
              const t3 = e.b4(o2.canonical, c2), i3 = e.d8(t3);
              _2 = e.a6.mat4.multiply(new Float32Array(16), c2.globeMatrix, i3), e.a6.mat4.multiply(_2, c2.projMatrix, _2);
            }
            const p2 = e.a6.mat4.create();
            p2[12] += 2 * s2 / (e.q.devicePixelRatio * c2.width), p2[13] += 2 * a2 / (e.q.devicePixelRatio * c2.height), e.a6.mat4.multiply(_2, p2, _2);
            const m2 = t2.getOrCreateProgram("debug", { defines: d2 }), f2 = i2.getTileByID(o2.key);
            t2.terrain && t2.terrain.setupElevationDraw(f2, m2);
            const g2 = Li.disabled, v2 = Mi.disabled, x2 = t2.colorModeForRenderPass(), y2 = "$debug";
            l2.activeTexture.set(h2.TEXTURE0), t2.emptyTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), u2 ? f2._makeGlobeTileDebugBuffers(t2.context, c2) : f2._makeDebugTileBoundsBuffers(t2.context, c2.projection);
            const b2 = f2._tileDebugBuffer || t2.debugBuffer, w2 = f2._tileDebugIndexBuffer || t2.debugIndexBuffer, T2 = f2._tileDebugSegments || t2.debugSegments;
            if (m2.draw(t2, h2.LINE_STRIP, g2, v2, x2, Fi.disabled, Zr(_2, r2), y2, b2, w2, T2, null, null, null, [f2._globeTileDebugBorderBuffer]), n2) {
              const e2 = f2.latestRawTileData, i3 = Math.floor((e2 && e2.byteLength || 0) / 1024);
              let r3 = o2.canonical.toString();
              o2.overscaledZ !== o2.canonical.z && (r3 += ` => ${o2.overscaledZ}`), r3 += ` ${f2.state}`, r3 += ` ${i3}kb`, function(e3, t3) {
                e3.initDebugOverlayCanvas();
                const i4 = e3.debugOverlayCanvas, o3 = e3.context.gl, r4 = e3.debugOverlayCanvas.getContext("2d");
                r4.clearRect(0, 0, i4.width, i4.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(t3, 5, 5), r4.strokeText(t3, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
              }(t2, r3);
            }
            const E2 = i2.getTile(o2).tileSize, C2 = 512 / Math.min(E2, 512) * (o2.overscaledZ / c2.zoom) * 0.5, S2 = f2._tileDebugTextBuffer || t2.debugBuffer, I2 = f2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, D2 = f2._tileDebugTextSegments || t2.debugSegments;
            m2.draw(t2, h2.TRIANGLES, g2, v2, Ai.alphaBlended, Fi.disabled, Zr(_2, e.bz.transparent, C2), y2, S2, I2, D2, null, null, null, [f2._globeTileDebugTextBuffer]);
          }
          function Zs(e2, t2, i2, o2) {
            Ws(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
          }
          function Hs(e2, t2, i2, o2) {
            Ws(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
          }
          function Ws(t2, i2, o2, r2, s2, a2) {
            const n2 = t2.context, l2 = n2.gl;
            l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.q.devicePixelRatio, o2 * e.q.devicePixelRatio, r2 * e.q.devicePixelRatio, s2 * e.q.devicePixelRatio), n2.clear({ color: a2 }), l2.disable(l2.SCISSOR_TEST);
          }
          const $s = e.d5([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Xs } = $s;
          function Ys(e2, t2, i2, o2) {
            e2.emplaceBack(t2, i2, o2);
          }
          class Ks {
            constructor(t2) {
              this.vertexArray = new e.d9(), this.indices = new e.aO(), Ys(this.vertexArray, -1, -1, 1), Ys(this.vertexArray, 1, -1, 1), Ys(this.vertexArray, -1, 1, 1), Ys(this.vertexArray, 1, 1, 1), Ys(this.vertexArray, -1, -1, -1), Ys(this.vertexArray, 1, -1, -1), Ys(this.vertexArray, -1, 1, -1), Ys(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Xs), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.b1.simpleSegment(0, 0, 36, 12);
            }
          }
          function Js(t2, i2, o2, r2, s2, a2) {
            const n2 = t2.context.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e2, t3, i3, o3, r3) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r3.r, r3.g, r3.b, r3.a], u_luminance: 5e-5 }))(e.a6.mat3.fromMat4(e.a6.mat3.create(), r2), s2, h2, l2, c2);
            n2.framebufferTexture2D(n2.FRAMEBUFFER, n2.COLOR_ATTACHMENT0, n2.TEXTURE_CUBE_MAP_POSITIVE_X + a2, i2.skyboxTexture, 0), o2.draw(t2, n2.TRIANGLES, Li.disabled, Mi.disabled, Ai.unblended, Fi.frontCW, u2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
          }
          const Qs = e.d5([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
          class ea {
            constructor(t2) {
              const i2 = new e.da();
              i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
              const o2 = new e.aO();
              o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, Qs.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.b1.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
          }
          const ta = e.d5([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
          class ia {
            constructor() {
              this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
            }
          }
          class oa {
            constructor(t2) {
              this.colorModeAlphaBlendedWriteRGB = new Ai([1, Ri, 1, Ri], e.bz.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new Ai([1, 0, 1, 0], e.bz.transparent, [false, false, false, true]), this.params = new ia(), this.updateNeeded = true, t2.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
                this.updateNeeded = true;
              }), t2.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t2.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
                this.updateNeeded = true;
              }), t2.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
                this.updateNeeded = true;
              });
            }
            update(t2) {
              const i2 = t2.context;
              if (!this.atmosphereBuffer || this.updateNeeded) {
                this.updateNeeded = false, this.atmosphereBuffer = new ea(i2);
                const t3 = this.params.sizeRange, o2 = this.params.intensityRange, r2 = function(t4) {
                  const i3 = e.dd(30), o3 = [];
                  for (let r3 = 0; r3 < t4; ++r3) {
                    const t5 = 2 * Math.PI * i3(), r4 = Math.acos(1 - 2 * i3()) - 0.5 * Math.PI;
                    o3.push(e.a6.vec3.fromValues(Math.cos(r4) * Math.cos(t5), Math.cos(r4) * Math.sin(t5), Math.sin(r4)));
                  }
                  return o3;
                }(this.params.starsCount), s2 = e.dd(300), a2 = new e.db(), n2 = new e.aO();
                let l2 = 0;
                for (let i3 = 0; i3 < r2.length; ++i3) {
                  const c2 = e.a6.vec3.scale([], r2[i3], 200), h2 = Math.max(0, 1 + 0.01 * t3 * (1 * s2() - 0.5)), u2 = Math.max(0, 1 + 0.01 * o2 * (1 * s2() - 0.5));
                  a2.emplaceBack(c2[0], c2[1], c2[2], -1, -1, h2, u2), a2.emplaceBack(c2[0], c2[1], c2[2], 1, -1, h2, u2), a2.emplaceBack(c2[0], c2[1], c2[2], 1, 1, h2, u2), a2.emplaceBack(c2[0], c2[1], c2[2], -1, 1, h2, u2), n2.emplaceBack(l2 + 0, l2 + 1, l2 + 2), n2.emplaceBack(l2 + 0, l2 + 2, l2 + 3), l2 += 4;
                }
                this.starsVx = i2.createVertexBuffer(a2, ta.members), this.starsIdx = i2.createIndexBuffer(n2), this.starsSegments = e.b1.simpleSegment(0, 0, a2.length, n2.length);
              }
            }
            destroy() {
              this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
            }
            drawAtmosphereGlow(t2, i2) {
              const o2 = t2.context, r2 = o2.gl, s2 = t2.transform, a2 = new Li(r2.LEQUAL, Li.ReadOnly, [0, 1]), n2 = e.a9(s2.zoom), l2 = t2.style.getLut(i2.scope), c2 = i2.properties.get("color").toRenderColor(l2).toArray01(), h2 = i2.properties.get("high-color").toRenderColor(l2).toArray01(), u2 = i2.properties.get("space-color").toRenderColor(l2).toArray01PremultipliedAlpha(), d2 = 5e-4, _2 = e.dc(i2.properties.get("horizon-blend"), 0, 1, d2, 0.25), p2 = e.cx(t2, o2, s2) && _2 === d2 ? s2.worldSize / (2 * Math.PI * 1.025) - 1 : s2.globeRadius, m2 = t2.frameCounter / 1e3 % 1, f2 = e.a6.vec3.length(s2.globeCenterInViewSpace), g2 = Math.sqrt(Math.pow(f2, 2) - Math.pow(p2, 2)), v2 = Math.acos(g2 / f2), x2 = (e2) => {
                const i3 = "globe" === s2.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
                e2 && i3.push("ALPHA_PASS");
                const l3 = t2.getOrCreateProgram("globeAtmosphere", { defines: i3 }), d3 = /* @__PURE__ */ ((e3, t3, i4, o3, r3, s3, a3, n3, l4, c3, h3, u3) => ({ u_frustum_tl: e3, u_frustum_tr: t3, u_frustum_br: i4, u_frustum_bl: o3, u_horizon: r3, u_transition: s3, u_fadeout_range: a3, u_color: n3, u_high_color: l4, u_space_color: c3, u_temporal_offset: h3, u_horizon_angle: u3 }))(s2.frustumCorners.TL, s2.frustumCorners.TR, s2.frustumCorners.BR, s2.frustumCorners.BL, s2.frustumCorners.horizon, n2, _2, c2, h2, u2, m2, v2);
                t2.uploadCommonUniforms(o2, l3);
                const p3 = this.atmosphereBuffer;
                p3 && l3.draw(t2, r2.TRIANGLES, a2, Mi.disabled, e2 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Fi.backCW, d3, e2 ? "atmosphere_glow_alpha" : "atmosphere_glow", p3.vertexBuffer, p3.indexBuffer, p3.segments);
              };
              x2(false), x2(true);
            }
            drawStars(t2, i2) {
              const o2 = e.ap(i2.properties.get("star-intensity"), 0, 1);
              if (0 === o2)
                return;
              const r2 = t2.context, s2 = r2.gl, a2 = t2.transform, n2 = t2.getOrCreateProgram("stars"), l2 = e.a6.quat.identity([]);
              e.a6.quat.rotateX(l2, l2, -a2._pitch), e.a6.quat.rotateZ(l2, l2, -a2.angle), e.a6.quat.rotateX(l2, l2, e.bB(a2._center.lat)), e.a6.quat.rotateY(l2, l2, -e.bB(a2._center.lng));
              const c2 = e.a6.mat4.fromQuat(new Float32Array(16), l2), h2 = e.a6.mat4.multiply([], a2.starsProjMatrix, c2), u2 = e.a6.mat3.fromMat4([], c2), d2 = e.a6.mat3.invert([], u2), _2 = [0, 1, 0];
              e.a6.vec3.transformMat3(_2, _2, d2), e.a6.vec3.scale(_2, _2, this.params.sizeMultiplier);
              const p2 = [1, 0, 0];
              e.a6.vec3.transformMat3(p2, p2, d2), e.a6.vec3.scale(p2, p2, this.params.sizeMultiplier);
              const m2 = (f2 = _2, g2 = p2, v2 = o2, { u_matrix: Float32Array.from(h2), u_up: f2, u_right: g2, u_intensity_multiplier: v2 });
              var f2, g2, v2;
              t2.uploadCommonUniforms(r2, n2), this.starsVx && this.starsIdx && n2.draw(t2, s2.TRIANGLES, Li.disabled, Mi.disabled, this.colorModeAlphaBlendedWriteRGB, Fi.disabled, m2, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
            }
          }
          function ra(t2, i2) {
            const o2 = [...t2], r2 = i2.cameraWorldSizeForFog / i2.worldSize, s2 = e.a6.mat4.identity([]);
            return e.a6.mat4.scale(s2, s2, [r2, r2, 1]), e.a6.mat4.multiply(o2, s2, o2), e.a6.mat4.multiply(o2, i2.worldToFogMatrix, o2), o2;
          }
          function sa(t2, i2, o2, r2, s2) {
            const a2 = o2.material, n2 = r2.context, { baseColorTexture: l2, metallicRoughnessTexture: c2 } = a2.pbrMetallicRoughness, { normalTexture: h2, occlusionTexture: u2, emissionTexture: d2 } = a2;
            function _2(e2, i3, o3) {
              if (e2 && (t2.push(i3), n2.activeTexture.set(n2.gl.TEXTURE0 + o3), e2.gfxTexture)) {
                const { minFilter: t3, magFilter: i4, wrapS: o4, wrapT: r3 } = e2.sampler;
                e2.gfxTexture.bindExtraParam(t3, i4, o4, r3);
              }
            }
            _2(l2, "HAS_TEXTURE_u_baseColorTexture", ji.BaseColor), _2(c2, "HAS_TEXTURE_u_metallicRoughnessTexture", ji.MetallicRoughness), _2(h2, "HAS_TEXTURE_u_normalTexture", ji.Normal), _2(u2, "HAS_TEXTURE_u_occlusionTexture", ji.Occlusion), _2(d2, "HAS_TEXTURE_u_emissionTexture", ji.Emission), s2 && (s2.texture || (s2.texture = new e.df(r2.context, s2.image, [s2.image.height, s2.image.height, s2.image.height], n2.gl.RGBA8)), n2.activeTexture.set(n2.gl.TEXTURE0 + ji.LUT), s2.texture && s2.texture.bind(n2.gl.LINEAR, n2.gl.CLAMP_TO_EDGE), t2.push("APPLY_LUT_ON_GPU")), o2.texcoordBuffer && (t2.push("HAS_ATTRIBUTE_a_uv_2f"), i2.push(o2.texcoordBuffer)), o2.colorBuffer && (t2.push(12 === o2.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i2.push(o2.colorBuffer)), o2.normalBuffer && (t2.push("HAS_ATTRIBUTE_a_normal_3f"), i2.push(o2.normalBuffer)), o2.pbrBuffer && (t2.push("HAS_ATTRIBUTE_a_pbr"), t2.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i2.push(o2.pbrBuffer)), "OPAQUE" !== a2.alphaMode && "MASK" !== a2.alphaMode || t2.push("UNPREMULT_TEXTURE_IN_SHADER"), a2.defined || t2.push("DIFFUSE_SHADED"), t2.push("USE_STANDARD_DERIVATIVES");
          }
          function aa(t2, i2, o2, r2, s2, a2) {
            const n2 = o2.paint.get("model-opacity"), l2 = i2.context, c2 = new Li(i2.context.gl.LEQUAL, Li.ReadWrite, i2.depthRangeFor3D), h2 = i2.transform, u2 = t2.mesh, d2 = u2.material, _2 = d2.pbrMetallicRoughness, p2 = i2.style.fog;
            let m2;
            m2 = "pixels" === i2.transform.projection.zAxisUnit ? [...t2.nodeModelMatrix] : e.a6.mat4.multiply([], r2.zScaleMatrix, t2.nodeModelMatrix), e.a6.mat4.multiply(m2, r2.negCameraPosMatrix, m2);
            const f2 = e.a6.mat4.invert([], m2);
            e.a6.mat4.transpose(f2, f2);
            const g2 = o2.paint.get("model-emissive-strength").constantOr(0), v2 = ns(new Float32Array(t2.worldViewProjection), new Float32Array(m2), new Float32Array(f2), null, i2, n2, _2.baseColorFactor.toRenderColor(null), d2.emissiveFactor, _2.metallicFactor, _2.roughnessFactor, d2, g2, o2), x2 = { defines: [] }, y2 = [];
            sa(x2.defines, y2, u2, i2, o2.lut);
            const b2 = i2.shadowRenderer;
            b2 && (b2.useNormalOffset = false);
            let w2 = null;
            if (p2) {
              const e2 = ra(t2.nodeModelMatrix, i2.transform);
              if (w2 = new Float32Array(e2), "globe" !== h2.projection.name) {
                const t3 = u2.aabb.min, i3 = u2.aabb.max, [o3, r3] = p2.getOpacityForBounds(e2, t3[0], t3[1], i3[0], i3[1]);
                x2.overrideFog = o3 >= Oe || r3 >= Oe;
              }
            }
            const T2 = Wi(i2, o2.paint.get("model-cutoff-fade-range"));
            T2.shouldRenderCutoff && x2.defines.push("RENDER_CUTOFF");
            const E2 = i2.getOrCreateProgram("model", x2);
            i2.uploadCommonUniforms(l2, E2, null, w2, T2), "shadow" !== i2.renderPass && b2 && b2.setupShadowsFromMatrix(t2.nodeModelMatrix, E2), E2.draw(i2, l2.gl.TRIANGLES, c2, s2, a2, u2.material.doubleSided ? Fi.disabled : Fi.backCCW, v2, o2.id, u2.vertexBuffer, u2.indexBuffer, u2.segments, o2.paint, i2.transform.zoom, void 0, y2);
          }
          function na(t2, i2, o2, r2, s2, a2, n2) {
            let l2;
            l2 = "globe" === t2.projection.name ? e.dg(o2, t2) : [...o2], e.a6.mat4.multiply(l2, l2, i2.matrix);
            const c2 = e.a6.mat4.multiply([], r2, l2);
            if (i2.meshes)
              for (const t3 of i2.meshes) {
                if ("BLEND" !== t3.material.alphaMode) {
                  n2.push({ mesh: t3, depth: 0, modelIndex: s2, worldViewProjection: c2, nodeModelMatrix: l2 });
                  continue;
                }
                const i3 = e.a6.vec3.transformMat4([], t3.centroid, c2);
                i3[2] > 0 && a2.push({ mesh: t3, depth: i3[2], modelIndex: s2, worldViewProjection: c2, nodeModelMatrix: l2 });
              }
            if (i2.children)
              for (const e2 of i2.children)
                na(t2, e2, o2, r2, s2, a2, n2);
          }
          function la(e2, t2, i2, o2) {
            const r2 = i2.shadowRenderer;
            if (!r2)
              return;
            const s2 = r2.getShadowPassDepthMode(), a2 = r2.getShadowPassColorMode(), n2 = r2.calculateShadowPassMatrixFromMatrix(t2), l2 = ls(n2);
            i2.getOrCreateProgram("modelDepth", { defines: i2._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i2, i2.context.gl.TRIANGLES, s2, Mi.disabled, a2, Fi.backCCW, l2, o2.id, e2.vertexBuffer, e2.indexBuffer, e2.segments, o2.paint, i2.transform.zoom, void 0, void 0);
          }
          function ca(t2, i2, o2) {
            const r2 = i2.updateZoomBasedPaintProperties(), s2 = function(t3, i3, o3) {
              let r3, s3, a2, n2 = t3.terrain ? t3.terrain.exaggeration() : 0;
              if (t3.terrain && n2 > 0) {
                const i4 = t3.terrain, s4 = i4.findDEMTileFor(o3);
                s4 && s4.dem ? r3 = e.di.create(i4, o3, s4) : n2 = 0;
              }
              if (0 === n2 && (i3.terrainElevationMin = 0, i3.terrainElevationMax = 0), n2 === i3.validForExaggeration && (0 === n2 || r3 && r3._demTile && r3._demTile.tileID === i3.validForDEMTile.id && r3._dem._timestamp === i3.validForDEMTile.timestamp))
                return false;
              for (const e2 in i3.instancesPerModel) {
                const t4 = i3.instancesPerModel[e2];
                for (let e3 = 0; e3 < t4.instancedDataArray.length; ++e3) {
                  const o4 = (r3 ? n2 * r3.getElevationAt(0 | t4.instancedDataArray.float32[16 * e3], 0 | t4.instancedDataArray.float32[16 * e3 + 1], true, true) : 0) + t4.instancesEvaluatedElevation[e3];
                  t4.instancedDataArray.float32[16 * e3 + 6] = o4, s3 = s3 ? Math.min(i3.terrainElevationMin, o4) : o4, a2 = a2 ? Math.max(i3.terrainElevationMax, o4) : o4;
                }
              }
              return i3.terrainElevationMin = s3 || 0, i3.terrainElevationMax = a2 || 0, i3.validForExaggeration = n2, i3.validForDEMTile = r3 && r3._demTile ? { id: r3._demTile.tileID, timestamp: r3._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
            }(t2, i2, o2);
            (r2 || s2) && (i2.uploaded = false, i2.upload(t2.context));
          }
          const ha = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e.c9([0, 0, 0], [e.ab, e.ab, 0]) };
          function ua(t2, i2) {
            const o2 = 1 << t2.canonical.z, r2 = i2.getFreeCameraOptions().position, s2 = i2.elevation, a2 = t2.canonical.x / o2, n2 = (t2.canonical.x + 1) / o2, l2 = t2.canonical.y / o2, c2 = (t2.canonical.y + 1) / o2;
            let h2 = i2._centerAltitude;
            if (s2) {
              const e2 = s2.getMinMaxForTile(t2);
              e2 && e2.max > h2 && (h2 = e2.max);
            }
            const u2 = e.ap(r2.x, a2, n2) - r2.x, d2 = e.ap(r2.y, l2, c2) - r2.y, _2 = e.bD(h2, i2.center.lat) - r2.z;
            return i2._zoomFromMercatorZ(Math.sqrt(u2 * u2 + d2 * d2 + _2 * _2));
          }
          function da(e2, t2, i2, o2, r2, s2, a2) {
            const n2 = e2.context, l2 = "shadow" === e2.renderPass, c2 = e2.shadowRenderer, h2 = l2 && c2 ? c2.getShadowPassDepthMode() : new Li(n2.gl.LEQUAL, Li.ReadWrite, e2.depthRangeFor3D), u2 = e2.isTileAffectedByFog(s2);
            if (i2.meshes)
              for (const d2 of i2.meshes) {
                const _2 = ["MODEL_POSITION_ON_GPU"], p2 = [];
                let m2, f2, g2;
                o2.instancedDataArray.length > 20 && _2.push("INSTANCED_ARRAYS");
                const v2 = Wi(e2, t2.paint.get("model-cutoff-fade-range"));
                if (v2.shouldRenderCutoff && _2.push("RENDER_CUTOFF"), l2 && c2)
                  m2 = e2.getOrCreateProgram("modelDepth", { defines: _2 }), f2 = ls(a2.shadowTileMatrix, a2.shadowTileMatrix, Float32Array.from(i2.matrix)), g2 = c2.getShadowPassColorMode();
                else {
                  sa(_2, p2, d2, e2, t2.lut), m2 = e2.getOrCreateProgram("model", { defines: _2, overrideFog: u2 });
                  const o3 = d2.material, l3 = o3.pbrMetallicRoughness, h3 = t2.paint.get("model-opacity"), x3 = t2.paint.get("model-emissive-strength").constantOr(0);
                  f2 = ns(s2.expandedProjMatrix, Float32Array.from(i2.matrix), new Float32Array(16), null, e2, h3, l3.baseColorFactor.toRenderColor(null), o3.emissiveFactor, l3.metallicFactor, l3.roughnessFactor, o3, x3, t2, r2), c2 && (a2.shadowUniformsInitialized ? m2.setShadowUniformValues(n2, c2.getShadowUniformValues()) : (c2.setupShadows(s2.toUnwrapped(), m2, "model-tile", s2.overscaledZ), a2.shadowUniformsInitialized = true)), g2 = v2.shouldRenderCutoff || h3 < 1 || "OPAQUE" !== o3.alphaMode ? Ai.alphaBlended : Ai.unblended;
                }
                e2.uploadCommonUniforms(n2, m2, s2.toUnwrapped(), null, v2);
                const x2 = d2.material.doubleSided ? Fi.disabled : Fi.backCCW;
                if (o2.instancedDataArray.length > 20)
                  p2.push(o2.instancedDataBuffer), m2.draw(e2, n2.gl.TRIANGLES, h2, Mi.disabled, g2, x2, f2, t2.id, d2.vertexBuffer, d2.indexBuffer, d2.segments, t2.paint, e2.transform.zoom, void 0, p2, o2.instancedDataArray.length);
                else {
                  const i3 = l2 ? "u_instance" : "u_normal_matrix";
                  for (let r3 = 0; r3 < o2.instancedDataArray.length; ++r3)
                    f2[i3] = new Float32Array(o2.instancedDataArray.arrayBuffer, 64 * r3, 16), m2.draw(e2, n2.gl.TRIANGLES, h2, Mi.disabled, g2, x2, f2, t2.id, d2.vertexBuffer, d2.indexBuffer, d2.segments, t2.paint, e2.transform.zoom, void 0, p2);
                }
              }
            if (i2.children)
              for (const n3 of i2.children)
                da(e2, t2, n3, o2, r2, s2, a2);
          }
          const _a = [1, -1, 1];
          function pa(t2, i2, o2, r2) {
            if (!o2.modelManager)
              return true;
            const s2 = o2.modelManager;
            if (!o2.shadowRenderer)
              return true;
            const a2 = o2.shadowRenderer, n2 = i2.aabb;
            let l2 = true, c2 = t2.maxHeight;
            if (0 === c2) {
              let e2 = 0;
              for (const i3 in t2.instancesPerModel) {
                const t3 = s2.getModel(i3, r2);
                t3 ? e2 = Math.max(e2, Math.max(Math.max(t3.aabb.max[0], t3.aabb.max[1]), t3.aabb.max[2])) : l2 = false;
              }
              c2 = t2.maxScale * e2 * 1.41 + t2.maxVerticalOffset, l2 && (t2.maxHeight = c2);
            }
            n2.max[2] = c2, n2.min[2] += t2.terrainElevationMin, n2.max[2] += t2.terrainElevationMax, e.a6.vec3.transformMat4(n2.min, n2.min, i2.tileMatrix), e.a6.vec3.transformMat4(n2.max, n2.max, i2.tileMatrix);
            const h2 = n2.intersects(a2.getCurrentCascadeFrustum());
            return 0 === o2.currentShadowCascade && (t2.isInsideFirstShadowMapFrustum = 2 === h2), 0 === h2;
          }
          function ma(t2, i2) {
            const o2 = t2.uniformValues.u_cutoff_params[0], r2 = t2.uniformValues.u_cutoff_params[1], s2 = t2.uniformValues.u_cutoff_params[2], a2 = t2.uniformValues.u_cutoff_params[3];
            return r2 === o2 || a2 === s2 ? 1 : e.ap(((i2 - o2) / (r2 - o2) - s2) / (a2 - s2), 0, 1);
          }
          function fa(t2, i2, o2, r2) {
            if (i2.pitch < 20)
              return 1;
            const s2 = i2.getWorldToCameraMatrix();
            e.a6.mat4.multiply(s2, s2, t2);
            const a2 = e.a6.vec4.fromValues(o2.min[0], o2.min[1], o2.min[2], 1);
            let n2 = e.a6.vec4.transformMat4(e.a6.vec4.create(), a2, s2), l2 = n2, c2 = n2;
            a2[1] = o2.max[1], n2 = e.a6.vec4.transformMat4(e.a6.vec4.create(), a2, s2), l2 = n2[1] < l2[1] ? n2 : l2, c2 = n2[1] > c2[1] ? n2 : c2, a2[0] = o2.max[0], n2 = e.a6.vec4.transformMat4(e.a6.vec4.create(), a2, s2), l2 = n2[1] < l2[1] ? n2 : l2, c2 = n2[1] > c2[1] ? n2 : c2, a2[1] = o2.min[1], n2 = e.a6.vec4.transformMat4(e.a6.vec4.create(), a2, s2), l2 = n2[1] < l2[1] ? n2 : l2, c2 = n2[1] > c2[1] ? n2 : c2;
            const h2 = e.ap(r2[0], 0, 1), u2 = 100 * i2.pixelsPerMeter * e.ap(r2[1], 0, 1), d2 = e.ap(r2[2], 0, 1), _2 = e.a6.vec4.lerp(e.a6.vec4.create(), l2, c2, h2), p2 = Math.tan(0.5 * i2.fovX), m2 = -_2[2] * p2;
            if (0 === u2)
              return _2[1] < -Math.abs(m2) ? d2 : 1;
            const f2 = (-Math.abs(m2) - _2[1]) / u2, g2 = (e2, t3, i3) => (1 - i3) * e2 + i3 * t3, v2 = e.ap(g2(1, d2, f2), d2, 1);
            return g2(1, v2, e.ap((i2.pitch - 20) / 20, 0, 1));
          }
          class ga {
          }
          class va {
            constructor() {
              this._storage = /* @__PURE__ */ new Map();
            }
            getLinesFromTrianglesBuffer(t2, i2, o2) {
              {
                const e2 = this._storage.get(i2.id);
                if (e2)
                  return e2.lastUsedFrameIdx = t2, e2.buf;
              }
              const r2 = o2.gl, s2 = r2.getBufferParameter(r2.ELEMENT_ARRAY_BUFFER, r2.BUFFER_SIZE), a2 = new ArrayBuffer(s2), n2 = new Int16Array(a2);
              r2.getBufferSubData(r2.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(a2));
              const l2 = new e.dk();
              for (let e2 = 0; e2 < s2 / 2; e2 += 3) {
                const t3 = n2[e2], i3 = n2[e2 + 1], o3 = n2[e2 + 2];
                l2.emplaceBack(t3, i3), l2.emplaceBack(i3, o3), l2.emplaceBack(o3, t3);
              }
              const c2 = o2.bindVertexArrayOES.current, h2 = new ga();
              return h2.buf = new hs(o2, l2), h2.lastUsedFrameIdx = t2, this._storage.set(i2.id, h2), o2.bindVertexArrayOES.set(c2), h2.buf;
            }
            update(e2) {
              for (const [t2, i2] of this._storage)
                e2 - i2.lastUsedFrameIdx > 30 && (i2.buf.destroy(), this._storage.delete(t2));
            }
            destroy() {
              for (const [e2, t2] of this._storage)
                t2.buf.destroy(), this._storage.delete(e2);
            }
          }
          class xa {
            constructor(e2) {
              this.occluderSize = 30, this.depthOffset = -1e-4, e2.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), e2.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
            }
          }
          const ya = { symbol: function(t2, i2, o2, r2, s2) {
            if ("translucent" !== t2.renderPass)
              return;
            const a2 = Mi.disabled, n2 = t2.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r3, s3, a3, n3) {
              const l3 = i3.transform, c3 = "map" === s3, h2 = "map" === a3;
              for (const i4 of t3) {
                const t4 = r3.getTile(i4), s4 = t4.getBucket(o3);
                if (!s4 || !s4.text || !s4.text.segments.get().length)
                  continue;
                const a4 = e.bj(s4.textSizeData, l3.zoom), u2 = ii(i4, s4.getProjection(), l3), d2 = l3.calculatePixelsToTileUnitsMatrix(t4), _2 = kt(u2, t4.tileID.canonical, h2, c3, l3, s4.getProjection(), d2), p2 = s4.hasIconTextFit() && s4.hasIconData();
                if (a4) {
                  const o4 = Math.pow(2, l3.zoom - t4.tileID.overscaledZ);
                  ys(s4, c3, h2, n3, e.cS, l3, _2, i4, o4, a4, p2);
                }
              }
            }(r2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), s2);
            const l2 = 0 !== o2.paint.get("icon-opacity").constantOr(1), c2 = 0 !== o2.paint.get("text-opacity").constantOr(1);
            void 0 !== o2.layout.get("symbol-sort-key").constantOr(1) && (l2 || c2) ? bs(t2, i2, o2, r2, a2, n2) : (l2 && bs(t2, i2, o2, r2, a2, n2, { onlyIcons: true }), c2 && bs(t2, i2, o2, r2, a2, n2, { onlyText: true })), i2.map.showCollisionBoxes && (fs(t2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), fs(t2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }, circle: function(t2, i2, o2, r2) {
            if ("translucent" !== t2.renderPass)
              return;
            const s2 = o2.paint.get("circle-opacity"), a2 = o2.paint.get("circle-stroke-width"), n2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1), c2 = o2.paint.get("circle-emissive-strength");
            if (0 === s2.constantOr(1) && (0 === a2.constantOr(1) || 0 === n2.constantOr(1)))
              return;
            const h2 = t2.context, u2 = h2.gl, d2 = t2.transform, _2 = t2.depthModeForSublayer(0, Li.ReadOnly), p2 = Mi.disabled, m2 = t2.colorModeForDrapableLayerRenderPass(c2), f2 = "globe" === d2.projection.name, g2 = [e.am(d2.center.lng), e.at(d2.center.lat)], v2 = [];
            for (let s3 = 0; s3 < r2.length; s3++) {
              const a3 = r2[s3], n3 = i2.getTile(a3), c3 = n3.getBucket(o2);
              if (!c3 || c3.projection.name !== d2.projection.name)
                continue;
              const h3 = c3.programConfigurations.get(o2.id), u3 = e.cT(o2), _3 = t2.isTileAffectedByFog(a3);
              f2 && u3.push("PROJECTION_GLOBE_VIEW"), u3.push("DEPTH_D24"), t2.terrain && d2.depthOcclusionForSymbolsAndCircles && u3.push("DEPTH_OCCLUSION");
              const p3 = t2.getOrCreateProgram("circle", { config: h3, defines: u3, overrideFog: _3 }), m3 = c3.layoutVertexBuffer, x3 = c3.globeExtVertexBuffer, y2 = c3.indexBuffer, b2 = d2.projection.createInversionMatrix(d2, a3.canonical), w2 = { programConfiguration: h3, program: p3, layoutVertexBuffer: m3, globeExtVertexBuffer: x3, indexBuffer: y2, uniformValues: e.cU(t2, a3, n3, b2, g2, o2), tile: n3 };
              if (l2) {
                const t3 = c3.segments.get();
                for (const i3 of t3)
                  v2.push({ segments: new e.b1([i3]), sortKey: i3.sortKey, state: w2 });
              } else
                v2.push({ segments: c3.segments, sortKey: 0, state: w2 });
            }
            l2 && v2.sort((e2, t3) => e2.sortKey - t3.sortKey);
            const x2 = { useDepthForOcclusion: d2.depthOcclusionForSymbolsAndCircles };
            for (const e2 of v2) {
              const { programConfiguration: i3, program: r3, layoutVertexBuffer: s3, globeExtVertexBuffer: a3, indexBuffer: n3, uniformValues: l3, tile: c3 } = e2.state, f3 = e2.segments;
              t2.terrain && t2.terrain.setupElevationDraw(c3, r3, x2), t2.uploadCommonUniforms(h2, r3, c3.tileID.toUnwrapped()), r3.draw(t2, u2.TRIANGLES, _2, p2, m2, Fi.disabled, l3, o2.id, s3, n3, f3, o2.paint, d2.zoom, i3, [a3]);
            }
          }, heatmap: function(t2, i2, o2, r2) {
            if (0 !== o2.paint.get("heatmap-opacity"))
              if ("offscreen" === t2.renderPass) {
                const s2 = t2.context, a2 = s2.gl, n2 = Mi.disabled, l2 = new Ai([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.bz.transparent, [true, true, true, true]);
                !function(e2, t3, i3, o3) {
                  const r3 = e2.gl, s3 = t3.width * o3, a3 = t3.height * o3;
                  e2.activeTexture.set(r3.TEXTURE1), e2.viewport.set([0, 0, s3, a3]);
                  let n3 = i3.heatmapFbo;
                  if (!n3 || n3 && (n3.width !== s3 || n3.height !== a3)) {
                    n3 && n3.destroy();
                    const t4 = r3.createTexture();
                    r3.bindTexture(r3.TEXTURE_2D, t4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR), n3 = i3.heatmapFbo = e2.createFramebuffer(s3, a3, true, null), function(e3, t5, i4, o4, r4, s4) {
                      const a4 = e3.gl;
                      a4.texImage2D(a4.TEXTURE_2D, 0, e3.extRenderToTextureHalfFloat ? a4.RGBA16F : a4.RGBA, r4, s4, 0, a4.RGBA, e3.extRenderToTextureHalfFloat ? a4.HALF_FLOAT : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                    }(e2, 0, t4, n3, s3, a3);
                  } else
                    r3.bindTexture(r3.TEXTURE_2D, n3.colorAttachment.get()), e2.bindFramebuffer.set(n3.framebuffer);
                }(s2, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), s2.clear({ color: e.bz.transparent });
                const c2 = t2.transform, h2 = "globe" === c2.projection.name, u2 = h2 ? ["PROJECTION_GLOBE_VIEW"] : [], d2 = h2 ? Fi.frontCCW : Fi.disabled, _2 = [e.am(c2.center.lng), e.at(c2.center.lat)];
                for (let e2 = 0; e2 < r2.length; e2++) {
                  const p2 = r2[e2];
                  if (i2.hasRenderableParent(p2))
                    continue;
                  const m2 = i2.getTile(p2), f2 = m2.getBucket(o2);
                  if (!f2 || f2.projection.name !== c2.projection.name)
                    continue;
                  const g2 = t2.isTileAffectedByFog(p2), v2 = f2.programConfigurations.get(o2.id), x2 = t2.getOrCreateProgram("heatmap", { config: v2, defines: u2, overrideFog: g2 }), { zoom: y2 } = t2.transform;
                  t2.terrain && t2.terrain.setupElevationDraw(m2, x2), t2.uploadCommonUniforms(s2, x2, p2.toUnwrapped());
                  const b2 = c2.projection.createInversionMatrix(c2, p2.canonical);
                  x2.draw(t2, a2.TRIANGLES, Li.disabled, n2, l2, d2, Wr(t2, p2, m2, b2, _2, y2, o2.paint.get("heatmap-intensity")), o2.id, f2.layoutVertexBuffer, f2.indexBuffer, f2.segments, o2.paint, t2.transform.zoom, v2, h2 ? [f2.globeExtVertexBuffer] : null);
                }
                s2.viewport.set([0, 0, t2.width, t2.height]);
              } else
                "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
                  const o3 = t3.context, r3 = o3.gl, s2 = i3.heatmapFbo;
                  if (!s2)
                    return;
                  o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, s2.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                  let a2 = i3.colorRampTexture;
                  a2 || (a2 = i3.colorRampTexture = new e.T(o3, i3.colorRamp, r3.RGBA8)), a2.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), t3.getOrCreateProgram("heatmapTexture").draw(t3, r3.TRIANGLES, Li.disabled, Mi.disabled, t3.colorModeForRenderPass(), Fi.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
                }(t2, o2));
          }, line: function(t2, i2, o2, r2) {
            if ("translucent" !== t2.renderPass)
              return;
            const s2 = o2.paint.get("line-opacity"), a2 = o2.paint.get("line-width");
            if (0 === s2.constantOr(1) || 0 === a2.constantOr(1))
              return;
            const n2 = o2.paint.get("line-emissive-strength"), l2 = o2.paint.get("line-occlusion-opacity"), c2 = t2.context, h2 = c2.gl, u2 = o2.layout.get("line-z-offset"), d2 = !u2.isConstant() || !!u2.constantOr(0), _2 = d2 ? new Li(t2.depthOcclusion ? h2.GREATER : h2.LEQUAL, Li.ReadOnly, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, Li.ReadOnly), p2 = t2.colorModeForDrapableLayerRenderPass(n2), m2 = t2.terrain && t2.terrain.renderingToTexture, f2 = m2 ? 1 : e.q.devicePixelRatio, g2 = o2.paint.get("line-dasharray"), v2 = g2.constantOr(1), x2 = o2.layout.get("line-cap"), y2 = g2.constantOr(null), b2 = x2.constantOr(null), w2 = o2.paint.get("line-pattern"), T2 = w2.constantOr(1), E2 = w2.constantOr(null), C2 = o2.paint.get("line-opacity").constantOr(1);
            let S2 = !T2 && 1 !== C2 || t2.depthOcclusion && l2 > 0 && l2 < 1;
            const I2 = o2.paint.get("line-gradient"), D2 = T2 ? "linePattern" : "line", R2 = e.cV(o2);
            let A2;
            if (m2 && t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (S2 = false), 0 !== l2 && t2.depthOcclusion) {
              const t3 = o2.paint._values["line-opacity"];
              t3 && t3.value && "constant" === t3.value.kind ? A2 = t3.value : e.w(`Occlusion opacity for layer ${o2.id} is supported only when line-opacity isn't data-driven.`);
            }
            if (d2 && (t2.forceTerrainMode = true), !d2 && 0 !== l2 && t2.terrain && !m2)
              return void e.w(`Occlusion opacity for layer ${o2.id} is supported on terrain only if the layer has non-zero line-z-offset.`);
            const L2 = S2 && d2 ? t2.stencilModeFor3D() : Mi.disabled;
            for (const s3 of r2) {
              const r3 = i2.getTile(s3);
              if (T2 && !r3.patternsLoaded())
                continue;
              const a3 = r3.getBucket(o2);
              if (!a3)
                continue;
              t2.prepareDrawTile();
              const n3 = a3.programConfigurations.get(o2.id), u3 = t2.isTileAffectedByFog(s3), g3 = t2.getOrCreateProgram(D2, { config: n3, defines: d2 ? [...R2, "ELEVATED"] : R2, overrideFog: u3 });
              if (E2 && r3.imageAtlas) {
                const e2 = r3.imageAtlas.patternPositions[E2.toString()];
                e2 && n3.setConstantPatternPositions(e2);
              }
              if (!T2 && y2 && b2 && r3.lineAtlas) {
                const e2 = r3.lineAtlas.getDash(y2, b2);
                e2 && n3.setConstantPatternPositions(e2);
              }
              let [x3, w3] = o2.paint.get("line-trim-offset");
              if ("round" === b2 || "square" === b2) {
                const e2 = 1;
                x3 !== w3 && (0 === x3 && (x3 -= e2), 1 === w3 && (w3 += e2));
              }
              const P2 = m2 ? s3.projMatrix : null, M2 = T2 ? e.cW(t2, r3, o2, P2, f2, [x3, w3]) : e.cX(t2, r3, o2, P2, a3.lineClipsArray.length, f2, [x3, w3]);
              if (I2) {
                const r4 = a3.gradients[o2.id];
                let n4 = r4.texture;
                if (o2.gradientVersion !== r4.version) {
                  let l3 = 256;
                  if (o2.stepInterpolant) {
                    const o3 = i2.getSource().maxzoom, r5 = s3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - s3.canonical.z) : 1;
                    l3 = e.ap(e.cY(a3.maxLineLength / e.ab * 1024 * r5), 256, c2.maxTextureSize);
                  }
                  r4.gradient = e.cZ({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r4.gradient || void 0, clips: a3.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new e.T(c2, r4.gradient, h2.RGBA8), r4.version = o2.gradientVersion, n4 = r4.texture;
                }
                c2.activeTexture.set(h2.TEXTURE1), n4.bind(o2.stepInterpolant ? h2.NEAREST : h2.LINEAR, h2.CLAMP_TO_EDGE);
              }
              v2 && (c2.activeTexture.set(h2.TEXTURE0), r3.lineAtlasTexture && r3.lineAtlasTexture.bind(h2.LINEAR, h2.REPEAT), n3.updatePaintBuffers()), T2 && (c2.activeTexture.set(h2.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), n3.updatePaintBuffers()), d2 && t2.terrain.setupElevationDraw(r3, g3), t2.uploadCommonUniforms(c2, g3, s3.toUnwrapped());
              const z2 = (e2) => {
                null != A2 && (A2.value = C2 * l2), g3.draw(t2, h2.TRIANGLES, _2, e2, p2, Fi.disabled, M2, o2.id, a3.layoutVertexBuffer, a3.indexBuffer, a3.segments, o2.paint, t2.transform.zoom, n3, [a3.layoutVertexBuffer2, a3.patternVertexBuffer, a3.zOffsetVertexBuffer]), null != A2 && (A2.value = C2);
              };
              if (S2 && !d2) {
                const e2 = t2.stencilModeForClipping(s3).ref;
                0 === e2 && m2 && c2.clear({ stencil: 0 });
                const i3 = { func: h2.EQUAL, mask: 255 };
                M2.u_alpha_discard_threshold = 0.8, z2(new Mi(i3, e2, 255, h2.KEEP, h2.KEEP, h2.INVERT)), M2.u_alpha_discard_threshold = 0, z2(new Mi(i3, e2, 255, h2.KEEP, h2.KEEP, h2.KEEP));
              } else
                S2 && d2 && (M2.u_alpha_discard_threshold = 1e-3), z2(d2 ? L2 : t2.stencilModeForClipping(s3));
            }
            S2 && (t2.resetStencilClippingMasks(), m2 && c2.clear({ stencil: 0 })), 0 === l2 || t2.depthOcclusion || m2 || t2.layersWithOcclusionOpacity.push(t2.currentLayer), d2 && (t2.forceTerrainMode = false);
          }, fill: function(t2, i2, o2, r2) {
            const s2 = o2.paint.get("fill-color"), a2 = o2.paint.get("fill-opacity"), n2 = o2.is3D(), l2 = new Li(t2.context.gl.LEQUAL, Li.ReadWrite, t2.depthRangeFor3D);
            if (0 === a2.constantOr(1))
              return;
            const c2 = o2.paint.get("fill-emissive-strength"), h2 = t2.colorModeForDrapableLayerRenderPass(c2), u2 = o2.paint.get("fill-pattern"), d2 = t2.opaquePassEnabledForLayer() && !u2.constantOr(1) && 1 === s2.constantOr(e.bz.transparent).a && 1 === a2.constantOr(0) ? "opaque" : "translucent";
            if (t2.renderPass === d2) {
              const e2 = n2 ? l2 : t2.depthModeForSublayer(1, "opaque" === t2.renderPass ? Li.ReadWrite : Li.ReadOnly);
              Ts(t2, i2, o2, r2, e2, h2, false);
            }
            if (!n2 && "translucent" === t2.renderPass && o2.paint.get("fill-antialias")) {
              const e2 = n2 ? l2 : t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, Li.ReadOnly);
              Ts(t2, i2, o2, r2, e2, h2, true);
            }
          }, "fill-extrusion": function(t2, i2, o2, r2) {
            const s2 = o2.paint.get("fill-extrusion-opacity"), a2 = t2.context, n2 = a2.gl, l2 = t2.terrain, c2 = l2 && l2.renderingToTexture;
            if (0 === s2)
              return;
            const h2 = t2.conflationActive && t2.style.isLayerClipped(o2, i2.getSource()), u2 = t2.style.order.indexOf(o2.fqid);
            if (h2 && function(e2, t3, i3, o3, r3) {
              for (const s3 of o3) {
                const o4 = t3.getTile(s3).getBucket(i3);
                o4 && (o4.updateReplacement(s3, e2.replacementSource, r3), o4.uploadCentroid(e2.context));
              }
            }(t2, i2, o2, r2, u2), l2 || h2)
              for (const e2 of r2) {
                const r3 = i2.getTile(e2).getBucket(o2);
                r3 && Ss(t2.context, i2, e2, r3, o2, l2, h2);
              }
            if ("shadow" === t2.renderPass && t2.shadowRenderer) {
              const a3 = t2.shadowRenderer;
              if (l2 && s2 < 0.65 && o2._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.a4)
                return;
              const n3 = a3.getShadowPassDepthMode(), c3 = a3.getShadowPassColorMode();
              Es(t2, i2, o2, r2, n3, Mi.disabled, c3, h2);
            } else if ("translucent" === t2.renderPass) {
              const u3 = !o2.paint.get("fill-extrusion-pattern").constantOr(1), d2 = o2.paint.get("fill-extrusion-color").constantOr(e.bz.white);
              if (!c2 && 0 !== d2.a) {
                const e2 = new Li(t2.context.gl.LEQUAL, Li.ReadWrite, t2.depthRangeFor3D);
                1 === s2 && u3 ? Es(t2, i2, o2, r2, e2, Mi.disabled, Ai.unblended, h2) : (Es(t2, i2, o2, r2, e2, Mi.disabled, Ai.disabled, h2), Es(t2, i2, o2, r2, e2, t2.stencilModeFor3D(), t2.colorModeForRenderPass(), h2), t2.resetStencilClippingMasks());
              }
              if (t2.style.enable3dLights() && u3 && (!l2 && "globe" !== t2.transform.projection.name || c2)) {
                const s3 = o2.paint.get("fill-extrusion-opacity"), u4 = o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), d3 = o2.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _2 = o2.paint.get("fill-extrusion-flood-light-intensity"), p2 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(o2.lut).toArray01().slice(0, 3), m2 = u4 > 0 && d3 > 0, f2 = _2 > 0, g2 = (e2, t3, i3) => (1 - i3) * e2 + i3 * t3, v2 = (a3) => {
                  const l3 = t2.depthModeForSublayer(1, Li.ReadOnly, n2.LEQUAL, true), c3 = o2.paint.get(a3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), m3 = g2(0.1, 3, c3), f3 = t2._showOverdrawInspector;
                  if (!f3) {
                    const c4 = new Mi({ func: n2.ALWAYS, mask: 255 }, 255, 255, n2.KEEP, n2.KEEP, n2.REPLACE), f4 = new Ai([n2.ONE, n2.ONE, n2.ONE, n2.ONE], e.bz.transparent, [false, false, false, true], n2.MIN);
                    Cs(t2, i2, o2, r2, l3, c4, f4, Fi.disabled, a3, "sdf", s3, u4, d3, _2, p2, m3, h2, false);
                  }
                  {
                    const c4 = f3 ? Mi.disabled : new Mi({ func: n2.EQUAL, mask: 255 }, 255, 255, n2.KEEP, n2.DECR, n2.DECR), g3 = f3 ? t2.colorModeForRenderPass() : new Ai([n2.ONE_MINUS_DST_ALPHA, n2.DST_ALPHA, n2.ONE, n2.ONE], e.bz.transparent, [true, true, true, true]);
                    Cs(t2, i2, o2, r2, l3, c4, g3, Fi.disabled, a3, "color", s3, u4, d3, _2, p2, m3, h2, false);
                  }
                };
                if (c2) {
                  const c3 = (a3, l3, c4) => {
                    const m3 = t2.depthModeForSublayer(1, Li.ReadOnly, n2.LEQUAL, false), f3 = o2.paint.get(a3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), v3 = g2(0.1, 3, f3);
                    {
                      const c5 = new Ai([n2.ONE, n2.ONE, n2.ONE, n2.ONE], e.bz.transparent, [false, false, false, true]);
                      Cs(t2, i2, o2, r2, m3, Mi.disabled, c5, Fi.disabled, a3, "clear", s3, u4, d3, _2, p2, v3, h2, l3);
                    }
                    {
                      const c5 = new Mi({ func: n2.ALWAYS, mask: 255 }, 255, 255, n2.KEEP, n2.KEEP, n2.REPLACE), f4 = new Ai([n2.ONE, n2.ONE, n2.ONE, n2.ONE], e.bz.transparent, [false, false, false, true], n2.MIN);
                      Cs(t2, i2, o2, r2, m3, c5, f4, Fi.disabled, a3, "sdf", s3, u4, d3, _2, p2, v3, h2, l3);
                    }
                    {
                      const c5 = a3 ? n2.ZERO : n2.ONE_MINUS_DST_ALPHA, f4 = new Mi({ func: n2.EQUAL, mask: 255 }, 255, 255, n2.KEEP, n2.DECR, n2.DECR), g3 = new Ai([c5, n2.DST_ALPHA, n2.ONE_MINUS_DST_ALPHA, n2.ZERO], e.bz.transparent, [true, true, true, true]);
                      Cs(t2, i2, o2, r2, m3, f4, g3, Fi.disabled, a3, "color", s3, u4, d3, _2, p2, v3, h2, l3);
                    }
                    {
                      const f4 = new Ai([n2.ONE, n2.ONE, n2.ONE, a3 ? n2.ZERO : n2.ONE], e.bz.transparent, [false, false, false, true], a3 ? n2.FUNC_ADD : n2.MAX);
                      Cs(t2, i2, o2, r2, m3, Mi.disabled, f4, Fi.disabled, a3, "clear", s3, u4, d3, _2, p2, v3, h2, l3, c4);
                    }
                  };
                  if (m2 || f2) {
                    let i3;
                    if (t2.prepareDrawTile(), l2) {
                      const t3 = l2.drapeBufferSize[0], o3 = l2.drapeBufferSize[1];
                      i3 = l2.framebufferCopyTexture, i3 && (!i3 || i3.size[0] === t3 && i3.size[1] === o3) || (i3 && i3.destroy(), i3 = l2.framebufferCopyTexture = new e.T(a2, new e.r({ width: t3, height: o3 }), n2.RGBA8)), i3.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), n2.copyTexImage2D(n2.TEXTURE_2D, 0, n2.RGBA, 0, 0, t3, o3, 0);
                    }
                    m2 && c3(true, false, i3), f2 && c3(false, true, i3);
                  }
                } else
                  m2 && v2(true), f2 && v2(false), (m2 || f2) && t2.resetStencilClippingMasks();
              }
            }
          }, hillshade: function(e2, t2, i2, o2) {
            if ("offscreen" !== e2.renderPass && "translucent" !== e2.renderPass)
              return;
            if (e2.style.disableElevatedTerrain)
              return;
            const r2 = e2.context, s2 = e2.terrain && e2.terrain.renderingToTexture, [a2, n2] = "translucent" !== e2.renderPass || s2 ? [{}, o2] : e2.stencilConfigForOverlap(o2);
            for (const o3 of n2) {
              const r3 = t2.getTile(o3);
              if (r3.needsHillshadePrepare && "offscreen" === e2.renderPass)
                zo(e2, r3, i2);
              else if ("translucent" === e2.renderPass) {
                const t3 = e2.depthModeForSublayer(0, Li.ReadOnly), n3 = i2.paint.get("hillshade-emissive-strength"), l2 = e2.colorModeForDrapableLayerRenderPass(n3), c2 = s2 && e2.terrain ? e2.terrain.stencilModeForRTTOverlap(o3) : a2[o3.overscaledZ];
                Po(e2, o3, r3, i2, t3, c2, l2);
              }
            }
            r2.viewport.set([0, 0, e2.width, e2.height]), e2.resetStencilClippingMasks();
          }, raster: function(t2, i2, o2, r2, s2, a2) {
            if ("translucent" !== t2.renderPass)
              return;
            if (0 === o2.paint.get("raster-opacity"))
              return;
            const n2 = "globe" === t2.transform.projection.name, l2 = 0 !== o2.paint.get("raster-elevation"), c2 = l2 && n2;
            if (t2.renderElevatedRasterBackface && !c2)
              return;
            const h2 = t2.context, u2 = h2.gl, d2 = i2.getSource(), _2 = function(t3, i3, o3, r3) {
              const s3 = i3.paint.get("raster-color"), a3 = "raster-array" === t3.type, n3 = [], l3 = i3.paint.get("raster-resampling"), c3 = i3.paint.get("raster-color-mix");
              let h3 = i3.paint.get("raster-color-range");
              const u3 = [c3[0], c3[1], c3[2], 0], d3 = c3[3];
              let _3 = "nearest" === l3 ? r3.NEAREST : r3.LINEAR;
              if (a3 && (n3.push("RASTER_ARRAY"), s3 || n3.push("RASTER_COLOR"), "linear" === l3 && n3.push("RASTER_ARRAY_LINEAR"), _3 = r3.NEAREST, !h3 && t3.rasterLayers)) {
                const e2 = t3.rasterLayers.find(({ id: e3 }) => e3 === i3.sourceLayer);
                e2 && e2.fields && e2.fields.range && (h3 = e2.fields.range);
              }
              if (h3 = h3 || [0, 1], s3) {
                n3.push("RASTER_COLOR"), o3.activeTexture.set(r3.TEXTURE2), i3.updateColorRamp(h3);
                let t4 = i3.colorRampTexture;
                t4 || (t4 = i3.colorRampTexture = new e.T(o3, i3.colorRamp, r3.RGBA8)), t4.bind(r3.LINEAR, r3.CLAMP_TO_EDGE);
              }
              return { mix: u3, range: h3, offset: d3, defines: n3, resampling: _3 };
            }(d2, o2, h2, u2);
            if (d2 instanceof e.aD && !r2.length && !n2)
              return;
            const p2 = o2.paint.get("raster-emissive-strength"), m2 = t2.colorModeForDrapableLayerRenderPass(p2), f2 = t2.terrain && t2.terrain.renderingToTexture, g2 = !t2.options.moving, v2 = "nearest" === o2.paint.get("raster-resampling") ? u2.NEAREST : u2.LINEAR;
            if (d2 instanceof e.aD && !r2.length && (d2.onNorthPole || d2.onSouthPole)) {
              const e2 = l2 ? t2.stencilModeFor3D() : Mi.disabled;
              return void Ps(!!d2.onNorthPole, null, t2, i2, o2, p2, _2, Fi.disabled, e2);
            }
            if (!r2.length)
              return;
            const [x2, y2] = d2 instanceof e.aD || f2 ? [{}, r2] : t2.stencilConfigForOverlap(r2), b2 = y2[y2.length - 1].overscaledZ;
            c2 && _2.defines.push("PROJECTION_GLOBE_VIEW"), l2 && _2.defines.push("RENDER_CUTOFF");
            const w2 = (r3, s3, y3) => {
              for (const w3 of r3) {
                const r4 = w3.toUnwrapped(), T2 = i2.getTile(w3);
                if (f2 && (!T2 || !T2.hasData()))
                  continue;
                h2.activeTexture.set(u2.TEXTURE0);
                const E2 = zs(T2, d2, o2, _2);
                if (!E2 || !E2.texture)
                  continue;
                const { texture: C2, mix: S2, offset: I2, tileSize: D2, buffer: R2 } = E2;
                let A2, L2;
                f2 ? (A2 = Li.disabled, L2 = w3.projMatrix) : l2 ? (A2 = new Li(u2.LEQUAL, Li.ReadWrite, t2.depthRangeFor3D), L2 = n2 ? Float32Array.from(t2.transform.expandedFarZProjMatrix) : t2.transform.calculateProjMatrix(r4, g2)) : (A2 = t2.depthModeForSublayer(w3.overscaledZ - b2, 1 === o2.paint.get("raster-opacity") ? Li.ReadWrite : Li.ReadOnly, u2.LESS), L2 = t2.transform.calculateProjMatrix(r4, g2));
                const P2 = t2.terrain && f2 ? t2.terrain.stencilModeForRTTOverlap(w3) : x2[w3.overscaledZ], M2 = a2 ? 0 : o2.paint.get("raster-fade-duration");
                T2.registerFadeDuration(M2);
                const z2 = i2.findLoadedParent(w3, 0), O2 = Sr(T2, z2, i2, t2.transform, M2);
                let F2, k2;
                t2.terrain && t2.terrain.prepareDrawTile(), h2.activeTexture.set(u2.TEXTURE0), C2.bind(v2, u2.CLAMP_TO_EDGE), h2.activeTexture.set(u2.TEXTURE1), z2 ? (z2.texture && z2.texture.bind(v2, u2.CLAMP_TO_EDGE), F2 = Math.pow(2, z2.tileID.overscaledZ - T2.tileID.overscaledZ), k2 = [T2.tileID.canonical.x * F2 % 1, T2.tileID.canonical.y * F2 % 1]) : C2.bind(v2, u2.CLAMP_TO_EDGE), C2.useMipmap && h2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && u2.texParameterf(u2.TEXTURE_2D, h2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h2.extTextureFilterAnisotropicMax);
                const B2 = t2.transform;
                let N2;
                const U2 = l2 ? Ms(B2) : [0, 0, 0, 0];
                let G2, j2, V2, q2, Z2, H2 = 0;
                if (c2 && d2 instanceof e.aD && d2.coordinates.length > 3)
                  G2 = Float32Array.from(e.b5(e.cC(new e.bP(0, 0, 0)))), j2 = Float32Array.from(B2.globeMatrix), V2 = Float32Array.from(e.cy(B2)), q2 = [e.am(B2.center.lng), e.at(B2.center.lat)], N2 = d2.elevatedGlobePerspectiveTransform, Z2 = d2.elevatedGlobeGridMatrix || new Float32Array(9);
                else if (c2) {
                  const t3 = e.cz(w3.canonical);
                  H2 = e.cA(t3.getCenter().lat), G2 = Float32Array.from(e.b5(e.cC(w3.canonical))), j2 = Float32Array.from(B2.globeMatrix), V2 = Float32Array.from(e.cy(B2)), q2 = [e.am(B2.center.lng), e.at(B2.center.lat)], N2 = [0, 0], Z2 = Float32Array.from(e.cB(w3.canonical, t3, H2, B2.worldSize / B2._pixelsPerMercatorPixel));
                } else
                  N2 = d2 instanceof e.aD ? d2.perspectiveTransform : [0, 0], G2 = new Float32Array(16), j2 = new Float32Array(9), V2 = new Float32Array(16), q2 = [0, 0], Z2 = new Float32Array(9);
                const W2 = Yr(L2, G2, j2, V2, Z2, k2 || [0, 0], e.a9(t2.transform.zoom), q2, U2, F2 || 1, O2, o2, N2, l2 ? o2.paint.get("raster-elevation") : 0, 2, S2, I2, _2.range, D2, R2, p2), $2 = t2.isTileAffectedByFog(w3), X2 = t2.getOrCreateProgram("raster", { defines: _2.defines, overrideFog: $2 });
                if (t2.uploadCommonUniforms(h2, X2, r4), d2 instanceof e.aD) {
                  const i3 = d2.elevatedGlobeVertexBuffer, r5 = d2.elevatedGlobeIndexBuffer;
                  if (f2 || !n2)
                    d2.boundsBuffer && d2.boundsSegments && X2.draw(t2, u2.TRIANGLES, A2, Mi.disabled, m2, Fi.disabled, W2, o2.id, d2.boundsBuffer, t2.quadTriangleIndexBuffer, d2.boundsSegments);
                  else if (i3 && r5) {
                    const a3 = B2.zoom <= e.c2 ? d2.elevatedGlobeSegments : d2.getSegmentsForLongitude(B2.center.lng);
                    a3 && X2.draw(t2, u2.TRIANGLES, A2, Mi.disabled, m2, s3, W2, o2.id, i3, r5, a3);
                  }
                } else if (c2) {
                  A2 = new Li(u2.LEQUAL, Li.ReadOnly, t2.depthRangeFor3D);
                  const e2 = t2.globeSharedBuffers;
                  if (e2) {
                    const [i3, r5, a3] = e2.getGridBuffers(H2, false);
                    X2.draw(t2, u2.TRIANGLES, A2, y3 || P2, t2.colorModeForRenderPass(), s3, W2, o2.id, i3, r5, a3);
                  }
                } else {
                  const { tileBoundsBuffer: e2, tileBoundsIndexBuffer: i3, tileBoundsSegments: r5 } = t2.getTileBoundsBuffers(T2);
                  X2.draw(t2, u2.TRIANGLES, A2, P2, m2, Fi.disabled, W2, o2.id, e2, i3, r5);
                }
              }
              if (!(d2 instanceof e.aD) && c2)
                for (const e2 of r3) {
                  const r4 = e2.canonical.y === (1 << e2.canonical.z) - 1;
                  0 === e2.canonical.y && Ps(true, e2, t2, i2, o2, p2, _2, s3, y3 || Mi.disabled), r4 && Ps(false, e2, t2, i2, o2, p2, _2, s3 === Fi.frontCW ? Fi.backCW : Fi.frontCW, y3 || Mi.disabled);
                }
            };
            c2 ? w2(y2, t2.renderElevatedRasterBackface ? Fi.backCW : Fi.frontCW, t2.stencilModeFor3D()) : w2(y2, Fi.disabled, void 0), t2.resetStencilClippingMasks();
          }, "raster-particle": function(t2, i2, o2, r2, s2, a2) {
            "offscreen" === t2.renderPass && function(t3, i3, o3, r3) {
              if (!r3.length)
                return;
              const s3 = t3.context, a3 = s3.gl, n2 = i3.getSource();
              if (!(n2 instanceof Qe))
                return;
              const l2 = Math.ceil(Math.sqrt(o3.paint.get("raster-particle-count")));
              let c2 = o3.particlePositionRGBAImage;
              if (!c2 || c2.width !== l2) {
                const t4 = function(e2) {
                  const t5 = e2 * e2, i4 = new Uint8Array(4 * t5), o4 = function(e3) {
                    return e3 |= 0, e3 = Math.imul(2747636419 ^ e3, 2654435769), e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769), ((e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769)) >>> 0) / 4294967296;
                  }, r4 = 1 / 1.1;
                  for (let e3 = 0; e3 < t5; e3++) {
                    const t6 = r4 * (o4(2 * e3 + 0) + Jr), s4 = r4 * (o4(2 * e3 + 1) + Jr), a4 = 255 * t6 % 1, n3 = 255 * s4 % 1, l3 = a4, c3 = s4 - n3 / 255, h3 = n3;
                    i4[4 * e3 + 0] = 255 * (t6 - a4 / 255), i4[4 * e3 + 1] = 255 * l3, i4[4 * e3 + 2] = 255 * c3, i4[4 * e3 + 3] = 255 * h3;
                  }
                  return i4;
                }(l2);
                c2 = o3.particlePositionRGBAImage = new e.r({ width: l2, height: l2 }, t4);
              }
              let h2 = o3.particleFramebuffer;
              h2 ? h2.width !== l2 && (h2.destroy(), h2 = o3.particleFramebuffer = s3.createFramebuffer(l2, l2, true, null)) : h2 = o3.particleFramebuffer = s3.createFramebuffer(l2, l2, true, null);
              const u2 = [];
              for (const e2 of r3) {
                const t4 = i3.getTile(e2);
                if (!(t4 instanceof mt))
                  continue;
                const r4 = ks(t4, n2, o3);
                if (!r4)
                  continue;
                const a4 = [t4.tileSize, t4.tileSize];
                let h3 = o3.tileFramebuffer;
                h3 || (h3 = o3.tileFramebuffer = s3.createFramebuffer(a4[0], a4[1], true, null));
                let d3 = t4.rasterParticleState;
                d3 || (d3 = t4.rasterParticleState = new Fs(s3, e2, a4, c2));
                const _3 = d3.update(o3.lastInvalidatedAt);
                d3.particleTextureDimension !== l2 && d3.updateParticleTexture(e2, c2);
                const p2 = d3.targetColorTexture;
                d3.targetColorTexture = d3.backgroundColorTexture, d3.backgroundColorTexture = p2;
                const m2 = d3.particleTexture0;
                d3.particleTexture0 = d3.particleTexture1, d3.particleTexture1 = m2, u2.push([e2, r4, d3, _3]);
              }
              if (0 === u2.length)
                return;
              const d2 = e.q.now(), _2 = o3.previousDrawTimestamp ? 1e-3 * (d2 - o3.previousDrawTimestamp) : 0.0167;
              if (o3.previousDrawTimestamp = d2, o3.hasColorMap()) {
                s3.activeTexture.set(a3.TEXTURE0 + 2);
                let t4 = o3.colorRampTexture;
                t4 || (t4 = o3.colorRampTexture = new e.T(s3, o3.colorRamp, a3.RGBA8)), t4.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
              }
              s3.bindFramebuffer.set(o3.tileFramebuffer.framebuffer), function(t4, i4, o4) {
                const r4 = t4.context, s4 = r4.gl, a4 = i4.tileFramebuffer;
                r4.activeTexture.set(s4.TEXTURE0);
                const n3 = { u_texture: 0, u_opacity: 1.05 * (c3 = i4.paint.get("raster-particle-fade-opacity-factor")) / (c3 + 0.05) }, l3 = t4.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
                var c3;
                for (const c4 of o4) {
                  const [, , o5, h3] = c4;
                  a4.colorAttachment.set(o5.targetColorTexture.texture), r4.viewport.set([0, 0, a4.width, a4.height]), r4.clear({ color: e.bz.transparent }), h3 && (o5.backgroundColorTexture.bind(s4.NEAREST, s4.CLAMP_TO_EDGE), l3.draw(t4, s4.TRIANGLES, Li.disabled, Mi.disabled, Ai.alphaBlended, Fi.disabled, n3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments));
                }
              }(t3, o3, u2), function(t4, i4, o4, r4) {
                const s4 = t4.context, a4 = s4.gl, n3 = o4.tileFramebuffer, l3 = "globe" === t4.transform.projection.name, c3 = o4.paint.get("raster-particle-max-speed");
                for (const h3 of r4) {
                  const [r5, u3, d3] = h3;
                  s4.activeTexture.set(a4.TEXTURE0 + 0), u3.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), n3.colorAttachment.set(d3.targetColorTexture.texture);
                  const _3 = t4.getOrCreateProgram("rasterParticleDraw", { defines: u3.defines, overrideFog: false });
                  s4.activeTexture.set(a4.TEXTURE0 + 1);
                  const p2 = u3.scalarData ? [] : [0, 1, 2, 3].map((t5) => e.c$[t5](r5));
                  p2.push(r5);
                  const m2 = r5.canonical.x, f2 = r5.canonical.y;
                  for (const e2 of p2) {
                    const s5 = i4.getTile(l3 ? e2.wrapped() : e2);
                    if (!s5)
                      continue;
                    const n4 = s5.rasterParticleState;
                    if (!n4)
                      continue;
                    const h4 = e2.canonical.x + (1 << e2.canonical.z) * (e2.wrap - r5.wrap), d4 = e2.canonical.y;
                    n4.particleTexture0.bind(a4.NEAREST, a4.CLAMP_TO_EDGE);
                    const p3 = es(1, n4.particleTexture0.size[0], [h4 - m2, d4 - f2], 0, u3.texture.size, 2, c3, u3.textureOffset, u3.scale, u3.offset);
                    _3.draw(t4, a4.POINTS, Li.disabled, Mi.disabled, Ai.alphaBlended, Fi.disabled, p3, o4.id, n4.particleIndexBuffer, void 0, n4.particleSegment);
                  }
                }
              }(t3, i3, o3, u2), s3.bindFramebuffer.set(o3.particleFramebuffer.framebuffer), function(t4, i4, o4, r4) {
                const s4 = t4.context, a4 = s4.gl, n3 = i4.paint.get("raster-particle-max-speed"), l3 = r4 * i4.paint.get("raster-particle-speed-factor") * 0.15, c3 = function(e2) {
                  return Math.pow(e2, 6);
                }(0.01 + 1 * i4.paint.get("raster-particle-reset-rate-factor")), h3 = i4.particleFramebuffer;
                s4.viewport.set([0, 0, h3.width, h3.height]);
                for (const r5 of o4) {
                  const [, o5, u3] = r5;
                  s4.activeTexture.set(a4.TEXTURE0 + 0), o5.texture.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), s4.activeTexture.set(a4.TEXTURE0 + 1);
                  const d3 = u3.particleTexture0;
                  d3.bind(a4.NEAREST, a4.CLAMP_TO_EDGE);
                  const _3 = ts(1, d3.size[0], 0, o5.texture.size, n3, l3, c3, o5.textureOffset, o5.scale, o5.offset);
                  h3.colorAttachment.set(u3.particleTexture1.texture), s4.clear({ color: e.bz.transparent }), t4.getOrCreateProgram("rasterParticleUpdate", { defines: o5.defines }).draw(t4, a4.TRIANGLES, Li.disabled, Mi.disabled, Ai.unblended, Fi.disabled, _3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments);
                }
              }(t3, o3, u2, _2);
            }(t2, i2, o2, r2), "translucent" === t2.renderPass && (function(t3, i3, o3, r3, s3) {
              const a3 = t3.context, n2 = a3.gl, l2 = i3.getSource().tileSize, c2 = 5 * (1 - e.a7(e.bU, e.bU + 1, t3.transform.zoom)) * l2 + o3.paint.get("raster-particle-elevation"), h2 = !t3.options.moving, u2 = "globe" === t3.transform.projection.name;
              if (!r3.length)
                return;
              const [d2, _2] = t3.stencilConfigForOverlap(r3), p2 = [];
              u2 && p2.push("PROJECTION_GLOBE_VIEW");
              const m2 = t3.stencilModeFor3D();
              for (const r4 of _2) {
                const s4 = r4.toUnwrapped(), l3 = i3.getTile(r4);
                if (!l3.rasterParticleState)
                  continue;
                const _3 = l3.rasterParticleState, f2 = 100;
                l3.registerFadeDuration(f2);
                const g2 = i3.findLoadedParent(r4, 0), v2 = Sr(l3, g2, i3, t3.transform, f2);
                let x2, y2;
                t3.terrain && t3.terrain.prepareDrawTile(), a3.activeTexture.set(n2.TEXTURE0), _3.targetColorTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), a3.activeTexture.set(n2.TEXTURE1), g2 && g2.rasterParticleState ? (g2.rasterParticleState.targetColorTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2 = Math.pow(2, g2.tileID.overscaledZ - l3.tileID.overscaledZ), y2 = [l3.tileID.canonical.x * x2 % 1, l3.tileID.canonical.y * x2 % 1]) : _3.targetColorTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE);
                const b2 = u2 ? Float32Array.from(t3.transform.expandedFarZProjMatrix) : t3.transform.calculateProjMatrix(s4, h2), w2 = t3.transform, T2 = Bs(w2), E2 = e.cz(r4.canonical), C2 = e.cA(E2.getCenter().lat);
                let S2, I2, D2, R2, A2;
                u2 ? (S2 = Float32Array.from(e.b5(e.cC(r4.canonical))), I2 = Float32Array.from(w2.globeMatrix), D2 = Float32Array.from(e.cy(w2)), R2 = [e.am(w2.center.lng), e.at(w2.center.lat)], A2 = Float32Array.from(e.cB(r4.canonical, E2, C2, w2.worldSize / w2._pixelsPerMercatorPixel))) : (S2 = new Float32Array(16), I2 = new Float32Array(9), D2 = new Float32Array(16), R2 = [0, 0], A2 = new Float32Array(9));
                const L2 = Qr(b2, S2, I2, D2, A2, y2 || [0, 0], e.a9(t3.transform.zoom), R2, T2, x2 || 1, v2, c2), P2 = t3.isTileAffectedByFog(r4), M2 = t3.getOrCreateProgram("rasterParticle", { defines: p2, overrideFog: P2 });
                if (t3.uploadCommonUniforms(a3, M2, s4), u2) {
                  const e2 = new Li(n2.LEQUAL, Li.ReadOnly, t3.depthRangeFor3D), i4 = 0, r5 = t3.globeSharedBuffers;
                  if (r5) {
                    const [s5, a4, l4] = r5.getGridBuffers(C2, 0 !== i4);
                    M2.draw(t3, n2.TRIANGLES, e2, m2, Ai.alphaBlended, t3.renderElevatedRasterBackface ? Fi.frontCCW : Fi.backCCW, L2, o3.id, s5, a4, l4);
                  }
                } else {
                  const e2 = t3.depthModeForSublayer(0, Li.ReadOnly), i4 = d2[r4.overscaledZ], { tileBoundsBuffer: s5, tileBoundsIndexBuffer: a4, tileBoundsSegments: c3 } = t3.getTileBoundsBuffers(l3);
                  M2.draw(t3, n2.TRIANGLES, e2, i4, Ai.alphaBlended, Fi.disabled, L2, o3.id, s5, a4, c3);
                }
              }
              t3.resetStencilClippingMasks();
            }(t2, i2, o2, r2), t2.style.map.triggerRepaint());
          }, background: function(t2, i2, o2, r2) {
            const s2 = o2.paint.get("background-color"), a2 = o2.paint.get("background-opacity"), n2 = o2.paint.get("background-emissive-strength"), l2 = "viewport" === o2.paint.get("background-pitch-alignment");
            if (0 === a2)
              return;
            const c2 = t2.context, h2 = c2.gl, u2 = t2.transform, d2 = u2.tileSize, _2 = o2.paint.get("background-pattern");
            let p2;
            if (void 0 !== _2) {
              if (null === _2)
                return;
              if (p2 = t2.imageManager.getPattern(_2.toString(), o2.scope, t2.style.getLut(o2.scope)), !p2)
                return;
            }
            const m2 = !_2 && 1 === s2.a && 1 === a2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (t2.renderPass !== m2)
              return;
            const f2 = Mi.disabled, g2 = t2.depthModeForSublayer(0, "opaque" === m2 ? Li.ReadWrite : Li.ReadOnly), v2 = t2.colorModeForDrapableLayerRenderPass(n2), x2 = _2 ? "backgroundPattern" : "background";
            let y2, b2 = r2;
            if (b2 || (y2 = t2.getBackgroundTiles(), b2 = Object.values(y2).map((e2) => e2.tileID)), _2 && (c2.activeTexture.set(h2.TEXTURE0), t2.imageManager.bind(t2.context, o2.scope)), l2) {
              const i3 = t2.getOrCreateProgram(x2, { overrideFog: false, overrideRtt: true }), r3 = new Float32Array(e.a6.mat4.identity([])), c3 = new e.aA(0, 0, 0, 0, 0), u3 = _2 ? ss2(r3, n2, a2, t2, 0, o2.scope, p2, l2, { tileID: c3, tileSize: d2 }) : rs(r3, n2, a2, s2.toRenderColor(o2.lut));
              i3.draw(t2, h2.TRIANGLES, g2, f2, v2, Fi.disabled, u3, o2.id, t2.viewportBuffer, t2.quadTriangleIndexBuffer, t2.viewportSegments);
            } else
              for (const e2 of b2) {
                const m3 = t2.isTileAffectedByFog(e2), b3 = t2.getOrCreateProgram(x2, { overrideFog: m3 }), w2 = e2.toUnwrapped(), T2 = r2 ? e2.projMatrix : t2.transform.calculateProjMatrix(w2);
                t2.prepareDrawTile();
                const E2 = i2 ? i2.getTile(e2) : y2 ? y2[e2.key] : new pt(e2, d2, u2.zoom, t2), C2 = _2 ? ss2(T2, n2, a2, t2, 0, o2.scope, p2, l2, { tileID: e2, tileSize: d2 }) : rs(T2, n2, a2, s2.toRenderColor(o2.lut));
                t2.uploadCommonUniforms(c2, b3, w2);
                const { tileBoundsBuffer: S2, tileBoundsIndexBuffer: I2, tileBoundsSegments: D2 } = t2.getTileBoundsBuffers(E2);
                b3.draw(t2, h2.TRIANGLES, g2, f2, v2, Fi.disabled, C2, o2.id, S2, I2, D2);
              }
          }, sky: function(t2, i2, o2) {
            const r2 = t2._atmosphere ? e.a9(t2.transform.zoom) : 1, s2 = o2.paint.get("sky-opacity") * r2;
            if (0 === s2)
              return;
            const a2 = t2.context, n2 = o2.paint.get("sky-type"), l2 = new Li(a2.gl.LEQUAL, Li.ReadOnly, [0, 1]), c2 = t2.frameCounter / 1e3 % 1;
            "atmosphere" === n2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r3) {
              const s3 = t3.context, a3 = s3.gl;
              let n3 = i3.skyboxFbo;
              if (!n3) {
                n3 = i3.skyboxFbo = s3.createFramebuffer(32, 32, true, null), i3.skyboxGeometry = new Ks(s3), i3.skyboxTexture = s3.gl.createTexture(), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_S, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_T, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MIN_FILTER, a3.LINEAR), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MAG_FILTER, a3.LINEAR);
                for (let e2 = 0; e2 < 6; ++e2)
                  a3.texImage2D(a3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, a3.RGBA, 32, 32, 0, a3.RGBA, a3.UNSIGNED_BYTE, null);
              }
              s3.bindFramebuffer.set(n3.framebuffer), s3.viewport.set([0, 0, 32, 32]);
              const l3 = i3.getCenter(t3, true), c3 = t3.getOrCreateProgram("skyboxCapture"), h2 = new Float64Array(16);
              e.a6.mat4.identity(h2), e.a6.mat4.rotateY(h2, h2, 0.5 * -Math.PI), Js(t3, i3, c3, h2, l3, 0), e.a6.mat4.identity(h2), e.a6.mat4.rotateY(h2, h2, 0.5 * Math.PI), Js(t3, i3, c3, h2, l3, 1), e.a6.mat4.identity(h2), e.a6.mat4.rotateX(h2, h2, 0.5 * -Math.PI), Js(t3, i3, c3, h2, l3, 2), e.a6.mat4.identity(h2), e.a6.mat4.rotateX(h2, h2, 0.5 * Math.PI), Js(t3, i3, c3, h2, l3, 3), e.a6.mat4.identity(h2), Js(t3, i3, c3, h2, l3, 4), e.a6.mat4.identity(h2), e.a6.mat4.rotateY(h2, h2, Math.PI), Js(t3, i3, c3, h2, l3, 5), s3.viewport.set([0, 0, t3.width, t3.height]);
            }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(e2, t3, i3, o3, r3) {
              const s3 = e2.context, a3 = s3.gl, n3 = e2.transform, l3 = e2.getOrCreateProgram("skybox");
              s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, t3.skyboxTexture);
              const c3 = /* @__PURE__ */ ((e3, t4, i4, o4, r4) => ({ u_matrix: e3, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r4 }))(n3.skyboxMatrix, t3.getCenter(e2, false), 0, o3, r3);
              e2.uploadCommonUniforms(s3, l3), l3.draw(e2, a3.TRIANGLES, i3, Mi.disabled, e2.colorModeForRenderPass(), Fi.backCW, c3, "skybox", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
            }(t2, o2, l2, s2, c2) : "gradient" === n2 && "sky" === t2.renderPass && function(t3, i3, o3, r3, s3) {
              const a3 = t3.context, n3 = a3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skyboxGradient");
              i3.skyboxGeometry || (i3.skyboxGeometry = new Ks(a3)), a3.activeTexture.set(n3.TEXTURE0);
              let h2 = i3.colorRampTexture;
              h2 || (h2 = i3.colorRampTexture = new e.T(a3, i3.colorRamp, n3.RGBA8)), h2.bind(n3.LINEAR, n3.CLAMP_TO_EDGE);
              const u2 = ((t4, i4, o4, r4, s4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.bB(o4), u_opacity: r4, u_temporal_offset: s4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r3, s3);
              t3.uploadCommonUniforms(a3, c3), c3.draw(t3, n3.TRIANGLES, o3, Mi.disabled, t3.colorModeForRenderPass(), Fi.backCW, u2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
            }(t2, o2, l2, s2, c2);
          }, debug: function(t2, i2, o2, r2, s2, a2) {
            for (let n2 = 0; n2 < o2.length; n2++)
              if (s2) {
                const s3 = 1, l2 = 0.8, c2 = new e.bz(r2.r * l2, r2.g * l2, r2.b * l2, 1);
                qs(t2, i2, o2[n2], r2, -s3, -s3, a2), qs(t2, i2, o2[n2], r2, -s3, s3, a2), qs(t2, i2, o2[n2], r2, s3, s3, a2), qs(t2, i2, o2[n2], r2, s3, -s3, a2), qs(t2, i2, o2[n2], c2, 0, 0, a2);
              } else
                qs(t2, i2, o2[n2], r2, 0, 0, a2);
          }, custom: function(t2, i2, o2, r2) {
            const s2 = t2.context, a2 = o2.implementation;
            if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isDraped(i2)) {
              if ("offscreen" === t2.renderPass) {
                const i3 = a2.prerender;
                if (i3) {
                  if (t2.setCustomLayerDefaults(), s2.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                    const o3 = t2.transform.pointMerc;
                    i3.call(a2, s2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.a9(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
                  } else
                    i3.call(a2, s2.gl, t2.transform.customLayerMatrix());
                  s2.setDirty(), t2.setBaseState();
                }
              } else if ("translucent" === t2.renderPass) {
                if (t2.terrain && t2.terrain.renderingToTexture) {
                  const i4 = a2.renderToTile;
                  if (i4) {
                    const o3 = r2[0].canonical, n2 = new e.a5(o3.x + r2[0].wrap * (1 << o3.z), o3.y, o3.z);
                    s2.setDepthMode(Li.disabled), s2.setStencilMode(Mi.disabled), s2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), i4.call(a2, s2.gl, n2), s2.setDirty(), t2.setBaseState();
                  }
                  return;
                }
                t2.setCustomLayerDefaults(), s2.setColorMode(t2.colorModeForRenderPass()), s2.setStencilMode(Mi.disabled);
                const i3 = "3d" === a2.renderingMode ? new Li(t2.context.gl.LEQUAL, Li.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, Li.ReadOnly);
                if (s2.setDepthMode(i3), "globe" === t2.transform.projection.name) {
                  const i4 = t2.transform.pointMerc;
                  a2.render(s2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.a9(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
                } else
                  a2.render(s2.gl, t2.transform.customLayerMatrix());
                s2.setDirty(), t2.setBaseState(), s2.bindFramebuffer.set(null);
              }
            } else
              e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
          }, model: function(t2, i2, o2, r2) {
            if ("opaque" === t2.renderPass)
              return;
            const s2 = o2.paint.get("model-opacity");
            if (0 === s2)
              return;
            const a2 = o2.paint.get("model-cast-shadows");
            if ("shadow" === t2.renderPass) {
              if (!a2)
                return;
              if (t2.terrain && s2 < 0.65 && o2._transitionablePaint._values["model-opacity"].value.expression instanceof e.a4)
                return;
            }
            const n2 = t2.shadowRenderer, l2 = o2.paint.get("model-receive-shadows");
            n2 && (n2.useNormalOffset = true, l2 || (n2.enabled = false));
            const c2 = () => {
              n2 && (n2.useNormalOffset = true, l2 || (n2.enabled = true));
            }, h2 = i2.getSource();
            if ("light-beam" === t2.renderPass && "batched-model" !== h2.type)
              return;
            if ("vector" === h2.type || "geojson" === h2.type)
              return function(t3, i3, o3, r3, s3) {
                const a3 = t3.transform;
                if ("mercator" !== a3.projection.name)
                  return void e.w(`Drawing 3D models for ${a3.projection.name} projection is not yet implemented`);
                const n3 = a3.getFreeCameraOptions().position;
                if (!t3.modelManager)
                  return;
                const l3 = t3.modelManager;
                o3.modelManager = l3;
                const c3 = t3.shadowRenderer;
                if (!o3._unevaluatedLayout._values.hasOwnProperty("model-id"))
                  return;
                const h3 = o3._unevaluatedLayout._values["model-id"], u3 = { ...o3.layout.get("model-id").parameters }, d3 = t3.style.order.indexOf(o3.fqid);
                for (const _3 of r3) {
                  const r4 = i3.getTile(_3).getBucket(o3);
                  if (!r4 || r4.projection.name !== a3.projection.name)
                    continue;
                  const p3 = r4.getModelUris();
                  p3 && !r4.modelsRequested && (l3.addModelsFromBucket(p3, s3), r4.modelsRequested = true);
                  const m3 = ua(_3, a3);
                  u3.zoom = m3;
                  const f3 = h3.possiblyEvaluate(u3);
                  if (ca(t3, r4, _3), ha.shadowUniformsInitialized = false, ha.useSingleShadowCascade = !!c3 && 0 === c3.getMaxCascadeForTile(_3.toUnwrapped()), "shadow" === t3.renderPass && c3) {
                    if (1 === t3.currentShadowCascade && r4.isInsideFirstShadowMapFrustum)
                      continue;
                    const i4 = a3.calculatePosMatrix(_3.toUnwrapped(), a3.worldSize);
                    if (ha.tileMatrix.set(i4), ha.shadowTileMatrix = Float32Array.from(c3.calculateShadowPassMatrixFromMatrix(i4)), ha.aabb.min.fill(0), ha.aabb.max[0] = ha.aabb.max[1] = e.ab, ha.aabb.max[2] = 0, pa(r4, ha, t3, o3.scope))
                      continue;
                  }
                  const g3 = 1 << _3.canonical.z, v2 = [((n3.x - _3.wrap) * g3 - _3.canonical.x) * e.ab, (n3.y * g3 - _3.canonical.y) * e.ab, n3.z * g3 * e.ab];
                  t3.conflationActive && Object.keys(r4.instancesPerModel).length > 0 && t3.style.isLayerClipped(o3, i3.getSource()) && r4.updateReplacement(_3, t3.replacementSource, d3, s3) && (r4.uploaded = false, r4.upload(t3.context));
                  for (let e2 in r4.instancesPerModel) {
                    const i4 = r4.instancesPerModel[e2];
                    i4.features.length > 0 && (e2 = f3.evaluate(i4.features[0].feature, {}));
                    const a4 = l3.getModel(e2, s3);
                    if (a4 && a4.uploaded)
                      for (const e3 of a4.nodes)
                        da(t3, o3, e3, i4, v2, _3, ha);
                  }
                }
              }(t2, i2, o2, r2, "vector" === h2.type ? o2.scope : ""), void c2();
            if (!h2.loaded())
              return;
            if ("batched-model" === h2.type)
              return function(t3, i3, o3, r3) {
                o3.resetLayerRenderingStats(t3);
                const s3 = t3.context, a3 = t3.transform, n3 = t3.style.fog, l3 = t3.shadowRenderer;
                if ("mercator" !== a3.projection.name)
                  return void e.w(`Drawing 3D landmark models for ${a3.projection.name} projection is not yet implemented`);
                const c3 = t3.transform.getFreeCameraOptions().position, h3 = e.a6.vec3.scale([], [c3.x, c3.y, c3.z], t3.transform.worldSize), u3 = e.a6.vec3.negate([], h3), d3 = e.a6.mat4.identity([]), _3 = e.de(a3.center.lat, a3.zoom), p3 = e.a6.mat4.fromScaling([], [1, 1, 1 / _3]);
                e.a6.mat4.translate(d3, d3, u3);
                const m3 = o3.paint.get("model-opacity"), f3 = new Li(s3.gl.LEQUAL, Li.ReadWrite, t3.depthRangeFor3D), g3 = new Li(s3.gl.LEQUAL, Li.ReadOnly, t3.depthRangeFor3D), v2 = new e.c9([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), x2 = "shadow" === t3.renderPass, y2 = x2 && l3 ? l3.getCurrentCascadeFrustum() : a3.getFrustum(a3.scaleZoom(a3.worldSize)), b2 = o3.paint.get("model-front-cutoff"), w2 = b2[2] < 1, T2 = Wi(t3, o3.paint.get("model-cutoff-fade-range")), E2 = o3.getLayerRenderingStats();
                (function(e2, t4, i4, o4) {
                  const r4 = e2.terrain ? e2.terrain.exaggeration() : 0, s4 = e2.transform.zoom;
                  for (const a4 of o4) {
                    const o5 = t4.getTile(a4).getBucket(i4);
                    o5 && (e2.conflationActive && o5.updateReplacement(a4, e2.replacementSource), o5.evaluateScale(e2, i4), e2.terrain && r4 > 0 && o5.elevationUpdate(e2.terrain, r4, a4, i4.source), o5.needsReEvaluation(e2, s4, i4) && o5.evaluate(i4));
                  }
                })(t3, i3, o3, r3), function() {
                  let c4, u4, C2;
                  w2 ? (c4 = r3.length - 1, u4 = -1, C2 = -1) : (c4 = 0, u4 = r3.length, C2 = 1);
                  const S2 = new Float64Array(16), I2 = e.a6.vec3.create(), D2 = new e.P(0, 0);
                  for (let R2 = c4; R2 !== u4; R2 += C2) {
                    const c5 = r3[R2], u5 = i3.getTile(c5).getBucket(o3);
                    if (!u5 || !u5.uploaded)
                      continue;
                    let C3 = false;
                    l3 && (C3 = 0 === l3.getMaxCascadeForTile(c5.toUnwrapped()));
                    const A2 = a3.calculatePosMatrix(c5.toUnwrapped(), a3.worldSize), L2 = u5.modelTraits;
                    !x2 && w2 && (e.a6.mat4.invert(S2, A2), e.a6.vec3.transformMat4(I2, h3, S2), D2.x = I2[0], D2.y = I2[1]);
                    const P2 = [];
                    for (const i4 of u5.getNodesInfo()) {
                      if (i4.hiddenByReplacement)
                        continue;
                      if (!i4.node.meshes)
                        continue;
                      const o4 = i4.node;
                      let r4 = 0;
                      t3.terrain && o4.elevation && (r4 = o4.elevation * t3.terrain.exaggeration());
                      const s4 = (() => {
                        const t4 = i4.aabb;
                        return v2.min = [...t4.min], v2.max = [...t4.max], v2.min[2] += r4, v2.max[2] += r4, e.a6.vec3.transformMat4(v2.min, v2.min, A2), e.a6.vec3.transformMat4(v2.max, v2.max, A2), v2;
                      })(), n4 = i4.evaluatedScale;
                      if (n4[0] <= 1 && n4[1] <= 1 && n4[2] <= 1 && 0 === s4.intersects(y2))
                        continue;
                      if (!x2 && w2) {
                        const t4 = 1 / 6;
                        i4.cameraCollisionOpacity = h3[0] > s4.min[0] && h3[0] < s4.max[0] && h3[1] > s4.min[1] && h3[1] < s4.max[1] && h3[2] * _3 < s4.max[2] && o4.footprint && e.bu(D2, o4.footprint) ? Math.max(i4.cameraCollisionOpacity - t4, 0) : Math.min(1, i4.cameraCollisionOpacity + t4);
                      }
                      const l4 = [...A2], c6 = o4.anchor ? o4.anchor[0] : 0, u6 = o4.anchor ? o4.anchor[1] : 0;
                      e.a6.mat4.translate(l4, l4, [c6 * (n4[0] - 1), u6 * (n4[1] - 1), r4]), e.a6.vec3.exactEquals(n4, e.dh) || e.a6.mat4.scale(l4, l4, n4);
                      const d4 = e.a6.mat4.multiply([], l4, o4.matrix), p4 = e.a6.mat4.multiply([], a3.expandedFarZProjMatrix, d4), f4 = e.a6.mat4.multiply([], a3.expandedFarZProjMatrix, l4), g4 = e.a6.vec4.transformMat4([], [c6, u6, r4, 1], p4)[2];
                      o4.hidden = false;
                      let E3 = m3;
                      x2 || (w2 && (E3 *= i4.cameraCollisionOpacity, E3 *= fa(l4, a3, i4.aabb, b2)), E3 *= ma(T2, g4)), 0 !== E3 ? P2.push({ nodeInfo: i4, depth: g4, opacity: E3, wvpForNode: p4, wvpForTile: f4, nodeModelMatrix: d4, tileModelMatrix: l4 }) : o4.hidden = true;
                    }
                    x2 || P2.sort((e2, t4) => !w2 || 1 === e2.opacity && 1 === t4.opacity ? e2.depth < t4.depth ? -1 : 1 : 1 === e2.opacity ? -1 : 1 === t4.opacity ? 1 : e2.depth > t4.depth ? -1 : 1);
                    for (const i4 of P2) {
                      const r4 = i4.nodeInfo, c6 = r4.node;
                      let h4 = e.a6.mat4.multiply([], p3, i4.tileModelMatrix);
                      e.a6.mat4.multiply(h4, d3, h4);
                      const u6 = e.a6.mat4.invert([], h4);
                      e.a6.mat4.transpose(u6, u6), e.a6.mat4.scale(u6, u6, _a), h4 = e.a6.mat4.multiply(h4, h4, c6.matrix);
                      const _4 = "light-beam" === t3.renderPass, m4 = L2 & e.dj.HasMapboxMeshFeatures, v3 = m4 ? 0 : r4.evaluatedRMEA[0][2];
                      for (let e2 = 0; e2 < c6.meshes.length; ++e2) {
                        const d4 = c6.meshes[e2], p4 = e2 === c6.lightMeshIndex;
                        let y3 = i4.wvpForNode;
                        if (p4) {
                          if (!_4 && !t3.terrain && t3.shadowRenderer) {
                            t3.currentLayer < t3.firstLightBeamLayer && (t3.firstLightBeamLayer = t3.currentLayer);
                            continue;
                          }
                          y3 = i4.wvpForTile;
                        } else if (_4)
                          continue;
                        const b3 = { defines: [] }, w3 = [];
                        if (sa(b3.defines, w3, d4, t3, o3.lut), m4 || b3.defines.push("DIFFUSE_SHADED"), C3 && b3.defines.push("SHADOWS_SINGLE_CASCADE"), E2 && (x2 ? E2.numRenderedVerticesInShadowPass += d4.vertexArray.length : E2.numRenderedVerticesInTransparentPass += d4.vertexArray.length), x2) {
                          la(d4, i4.nodeModelMatrix, t3, o3);
                          continue;
                        }
                        let T3 = null;
                        if (n3) {
                          const e3 = ra(i4.nodeModelMatrix, t3.transform);
                          if (T3 = new Float32Array(e3), "globe" !== a3.projection.name) {
                            const t4 = d4.aabb.min, i5 = d4.aabb.max, [o4, r5] = n3.getOpacityForBounds(e3, t4[0], t4[1], i5[0], i5[1]);
                            b3.overrideFog = o4 >= Oe || r5 >= Oe;
                          }
                        }
                        const S3 = d4.material;
                        let I3;
                        S3.occlusionTexture && S3.occlusionTexture.offsetScale && (I3 = S3.occlusionTexture.offsetScale, b3.defines.push("OCCLUSION_TEXTURE_TRANSFORM")), !x2 && l3 && (l3.useNormalOffset = !!d4.normalBuffer);
                        const D3 = t3.getOrCreateProgram("model", b3);
                        !x2 && l3 && l3.setupShadowsFromMatrix(i4.tileModelMatrix, D3, l3.useNormalOffset), t3.uploadCommonUniforms(s3, D3, null, T3);
                        const R3 = S3.pbrMetallicRoughness;
                        R3.metallicFactor = 0.9, R3.roughnessFactor = 0.5;
                        const A3 = ns(new Float32Array(y3), new Float32Array(h4), new Float32Array(u6), new Float32Array(c6.matrix), t3, i4.opacity, R3.baseColorFactor.toRenderColor(null), S3.emissiveFactor, R3.metallicFactor, R3.roughnessFactor, S3, v3, o3, [0, 0, 0], I3);
                        !p4 && (r4.hasTranslucentParts || i4.opacity < 1) && D3.draw(t3, s3.gl.TRIANGLES, f3, Mi.disabled, Ai.disabled, Fi.backCCW, A3, o3.id, d4.vertexBuffer, d4.indexBuffer, d4.segments, o3.paint, t3.transform.zoom, void 0, w3), D3.draw(t3, s3.gl.TRIANGLES, p4 ? g3 : f3, Mi.disabled, p4 || i4.opacity < 1 || r4.hasTranslucentParts ? Ai.alphaBlended : Ai.unblended, Fi.backCCW, A3, o3.id, d4.vertexBuffer, d4.indexBuffer, d4.segments, o3.paint, t3.transform.zoom, void 0, w3);
                      }
                    }
                  }
                }();
              }(t2, i2, o2, r2), void c2();
            if ("model" !== h2.type)
              return;
            const u2 = h2.getModels(), d2 = [], _2 = t2.transform.getFreeCameraOptions().position, p2 = e.a6.vec3.scale([], [_2.x, _2.y, _2.z], t2.transform.worldSize);
            e.a6.vec3.negate(p2, p2);
            const m2 = [], f2 = [];
            let g2 = 0;
            for (const i3 of u2) {
              const r3 = o2.paint.get("model-rotation").constantOr(null), s3 = o2.paint.get("model-scale").constantOr(null), a3 = o2.paint.get("model-translation").constantOr(null);
              i3.computeModelMatrix(t2, r3, s3, a3, true, true, false);
              const n3 = e.a6.mat4.identity([]), l3 = e.de(i3.position.lat, t2.transform.zoom), c3 = e.a6.mat4.fromScaling([], [1, 1, 1 / l3]);
              e.a6.mat4.translate(n3, n3, p2), d2.push({ zScaleMatrix: c3, negCameraPosMatrix: n3 });
              for (const e2 of i3.nodes)
                na(t2.transform, e2, i3.matrix, t2.transform.expandedFarZProjMatrix, g2, m2, f2);
              g2++;
            }
            if (m2.sort((e2, t3) => t3.depth - e2.depth), "shadow" !== t2.renderPass) {
              if (1 === s2)
                for (const e2 of f2)
                  aa(e2, t2, o2, d2[e2.modelIndex], Mi.disabled, t2.colorModeForRenderPass());
              else {
                for (const e2 of f2)
                  aa(e2, t2, o2, d2[e2.modelIndex], Mi.disabled, Ai.disabled);
                for (const e2 of f2)
                  aa(e2, t2, o2, d2[e2.modelIndex], t2.stencilModeFor3D(), t2.colorModeForRenderPass());
                t2.resetStencilClippingMasks();
              }
              for (const e2 of m2)
                aa(e2, t2, o2, d2[e2.modelIndex], Mi.disabled, t2.colorModeForRenderPass());
              c2();
            } else {
              for (const e2 of f2)
                la(e2.mesh, e2.nodeModelMatrix, t2, o2);
              for (const e2 of m2)
                la(e2.mesh, e2.nodeModelMatrix, t2, o2);
              c2();
            }
          } }, ba = { model: function(e2, t2, i2) {
            const o2 = t2.getSource();
            if (!o2.loaded())
              return;
            if ("vector" === o2.type || "geojson" === o2.type)
              return void (i2.modelManager && i2.modelManager.upload(i2, "vector" === o2.type ? e2.scope : ""));
            if ("batched-model" === o2.type)
              return;
            if ("model" !== o2.type)
              return;
            const r2 = o2.getModels();
            for (const e3 of r2)
              e3.upload(i2.context);
          }, raster: function(e2, t2, i2) {
            const o2 = t2.getSource();
            if (!(o2 instanceof Qe && o2.loaded()))
              return;
            const r2 = e2.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
            if (!r2)
              return;
            const s2 = e2.paint.get("raster-array-band") || o2.getInitialBand(r2);
            if (null == s2)
              return;
            const a2 = t2.getIds().map((e3) => t2.getTileByID(e3));
            for (const e3 of a2)
              e3.updateNeeded(r2, s2) && o2.prepareTile(e3, r2, s2);
          }, "raster-particle": function(e2, t2, i2) {
            const o2 = t2.getSource();
            if (!(o2 instanceof Qe && o2.loaded()))
              return;
            const r2 = e2.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
            if (!r2)
              return;
            const s2 = e2.paint.get("raster-particle-array-band") || o2.getInitialBand(r2);
            if (null == s2)
              return;
            const a2 = t2.getIds().map((e3) => t2.getTileByID(e3));
            for (const e3 of a2)
              e3.updateNeeded(r2, s2) && o2.prepareTile(e3, r2, s2);
          } };
          class wa {
            constructor(t2, i2, o2, r2) {
              this.context = new ps(t2, i2), this.transform = o2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r2, this._timeStamp = e.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
              const s2 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
              for (const e2 of s2)
                this._debugParams.enabledLayers[e2] = true;
              r2.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
                this.style.map.triggerRepaint();
              }), r2.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), r2.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: true, label: "continuous redraw" }), r2.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "value" }), r2.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "graph", view: "graph", min: 0, max: 200 });
              for (const e2 of s2)
                r2.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], e2);
              this.occlusionParams = new xa(r2), this.setup(), this.numSublayers = vt.maxUnderzooming + vt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e.dl(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new Ki(this), this._wireframeDebugCache = new va(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true, this.layersWithOcclusionOpacity = [];
              const a2 = new e.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
              this.emptyDepthTexture = new e.T(this.context, a2, t2.RGBA8), this._clippingActiveLastFrame = false;
            }
            updateTerrain(e2, t2) {
              const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
              if (!(i2 || this._terrain && this._terrain.enabled))
                return;
              this._terrain || (this._terrain = new Ar(this, e2));
              const o2 = this._terrain;
              this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2), this.transform.elevation && !o2.enabled && (this.transform.elevation = null);
            }
            _updateFog(e2) {
              const t2 = e2.fog;
              if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
                return void (this.transform.fogCullDistSq = null);
              const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
              if (i2 > o2)
                return void (this.transform.fogCullDistSq = null);
              const r2 = i2 + 0.78 * (o2 - i2);
              this.transform.fogCullDistSq = r2 * r2;
            }
            get terrain() {
              return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
            }
            get forceTerrainMode() {
              return this._forceTerrainMode;
            }
            set forceTerrainMode(e2) {
              e2 && !this._terrain && (this._terrain = new Ar(this, this.style)), this._forceTerrainMode = e2;
            }
            get shadowRenderer() {
              return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
            }
            get wireframeDebugCache() {
              return this._wireframeDebugCache;
            }
            resize(t2, i2) {
              if (this.width = t2 * e.q.devicePixelRatio, this.height = i2 * e.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const e2 of this.style.order)
                  this.style._mergedLayers[e2].resize();
            }
            setup() {
              const t2 = this.context, i2 = new e.a_();
              i2.emplaceBack(0, 0), i2.emplaceBack(e.ab, 0), i2.emplaceBack(0, e.ab), i2.emplaceBack(e.ab, e.ab), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.b0.members), this.tileExtentSegments = e.b1.simpleSegment(0, 0, 4, 2);
              const o2 = new e.a_();
              o2.emplaceBack(0, 0), o2.emplaceBack(e.ab, 0), o2.emplaceBack(0, e.ab), o2.emplaceBack(e.ab, e.ab), this.debugBuffer = t2.createVertexBuffer(o2, e.b0.members), this.debugSegments = e.b1.simpleSegment(0, 0, 4, 5);
              const r2 = new e.a_();
              r2.emplaceBack(-1, -1), r2.emplaceBack(1, -1), r2.emplaceBack(-1, 1), r2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(r2, e.b0.members), this.viewportSegments = e.b1.simpleSegment(0, 0, 4, 2);
              const s2 = new e.aN();
              s2.emplaceBack(0, 0, 0, 0), s2.emplaceBack(e.ab, 0, e.ab, 0), s2.emplaceBack(0, e.ab, 0, e.ab), s2.emplaceBack(e.ab, e.ab, e.ab, e.ab), this.mercatorBoundsBuffer = t2.createVertexBuffer(s2, e.b3.members), this.mercatorBoundsSegments = e.b1.simpleSegment(0, 0, 4, 2);
              const a2 = new e.aO();
              a2.emplaceBack(0, 1, 2), a2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(a2);
              const n2 = new e.a$();
              for (const e2 of [0, 1, 3, 2, 0])
                n2.emplaceBack(e2);
              this.debugIndexBuffer = t2.createIndexBuffer(n2), this.emptyTexture = new e.T(t2, new e.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA8), this.identityMat = e.a6.mat4.create();
              const l2 = this.context.gl;
              this.stencilClearMode = new Mi({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(performance.now());
            }
            getMercatorTileBoundsBuffers() {
              return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
            }
            getTileBoundsBuffers(e2) {
              return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
              const e2 = this.context.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e2.TRIANGLES, Li.disabled, this.stencilClearMode, Ai.disabled, Fi.disabled, Cr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
              this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(e2, t2, i2) {
              if (!t2 || this.currentStencilSource === t2.id || !e2.isTileClipped() || !i2 || 0 === i2.length)
                return;
              if (this._tileClippingMaskIDs && !this.terrain) {
                let e3 = false;
                for (const t3 of i2)
                  if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                    e3 = true;
                    break;
                  }
                if (!e3)
                  return;
              }
              this.currentStencilSource = t2.id;
              const o2 = this.context, r2 = o2.gl;
              this.nextStencilID + i2.length > 256 && this.clearStencil(), o2.setColorMode(Ai.disabled), o2.setDepthMode(Li.disabled);
              const s2 = this.getOrCreateProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const e3 of i2) {
                const i3 = t2.getTile(e3), o3 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++, { tileBoundsBuffer: a2, tileBoundsIndexBuffer: n2, tileBoundsSegments: l2 } = this.getTileBoundsBuffers(i3);
                s2.draw(this, r2.TRIANGLES, Li.disabled, new Mi({ func: r2.ALWAYS, mask: 0 }, o3, 255, r2.KEEP, r2.KEEP, r2.REPLACE), Ai.disabled, Fi.disabled, Cr(e3.projMatrix), "$clipping", a2, n2, l2);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const e2 = this.nextStencilID++, t2 = this.context.gl;
              return new Mi({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
            }
            stencilModeForClipping(e2) {
              if (this.terrain)
                return this.terrain.stencilModeForRTTOverlap(e2);
              const t2 = this.context.gl;
              return new Mi({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
            }
            stencilConfigForOverlap(e2) {
              const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, r2 = i2[0].overscaledZ - o2 + 1;
              if (r2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + r2 > 256 && this.clearStencil();
                const e3 = {};
                for (let i3 = 0; i3 < r2; i3++)
                  e3[i3 + o2] = new Mi({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
                return this.nextStencilID += r2, [e3, i2];
              }
              return [{ [o2]: Mi.disabled }, i2];
            }
            colorModeForRenderPass() {
              const t2 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new Ai([t2.CONSTANT_COLOR, t2.ONE, t2.CONSTANT_COLOR, t2.ONE], new e.bz(i2, i2, i2, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? Ai.unblended : Ai.alphaBlended;
            }
            colorModeForDrapableLayerRenderPass(t2) {
              const i2 = this.context.gl;
              return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new Ai([i2.ONE, i2.ONE_MINUS_SRC_ALPHA, i2.CONSTANT_ALPHA, i2.ONE_MINUS_SRC_ALPHA], new e.bz(0, 0, 0, void 0 === t2 ? 0 : t2), [true, true, true, true]) : this.colorModeForRenderPass();
            }
            depthModeForSublayer(e2, t2, i2, o2 = false) {
              if (this.depthOcclusion)
                return new Li(this.context.gl.GREATER, Li.ReadOnly, this.depthRangeFor3D);
              if (!this.opaquePassEnabledForLayer() && !o2)
                return Li.disabled;
              const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
              return new Li(i2 || this.context.gl.LEQUAL, t2, [r2, r2]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            blitDepth() {
              const t2 = this.context.gl, i2 = Math.ceil(this.width), o2 = Math.ceil(this.height), r2 = this.context.bindFramebuffer.get(), s2 = t2.getParameter(t2.TEXTURE_BINDING_2D);
              this.depthFBO && this.depthFBO.width === i2 && this.depthFBO.height === o2 || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i2 && 0 !== o2 && (this.depthFBO = new _s(this.context, i2, o2, false, "texture"), this.depthTexture = new e.T(this.context, { width: i2, height: o2, data: null }, t2.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(r2), t2.bindTexture(t2.TEXTURE_2D, s2), this.depthFBO && (t2.bindFramebuffer(t2.READ_FRAMEBUFFER, null), t2.bindFramebuffer(t2.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t2.blitFramebuffer(0, 0, i2, o2, 0, 0, i2, o2, t2.DEPTH_BUFFER_BIT, t2.NEAREST), t2.bindFramebuffer(t2.FRAMEBUFFER, this.context.bindFramebuffer.current));
            }
            updateAverageFPS() {
              this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e2, t2) => e2 + t2 / this._fpsHistory.length, 0));
            }
            render(t2, i2) {
              const o2 = e.q.now();
              this._dt = o2 - this._timeStamp, this._timeStamp = o2, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t2.map.repaint, this.style = t2, this.options = i2;
              const r2 = this.style._mergedLayers, s2 = this.style.order.filter((e2) => {
                const t3 = r2[e2];
                return !(t3.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t3.type];
              });
              let a2 = false, n2 = false;
              for (const e2 of s2) {
                const t3 = r2[e2];
                "circle" === t3.type && (a2 = true), "symbol" === t3.type && (t3.hasInitialOcclusionOpacityProperties ? n2 = true : a2 = true);
              }
              const l2 = s2.map((e2) => r2[e2]), c2 = this.style._mergedSourceCaches;
              this.imageManager = t2.imageManager, this.modelManager = t2.modelManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.q.now()), this.imageManager.beginFrame();
              let h2 = 0, u2 = false;
              for (const e2 in c2) {
                const t3 = c2[e2];
                t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++h2);
              }
              let d2 = false;
              for (const e2 of l2)
                e2.isHidden(this.transform.zoom) || ("clip" === e2.type && (d2 = true), this.prepareLayer(e2));
              const _2 = {}, p2 = {}, m2 = {}, f2 = {}, g2 = {};
              for (const e2 in c2) {
                const t3 = c2[e2];
                _2[e2] = t3.getVisibleCoordinates(), p2[e2] = _2[e2].slice().reverse(), m2[e2] = t3.getVisibleCoordinates(true).reverse(), f2[e2] = t3.getShadowCasterCoordinates(), g2[e2] = t3.sortCoordinatesByDistance(_2[e2]);
              }
              const v2 = (e2) => {
                const t3 = this.style.getLayerSourceCache(e2);
                return t3 && t3.used ? t3.getSource() : null;
              };
              if (h2 || d2 || this._clippingActiveLastFrame) {
                const t3 = [], i3 = [];
                let o3 = 0;
                for (const e2 of l2)
                  this.isSourceForClippingOrConflation(e2, v2(e2)) && (t3.push(e2), i3.push(o3)), o3++;
                if (t3 && (d2 || t3.length > 1) || this._clippingActiveLastFrame) {
                  d2 = false;
                  const o4 = [];
                  for (let r3 = 0; r3 < t3.length; r3++) {
                    const s3 = t3[r3], a3 = i3[r3], n3 = this.style.getLayerSourceCache(s3);
                    if (!n3 || !n3.used || !n3.getSource().usedInConflation && "clip" !== s3.type)
                      continue;
                    let l3 = e.dn, c3 = e.bs.None;
                    const h3 = [];
                    let u3 = true;
                    if ("clip" === s3.type) {
                      l3 = a3;
                      for (const t4 of s3.layout.get("clip-layer-types"))
                        c3 |= "model" === t4 ? e.bs.Model : "symbol" === t4 ? e.bs.Symbol : e.bs.FillExtrusion;
                      for (const e2 of s3.layout.get("clip-layer-scope"))
                        h3.push(e2);
                      s3.isHidden(this.transform.zoom) ? u3 = false : d2 = true;
                    }
                    u3 && o4.push({ layer: s3.fqid, cache: n3, order: l3, clipMask: c3, clipScope: h3 });
                  }
                  this.replacementSource.setSources(o4), u2 = true;
                }
              }
              this._clippingActiveLastFrame = d2, u2 || this.replacementSource.clear(), this.conflationActive = u2, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
              for (let e2 = 0; e2 < l2.length; e2++) {
                const t3 = l2[e2], i3 = t3.cutoffRange();
                if (this.longestCutoffRange = Math.max(i3, this.longestCutoffRange), i3 > 0) {
                  const e3 = v2(t3);
                  e3 && (this.minCutoffZoom = Math.max(e3.minzoom, this.minCutoffZoom)), t3.minzoom && (this.minCutoffZoom = Math.max(t3.minzoom, this.minCutoffZoom));
                }
                t3.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e2), this._lastOcclusionLayer = e2);
              }
              const x2 = this.style && this.style.fog;
              x2 ? (this._fogVisible = 0 !== x2.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = x2.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(m2), this.opaquePassCutoff = 0);
              const y2 = this._shadowRenderer;
              if (y2) {
                y2.updateShadowParameters(this.transform, this.style.directionalLight);
                for (const e2 in c2)
                  for (const t3 of _2[e2]) {
                    let e3 = { min: 0, max: 0 };
                    this.terrain && (e3 = this.terrain.getMinMaxForTile(t3) || e3), y2.addShadowReceiver(t3.toUnwrapped(), e3.min, e3.max);
                  }
              }
              if ("globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.dm(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new oa(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !U.has(this.context.gl))
                return;
              this.renderPass = "offscreen";
              for (const e2 of l2) {
                const i3 = t2.getLayerSourceCache(e2);
                if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom))
                  continue;
                const o3 = i3 ? p2[i3.id] : void 0;
                ("custom" === e2.type || "raster" === e2.type || "raster-particle" === e2.type || e2.isSky() || o3 && o3.length) && this.renderLayer(this, i3, e2, o3);
              }
              this.depthRangeFor3D = [0, 1 - (l2.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, f2)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
              const b2 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), w2 = (() => {
                if (i2.showOverdrawInspector)
                  return e.bz.black;
                const t3 = this.style.fog;
                if (t3 && this.transform.projection.supportsFog) {
                  const i3 = this.style.getLut(t3.scope);
                  if (!b2) {
                    const o3 = t3.properties.get("color").toRenderColor(i3).toArray01();
                    return new e.bz(...o3);
                  }
                  if (b2) {
                    const o3 = t3.properties.get("space-color").toRenderColor(i3).toArray01();
                    return new e.bz(...o3);
                  }
                }
                return e.bz.transparent;
              })();
              if (this.context.clear({ color: w2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && b2 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
                for (this.currentLayer = s2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const e2 = l2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
                  if (e2.isSky())
                    continue;
                  const o3 = i3 ? (e2.is3D() ? g2 : p2)[i3.id] : void 0;
                  this._renderTileClippingMasks(e2, i3, o3), this.renderLayer(this, i3, e2, o3);
                }
              if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && b2 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.a9(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible()))
                for (this.currentLayer = 0; this.currentLayer < s2.length; this.currentLayer++) {
                  const e2 = l2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
                  e2.isSky() && this.renderLayer(this, i3, e2, i3 ? p2[i3.id] : void 0);
                }
              function T2(e2, t3) {
                let i3;
                return t3 && (i3 = ("symbol" === e2.type ? m2 : e2.is3D() ? g2 : p2)[t3.id]), i3;
              }
              if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
                for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < s2.length; ) {
                  const e2 = l2[this.currentLayer];
                  if ("raster" === e2.type || "raster-particle" === e2.type) {
                    const i3 = t2.getLayerSourceCache(e2);
                    this.renderLayer(this, i3, e2, T2(e2, i3));
                  }
                  ++this.currentLayer;
                }
                this.renderElevatedRasterBackface = false;
              }
              this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
              let E2 = 0;
              y2 && (E2 = y2.getShadowCastingLayerCount());
              let C2 = false, S2 = -1;
              for (let e2 = 0; e2 < s2.length; ++e2) {
                const t3 = l2[e2];
                t3.isHidden(this.transform.zoom) || t3.is3D() && (S2 = e2);
              }
              for (n2 && -1 === S2 && (a2 = true); this.currentLayer < s2.length; ) {
                const e2 = l2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
                if (e2.isSky())
                  ++this.currentLayer;
                else if (this.terrain && this.style.isLayerDraped(e2)) {
                  if (e2.isHidden(this.transform.zoom)) {
                    ++this.currentLayer;
                    continue;
                  }
                  this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                } else {
                  if (a2 && !C2 && this.terrain && !this.transform.isOrthographic && (C2 = true, this.blitDepth()), n2 && -1 !== S2 && this.currentLayer === S2 + 1 && !this.transform.isOrthographic && this.blitDepth(), e2.is3D() || this.terrain || this._renderTileClippingMasks(e2, i3, i3 ? _2[i3.id] : void 0), this.renderLayer(this, i3, e2, T2(e2, i3)), !this.terrain && y2 && E2 > 0 && e2.hasShadowPass() && 0 == --E2 && (y2.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                    const e3 = this.currentLayer;
                    for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e3; this.currentLayer++) {
                      const e4 = l2[this.currentLayer];
                      if (!e4.hasLightBeamPass())
                        continue;
                      const i4 = t2.getLayerSourceCache(e4);
                      this.renderLayer(this, i4, e4, i4 ? p2[i4.id] : void 0);
                    }
                    this.currentLayer = e3, this.renderPass = "translucent";
                  }
                  if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                    const e3 = this.currentLayer;
                    this.depthOcclusion = true;
                    for (const e4 of this.layersWithOcclusionOpacity) {
                      this.currentLayer = e4;
                      const i4 = l2[this.currentLayer], o3 = t2.getLayerSourceCache(i4), r3 = o3 ? p2[o3.id] : void 0;
                      i4.is3D() || this.terrain || this._renderTileClippingMasks(i4, o3, o3 ? _2[o3.id] : void 0), this.renderLayer(this, o3, i4, r3);
                    }
                    this.depthOcclusion = false, this.currentLayer = e3, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                  }
                  ++this.currentLayer;
                }
              }
              if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                let i3 = null;
                l2.forEach((e2) => {
                  const o3 = t2.getLayerSourceCache(e2);
                  o3 && !e2.isHidden(this.transform.zoom) && o3.getVisibleCoordinates().length && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
                }), i3 && this.options.showTileBoundaries && ya.debug(this, i3, i3.getVisibleCoordinates(), e.bz.red, false, this.options.showParseStatus);
              }
              this.terrain && this._debugParams.showTerrainProxyTiles && ya.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.bz(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e2) {
                const t3 = e2.transform.padding;
                Zs(e2, e2.transform.height - (t3.top || 0), 3, Ns), Zs(e2, t3.bottom || 0, 3, Us), Hs(e2, t3.left || 0, 3, Gs), Hs(e2, e2.transform.width - (t3.right || 0), 3, js);
                const i3 = e2.transform.centerPoint;
                !function(e3, t4, i4, o3) {
                  Ws(e3, t4 - 1, i4 - 10, 2, 20, o3), Ws(e3, t4 - 10, i4 - 1, 20, 2, o3);
                }(e2, i3.x, e2.transform.height - i3.y, Vs);
              }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), u2 || (this.conflationActive = false);
            }
            prepareLayer(e2) {
              this.gpuTimingStart(e2);
              const { unsupportedLayers: t2 } = this.transform.projection, i2 = !t2 || !t2.includes(e2.type);
              if (ba[e2.type] && (i2 || this.terrain && "custom" === e2.type)) {
                const t3 = this.style.getLayerSourceCache(e2);
                ba[e2.type](e2, t3, this);
              }
              this.gpuTimingEnd();
            }
            renderLayer(e2, t2, i2, o2) {
              i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || "model" === i2.type || "raster" === i2.type || "raster-particle" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), e2.transform.projection.unsupportedLayers && e2.transform.projection.unsupportedLayers.includes(i2.type) && (!e2.terrain || "custom" !== i2.type) || "clip" === i2.type || ya[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e2) {
              if (!this.options.gpuTiming)
                return;
              const t2 = this.context.extTimerQuery, i2 = this.context.gl;
              let o2 = this.gpuTimers[e2.id];
              o2 || (o2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: i2.createQuery() }), o2.calls++, i2.beginQuery(t2.TIME_ELAPSED_EXT, o2.query);
            }
            gpuTimingDeferredRenderStart() {
              if (this.options.gpuTimingDeferredRender) {
                const e2 = this.context.extTimerQuery, t2 = this.context.gl, i2 = t2.createQuery();
                this.deferredRenderGpuTimeQueries.push(i2), t2.beginQuery(e2.TIME_ELAPSED_EXT, i2);
              }
            }
            gpuTimingDeferredRenderEnd() {
              this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
              this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
              const e2 = this.gpuTimers;
              return this.gpuTimers = {}, e2;
            }
            collectDeferredRenderGpuQueries() {
              const e2 = this.deferredRenderGpuTimeQueries;
              return this.deferredRenderGpuTimeQueries = [], e2;
            }
            queryGpuTimers(e2) {
              const t2 = {};
              for (const i2 in e2) {
                const o2 = e2[i2], r2 = this.context.extTimerQuery, s2 = r2.getQueryParameter(o2.query, this.context.gl.QUERY_RESULT) / 1e6;
                r2.deleteQueryEXT(o2.query), t2[i2] = s2;
              }
              return t2;
            }
            queryGpuTimeDeferredRender(e2) {
              if (!this.options.gpuTimingDeferredRender)
                return 0;
              const t2 = this.context.extTimerQuery, i2 = this.context.gl;
              let o2 = 0;
              for (const r2 of e2)
                o2 += t2.getQueryParameter(r2, i2.QUERY_RESULT) / 1e6, t2.deleteQueryEXT(r2);
              return o2;
            }
            translatePosMatrix(t2, i2, o2, r2, s2) {
              if (!o2[0] && !o2[1])
                return t2;
              const a2 = s2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
              if (a2) {
                const e2 = Math.sin(a2), t3 = Math.cos(a2);
                o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
              }
              const n2 = [s2 ? o2[0] : e.ak(i2, o2[0], this.transform.zoom), s2 ? o2[1] : e.ak(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return e.a6.mat4.translate(l2, t2, n2), l2;
            }
            saveTileTexture(e2) {
              const t2 = e2.size[0], i2 = this._tileTextures[t2];
              i2 ? i2.push(e2) : this._tileTextures[t2] = [e2];
            }
            getTileTexture(e2) {
              const t2 = this._tileTextures[e2];
              return t2 && t2.length > 0 ? t2.pop() : null;
            }
            terrainRenderModeElevated() {
              return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
            }
            linearFloatFilteringSupported() {
              return null != this.context.extTextureFloatLinear;
            }
            currentGlobalDefines(e2, t2, i2) {
              const o2 = void 0 === i2 ? this.terrain && this.terrain.renderingToTexture : i2, r2 = [];
              return this.style && this.style.enable3dLights() && ("globeRaster" === e2 || "terrainRaster" === e2 ? (r2.push("LIGHTING_3D_MODE"), r2.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o2 || r2.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || r2.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? r2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : r2.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (r2.push("TERRAIN"), this.linearFloatFilteringSupported() && r2.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && r2.push("GLOBE"), !this._fogVisible || o2 || void 0 !== t2 && !t2 || r2.push("FOG", "FOG_DITHERING"), o2 && r2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && r2.push("OVERDRAW_INSPECTOR"), r2;
            }
            getOrCreateProgram(e2, t2) {
              this.cache = this.cache || {};
              const i2 = t2 && t2.defines || [], o2 = t2 && t2.config, r2 = this.currentGlobalDefines(e2, t2 && t2.overrideFog, t2 && t2.overrideRtt).concat(i2), s2 = zr.cacheKey(Io[e2], e2, r2, o2);
              return this.cache[s2] || (this.cache[s2] = new zr(this.context, e2, Io[e2], o2, cs[e2], r2)), this.cache[s2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const e2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
            }
            destroy() {
              this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
            }
            prepareDrawTile() {
              this.terrain && this.terrain.prepareDrawTile();
            }
            uploadCommonLightUniforms(t2, i2) {
              if (this.style.enable3dLights()) {
                const o2 = this.style.directionalLight, r2 = this.style.ambientLight;
                if (o2 && r2) {
                  const s2 = ((t3, i3, o3) => {
                    const r3 = t3.properties.get("direction"), s3 = t3.properties.get("color").toRenderColor(o3.getLut(t3.scope)).toArray01(), a2 = t3.properties.get("intensity"), n2 = i3.properties.get("color").toRenderColor(o3.getLut(i3.scope)).toArray01(), l2 = i3.properties.get("intensity"), c2 = [r3.x, r3.y, r3.z], h2 = e.cH(n2, l2), u2 = e.cH(s3, a2);
                    return { u_lighting_ambient_color: h2, u_lighting_directional_dir: c2, u_lighting_directional_color: u2, u_ground_radiance: Lr(c2, u2, h2) };
                  })(o2, r2, this.style);
                  i2.setLightsUniformValues(t2, s2);
                }
              }
            }
            uploadCommonUniforms(t2, i2, o2, r2, s2) {
              if (this.uploadCommonLightUniforms(t2, i2), this.terrain && this.terrain.renderingToTexture)
                return;
              const a2 = this.style.fog;
              if (a2) {
                const s3 = a2.getOpacity(this.transform.pitch), n2 = ((t3, i3, o3, r3, s4, a3, n3, l2, c2, h2, u2, d2) => {
                  const _2 = t3.transform, p2 = i3.properties.get("color").toRenderColor(t3.style.getLut(i3.scope)).toArray01();
                  p2[3] = r3;
                  const m2 = t3.frameCounter / 1e3 % 1, [f2, g2] = i3.properties.get("vertical-range");
                  return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : d2 || t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: p2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(f2, g2), g2], u_fog_temporal_offset: m2, u_frustum_tl: s4, u_frustum_tr: a3, u_frustum_br: n3, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h2, u_viewport: u2, u_globe_transition: e.a9(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
                })(this, a2, o2, s3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.q.devicePixelRatio, this.transform.height * e.q.devicePixelRatio], r2);
                i2.setFogUniformValues(t2, n2);
              }
              s2 && i2.setCutoffUniformValues(t2, s2.uniformValues);
            }
            setTileLoadedFlag(e2) {
              this.tileLoaded = e2;
            }
            saveCanvasCopy() {
              const e2 = this.canvasCopy();
              e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
            }
            canvasCopy() {
              const e2 = this.context.gl, t2 = e2.createTexture();
              return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
            }
            getCanvasCopiesAndTimestamps() {
              return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
            }
            averageElevationNeedsEasing() {
              if (!this.transform._elevation)
                return false;
              const e2 = this.style && this.style.fog;
              return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
              const e2 = this._backgroundTiles, t2 = this._backgroundTiles = {}, i2 = this.transform.coveringTiles({ tileSize: 512 });
              for (const o2 of i2)
                t2[o2.key] = e2[o2.key] || new pt(o2, 512, this.transform.tileZoom, this);
              return t2;
            }
            clearBackgroundTiles() {
              this._backgroundTiles = {};
            }
            isSourceForClippingOrConflation(e2, t2) {
              return !(!e2.is3D() || "clip" !== e2.type && (e2.minzoom && e2.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e2.sourceLayer) && (!t2 || "batched-model" !== t2.type)));
            }
            isTileAffectedByFog(e2) {
              if (!this.style || !this.style.fog)
                return false;
              if ("globe" === this.transform.projection.name)
                return true;
              let t2 = this._cachedTileFogOpacities[e2.key];
              return t2 || (this._cachedTileFogOpacities[e2.key] = t2 = this.style.fog.getOpacityForTile(e2)), t2[0] >= Oe || t2[1] >= Oe;
            }
            setupDepthForOcclusion(e2, t2, i2) {
              const o2 = this.context, r2 = o2.gl, s2 = !!i2;
              var a2;
              i2 || (i2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), o2.activeTexture.set(r2.TEXTURE3), e2 && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(r2.NEAREST, r2.CLAMP_TO_EDGE), i2.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i2.u_depth_range_unpack = [2 / ((a2 = this.depthRangeFor3D)[1] - a2[0]), -1 - 2 * a2[0] / (a2[1] - a2[0])], i2.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, i2.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(r2.NEAREST, r2.CLAMP_TO_EDGE), o2.activeTexture.set(r2.TEXTURE0), s2 || t2.setTerrainUniformValues(o2, i2);
            }
          }
          function Ta(e2, t2) {
            let i2 = false, o2 = null;
            const r2 = () => {
              o2 = null, i2 && (e2(), o2 = setTimeout(r2, t2), i2 = false);
            };
            return () => (i2 = true, o2 || r2(), o2);
          }
          class Ea {
            constructor(t2) {
              this._hashName = t2 && encodeURIComponent(t2), e.aJ(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Ta(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e2) {
              return this._map = e2, window.addEventListener("hashchange", this._onHashChange, false), e2.on("moveend", this._updateHash), this;
            }
            remove() {
              return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
              const e2 = this._map;
              if (!e2)
                return "";
              const t2 = Ca(e2);
              if (this._hashName) {
                const e3 = this._hashName;
                let i2 = false;
                const o2 = location.hash.slice(1).split("&").map((o3) => {
                  const r2 = o3.split("=")[0];
                  return r2 === e3 ? (i2 = true, `${r2}=${t2}`) : o3;
                }).filter((e4) => e4);
                return i2 || o2.push(`${e3}=${t2}`), `#${o2.join("&")}`;
              }
              return `#${t2}`;
            }
            _getCurrentHash() {
              const e2 = location.hash.replace("#", "");
              if (this._hashName) {
                let t2;
                return e2.split("&").map((e3) => e3.split("=")).forEach((e3) => {
                  e3[0] === this._hashName && (t2 = e3);
                }), (t2 && t2[1] || "").split("/");
              }
              return e2.split("/");
            }
            _onHashChange() {
              const e2 = this._map;
              if (!e2)
                return false;
              const t2 = this._getCurrentHash();
              if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
                const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
                return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
              }
              return false;
            }
            _updateHashUnthrottled() {
              history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
            }
          }
          function Ca(e2, t2) {
            const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s2 = Math.pow(10, r2), a2 = Math.round(i2.lng * s2) / s2, n2 = Math.round(i2.lat * s2) / s2, l2 = e2.getBearing(), c2 = e2.getPitch();
            let h2 = t2 ? `/${a2}/${n2}/${o2}` : `${o2}/${n2}/${a2}`;
            return (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), h2;
          }
          const Sa = { linearity: 0.3, easing: e.dp(0, 0, 0.3, 1) }, Ia = e.l({ deceleration: 2500, maxSpeed: 1400 }, Sa), Da = e.l({ deceleration: 20, maxSpeed: 1400 }, Sa), Ra = e.l({ deceleration: 1e3, maxSpeed: 360 }, Sa), Aa = e.l({ deceleration: 1e3, maxSpeed: 90 }, Sa);
          class La {
            constructor(e2) {
              this._map = e2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(t2) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.q.now(), settings: t2 });
            }
            _drainInertiaBuffer() {
              const t2 = this._inertiaBuffer, i2 = e.q.now();
              for (; t2.length > 0 && i2 - t2[0].time > 160; )
                t2.shift();
            }
            _onMoveEnd(t2) {
              if (this._map._prefersReducedMotion())
                return;
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: e2 } of this._inertiaBuffer)
                i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
              const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
              if (i2.pan.mag()) {
                const s2 = Ma(i2.pan.mag(), o2, e.l({}, Ia, t2 || {}));
                r2.offset = i2.pan.mult(s2.amount / i2.pan.mag()), r2.center = this._map.transform.center, Pa(r2, s2);
              }
              if (i2.zoom) {
                const e2 = Ma(i2.zoom, o2, Da);
                r2.zoom = this._map.transform.zoom + e2.amount, Pa(r2, e2);
              }
              if (i2.bearing) {
                const t3 = Ma(i2.bearing, o2, Ra);
                r2.bearing = this._map.transform.bearing + e.ap(t3.amount, -179, 179), Pa(r2, t3);
              }
              if (i2.pitch) {
                const e2 = Ma(i2.pitch, o2, Aa);
                r2.pitch = this._map.transform.pitch + e2.amount, Pa(r2, e2);
              }
              if (r2.zoom || r2.bearing) {
                const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
                r2.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
              }
              return this.clear(), r2.noMoveStart = true, r2;
            }
          }
          function Pa(e2, t2) {
            (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
          }
          function Ma(t2, i2, o2) {
            const { maxSpeed: r2, linearity: s2, deceleration: a2 } = o2, n2 = e.ap(t2 * s2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(n2) / (a2 * s2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
          }
          class za extends e.x {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, i2, o2, r2 = {}) {
              const s2 = g(i2.getCanvasContainer(), o2), a2 = i2.unproject(s2);
              super(t2, e.l({ point: s2, lngLat: a2, originalEvent: o2 }, r2)), this._defaultPrevented = false, this.target = i2;
            }
          }
          class Oa extends e.x {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, i2, o2) {
              const r2 = "touchend" === t2 ? o2.changedTouches : o2.touches, s2 = v(i2.getCanvasContainer(), r2), a2 = s2.map((e2) => i2.unproject(e2)), n2 = s2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.P(0, 0));
              super(t2, { points: s2, point: n2, lngLats: a2, lngLat: i2.unproject(n2), originalEvent: o2 }), this._defaultPrevented = false;
            }
          }
          class Fa extends e.x {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, t2) {
              super("wheel", { originalEvent: t2 }), this._defaultPrevented = false;
            }
          }
          class ka {
            constructor(e2, t2) {
              this._map = e2, this._clickTolerance = t2.clickTolerance;
            }
            reset() {
              this._mousedownPos = void 0;
            }
            wheel(e2) {
              return this._firePreventable(new Fa(this._map, e2));
            }
            mousedown(e2, t2) {
              return this._mousedownPos = t2, this._firePreventable(new za(e2.type, this._map, e2));
            }
            mouseup(e2) {
              this._map.fire(new za(e2.type, this._map, e2));
            }
            preclick(t2) {
              const i2 = e.l({}, t2);
              i2.type = "preclick", this._map.fire(new za(i2.type, this._map, i2));
            }
            click(e2, t2) {
              this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new za(e2.type, this._map, e2)));
            }
            dblclick(e2) {
              return this._firePreventable(new za(e2.type, this._map, e2));
            }
            mouseover(e2) {
              this._map.fire(new za(e2.type, this._map, e2));
            }
            mouseout(e2) {
              this._map.fire(new za(e2.type, this._map, e2));
            }
            touchstart(e2) {
              return this._firePreventable(new Oa(e2.type, this._map, e2));
            }
            touchmove(e2) {
              this._map.fire(new Oa(e2.type, this._map, e2));
            }
            touchend(e2) {
              this._map.fire(new Oa(e2.type, this._map, e2));
            }
            touchcancel(e2) {
              this._map.fire(new Oa(e2.type, this._map, e2));
            }
            _firePreventable(e2) {
              if (this._map.fire(e2), e2.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Ba {
            constructor(e2) {
              this._map = e2;
            }
            reset() {
              this._delayContextMenu = false, this._contextMenuEvent = void 0;
            }
            mousemove(e2) {
              this._map.fire(new za(e2.type, this._map, e2));
            }
            mousedown() {
              this._delayContextMenu = true;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new za("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e2) {
              this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new za(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Na {
            constructor(e2, t2) {
              this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(e2, t2) {
              this.isEnabled() && e2.shiftKey && 0 === e2.button && (_(), this._startPos = this._lastPos = t2, this._active = true);
            }
            mousemoveWindow(e2, t2) {
              if (!this._active)
                return;
              const i2 = t2, o2 = this._startPos, r2 = this._lastPos;
              if (!o2 || !r2 || r2.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance)
                return;
              this._lastPos = i2, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
              const s2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), n2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
              this._map._requestDomTask(() => {
                this._box && (this._box.style.transform = `translate(${s2}px,${n2}px)`, this._box.style.width = a2 - s2 + "px", this._box.style.height = c2 - n2 + "px");
              });
            }
            mouseupWindow(t2, i2) {
              if (!this._active)
                return;
              const o2 = this._startPos, r2 = i2;
              if (o2 && 0 === t2.button) {
                if (this.reset(), f(), o2.x !== r2.x || o2.y !== r2.y)
                  return this._map.fire(new e.x("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r2, this._map.getBearing(), { linear: false }) };
                this._fireEvent("boxzoomcancel", t2);
              }
            }
            keydown(e2) {
              this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t2, i2) {
              return this._map.fire(new e.x(t2, { originalEvent: i2 }));
            }
          }
          function Ua(e2, t2) {
            const i2 = {};
            for (let o2 = 0; o2 < e2.length; o2++)
              i2[e2[o2].identifier] = t2[o2];
            return i2;
          }
          class Ga {
            constructor(e2) {
              this.reset(), this.numTouches = e2.numTouches;
            }
            reset() {
              this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
            }
            touchstart(t2, i2, o2) {
              (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
                const i3 = new e.P(0, 0);
                for (const e2 of t3)
                  i3._add(e2);
                return i3.div(t3.length);
              }(i2), this.touches = Ua(o2, i2)));
            }
            touchmove(e2, t2, i2) {
              if (this.aborted || !this.centroid)
                return;
              const o2 = Ua(i2, t2);
              for (const e3 in this.touches) {
                const t3 = o2[e3];
                (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
              }
            }
            touchend(e2, t2, i2) {
              if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
                const e3 = !this.aborted && this.centroid;
                if (this.reset(), e3)
                  return e3;
              }
            }
          }
          class ja {
            constructor(e2) {
              this.singleTap = new Ga(e2), this.numTaps = e2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e2, t2, i2) {
              this.singleTap.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this.singleTap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const o2 = this.singleTap.touchend(e2, t2, i2);
              if (o2) {
                const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
                if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                  return this.reset(), o2;
              }
            }
          }
          class Va {
            constructor() {
              this._zoomIn = new ja({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ja({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e2, t2, i2) {
              this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const o2 = this._zoomIn.touchend(e2, t2, i2), r2 = this._zoomOut.touchend(e2, t2, i2);
              return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r2) }, { originalEvent: e2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          const qa = { 0: 1, 2: 2 };
          class Za {
            constructor(e2) {
              this.reset(), this._clickTolerance = e2.clickTolerance || 1;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e2, t2) {
              return false;
            }
            _move(e2, t2) {
              return {};
            }
            mousedown(e2, t2) {
              if (this._lastPoint)
                return;
              const i2 = x(e2);
              this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
            }
            mousemoveWindow(e2, t2) {
              const i2 = this._lastPoint;
              if (i2) {
                if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
                  const i3 = qa[t3];
                  return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
                }(e2, this._eventButton))
                  this.reset();
                else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
                  return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
              }
            }
            mouseupWindow(e2) {
              this._lastPoint && x(e2) === this._eventButton && (this._moved && f(), this.reset());
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ha extends Za {
            mousedown(e2, t2) {
              super.mousedown(e2, t2), this._lastPoint && (this._active = true);
            }
            _correctButton(e2, t2) {
              return 0 === t2 && !e2.ctrlKey;
            }
            _move(e2, t2) {
              return { around: t2, panDelta: t2.sub(e2) };
            }
          }
          class Wa extends Za {
            _correctButton(e2, t2) {
              return 0 === t2 && e2.ctrlKey || 2 === t2;
            }
            _move(e2, t2) {
              const i2 = 0.8 * (t2.x - e2.x);
              if (i2)
                return this._active = true, { bearingDelta: i2 };
            }
            contextmenu(e2) {
              e2.preventDefault();
            }
          }
          class $a extends Za {
            _correctButton(e2, t2) {
              return 0 === t2 && e2.ctrlKey || 2 === t2;
            }
            _move(e2, t2) {
              const i2 = -0.5 * (t2.y - e2.y);
              if (i2)
                return this._active = true, { pitchDelta: i2 };
            }
            contextmenu(e2) {
              e2.preventDefault();
            }
          }
          class Xa {
            constructor(t2, i2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.aJ(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
            }
            touchstart(e2, t2, i2) {
              return this._calculateTransform(e2, t2, i2);
            }
            touchmove(t2, i2, o2) {
              if (this._active && !(o2.length < this._minTouches)) {
                if (this._map._cooperativeGestures && !this._map.isMoving()) {
                  if (1 === o2.length && !e.dq())
                    return void this._showTouchPanBlockerAlert();
                  "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
              }
            }
            touchend(e2, t2, i2) {
              this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(t2, i2, o2) {
              o2.length > 0 && (this._active = true);
              const r2 = Ua(o2, i2), s2 = new e.P(0, 0), a2 = new e.P(0, 0);
              let n2 = 0;
              for (const e2 in r2) {
                const t3 = r2[e2], i3 = this._touches[e2];
                i3 && (s2._add(t3), a2._add(t3.sub(i3)), n2++, r2[e2] = t3);
              }
              if (this._touches = r2, n2 < this._minTouches || !a2.mag())
                return;
              const l2 = a2.div(n2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: s2.div(n2), panDelta: l2 };
            }
            enable() {
              this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
              this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            _addTouchPanBlocker() {
              this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
              this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
                this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
              }, 500);
            }
          }
          class Ya {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, this._firstTwoTouches = void 0;
            }
            _start(e2) {
            }
            _move(e2, t2, i2) {
              return {};
            }
            touchstart(e2, t2, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
            }
            touchmove(e2, t2, i2) {
              const o2 = this._firstTwoTouches;
              if (!o2)
                return;
              e2.preventDefault();
              const [r2, s2] = o2, a2 = Ka(i2, t2, r2), n2 = Ka(i2, t2, s2);
              if (!a2 || !n2)
                return;
              const l2 = this._aroundCenter ? null : a2.add(n2).div(2);
              return this._move([a2, n2], l2, e2);
            }
            touchend(e2, t2, i2) {
              if (!this._firstTwoTouches)
                return;
              const [o2, r2] = this._firstTwoTouches, s2 = Ka(i2, t2, o2), a2 = Ka(i2, t2, r2);
              s2 && a2 || (this._active && f(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(e2) {
              this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Ka(e2, t2, i2) {
            for (let o2 = 0; o2 < e2.length; o2++)
              if (e2[o2].identifier === i2)
                return t2[o2];
          }
          function Ja(e2, t2) {
            return Math.log(e2 / t2) / Math.LN2;
          }
          class Qa extends Ya {
            reset() {
              super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e2) {
              this._startDistance = this._distance = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._distance;
              if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Ja(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Ja(this._distance, i2), pinchAround: t2 };
            }
          }
          function en(e2, t2) {
            return 180 * e2.angleWith(t2) / Math.PI;
          }
          class tn extends Ya {
            reset() {
              super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e2) {
              this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._vector;
              if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
                return this._active = true, { bearingDelta: en(this._vector, i2), pinchAround: t2 };
            }
            _isBelowThreshold(e2) {
              this._minDiameter = Math.min(this._minDiameter, e2.mag());
              const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
              if (!i2)
                return false;
              const o2 = en(e2, i2);
              return Math.abs(o2) < t2;
            }
          }
          function on(e2) {
            return Math.abs(e2.y) > Math.abs(e2.x);
          }
          class rn extends Ya {
            constructor(e2) {
              super(), this._map = e2;
            }
            reset() {
              super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e2) {
              this._lastPoints = e2, on(e2[0].sub(e2[1])) && (this._valid = false);
            }
            _move(t2, i2, o2) {
              const r2 = this._lastPoints;
              if (!r2)
                return;
              const s2 = t2[0].sub(r2[0]), a2 = t2[1].sub(r2[1]);
              return this._map._cooperativeGestures && !e.dq() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s2, a2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (s2.y + a2.y) / 2 * -0.5 });
            }
            gestureBeginsVertically(e2, t2, i2) {
              if (void 0 !== this._valid)
                return this._valid;
              const o2 = e2.mag() >= 2, r2 = t2.mag() >= 2;
              if (!o2 && !r2)
                return;
              if (!o2 || !r2)
                return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const s2 = e2.y > 0 == t2.y > 0;
              return on(e2) && on(t2) && s2;
            }
          }
          const sn = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class an {
            constructor() {
              const e2 = sn;
              this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            keydown(e2) {
              if (e2.altKey || e2.ctrlKey || e2.metaKey)
                return;
              let t2 = 0, i2 = 0, o2 = 0, r2 = 0, s2 = 0;
              switch (e2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  t2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  t2 = -1;
                  break;
                case 37:
                  e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r2 = -1);
                  break;
                case 39:
                  e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r2 = 1);
                  break;
                case 38:
                  e2.shiftKey ? o2 = 1 : (e2.preventDefault(), s2 = -1);
                  break;
                case 40:
                  e2.shiftKey ? o2 = -1 : (e2.preventDefault(), s2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (a2) => {
                const n2 = a2.getZoom();
                a2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nn, zoom: t2 ? Math.round(n2) + t2 * (e2.shiftKey ? 2 : 1) : n2, bearing: a2.getBearing() + i2 * this._bearingStep, pitch: a2.getPitch() + o2 * this._pitchStep, offset: [-r2 * this._panStep, -s2 * this._panStep], center: a2.getCenter() }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function nn(e2) {
            return e2 * (2 - e2);
          }
          const ln = 4.000244140625, cn = 1 / 450;
          class hn {
            constructor(t2, i2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = cn, e.aJ(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
            }
            setZoomRate(e2) {
              this._defaultZoomRate = e2;
            }
            setWheelZoomRate(e2) {
              this._wheelZoomRate = e2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(e2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
              this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t2) {
              if (!this.isEnabled())
                return;
              if (this._map._cooperativeGestures) {
                if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.dq()))
                  return void this._showBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              let i2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
              const o2 = e.q.now(), r2 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, 0 !== i2 && i2 % ln == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = window.setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
            }
            _onTimeout(e2) {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
            }
            _start(e2) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const t2 = g(this._el, e2);
              this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const t2 = this._map.transform;
              "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
              const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
              if (0 !== this._delta) {
                const e2 = "wheel" === this._type && Math.abs(this._delta) > ln ? this._wheelZoomRate : this._defaultZoomRate;
                let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
                this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
                const r3 = i2(), s3 = Math.pow(2, r3), a3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : s3;
                this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(a3 * o3))), "wheel" === this._type && (this._startZoom = r3, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
              }
              const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r2 = this._startZoom, s2 = this._easing;
              let a2, n2 = false;
              if ("wheel" === this._type && r2 && s2) {
                const t3 = Math.min((e.q.now() - this._lastWheelEventTime) / 200, 1), i3 = s2(t3);
                a2 = e.aa(r2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
              } else
                a2 = o2, n2 = true;
              this._active = true, n2 && (this._active = false, this._finishTimeout = window.setTimeout(() => {
                this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200));
              let l2 = a2 - i2();
              return l2 * this._lastDelta < 0 && (l2 = 0), { noInertia: true, needsRenderFrame: !n2, zoomDelta: l2, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(t2) {
              let i2 = e.dr;
              if (this._prevEase) {
                const t3 = this._prevEase, o2 = (e.q.now() - t3.start) / t3.duration, r2 = t3.easing(o2 + 0.01) - t3.easing(o2), s2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, a2 = Math.sqrt(0.0729 - s2 * s2);
                i2 = e.dp(s2, a2, 0.25, 1);
              }
              return this._prevEase = { start: e.q.now(), duration: t2, easing: i2 }, i2;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            _addScrollZoomBlocker() {
              this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
              this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
                this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
              }, 200);
            }
          }
          class un {
            constructor(e2, t2) {
              this._clickZoom = e2, this._tapZoom = t2;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class dn {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            blur() {
              this.reset();
            }
            dblclick(e2, t2) {
              return e2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class _n {
            constructor() {
              this._tap = new ja({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e2, t2, i2) {
              this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
            }
            touchmove(e2, t2, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch)
                    return;
                  const o2 = t2[0], r2 = o2.y - this._swipePoint.y;
                  return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
                }
              } else
                this._tap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class pn {
            constructor(e2, t2, i2) {
              this._el = e2, this._mousePan = t2, this._touchPan = i2;
            }
            enable(e2) {
              this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class mn {
            constructor(e2, t2, i2) {
              this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class fn {
            constructor(e2, t2, i2, o2) {
              this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(e2) {
              this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const gn = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
          class vn extends e.x {
          }
          class xn {
            constructor() {
              this.constants = [1, 1, 0.01], this.radius = 0;
            }
            setup(t2, i2) {
              const o2 = e.a6.vec3.sub([], i2, t2);
              this.radius = e.a6.vec3.length(o2[2] < 0 ? e.a6.vec3.div([], o2, this.constants) : [o2[0], o2[1], 0]);
            }
            projectRay(t2) {
              e.a6.vec3.div(t2, t2, this.constants), e.a6.vec3.normalize(t2, t2), e.a6.vec3.mul(t2, t2, this.constants);
              const i2 = e.a6.vec3.scale([], t2, this.radius);
              if (i2[2] > 0) {
                const t3 = e.a6.vec3.scale([], [0, 0, 1], e.a6.vec3.dot(i2, [0, 0, 1])), o2 = e.a6.vec3.scale([], e.a6.vec3.normalize([], [i2[0], i2[1], 0]), this.radius), r2 = e.a6.vec3.add([], i2, e.a6.vec3.scale([], e.a6.vec3.sub([], e.a6.vec3.add([], o2, t3), i2), 2));
                i2[0] = r2[0], i2[1] = r2[1];
              }
              return i2;
            }
          }
          function yn(e2) {
            return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
          }
          class bn {
            constructor(t2, i2) {
              this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new La(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new xn(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.aJ(["handleEvent", "handleWindowEvent"], this);
              const o2 = this._el;
              this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [e2, t3, i3] of this._listeners) {
                const o3 = e2 === document ? this.handleWindowEvent : this.handleEvent;
                e2.addEventListener(t3, o3, i3);
              }
            }
            destroy() {
              for (const [e2, t2, i2] of this._listeners) {
                const o2 = e2 === document ? this.handleWindowEvent : this.handleEvent;
                e2.removeEventListener(t2, o2, i2);
              }
            }
            _addDefaultHandlers(e2) {
              const t2 = this._map, i2 = t2.getCanvasContainer();
              this._add("mapEvent", new ka(t2, e2));
              const o2 = t2.boxZoom = new Na(t2, e2);
              this._add("boxZoom", o2);
              const r2 = new Va(), s2 = new dn();
              t2.doubleClickZoom = new un(s2, r2), this._add("tapZoom", r2), this._add("clickZoom", s2);
              const a2 = new _n();
              this._add("tapDragZoom", a2);
              const n2 = t2.touchPitch = new rn(t2);
              this._add("touchPitch", n2);
              const l2 = new Wa(e2), c2 = new $a(e2);
              t2.dragRotate = new mn(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
              const h2 = new Ha(e2), u2 = new Xa(t2, e2);
              t2.dragPan = new pn(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
              const d2 = new tn(), _2 = new Qa();
              t2.touchZoomRotate = new fn(i2, _2, d2, a2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Ba(t2));
              const p2 = t2.scrollZoom = new hn(t2, this);
              this._add("scrollZoom", p2, ["mousePan"]);
              const m2 = t2.keyboard = new an();
              this._add("keyboard", m2);
              for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
            }
            _add(e2, t2, i2) {
              this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
            }
            stop(e2) {
              if (!this._updatingCamera) {
                for (const { handler: e3 } of this._handlers)
                  e3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [], this._originalZoom = void 0;
              }
            }
            isActive() {
              for (const { handler: e2 } of this._handlers)
                if (e2.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return !!gn(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
              return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e2, t2, i2) {
              for (const o2 in e2)
                if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0))
                  return true;
              return false;
            }
            handleWindowEvent(e2) {
              this.handleEvent(e2, `${e2.type}Window`);
            }
            _getMapTouches(e2) {
              const t2 = [];
              for (const i2 of e2)
                this._el.contains(i2.target) && t2.push(i2);
              return t2;
            }
            handleEvent(e2, t2) {
              this._updatingCamera = true;
              const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, r2 = { needsRenderFrame: false }, s2 = {}, a2 = {}, n2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = n2 ? v(this._el, n2) : i2 ? void 0 : g(this._el, e2);
              for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
                if (!c3.isEnabled())
                  continue;
                let u2;
                this._blockedByActive(a2, h3, i3) ? c3.reset() : c3[t2 || e2.type] && (u2 = c3[t2 || e2.type](e2, l2, n2), this.mergeHandlerResult(r2, s2, u2, i3, o2), u2 && u2.needsRenderFrame && this._triggerRenderFrame()), (u2 || c3.isActive()) && (a2[i3] = c3);
              }
              const c2 = {};
              for (const e3 in this._previousActiveHandlers)
                a2[e3] || (c2[e3] = o2);
              this._previousActiveHandlers = a2, (Object.keys(c2).length || yn(r2)) && (this._changes.push([r2, s2, c2]), this._triggerRenderFrame()), (Object.keys(a2).length || yn(r2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: h2 } = r2;
              h2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h2(this._map));
            }
            mergeHandlerResult(t2, i2, o2, r2, s2) {
              if (!o2)
                return;
              e.l(t2, o2);
              const a2 = { handlerName: r2, originalEvent: o2.originalEvent || s2 };
              void 0 !== o2.zoomDelta && (i2.zoom = a2), void 0 !== o2.panDelta && (i2.drag = a2), void 0 !== o2.pitchDelta && (i2.pitch = a2), void 0 !== o2.bearingDelta && (i2.rotate = a2);
            }
            _applyChanges() {
              const t2 = {}, i2 = {}, o2 = {};
              for (const [r2, s2, a2] of this._changes)
                r2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(r2.panDelta)), r2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r2.pitchDelta), void 0 !== r2.around && (t2.around = r2.around), void 0 !== r2.aroundCoord && (t2.aroundCoord = r2.aroundCoord), void 0 !== r2.pinchAround && (t2.pinchAround = r2.pinchAround), r2.noInertia && (t2.noInertia = r2.noInertia), e.l(i2, s2), e.l(o2, a2);
              this._updateMapTransform(t2, i2, o2), this._changes = [];
            }
            _updateMapTransform(t2, i2, o2) {
              const r2 = this._map, s2 = r2.transform, a2 = (e2) => [e2.x, e2.y, e2.z];
              if (((e2) => {
                const t3 = this._eventsInProgress.drag;
                return t3 && !this._handlersById[t3.handlerName].isActive();
              })() && !yn(t2)) {
                const e2 = s2.zoom;
                s2.cameraElevationReference = "sea", null != this._originalZoom && s2._orthographicProjectionAtLowPitch && "globe" !== s2.projection.name && 0 === s2.pitch ? (s2.cameraElevationReference = "ground", s2.zoom = this._originalZoom) : (s2.recenterOnTerrain(), s2.cameraElevationReference = "ground"), e2 !== s2.zoom && this._map._update(true);
              }
              if (s2._isCameraConstrained && r2._stop(true), !yn(t2))
                return void this._fireEvents(i2, o2, true);
              let { panDelta: n2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, aroundCoord: d2, pinchAround: _2 } = t2;
              s2._isCameraConstrained && (l2 > 0 && (l2 = 0), s2._isCameraConstrained = false), void 0 !== _2 && (u2 = _2), (l2 || ((e2) => i2[e2] && !this._eventsInProgress[e2])("drag")) && u2 && (this._dragOrigin = a2(s2.pointCoordinate3D(u2)), this._originalZoom = s2.zoom, this._trackingEllipsoid.setup(s2._camera.position, this._dragOrigin)), s2.cameraElevationReference = "sea", r2._stop(true), u2 = u2 || r2.transform.centerPoint, c2 && (s2.bearing += c2), h2 && (s2.pitch += h2), s2._updateCameraState();
              const p2 = [0, 0, 0];
              if (n2)
                if ("mercator" === s2.projection.name) {
                  const e2 = this._trackingEllipsoid.projectRay(s2.screenPointToMercatorRay(u2).dir), t3 = this._trackingEllipsoid.projectRay(s2.screenPointToMercatorRay(u2.sub(n2)).dir);
                  p2[0] = t3[0] - e2[0], p2[1] = t3[1] - e2[1];
                } else {
                  const t3 = s2.pointCoordinate(u2);
                  if ("globe" === s2.projection.name) {
                    n2 = n2.rotate(-s2.angle);
                    const i3 = s2._pixelsPerMercatorPixel / s2.worldSize;
                    p2[0] = -n2.x * e.ds(e.aM(t3.y)) * i3, p2[1] = -n2.y * e.ds(s2.center.lat) * i3;
                  } else {
                    const e2 = s2.pointCoordinate(u2.sub(n2));
                    t3 && e2 && (p2[0] = e2.x - t3.x, p2[1] = e2.y - t3.y);
                  }
                }
              const m2 = s2.zoom, f2 = [0, 0, 0];
              if (l2) {
                const t3 = a2(d2 || s2.pointCoordinate3D(u2)), i3 = { dir: e.a6.vec3.normalize([], e.a6.vec3.sub([], t3, s2._camera.position)) };
                if (i3.dir[2] < 0) {
                  const o3 = s2.zoomDeltaToMovement(t3, l2);
                  e.a6.vec3.scale(f2, i3.dir, o3);
                }
              }
              const g2 = e.a6.vec3.add(p2, p2, f2);
              s2._translateCameraConstrained(g2), l2 && Math.abs(s2.zoom - m2) > 1e-4 && s2.recenterOnTerrain(), s2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
            }
            _fireEvents(t2, i2, o2) {
              const r2 = gn(this._eventsInProgress), s2 = gn(t2), a2 = {};
              for (const e2 in t2) {
                const { originalEvent: i3 } = t2[e2];
                this._eventsInProgress[e2] || (a2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
              }
              !r2 && s2 && this._fireEvent("movestart", s2.originalEvent);
              for (const e2 in a2)
                this._fireEvent(e2, a2[e2]);
              s2 && this._fireEvent("move", s2.originalEvent);
              for (const e2 in t2) {
                const { originalEvent: i3 } = t2[e2];
                this._fireEvent(e2, i3);
              }
              const n2 = {};
              let l2;
              for (const e2 in this._eventsInProgress) {
                const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
                this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, n2[`${e2}end`] = l2);
              }
              for (const e2 in n2)
                this._fireEvent(e2, n2[e2]);
              const c2 = gn(this._eventsInProgress);
              if (o2 && (r2 || s2) && !c2) {
                this._updatingCamera = true;
                const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
                t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.x("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(t2, i2) {
              this._map.fire(new e.x(t2, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
                this._frameId = void 0, this.handleEvent(new vn("renderFrame", { timeStamp: e2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          const wn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
          class Tn extends e.E {
            constructor(t2, i2) {
              super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, this._respectPrefersReducedMotion = false !== i2.respectPrefersReducedMotion, e.aJ(["_renderFrameCallback"], this);
            }
            getCenter() {
              return new e.bK(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e2, t2) {
              return this.jumpTo({ center: e2 }, t2);
            }
            panBy(t2, i2, o2) {
              return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.l({ offset: t2 }, i2), o2);
            }
            panTo(t2, i2, o2) {
              return this.easeTo(e.l({ center: t2 }, i2), o2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(e2, t2) {
              return this.jumpTo({ zoom: e2 }, t2), this;
            }
            zoomTo(t2, i2, o2) {
              return this.easeTo(e.l({ zoom: t2 }, i2), o2);
            }
            zoomIn(e2, t2) {
              return this.zoomTo(this.getZoom() + 1, e2, t2), this;
            }
            zoomOut(e2, t2) {
              return this.zoomTo(this.getZoom() - 1, e2, t2), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(e2, t2) {
              return this.jumpTo({ bearing: e2 }, t2), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(e2, t2) {
              return this.jumpTo({ padding: e2 }, t2), this;
            }
            rotateTo(t2, i2, o2) {
              return this.easeTo(e.l({ bearing: t2 }, i2), o2);
            }
            resetNorth(t2, i2) {
              return this.rotateTo(0, e.l({ duration: 1e3 }, t2), i2), this;
            }
            resetNorthPitch(t2, i2) {
              return this.easeTo(e.l({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
            }
            snapToNorth(e2, t2) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(e2, t2) {
              return this.jumpTo({ pitch: e2 }, t2), this;
            }
            cameraForBounds(t2, i2) {
              t2 = e.as.convert(t2);
              const o2 = i2 && i2.bearing || 0, r2 = i2 && i2.pitch || 0, s2 = t2.getNorthWest(), a2 = t2.getSouthEast();
              return this._cameraForBounds(this.transform, s2, a2, o2, r2, i2);
            }
            _extendPadding(t2) {
              const i2 = { top: 0, right: 0, bottom: 0, left: 0 };
              return null == t2 ? e.l({}, i2, this.transform.padding) : "number" == typeof t2 ? { top: t2, bottom: t2, right: t2, left: t2 } : e.l({}, i2, t2);
            }
            _extendCameraOptions(t2) {
              return (t2 = e.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding = this._extendPadding(t2.padding), t2;
            }
            _minimumAABBFrustumDistance(e2, t2) {
              const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
              return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
            }
            _cameraForBoundsOnGlobe(t2, i2, o2, r2, s2, a2) {
              const n2 = t2.clone(), l2 = this._extendCameraOptions(a2);
              n2.bearing = r2, n2.pitch = s2;
              const c2 = e.bK.convert(i2), h2 = e.bK.convert(o2), u2 = 0.5 * (c2.lat + h2.lat), d2 = 0.5 * (c2.lng + h2.lng), _2 = e.dt(u2, d2), p2 = e.a6.vec3.normalize([], _2), m2 = e.a6.vec3.normalize([], e.a6.vec3.cross([], p2, [0, 1, 0])), f2 = e.a6.vec3.cross([], m2, p2), g2 = [m2[0], m2[1], m2[2], 0, f2[0], f2[1], f2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v2 = [_2, e.dt(c2.lat, c2.lng), e.dt(h2.lat, c2.lng), e.dt(h2.lat, h2.lng), e.dt(c2.lat, h2.lng), e.dt(u2, c2.lng), e.dt(u2, h2.lng), e.dt(c2.lat, d2), e.dt(h2.lat, d2)];
              let x2 = e.c9.fromPoints(v2.map((t3) => [e.a6.vec3.dot(m2, t3), e.a6.vec3.dot(f2, t3), e.a6.vec3.dot(p2, t3)]));
              const y2 = e.a6.vec3.transformMat4([], x2.center, g2);
              0 === e.a6.vec3.squaredLength(y2) && e.a6.vec3.set(y2, 0, 0, 1), e.a6.vec3.normalize(y2, y2), e.a6.vec3.scale(y2, y2, e.aq), n2.center = e.du(y2);
              const b2 = n2.getWorldToCameraMatrix(), w2 = e.a6.mat4.invert(new Float64Array(16), b2);
              x2 = e.c9.applyTransform(x2, e.a6.mat4.multiply([], b2, g2));
              const T2 = this._extendAABB(x2, n2, l2, r2);
              if (!T2)
                return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              x2 = T2, e.a6.vec3.transformMat4(y2, y2, b2);
              const E2 = 0.5 * (x2.max[2] - x2.min[2]), C2 = this._minimumAABBFrustumDistance(n2, x2), S2 = e.a6.vec3.scale([], [0, 0, 1], E2), I2 = e.a6.vec3.add(S2, y2, S2), D2 = C2 + (0 === n2.pitch ? 0 : e.a6.vec3.distance(y2, I2)), R2 = n2.globeCenterInViewSpace, A2 = e.a6.vec3.sub([], y2, [R2[0], R2[1], R2[2]]);
              e.a6.vec3.normalize(A2, A2), e.a6.vec3.scale(A2, A2, D2);
              const L2 = e.a6.vec3.add([], y2, A2);
              e.a6.vec3.transformMat4(L2, L2, w2);
              const P2 = e.dw / e.aq, M2 = e.a6.vec3.length(L2), z2 = e.bD(Math.max(M2 * P2 - e.dw, Number.EPSILON), 0), O2 = Math.min(n2.zoomFromMercatorZAdjusted(z2), l2.maxZoom);
              return O2 > 0.5 * (e.c2 + e.bU) ? (n2.setProjection({ name: "mercator" }), n2.zoom = O2, this._cameraForBounds(n2, i2, o2, r2, s2, a2)) : { center: n2.center, zoom: O2, bearing: r2, pitch: s2 };
            }
            _extendAABB(t2, i2, o2, r2) {
              const s2 = 0.5 * ((o2.padding.left || 0) + (o2.padding.right || 0)), a2 = 0.5 * ((o2.padding.top || 0) + (o2.padding.bottom || 0)), n2 = a2, l2 = s2, c2 = s2, h2 = a2, u2 = i2.width - (l2 + c2), d2 = i2.height - (n2 + h2), _2 = e.a6.vec3.sub([], t2.max, t2.min), p2 = Math.min(u2 / _2[0], d2 / _2[1]), m2 = Math.min(i2.scaleZoom(i2.scale * p2), o2.maxZoom);
              if (isNaN(m2))
                return null;
              const f2 = i2.scale / i2.zoomScale(m2), g2 = new e.c9([t2.min[0] - l2 * f2, t2.min[1] - h2 * f2, t2.min[2]], [t2.max[0] + c2 * f2, t2.max[1] + n2 * f2, t2.max[2]]), v2 = ("number" == typeof o2.offset.x && "number" == typeof o2.offset.y ? new e.P(o2.offset.x, o2.offset.y) : e.P.convert(o2.offset)).rotate(-e.bB(r2));
              return g2.center[0] -= v2.x * f2, g2.center[1] += v2.y * f2, g2;
            }
            queryTerrainElevation(t2, i2) {
              const o2 = this.transform.elevation;
              return o2 ? (i2 = e.l({}, { exaggerated: true }, i2), o2.getAtPoint(e.a5.fromLngLat(t2), null, i2.exaggerated)) : null;
            }
            _cameraForBounds(t2, i2, o2, r2, s2, a2) {
              if ("globe" === t2.projection.name)
                return this._cameraForBoundsOnGlobe(t2, i2, o2, r2, s2, a2);
              const n2 = t2.clone(), l2 = this._extendCameraOptions(a2);
              n2.bearing = r2, n2.pitch = s2;
              const c2 = e.bK.convert(i2), h2 = e.bK.convert(o2), u2 = new e.bK(c2.lng, h2.lat), d2 = new e.bK(h2.lng, c2.lat), _2 = n2.project(c2), p2 = n2.project(h2), m2 = this.queryTerrainElevation(c2), f2 = this.queryTerrainElevation(h2), g2 = this.queryTerrainElevation(u2), v2 = this.queryTerrainElevation(d2), x2 = [[_2.x, _2.y, Math.min(m2 || 0, f2 || 0, g2 || 0, v2 || 0)], [p2.x, p2.y, Math.max(m2 || 0, f2 || 0, g2 || 0, v2 || 0)]];
              let y2 = e.c9.fromPoints(x2);
              const b2 = n2.getWorldToCameraMatrix(), w2 = e.a6.mat4.invert(new Float64Array(16), b2);
              y2 = e.c9.applyTransform(y2, b2);
              const T2 = this._extendAABB(y2, n2, l2, r2);
              if (!T2)
                return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              y2 = T2;
              const E2 = 0.5 * e.a6.vec3.sub([], y2.max, y2.min)[2], C2 = this._minimumAABBFrustumDistance(n2, y2), S2 = [0, 0, 1, 0];
              e.a6.vec4.transformMat4(S2, S2, b2), e.a6.vec4.normalize(S2, S2);
              const I2 = e.a6.vec3.scale([], S2, C2 + E2), D2 = e.a6.vec3.add([], y2.center, I2);
              e.a6.vec3.transformMat4(y2.center, y2.center, w2), e.a6.vec3.transformMat4(D2, D2, w2);
              const R2 = n2.unproject(new e.P(y2.center[0], y2.center[1])), A2 = e.dv(n2.projection, R2), L2 = Math.pow(2, A2), P2 = Math.min(n2._zoomFromMercatorZ(D2[2] * n2.pixelsPerMeter * L2 / n2.worldSize), l2.maxZoom);
              return n2.mercatorFromTransition && P2 < 0.5 * (e.c2 + e.bU) ? (n2.setProjection({ name: "globe" }), n2.zoom = P2, this._cameraForBounds(n2, i2, o2, r2, s2, a2)) : { center: R2, zoom: P2, bearing: r2, pitch: s2 };
            }
            fitBounds(e2, t2, i2) {
              const o2 = this.cameraForBounds(e2, t2);
              return this._fitInternal(o2, t2, i2);
            }
            fitScreenCoordinates(t2, i2, o2, r2, s2) {
              const a2 = e.P.convert(t2), n2 = e.P.convert(i2), l2 = new e.P(Math.min(a2.x, n2.x), Math.min(a2.y, n2.y)), c2 = new e.P(Math.max(a2.x, n2.x), Math.max(a2.y, n2.y));
              if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(a2, n2))
                return this;
              const h2 = this.transform.pointLocation3D(l2), u2 = this.transform.pointLocation3D(c2), d2 = this.transform.pointLocation3D(new e.P(l2.x, c2.y)), _2 = this.transform.pointLocation3D(new e.P(c2.x, l2.y)), p2 = [Math.min(h2.lng, u2.lng, d2.lng, _2.lng), Math.min(h2.lat, u2.lat, d2.lat, _2.lat)], m2 = [Math.max(h2.lng, u2.lng, d2.lng, _2.lng), Math.max(h2.lat, u2.lat, d2.lat, _2.lat)], f2 = r2 && r2.pitch ? r2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, m2, o2, f2, r2);
              return this._fitInternal(g2, r2, s2);
            }
            _fitInternal(t2, i2, o2) {
              return t2 ? (i2 = e.l(t2, i2)).linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2) : this;
            }
            jumpTo(t2, i2) {
              this.stop();
              const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
              let r2 = false, s2 = false, a2 = false;
              "zoom" in t2 && o2.zoom !== +t2.zoom && (r2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.bK.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (s2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (a2 = true, o2.pitch = +t2.pitch);
              const n2 = "number" == typeof t2.padding ? this._extendPadding(t2.padding) : t2.padding;
              if (null != t2.padding && !o2.isPaddingEqual(n2))
                if (false === t2.retainPadding) {
                  const e2 = o2.clone();
                  e2.padding = n2, o2.setLocationAtPoint(o2.center, e2.centerPoint);
                } else
                  o2.padding = n2;
              return t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.x("movestart", i2)).fire(new e.x("move", i2)), r2 && this.fire(new e.x("zoomstart", i2)).fire(new e.x("zoom", i2)).fire(new e.x("zoomend", i2)), s2 && this.fire(new e.x("rotatestart", i2)).fire(new e.x("rotate", i2)).fire(new e.x("rotateend", i2)), a2 && this.fire(new e.x("pitchstart", i2)).fire(new e.x("pitch", i2)).fire(new e.x("pitchend", i2)), this.fire(new e.x("moveend", i2)));
            }
            getFreeCameraOptions() {
              return this.transform.projection.supportsFreeCamera || e.w(wn), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t2, i2) {
              const o2 = this.transform;
              if (!o2.projection.supportsFreeCamera)
                return e.w(wn), this;
              this.stop();
              const r2 = o2.zoom, s2 = o2.pitch, a2 = o2.bearing;
              o2.setFreeCameraOptions(t2);
              const n2 = r2 !== o2.zoom, l2 = s2 !== o2.pitch, c2 = a2 !== o2.bearing;
              return this.fire(new e.x("movestart", i2)).fire(new e.x("move", i2)), n2 && this.fire(new e.x("zoomstart", i2)).fire(new e.x("zoom", i2)).fire(new e.x("zoomend", i2)), c2 && this.fire(new e.x("rotatestart", i2)).fire(new e.x("rotate", i2)).fire(new e.x("rotateend", i2)), l2 && this.fire(new e.x("pitchstart", i2)).fire(new e.x("pitch", i2)).fire(new e.x("pitchend", i2)), this.fire(new e.x("moveend", i2)), this;
            }
            easeTo(t2, i2) {
              this._stop(false, t2.easeId), (false === (t2 = e.l({ offset: [0, 0], duration: 500, easing: e.dr }, t2)).animate || this._prefersReducedMotion(t2)) && (t2.duration = 0);
              const o2 = this.transform, r2 = this.getZoom(), s2 = this.getBearing(), a2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, s2) : s2, h2 = "pitch" in t2 ? +t2.pitch : a2, u2 = this._extendPadding(t2.padding), d2 = e.P.convert(t2.offset);
              let _2, p2, m2;
              if ("globe" === o2.projection.name) {
                const i3 = e.a5.fromLngLat(o2.center), r3 = d2.rotate(-o2.angle);
                i3.x += r3.x / o2.worldSize, i3.y += r3.y / o2.worldSize;
                const s3 = i3.toLngLat(), a3 = e.bK.convert(t2.center || s3);
                this._normalizeCenter(a3), _2 = o2.centerPoint.add(r3), p2 = new e.P(i3.x, i3.y).mult(o2.worldSize), m2 = new e.P(e.am(a3.lng), e.at(a3.lat)).mult(o2.worldSize).sub(p2);
              } else {
                _2 = o2.centerPoint.add(d2);
                const i3 = o2.pointLocation(_2), r3 = e.bK.convert(t2.center || i3);
                this._normalizeCenter(r3), p2 = o2.project(i3), m2 = o2.project(r3).sub(p2);
              }
              const f2 = o2.zoomScale(l2 - r2);
              let g2, v2;
              t2.around && (g2 = e.bK.convert(t2.around), v2 = o2.locationPoint(g2));
              const x2 = this._zooming || l2 !== r2, y2 = this._rotating || s2 !== c2, b2 = this._pitching || h2 !== a2, w2 = !o2.isPaddingEqual(u2), T2 = false === t2.retainPadding ? o2.clone() : o2, E2 = (o3) => (E3) => {
                if (x2 && (o3.zoom = e.aa(r2, l2, E3)), y2 && (o3.bearing = e.aa(s2, c2, E3)), b2 && (o3.pitch = e.aa(a2, h2, E3)), w2 && (T2.interpolatePadding(n2, u2, E3), _2 = T2.centerPoint.add(d2)), g2)
                  o3.setLocationAtPoint(g2, v2);
                else {
                  const e2 = o3.zoomScale(o3.zoom - r2), t3 = l2 > r2 ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t3, 1 - E3), s3 = o3.unproject(p2.add(m2.mult(E3 * i3)).mult(e2));
                  o3.setLocationAtPoint(o3.renderWorldCopies ? s3.wrap() : s3, _2);
                }
                return t2.preloadOnly || this._fireMoveEvents(i2), o3;
              };
              if (t2.preloadOnly) {
                const e2 = this._emulate(E2, t2.duration, o2);
                return this._preloadTiles(e2), this;
              }
              const C2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = x2, this._rotating = y2, this._pitching = b2, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, C2), this._ease(E2(o2), (e2) => {
                "sea" === o2.cameraElevationReference && o2.recenterOnTerrain(), this._afterEase(i2, e2);
              }, t2), this;
            }
            _prepareEase(t2, i2, o2 = {}) {
              this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i2 || o2.moving || this.fire(new e.x("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.x("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.x("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.x("pitchstart", t2));
            }
            _fireMoveEvents(t2) {
              this.fire(new e.x("move", t2)), this._zooming && this.fire(new e.x("zoom", t2)), this._rotating && this.fire(new e.x("rotate", t2)), this._pitching && this.fire(new e.x("pitch", t2));
            }
            _afterEase(t2, i2) {
              if (this._easeId && i2 && this._easeId === i2)
                return;
              this._easeId = void 0, this.transform.cameraElevationReference = "ground";
              const o2 = this._zooming, r2 = this._rotating, s2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.x("zoomend", t2)), r2 && this.fire(new e.x("rotateend", t2)), s2 && this.fire(new e.x("pitchend", t2)), this.fire(new e.x("moveend", t2));
            }
            flyTo(t2, i2) {
              if (this._prefersReducedMotion(t2)) {
                const o3 = e.ar(t2, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
                return this.jumpTo(o3, i2);
              }
              this.stop(), t2 = e.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.dr }, t2);
              const o2 = this.transform, r2 = this.getZoom(), s2 = this.getBearing(), a2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in t2 ? e.ap(+t2.zoom, o2.minZoom, o2.maxZoom) : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, s2) : s2, h2 = "pitch" in t2 ? +t2.pitch : a2, u2 = this._extendPadding(t2.padding), d2 = o2.zoomScale(l2 - r2), _2 = e.P.convert(t2.offset);
              let p2 = o2.centerPoint.add(_2);
              const m2 = o2.pointLocation(p2), f2 = e.bK.convert(t2.center || m2);
              this._normalizeCenter(f2);
              const g2 = o2.project(m2), v2 = o2.project(f2).sub(g2);
              let x2 = t2.curve;
              const y2 = Math.max(o2.width, o2.height), b2 = y2 / d2, w2 = v2.mag();
              if ("minZoom" in t2) {
                const i3 = e.ap(Math.min(t2.minZoom, r2, l2), o2.minZoom, o2.maxZoom), s3 = y2 / o2.zoomScale(i3 - r2);
                x2 = Math.sqrt(s3 / w2 * 2);
              }
              const T2 = x2 * x2;
              function E2(e2) {
                const t3 = (b2 * b2 - y2 * y2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : y2) * T2 * w2);
                return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
              }
              function C2(e2) {
                return (Math.exp(e2) - Math.exp(-e2)) / 2;
              }
              function S2(e2) {
                return (Math.exp(e2) + Math.exp(-e2)) / 2;
              }
              const I2 = E2(0);
              let D2 = function(e2) {
                return S2(I2) / S2(I2 + x2 * e2);
              }, R2 = function(e2) {
                return y2 * ((S2(I2) * (C2(t3 = I2 + x2 * e2) / S2(t3)) - C2(I2)) / T2) / w2;
                var t3;
              }, A2 = (E2(1) - I2) / x2;
              if (Math.abs(w2) < 1e-6 || !isFinite(A2)) {
                if (Math.abs(y2 - b2) < 1e-6)
                  return this.easeTo(t2, i2);
                const e2 = b2 < y2 ? -1 : 1;
                A2 = Math.abs(Math.log(b2 / y2)) / x2, R2 = function() {
                  return 0;
                }, D2 = function(t3) {
                  return Math.exp(e2 * x2 * t3);
                };
              }
              t2.duration = "duration" in t2 ? +t2.duration : 1e3 * A2 / ("screenSpeed" in t2 ? +t2.screenSpeed / x2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
              const L2 = s2 !== c2, P2 = h2 !== a2, M2 = !o2.isPaddingEqual(u2), z2 = false === t2.retainPadding ? o2.clone() : o2, O2 = (o3) => (d3) => {
                const m3 = d3 * A2, x3 = 1 / D2(m3);
                o3.zoom = 1 === d3 ? l2 : r2 + o3.scaleZoom(x3), L2 && (o3.bearing = e.aa(s2, c2, d3)), P2 && (o3.pitch = e.aa(a2, h2, d3)), M2 && (z2.interpolatePadding(n2, u2, d3), p2 = z2.centerPoint.add(_2));
                const y3 = 1 === d3 ? f2 : o3.unproject(g2.add(v2.mult(R2(m3))).mult(x3));
                return o3.setLocationAtPoint(o3.renderWorldCopies ? y3.wrap() : y3, p2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
              };
              if (t2.preloadOnly) {
                const e2 = this._emulate(O2, t2.duration, o2);
                return this._preloadTiles(e2), this;
              }
              return this._zooming = true, this._rotating = L2, this._pitching = P2, this._padding = M2, this._prepareEase(i2, false), this._ease(O2(o2), () => this._afterEase(i2), t2), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _requestRenderFrame(e2) {
            }
            _cancelRenderFrame(e2) {
            }
            _stop(e2, t2) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                const e3 = this._onEaseEnd;
                this._onEaseEnd = void 0, e3.call(this, t2);
              }
              if (!e2) {
                const e3 = this.handlers;
                e3 && e3.stop(false);
              }
              return this;
            }
            _ease(t2, i2, o2) {
              false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.q.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
              const t2 = Math.min((e.q.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
              i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t2, i2) {
              t2 = e.bA(t2, -180, 180);
              const o2 = Math.abs(t2 - i2);
              return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
            }
            _normalizeCenter(e2) {
              const t2 = this.transform;
              if (t2.maxBounds)
                return;
              if ("globe" !== t2.projection.name && !t2.renderWorldCopies)
                return;
              const i2 = e2.lng - t2.center.lng;
              e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t2) {
              return this._respectPrefersReducedMotion && e.q.prefersReducedMotion && !(t2 && t2.essential);
            }
            _emulate(e2, t2, i2) {
              const o2 = Math.ceil(15 * t2 / 1e3), r2 = [], s2 = e2(i2.clone());
              for (let e3 = 0; e3 <= o2; e3++) {
                const t3 = s2(e3 / o2);
                r2.push(t3.clone());
              }
              return r2;
            }
            _preloadTiles(e2, t2) {
            }
          }
          class En {
            constructor(t2 = {}) {
              this.options = t2, e.aJ(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(e2) {
              const t2 = this.options && this.options.compact, i2 = e2._getUIString("AttributionControl.ToggleAttribution");
              this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i2);
              const o2 = l("span", "mapboxgl-ctrl-icon", this._compactButton);
              return o2.setAttribute("aria-hidden", "true"), o2.setAttribute("title", i2), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _toggleAttribution() {
              this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
              let t2 = this._editLink;
              t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
              const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN }];
              if (t2) {
                const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
                t2.href = `${e.e.FEEDBACK_URL}/${o2}#${Ca(this._map, true)}`, t2.rel = "noopener nofollow";
              }
            }
            _updateData(e2) {
              !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let e2 = [];
              if (this._map.style.stylesheet) {
                const e3 = this._map.style.stylesheet;
                this.styleOwner = e3.owner, this.styleId = e3.id;
              }
              const t2 = this._map.style._mergedSourceCaches;
              for (const i3 in t2) {
                const o2 = t2[i3];
                if (o2.used) {
                  const t3 = o2.getSource();
                  t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
                }
              }
              e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
                for (let o2 = i3 + 1; o2 < e2.length; o2++)
                  if (e2[o2].indexOf(t3) >= 0)
                    return false;
                return true;
              }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
              const i2 = e2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
              this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
          }
          class Cn {
            constructor() {
              e.aJ(["_updateLogo", "_updateCompact"], this);
            }
            onAdd(e2) {
              this._map = e2, this._container = l("div", "mapboxgl-ctrl");
              const t2 = l("a", "mapboxgl-ctrl-logo");
              return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _updateLogo(e2) {
              e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
              if (!this._map.style)
                return true;
              const e2 = this._map.style._sourceCaches;
              if (0 === Object.entries(e2).length)
                return true;
              for (const t2 in e2) {
                const i2 = e2[t2].getSource();
                if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
                  return false;
              }
              return true;
            }
            _updateCompact() {
              const e2 = this._container.children;
              if (e2.length) {
                const t2 = e2[0];
                this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
              }
            }
          }
          class Sn {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(e2) {
              const t2 = ++this._id;
              return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
            }
            remove(e2) {
              const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
              for (const t3 of i2)
                if (t3.id === e2)
                  return void (t3.cancelled = true);
            }
            run(e2 = 0) {
              const t2 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of t2)
                if (!i2.cancelled && (i2.callback(e2), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          class In {
            constructor(e2) {
              this.jumpTo(e2);
            }
            getValue(t2) {
              if (t2 <= this._startTime)
                return this._start;
              if (t2 >= this._endTime)
                return this._end;
              const i2 = e.cw((t2 - this._startTime) / (this._endTime - this._startTime));
              return this._start * (1 - i2) + this._end * i2;
            }
            isEasing(e2) {
              return e2 >= this._startTime && e2 <= this._endTime;
            }
            jumpTo(e2) {
              this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
            }
            easeTo(e2, t2, i2) {
              this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
            }
          }
          const Dn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
          class Rn {
            registerParameter() {
            }
            registerButton() {
            }
            registerBinding() {
            }
            refreshUI() {
            }
          }
          class An {
            constructor(e2) {
              this.map = e2, this.interactionsByType = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this);
            }
            add(t2, i2) {
              if (this.typeById.has(t2))
                throw new Error(`Interaction id "${t2}" already exists.`);
              const { type: o2, filter: r2 } = i2;
              if (r2) {
                const i3 = e.M(r2, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if ("error" === i3.result)
                  throw new Error(i3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                this.filters.set(t2, i3.value);
              }
              const s2 = this.interactionsByType.get(o2) || /* @__PURE__ */ new Map();
              0 === s2.size && (this.map.on(o2, this.handleType), this.interactionsByType.set(o2, s2)), s2.set(t2, i2), this.typeById.set(t2, o2);
            }
            remove(e2) {
              const t2 = this.typeById.get(e2);
              if (!t2)
                return;
              this.typeById.delete(e2), this.filters.delete(e2);
              const i2 = this.interactionsByType.get(t2);
              i2 && (i2.delete(e2), 0 === i2.size && this.map.off(t2, this.handleType));
            }
            handleType(e2) {
              const t2 = e2.features || this.map.queryRenderedFeatures(e2.point);
              if (!t2)
                return;
              const i2 = this.interactionsByType.get(e2.type), o2 = { zoom: 0 };
              for (const [e3, r2] of i2) {
                const i3 = this.filters.get(e3), { handler: s2, layers: a2 } = r2;
                for (const n2 of t2)
                  if ((!a2 || a2.includes(n2.layer.id)) && (!i3 || i3.evaluate(o2, n2)) && false !== s2({ id: e3, feature: n2, interaction: r2 }))
                    break;
              }
            }
          }
          const Ln = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false, precompilePrograms: true }, Pn = { showCompass: true, showZoom: true, visualizePitch: false };
          class Mn {
            constructor(t2, i2, o2 = false) {
              this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Wa({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new $a({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.aJ(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
            }
            down(e2, t2) {
              this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), _();
            }
            move(e2, t2) {
              const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), r2 = o2 && o2.bearingDelta;
              if (r2 && i2.setBearing(i2.getBearing() + r2), this.mousePitch) {
                const o3 = this.mousePitch.mousemoveWindow(e2, t2), r3 = o3 && o3.pitchDelta;
                r3 && i2.setPitch(i2.getPitch() + r3);
              }
            }
            off() {
              const e2 = this.element;
              e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart, { passive: false }), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t2) {
              this.down(e.l({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), g(this.element, t2)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e2) {
              this.move(e2, g(this.element, e2));
            }
            mouseup(e2) {
              this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
            }
            touchstart(e2) {
              1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
            }
            touchmove(e2) {
              1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
            }
            touchend(e2) {
              0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
          }
          function zn(t2, i2, o2) {
            if (t2 = new e.bK(t2.lng, t2.lat), i2) {
              const r2 = new e.bK(t2.lng - 360, t2.lat), s2 = new e.bK(t2.lng + 360, t2.lat), a2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), n2 = o2.locationPoint(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
              o2.locationPoint(r2).distSqr(i2) < n2 && (l2 || Math.abs(r2.lng - o2.center.lng) < a2) ? t2 = r2 : o2.locationPoint(s2).distSqr(i2) < n2 && (l2 || Math.abs(s2.lng - o2.center.lng) < a2) && (t2 = s2);
            }
            for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
              const e2 = o2.locationPoint(t2);
              if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height)
                break;
              t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
            }
            return t2;
          }
          const On = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          class Fn extends e.E {
            constructor(t2, i2) {
              if (super(), (t2 instanceof HTMLElement || i2) && (t2 = e.l({ element: t2 }, i2)), e.aJ(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element)
                this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = l("div");
                const i3 = 41, o3 = 27, r3 = c("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), s2 = c("radialGradient", { id: "shadowGradient" }, c("defs", {}, r3));
                c("stop", { offset: "10%", "stop-opacity": 0.4 }, s2), c("stop", { offset: "100%", "stop-opacity": 0.05 }, s2), c("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), c("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), c("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), c("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e.P.convert(t2 && t2.offset || [0, -14]);
              }
              this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
                e2.preventDefault();
              }), this._element.addEventListener("mousedown", (e2) => {
                e2.preventDefault();
              });
              const o2 = this._element.classList;
              for (const e2 in On)
                o2.remove(`mapboxgl-marker-anchor-${e2}`);
              o2.add(`mapboxgl-marker-anchor-${this._anchor}`);
              const r2 = t2 && t2.className ? t2.className.trim().split(/\s+/) : [];
              o2.add(...r2), this._popup = null;
            }
            addTo(e2) {
              return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
            }
            remove() {
              const e2 = this._map;
              return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t2) {
              return this._lngLat = e.bK.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(e2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
                if (!("offset" in e2.options)) {
                  const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                  e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
                }
                this._popup = e2, e2._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
              }
              return this;
            }
            _onKeyPress(e2) {
              const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
              "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }
            _onMapClick(e2) {
              const t2 = e2.originalEvent.target, i2 = this._element;
              this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const e2 = this._popup;
              return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
              const e2 = this._map, t2 = this._pos;
              if (!e2 || !t2)
                return false;
              const i2 = e2.unproject(t2), o2 = e2.getFreeCameraOptions();
              if (!o2.position)
                return false;
              const r2 = o2.position.toLngLat();
              return r2.distanceTo(i2) < 0.9 * r2.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
              const t2 = this._map;
              if (!t2)
                return;
              const i2 = this._pos;
              if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height)
                return void this._clearFadeTimer();
              const o2 = t2.unproject(i2);
              let r2;
              t2._showingGlobe() && e.dz(t2.transform, this._lngLat) ? r2 = 0 : (r2 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (r2 *= this._occludedOpacity)), this._element.style.opacity = `${r2}`, this._element.style.pointerEvents = r2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r2), this._fadeTimer = null;
            }
            _clearFadeTimer() {
              this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
              const e2 = this._pos;
              if (!e2 || !this._map)
                return;
              const t2 = this._offset.mult(this._scale);
              this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${On[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
            }
            _calculateXYTransform() {
              const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
              if (!i2 || !t2 || "map" !== o2)
                return "";
              if (!i2._showingGlobe()) {
                const e2 = i2.getPitch();
                return e2 ? `rotateX(${e2}deg)` : "";
              }
              const r2 = e.c0(e.dA(i2.transform, this._lngLat)), s2 = t2.sub(e.dB(i2.transform)), a2 = Math.abs(s2.x) + Math.abs(s2.y);
              if (0 === a2)
                return "";
              const n2 = r2 / a2;
              return `rotateX(${-s2.y * n2}deg) rotateY(${s2.x * n2}deg)`;
            }
            _calculateZTransform() {
              const t2 = this._pos, i2 = this._map;
              if (!i2 || !t2)
                return "";
              let o2 = 0;
              const r2 = this.getRotationAlignment();
              if ("map" === r2)
                if (i2._showingGlobe()) {
                  const t3 = i2.project(new e.bK(this._lngLat.lng, this._lngLat.lat + 1e-3)), r3 = i2.project(new e.bK(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
                  o2 = e.c0(Math.atan2(r3.y, r3.x)) - 90;
                } else
                  o2 = -i2.getBearing();
              else if ("horizon" === r2) {
                const r3 = e.a7(4, 6, i2.getZoom()), s2 = e.dB(i2.transform);
                s2.y += r3 * i2.transform.height;
                const a2 = t2.sub(s2), n2 = e.c0(Math.atan2(a2.y, a2.x));
                o2 = (n2 > 90 ? n2 - 270 : n2 + 90) * (1 - r3);
              }
              return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
            }
            _update(e2) {
              cancelAnimationFrame(this._updateFrameId);
              const t2 = this._map;
              t2 && (t2.transform.renderWorldCopies && (this._lngLat = zn(this._lngLat, this._pos, t2.transform)), this._pos = t2.project(this._lngLat), true === e2 ? this._updateFrameId = requestAnimationFrame(() => {
                this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
              }) : this._pos = this._pos.round(), t2._requestDomTask(() => {
                this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t2._showingGlobe() || t2.getTerrain() || t2.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
              }));
            }
            getOffset() {
              return this._offset;
            }
            setOffset(t2) {
              return this._offset = e.P.convert(t2), this._update(), this;
            }
            addClassName(e2) {
              return this._element.classList.add(e2), this;
            }
            removeClassName(e2) {
              return this._element.classList.remove(e2), this;
            }
            toggleClassName(e2) {
              return this._element.classList.toggle(e2);
            }
            _onMove(t2) {
              const i2 = this._map;
              if (!i2)
                return;
              const o2 = this._pointerdownPos, r2 = this._positionDelta;
              if (o2 && r2) {
                if (!this._isDragging) {
                  const e2 = this._clickTolerance || i2._clickTolerance;
                  if (t2.point.dist(o2) < e2)
                    return;
                  this._isDragging = true;
                }
                this._pos = t2.point.sub(r2), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.x("dragstart"))), this.fire(new e.x("drag"));
              }
            }
            _onUp() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
              const t2 = this._map;
              t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.x("dragend")), this._state = "inactive";
            }
            _addDragHandler(e2) {
              const t2 = this._map, i2 = this._pos;
              t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
            }
            setDraggable(e2) {
              this._draggable = !!e2;
              const t2 = this._map;
              return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(e2) {
              return this._rotation = e2 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(e2) {
              return this._rotationAlignment = e2 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e2) {
              return this._pitchAlignment = e2 || "auto", this._update(), this;
            }
            getPitchAlignment() {
              return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e2) {
              return this._occludedOpacity = e2 || 0.2, this._update(), this;
            }
            getOccludedOpacity() {
              return this._occludedOpacity;
            }
          }
          const kn = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, Bn = { maxWidth: 100, unit: "metric" }, Nn = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, Un = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Gn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function jn(t2 = new e.P(0, 0), i2 = "bottom") {
            if ("number" == typeof t2) {
              const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
              switch (i2) {
                case "top":
                  return new e.P(0, t2);
                case "top-left":
                  return new e.P(o2, o2);
                case "top-right":
                  return new e.P(-o2, o2);
                case "bottom":
                  return new e.P(0, -t2);
                case "bottom-left":
                  return new e.P(o2, -o2);
                case "bottom-right":
                  return new e.P(-o2, -o2);
                case "left":
                  return new e.P(t2, 0);
                case "right":
                  return new e.P(-t2, 0);
              }
              return new e.P(0, 0);
            }
            return t2 instanceof e.P || Array.isArray(t2) ? e.P.convert(t2) : e.P.convert(t2[i2] || [0, 0]);
          }
          return { version: t, supported: n.supported, setRTLTextPlugin: e.dC, getRTLTextPluginStatus: e.dD, Map: class extends Tn {
            constructor(t2) {
              o.mark(i.create);
              const r2 = t2;
              if (null != (t2 = e.l({}, Ln, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != t2.minPitch && t2.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (null != t2.maxPitch && t2.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2.antialias && e.dx(window) && (t2.antialias = false, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Hi(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._repaint = !!t2.repaint, this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new Sn(), this._domRenderTaskQueue = new Sn(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.aP(), this._locale = e.l({}, Dn, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._tessellationStep = t2.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._precompilePrograms = t2.precompilePrograms, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new In(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._frameId = 0, this._requestManager = new T(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, this._contextCreateOptions = t2.contextCreateOptions ? { ...t2.contextCreateOptions } : {}, "string" == typeof t2.container) {
                const e2 = document.getElementById(t2.container);
                if (!e2)
                  throw new Error(`Container '${t2.container.toString()}' not found.`);
                this._container = e2;
              } else {
                if (!(t2.container instanceof HTMLElement))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = t2.container;
              }
              if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.aJ(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new Rn()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: true }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: true }, () => {
                this._update();
              }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._setupPainter(), void 0 === this.painter)
                throw new Error("Failed to initialize WebGL.");
              if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new bn(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, (t2.style || !t2.testMode) && this.setStyle(t2.style || e.e.DEFAULT_STYLE, { config: t2.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), t2.hash && (this._hash = new Ea("string" == typeof t2.hash && t2.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                null == r2.center && null == r2.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch });
                const i2 = t2.bounds;
                i2 && (this.resize(), this.fitBounds(i2, e.l({}, t2.fitBoundsOptions, { duration: 0 })));
              }
              this.resize(), t2.attributionControl && this.addControl(new En({ customAttribution: t2.customAttribution })), this._logoControl = new Cn(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
              }), this.on("data", (t3) => {
                this._update("style" === t3.dataType), this.fire(new e.x(`${t3.dataType}data`, t3));
              }), this.on("dataloading", (t3) => {
                this.fire(new e.x(`${t3.dataType}dataloading`, t3));
              }), this._interactions = new An(this);
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(t2, i2) {
              if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
                return this.fire(new e.t(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const o2 = t2.onAdd(this);
              this._controls.push(t2);
              const r2 = this._controlPositions[i2];
              return -1 !== i2.indexOf("bottom") ? r2.insertBefore(o2, r2.firstChild) : r2.appendChild(o2), this;
            }
            removeControl(t2) {
              if (!t2 || !t2.onRemove)
                return this.fire(new e.t(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(t2);
              return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
            }
            hasControl(e2) {
              return this._controls.indexOf(e2) > -1;
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            resize(t2) {
              if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                return this;
              this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
              const i2 = !this._moving;
              return i2 && this.fire(new e.x("movestart", t2)).fire(new e.x("move", t2)), this.fire(new e.x("resize", t2)), i2 && this.fire(new e.x("moveend", t2)), this;
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds() || null;
            }
            setMaxBounds(t2) {
              return this.transform.setMaxBounds(e.as.convert(t2)), this._update();
            }
            setMinZoom(t2) {
              if ((t2 = t2 ?? -2) >= -2 && t2 <= this.transform.maxZoom)
                return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.x("zoomstart")).fire(new e.x("zoom")).fire(new e.x("zoomend")), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t2) {
              if ((t2 = t2 ?? 22) >= this.transform.minZoom)
                return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.x("zoomstart")).fire(new e.x("zoom")).fire(new e.x("zoomend")), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t2) {
              if ((t2 = t2 ?? 0) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch)
                return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.x("pitchstart")).fire(new e.x("pitch")).fire(new e.x("pitchend")), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t2) {
              if ((t2 = t2 ?? 85) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2 >= this.transform.minPitch)
                return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.x("pitchstart")).fire(new e.x("pitch")).fire(new e.x("pitchend")), this;
              throw new Error("maxPitch must be greater than or equal to minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(e2) {
              return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
            }
            getLanguage() {
              return this._language;
            }
            _parseLanguage(e2) {
              return "auto" === e2 ? navigator.language : Array.isArray(e2) ? 0 === e2.length ? void 0 : e2.map((e3) => "auto" === e3 ? navigator.language : e3) : e2;
            }
            setLanguage(e2) {
              const t2 = this._parseLanguage(e2);
              if (!this.style || t2 === this._language)
                return this;
              this._language = t2, this.style.reloadSources();
              for (const e3 of this._controls)
                e3._setLanguage && e3._setLanguage(this._language);
              return this;
            }
            getWorldview() {
              return this._worldview;
            }
            setWorldview(e2) {
              return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style.reloadSources(), this) : this;
            }
            getProjection() {
              return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
            }
            _showingGlobe() {
              return "globe" === this.transform.projection.name;
            }
            setProjection(e2) {
              return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.projection);
            }
            _updateProjectionTransition() {
              if ("globe" !== this.getProjection().name)
                return;
              const t2 = this.transform, i2 = t2.projection.name;
              let o2;
              "globe" === i2 && t2.zoom >= e.bU ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.bU && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
            }
            _prioritizeAndUpdateProjection(e2, t2) {
              return this._updateProjection(e2 || t2 || { name: "mercator" });
            }
            _updateProjection(t2) {
              let i2;
              return i2 = "globe" === t2.name && this.transform.zoom >= e.bU ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
            }
            project(t2) {
              return this.transform.locationPoint3D(e.bK.convert(t2));
            }
            unproject(t2) {
              return this.transform.pointLocation3D(e.P.convert(t2));
            }
            isMoving() {
              return this._moving || this.handlers && this.handlers.isMoving() || false;
            }
            isZooming() {
              return this._zooming || this.handlers && this.handlers.isZooming() || false;
            }
            isRotating() {
              return this._rotating || this.handlers && this.handlers.isRotating() || false;
            }
            _isDragging() {
              return this.handlers && this.handlers._isDragging() || false;
            }
            _createDelegatedListener(e2, t2, i2) {
              if ("mouseenter" === e2 || "mouseover" === e2) {
                let o2 = false;
                const r2 = (r3) => {
                  const s3 = t2.filter((e3) => this.getLayer(e3)), a2 = s3.length ? this.queryRenderedFeatures(r3.point, { layers: s3 }) : [];
                  a2.length ? o2 || (o2 = true, i2.call(this, new za(e2, this, r3.originalEvent, { features: a2 }))) : o2 = false;
                }, s2 = () => {
                  o2 = false;
                };
                return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: s2 } };
              }
              if ("mouseleave" === e2 || "mouseout" === e2) {
                let o2 = false;
                const r2 = (r3) => {
                  const s3 = t2.filter((e3) => this.getLayer(e3));
                  (s3.length ? this.queryRenderedFeatures(r3.point, { layers: s3 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new za(e2, this, r3.originalEvent)));
                }, s2 = (t3) => {
                  o2 && (o2 = false, i2.call(this, new za(e2, this, t3.originalEvent)));
                };
                return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: s2 } };
              }
              {
                const o2 = (e3) => {
                  const o3 = t2.filter((e4) => this.getLayer(e4)), r2 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
                  r2.length && (e3.features = r2, i2.call(this, e3), delete e3.features);
                };
                return { layers: new Set(t2), listener: i2, delegates: { [e2]: o2 } };
              }
            }
            on(e2, t2, i2) {
              if ("function" == typeof t2 || void 0 === i2)
                return super.on(e2, t2);
              if (Array.isArray(t2) || (t2 = [t2]), t2) {
                for (const e3 of t2)
                  if (!this._isValidId(e3))
                    return this;
              }
              const o2 = this._createDelegatedListener(e2, t2, i2);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
              for (const e3 in o2.delegates)
                this.on(e3, o2.delegates[e3]);
              return this;
            }
            once(e2, t2, i2) {
              if ("function" == typeof t2 || void 0 === i2)
                return super.once(e2, t2);
              if (Array.isArray(t2) || (t2 = [t2]), t2) {
                for (const e3 of t2)
                  if (!this._isValidId(e3))
                    return this;
              }
              const o2 = this._createDelegatedListener(e2, t2, i2);
              for (const e3 in o2.delegates)
                this.once(e3, o2.delegates[e3]);
              return this;
            }
            off(e2, t2, i2) {
              if ("function" == typeof t2 || void 0 === i2)
                return super.off(e2, t2);
              const o2 = new Set(Array.isArray(t2) ? t2 : [t2]);
              for (const e3 of o2)
                if (!this._isValidId(e3))
                  return this;
              const r2 = (e3, t3) => {
                if (e3.size !== t3.size)
                  return false;
                for (const i3 of e3)
                  if (!t3.has(i3))
                    return false;
                return true;
              }, s2 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
              return s2 && ((e3) => {
                for (let t3 = 0; t3 < e3.length; t3++) {
                  const s3 = e3[t3];
                  if (s3.listener === i2 && r2(s3.layers, o2)) {
                    for (const e4 in s3.delegates)
                      this.off(e4, s3.delegates[e4]);
                    return e3.splice(t3, 1), this;
                  }
                }
              })(s2), this;
            }
            queryRenderedFeatures(t2, i2) {
              if (!this.style)
                return [];
              if (void 0 !== i2 || void 0 === t2 || t2 instanceof e.P || Array.isArray(t2) || (i2 = t2, t2 = void 0), t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], (i2 = i2 || {}).layers && Array.isArray(i2.layers)) {
                for (const e2 of i2.layers)
                  if (!this._isValidId(e2))
                    return [];
              }
              return this.style.queryRenderedFeatures(t2, i2, this.transform);
            }
            querySourceFeatures(e2, t2) {
              return this._isValidId(e2) ? this.style.querySourceFeatures(e2, t2) : [];
            }
            isPointOnSurface(t2) {
              const { name: i2 } = this.transform.projection;
              return "globe" !== i2 && "mercator" !== i2 && e.w(`${i2} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t2));
            }
            addInteraction(e2, t2) {
              return this._interactions.add(e2, t2), this;
            }
            removeInteraction(e2) {
              return this._interactions.remove(e2), this;
            }
            setStyle(t2, i2) {
              return i2 = e.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2), this.style && t2 && false !== i2.diff && i2.localFontFamily === this._localFontFamily && i2.localIdeographFontFamily === this._localIdeographFontFamily && !i2.config ? (this.style._diffStyle(t2, (o2, r2) => {
                o2 ? (e.w(`Unable to perform style diff: ${String(o2.message || o2.error || o2)}. Rebuilding the style from scratch.`), this._updateStyle(t2, i2)) : r2 && this._update(true);
              }, () => {
                this._postStyleLoadEvent();
              }), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
            }
            _getUIString(e2) {
              const t2 = this._locale[e2];
              if (null == t2)
                throw new Error(`Missing UI string '${e2}'`);
              return t2;
            }
            _updateStyle(t2, i2) {
              if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t2) {
                const o2 = e.l({}, i2);
                i2 && i2.config && (o2.initialConfig = i2.config, delete o2.config), this.style = new co(this, o2).load(t2), this.style.setEventedParent(this, { style: this.style });
              }
              return this._updateTerrain(), this;
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new co(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), false);
            }
            _isValidId(t2) {
              return null == t2 ? (this.fire(new e.t(new Error("IDs can't be empty."))), false) : !e.cn(t2) || (this.fire(new e.t(new Error(`IDs can't contain special symbols: "${t2}".`))), false);
            }
            addSource(e2, t2) {
              return this._isValidId(e2) ? (this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true)) : this;
            }
            isSourceLoaded(e2) {
              return !!this._isValidId(e2) && !!this.style && this.style._isSourceCacheLoaded(e2);
            }
            areTilesLoaded() {
              return this.style.areTilesLoaded();
            }
            addSourceType(e2, t2, i2) {
              this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
            }
            removeSource(e2) {
              return this._isValidId(e2) ? (this.style.removeSource(e2), this._updateTerrain(), this._update(true)) : this;
            }
            getSource(e2) {
              return this._isValidId(e2) ? this.style.getOwnSource(e2) : null;
            }
            addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r2 = false, stretchX: s2, stretchY: a2, content: n2 } = {}) {
              if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap) {
                const { width: l2, height: c2, data: h2 } = e.q.getImageData(i2);
                this.style.addImage(t2, { data: new e.r({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: s2, stretchY: a2, content: n2, sdf: r2, version: 0 });
              } else if (void 0 === i2.width || void 0 === i2.height)
                this.fire(new e.t(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              else {
                const { width: l2, height: c2 } = i2, h2 = i2;
                this.style.addImage(t2, { data: new e.r({ width: l2, height: c2 }, new Uint8Array(h2.data)), pixelRatio: o2, stretchX: s2, stretchY: a2, content: n2, sdf: r2, version: 0, userImage: h2 }), h2.onAdd && h2.onAdd(this, t2);
              }
            }
            updateImage(t2, i2) {
              this._lazyInitEmptyStyle();
              const o2 = this.style.getImage(t2);
              if (!o2)
                return void this.fire(new e.t(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const r2 = i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap ? e.q.getImageData(i2) : i2, { width: s2, height: a2, data: n2 } = r2;
              if (void 0 === s2 || void 0 === a2)
                return void this.fire(new e.t(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (s2 !== o2.data.width || a2 !== o2.data.height)
                return void this.fire(new e.t(new Error(`The width and height of the updated image (${s2}, ${a2})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`)));
              const l2 = !(i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap);
              o2.data.replace(n2, l2), this.style.updateImage(t2, o2);
            }
            hasImage(t2) {
              return t2 ? !!this.style && !!this.style.getImage(t2) : (this.fire(new e.t(new Error("Missing required image id"))), false);
            }
            removeImage(e2) {
              this.style.removeImage(e2);
            }
            loadImage(t2, i2) {
              e.o(this._requestManager.transformRequest(t2, e.R.Image), (t3, o2) => {
                i2(t3, o2 instanceof HTMLImageElement ? e.q.getImageData(o2) : o2);
              });
            }
            listImages() {
              return this.style.listImages();
            }
            addModel(e2, t2) {
              this._lazyInitEmptyStyle(), this.style.addModel(e2, t2);
            }
            hasModel(t2) {
              return t2 ? this.style.hasModel(t2) : (this.fire(new e.t(new Error("Missing required model id"))), false);
            }
            removeModel(e2) {
              this.style.removeModel(e2);
            }
            listModels() {
              return this.style.listModels();
            }
            addLayer(e2, t2) {
              return this._isValidId(e2.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true)) : this;
            }
            getSlot(e2) {
              const t2 = this.getLayer(e2);
              return t2 && t2.slot || null;
            }
            setSlot(e2, t2) {
              return this.style.setSlot(e2, t2), this.style.mergeLayers(), this._update(true);
            }
            addImport(e2, t2) {
              return this.style.addImport(e2, t2), this;
            }
            updateImport(e2, t2) {
              return "string" != typeof t2 && t2.id !== e2 ? (this.removeImport(e2), this.addImport(t2)) : (this.style.updateImport(e2, t2), this._update(true));
            }
            removeImport(e2) {
              return this.style.removeImport(e2), this;
            }
            moveImport(e2, t2) {
              return this.style.moveImport(e2, t2), this._update(true);
            }
            moveLayer(e2, t2) {
              return this._isValidId(e2) ? (this.style.moveLayer(e2, t2), this._update(true)) : this;
            }
            removeLayer(e2) {
              return this._isValidId(e2) ? (this.style.removeLayer(e2), this._update(true)) : this;
            }
            getLayer(e2) {
              if (!this._isValidId(e2))
                return null;
              const t2 = this.style.getOwnLayer(e2);
              return t2 ? "custom" === t2.type ? t2.implementation : t2.serialize() : void 0;
            }
            getSlots() {
              return this.style.getSlots();
            }
            setLayerZoomRange(e2, t2, i2) {
              return this._isValidId(e2) ? (this.style.setLayerZoomRange(e2, t2, i2), this._update(true)) : this;
            }
            setFilter(e2, t2, i2 = {}) {
              return this._isValidId(e2) ? (this.style.setFilter(e2, t2, i2), this._update(true)) : this;
            }
            getFilter(e2) {
              return this._isValidId(e2) ? this.style.getFilter(e2) : null;
            }
            setPaintProperty(e2, t2, i2, o2 = {}) {
              return this._isValidId(e2) ? (this.style.setPaintProperty(e2, t2, i2, o2), this._update(true)) : this;
            }
            getPaintProperty(e2, t2) {
              return this._isValidId(e2) ? this.style.getPaintProperty(e2, t2) : null;
            }
            setLayoutProperty(e2, t2, i2, o2 = {}) {
              return this._isValidId(e2) ? (this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true)) : this;
            }
            getLayoutProperty(e2, t2) {
              return this._isValidId(e2) ? this.style.getLayoutProperty(e2, t2) : null;
            }
            getSchema(e2) {
              return this.style.getSchema(e2);
            }
            setSchema(e2, t2) {
              return this.style.setSchema(e2, t2), this._update(true);
            }
            getConfig(e2) {
              return this.style.getConfig(e2);
            }
            setConfig(e2, t2) {
              return this.style.setConfig(e2, t2), this._update(true);
            }
            getConfigProperty(e2, t2) {
              return this.style.getConfigProperty(e2, t2);
            }
            setConfigProperty(e2, t2, i2) {
              return this.style.setConfigProperty(e2, t2, i2), this._update(true);
            }
            setLights(e2) {
              if (this._lazyInitEmptyStyle(), e2 && 1 === e2.length && "flat" === e2[0].type) {
                const t2 = e2[0];
                t2.properties ? this.style.setFlatLight(t2.properties, t2.id, {}) : this.style.setFlatLight({}, "flat");
              } else
                this.style.setLights(e2), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
              return this._update(true);
            }
            getLights() {
              const e2 = this.style.getLights() || [];
              return 0 === e2.length && e2.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e2;
            }
            setLight(e2, t2 = {}) {
              return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e2 }]);
            }
            getLight() {
              return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
            }
            setTerrain(e2) {
              return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
            }
            getTerrain() {
              return this.style ? this.style.getTerrain() : null;
            }
            setFog(e2) {
              return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
            }
            getFog() {
              return this.style ? this.style.getFog() : null;
            }
            setColorTheme(e2) {
              return this._lazyInitEmptyStyle(), this.style.setColorTheme(e2), this._update(true);
            }
            setCamera(e2) {
              return this.style.setCamera(e2), this._triggerCameraUpdate(e2);
            }
            _triggerCameraUpdate(e2) {
              return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e2["camera-projection"]));
            }
            getCamera() {
              return this.style.camera;
            }
            _queryFogOpacity(t2) {
              return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.bK.convert(t2), this.transform) : 0;
            }
            setFeatureState(e2, t2) {
              return this._isValidId(e2.source) ? (this.style.setFeatureState(e2, t2), this._update()) : this;
            }
            removeFeatureState(e2, t2) {
              return this._isValidId(e2.source) ? (this.style.removeFeatureState(e2, t2), this._update()) : this;
            }
            getFeatureState(e2) {
              return this._isValidId(e2.source) ? this.style.getFeatureState(e2) : null;
            }
            _updateContainerDimensions() {
              if (!this._container)
                return;
              const e2 = this._container.getBoundingClientRect().width || 400, t2 = this._container.getBoundingClientRect().height || 300;
              let i2, o2, r2, s2 = this._container;
              for (; s2 && (!o2 || !r2); ) {
                const e3 = window.getComputedStyle(s2).transform;
                e3 && "none" !== e3 && (i2 = e3.match(/matrix.*\((.+)\)/)[1].split(", "), i2[0] && "0" !== i2[0] && "1" !== i2[0] && (o2 = i2[0]), i2[3] && "0" !== i2[3] && "1" !== i2[3] && (r2 = i2[3])), s2 = s2.parentElement;
              }
              this._containerWidth = o2 ? Math.abs(e2 / o2) : e2, this._containerHeight = r2 ? Math.abs(t2 / r2) : t2;
            }
            _detectMissingCSS() {
              "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
            }
            _setupContainer() {
              const e2 = this._container;
              e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
              const t2 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e2);
              this._canvas = l("canvas", "mapboxgl-canvas", t2), this._interactive && (t2.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
              const i2 = this._controlContainer = l("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
              ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((e3) => {
                o2[e3] = l("div", `mapboxgl-ctrl-${e3}`, i2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(t2, i2) {
              const o2 = e.q.devicePixelRatio || 1;
              this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
            }
            _addMarker(e2) {
              this._markers.push(e2);
            }
            _removeMarker(e2) {
              const t2 = this._markers.indexOf(e2);
              -1 !== t2 && this._markers.splice(t2, 1);
            }
            _addPopup(e2) {
              this._popups.push(e2);
            }
            _removePopup(e2) {
              const t2 = this._popups.indexOf(e2);
              -1 !== t2 && this._popups.splice(t2, 1);
            }
            _setupPainter() {
              const t2 = e.l({}, n.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), i2 = this._canvas.getContext("webgl2", t2);
              i2 ? (G(i2, true), this.painter = new wa(i2, this._contextCreateOptions, this.transform, this._tp), this.on("data", (e2) => {
                "source" === e2.dataType && this.painter.setTileLoadedFlag(true);
              }), e.m.testSupport(i2)) : this.fire(new e.t(new Error("Failed to initialize WebGL")));
            }
            _contextLost(t2) {
              t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.x("webglcontextlost", { originalEvent: t2 }));
            }
            _contextRestored(t2) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new e.x("webglcontextrestored", { originalEvent: t2 }));
            }
            _onMapScroll(e2) {
              if (e2.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }
            idle() {
              return !this.isMoving() && this.loaded();
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            frameReady() {
              return this.loaded() && !this._placementDirty;
            }
            _update(e2) {
              return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(e2) {
              return this._update(), this._renderTaskQueue.add(e2);
            }
            _cancelRenderFrame(e2) {
              this._renderTaskQueue.remove(e2);
            }
            _requestDomTask(e2) {
              !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
            }
            _render(t2) {
              let r2;
              this.fire(new e.x("renderstart")), ++this._frameId;
              const s2 = this.painter.context.extTimerQuery, a2 = e.q.now(), n2 = this.painter.context.gl;
              if (this.listens("gpu-timing-frame") && (r2 = n2.createQuery(), n2.beginQuery(s2.TIME_ELAPSED_EXT, r2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
                return;
              this._updateProjectionTransition();
              const l2 = this._isInitialLoad ? 0 : this._fadeDuration;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const t3 = this.transform.zoom, i2 = this.transform.pitch, o2 = e.q.now(), r3 = new e.a3(t3, { now: o2, fadeDuration: l2, pitch: i2, transition: this.style.transition });
                this.style.update(r3);
              }
              this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
              let c2 = false;
              this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), c2 = this._updateAverageElevation(a2), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : c2 = this._updateAverageElevation(a2);
              const h2 = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l2, this._crossSourceCollisions, this.painter.replacementSource);
              if (h2 && (this._placementDirty = h2.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.x("render")), this.loaded() && !this._loaded && (this._loaded = true, o.mark(i.load), this.fire(new e.x("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), r2) {
                const t3 = e.q.now() - a2;
                n2.endQuery(s2.TIME_ELAPSED_EXT), setTimeout(() => {
                  const i2 = n2.getQueryParameter(r2, n2.QUERY_RESULT) / 1e6;
                  n2.deleteQuery(r2), this.fire(new e.x("gpu-timing-frame", { cpuTime: t3, gpuTime: i2 }));
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                const t3 = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const i2 = this.painter.queryGpuTimers(t3);
                  this.fire(new e.x("gpu-timing-layer", { layerTimes: i2 }));
                }, 50);
              }
              if (this.listens("gpu-timing-deferred-render")) {
                const t3 = this.painter.collectDeferredRenderGpuQueries();
                setTimeout(() => {
                  const i2 = this.painter.queryGpuTimeDeferredRender(t3);
                  this.fire(new e.x("gpu-timing-deferred-render", { gpuTime: i2 }));
                }, 50);
              }
              const u2 = this._sourcesDirty || this._styleDirty || this._placementDirty || c2;
              if (u2 || this._repaint)
                this.triggerRepaint();
              else {
                const t3 = this.idle();
                if (t3 && (c2 = this._updateAverageElevation(a2, true)), c2)
                  this.triggerRepaint();
                else if (this._triggerFrame(false), t3 && (this.fire(new e.x("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                  const t4 = this._calculateSpeedIndex();
                  this.fire(new e.x("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
                }
              }
              !this._loaded || this._fullyLoaded || u2 || (this._fullyLoaded = true, o.mark(i.fullLoad), this._performanceMetricsCollection && k(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
            }
            _forceMarkerAndPopupUpdate(e2) {
              for (const t2 of this._markers)
                e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
              for (const t2 of this._popups)
                !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
            }
            _updateAverageElevation(e2, t2 = false) {
              const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
              if (!this.painter.averageElevationNeedsEasing())
                return 0 !== this.transform.averageElevation && i2(0);
              const o2 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
              if (o2 || (t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
                const t3 = this.transform.averageElevation;
                let r2 = this.transform.sampleAverageElevation();
                null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r2) ? r2 = 0 : this._averageElevationLastSampledAt = e2;
                const s2 = Math.abs(t3 - r2);
                if (s2 > 1) {
                  if (this._isInitialLoad || o2)
                    return this._averageElevation.jumpTo(r2), i2(r2);
                  this._averageElevation.easeTo(r2, e2, 300);
                } else if (s2 > 1e-4)
                  return this._averageElevation.jumpTo(r2), i2(r2);
              }
              return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
            }
            _authenticate() {
              N(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
                if (t2 && (t2.message === w || 401 === t2.status)) {
                  const t3 = this.painter.context.gl;
                  G(t3, false), this._logoControl instanceof Cn && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.t(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                }
              }), M(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
              });
            }
            _postStyleLoadEvent() {
              this.style.globalId && O(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
            }
            _updateTerrain() {
              const e2 = this._isDragging();
              this.painter.updateTerrain(this.style, e2);
            }
            _calculateSpeedIndex() {
              const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
              t2.timeStamps.push(performance.now());
              const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
              function r2(e3) {
                i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
                const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
                return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
              }
              return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r2(e2), t2.canvasCopies.map(r2), t2.timeStamps);
            }
            _canvasPixelComparison(e2, t2, i2) {
              let o2 = i2[1] - i2[0];
              const r2 = e2.length / 4;
              for (let s2 = 0; s2 < t2.length; s2++) {
                const a2 = t2[s2];
                let n2 = 0;
                for (let t3 = 0; t3 < a2.length; t3 += 4)
                  a2[t3] === e2[t3] && a2[t3 + 1] === e2[t3 + 1] && a2[t3 + 2] === e2[t3 + 2] && a2[t3 + 3] === e2[t3 + 3] && (n2 += 1);
                o2 += (i2[s2 + 2] - i2[s2 + 1]) * (1 - n2 / r2);
              }
              return o2;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const e2 of this._controls)
                e2.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
              const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), U.delete(this.painter.context.gl), B.remove(), P.remove(), this._removed = true, this.fire(new e.x("remove"));
            }
            triggerRepaint() {
              this._triggerFrame(true);
            }
            _triggerFrame(t2) {
              this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.q.frame((e2) => {
                const t3 = !!this._renderNextFrame;
                this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
              }));
            }
            _preloadTiles(t2) {
              const i2 = this.style ? this.style.getSourceCaches() : [];
              return e.bf(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
                this.triggerRepaint();
              }), this;
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(e2) {
              this._trackResize && this.resize({ originalEvent: e2 })._update();
            }
            _onVisibilityChange() {
              "hidden" === document.visibilityState && this._visibilityHidden++;
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(e2) {
              this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._tp.refreshUI(), this._update());
            }
            get showParseStatus() {
              return !!this._showParseStatus;
            }
            set showParseStatus(e2) {
              this._showParseStatus !== e2 && (this._showParseStatus = e2, this._tp.refreshUI(), this._update());
            }
            get showTerrainWireframe() {
              return !!this._showTerrainWireframe;
            }
            set showTerrainWireframe(e2) {
              this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._tp.refreshUI(), this._update());
            }
            get showLayers2DWireframe() {
              return !!this._showLayers2DWireframe;
            }
            set showLayers2DWireframe(e2) {
              this._showLayers2DWireframe !== e2 && (this._showLayers2DWireframe = e2, this._tp.refreshUI(), this._update());
            }
            get showLayers3DWireframe() {
              return !!this._showLayers3DWireframe;
            }
            set showLayers3DWireframe(e2) {
              this._showLayers3DWireframe !== e2 && (this._showLayers3DWireframe = e2, this._tp.refreshUI(), this._update());
            }
            get speedIndexTiming() {
              return !!this._speedIndexTiming;
            }
            set speedIndexTiming(e2) {
              this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(e2) {
              this._showPadding !== e2 && (this._showPadding = e2, this._tp.refreshUI(), this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(e2) {
              this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, this._tp.refreshUI(), e2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(e2) {
              this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._tp.refreshUI(), this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(e2) {
              this._repaint !== e2 && (this._repaint = e2, this._tp.refreshUI(), this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(e2) {
              this._vertices = e2, this._update();
            }
            get showTileAABBs() {
              return !!this._showTileAABBs;
            }
            set showTileAABBs(e2) {
              this._showTileAABBs !== e2 && (this._showTileAABBs = e2, this._tp.refreshUI(), e2 && this._update());
            }
            _setCacheLimits(t2, i2) {
              e.dy(t2, i2);
            }
            get version() {
              return t;
            }
          }, NavigationControl: class {
            constructor(t2 = {}) {
              this.options = e.l({}, Pn, t2), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.aJ(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
                this._map && this._map.zoomIn({}, { originalEvent: e2 });
              }), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
                this._map && this._map.zoomOut({}, { originalEvent: e2 });
              }), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aJ(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
                const t3 = this._map;
                t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
              }), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            _updateZoomButtons() {
              const e2 = this._map;
              if (!e2)
                return;
              const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
              this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
            }
            _rotateCompassArrow() {
              const e2 = this._map;
              if (!e2)
                return;
              const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
              e2._requestDomTask(() => {
                this._compassIcon && (this._compassIcon.style.transform = t2);
              });
            }
            onAdd(e2) {
              return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Mn(e2, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              const e2 = this._map;
              e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
            }
            _createButton(e2, t2) {
              const i2 = l("button", e2, this._container);
              return i2.type = "button", i2.addEventListener("click", t2), i2;
            }
            _setButtonTitle(e2, t2) {
              if (!this._map)
                return;
              const i2 = this._map._getUIString(`NavigationControl.${t2}`);
              e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
            }
          }, GeolocateControl: class extends e.E {
            constructor(t2 = {}) {
              super();
              const i2 = navigator.geolocation;
              this.options = e.l({ geolocation: i2 }, kn, t2), e.aJ(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Ta(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
            }
            onAdd(e2) {
              return this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
            }
            _checkGeolocationSupport(e2) {
              const t2 = (t3 = !!this.options.geolocation) => {
                this._supportsGeolocation = t3, e2(t3);
              };
              void 0 !== this._supportsGeolocation ? e2(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e3) => t2("denied" !== e3.state)).catch(() => t2()) : t2();
            }
            _isOutOfMapMaxBounds(e2) {
              const t2 = this._map.getMaxBounds(), i2 = e2.coords;
              return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              }
            }
            _onSuccess(t2) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t2))
                  return this._setErrorState(), this.fire(new e.x("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = t2, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.x("geolocate", t2)), this._finish();
              }
            }
            _updateCamera(t2) {
              const i2 = new e.bK(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r2 = this._map.getBearing(), s2 = e.l({ bearing: r2 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o2), s2, { geolocateSource: true });
            }
            _updateMarker(t2) {
              if (t2) {
                const i2 = new e.bK(t2.coords.longitude, t2.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const t2 = this._map.transform, i2 = e.bD(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
              this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _updateMarkerRotation() {
              this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
            }
            _onError(t2) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === t2.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === t2.code && this._noTimeout)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.x("error", t2)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }
            _setupUI(t2) {
              if (void 0 !== this._map) {
                if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
                  e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
                } else {
                  const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Fn({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Fn({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
                  t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.x("trackuserlocationend")));
                });
              }
            }
            _onDeviceOrientation(e2) {
              this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
            }
            trigger() {
              if (!this._setup)
                return e.w("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new e.x("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.x("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.x("trackuserlocationstart"));
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                    break;
                  case "BACKGROUND":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                    break;
                  case "BACKGROUND_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let e2;
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
                }
              } else
                this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
              return true;
            }
            _addDeviceOrientationListener() {
              const e2 = () => {
                "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
              };
              "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t2) => {
                "granted" === t2 && e2();
              }).catch(console.error) : e2();
            }
            _clearWatch() {
              this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, AttributionControl: En, ScaleControl: class {
            constructor(t2 = {}) {
              this.options = e.l({}, Bn, t2), this._isNumberFormatSupported = function() {
                try {
                  return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
                } catch (e2) {
                  return false;
                }
              }(), e.aJ(["_update", "_setScale", "setUnit"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _update() {
              const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, r2 = t2.unproject([o2, i2]), s2 = t2.unproject([o2 + e2, i2]), a2 = r2.distanceTo(s2);
              if ("imperial" === this.options.unit) {
                const t3 = 3.2808 * a2;
                t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
              } else
                "nautical" === this.options.unit ? this._setScale(e2, a2 / 1852, "nautical-mile") : a2 >= 1e3 ? this._setScale(e2, a2 / 1e3, "kilometer") : this._setScale(e2, a2, "meter");
            }
            _setScale(e2, t2, i2) {
              this._map._requestDomTask(() => {
                const o2 = function(e3) {
                  const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
                  let i3 = e3 / t3;
                  return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                    const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                    return Math.round(e4 * t4) / t4;
                  }(i3), t3 * i3;
                }(t2), r2 = o2 / t2;
                this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i2 }).format(o2) : `${o2}&nbsp;${Nn[i2]}`, this._container.style.width = e2 * r2 + "px";
              });
            }
            onAdd(e2) {
              return this._map = e2, this._language = e2.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("move", this._update), this._map = void 0;
            }
            _setLanguage(e2) {
              this._language = e2, this._update();
            }
            setUnit(e2) {
              this.options.unit = e2, this._update();
            }
          }, FullscreenControl: class {
            constructor(t2 = {}) {
              this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), e.aJ(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
            }
            onAdd(t2) {
              return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
            }
            onRemove() {
              this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const e2 = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
              l("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const e2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          }, Popup: class extends e.E {
            constructor(t2) {
              super(), this.options = e.l(Object.create(Un), t2), e.aJ(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
            }
            addTo(t2) {
              return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.x("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
              const t2 = this._map;
              return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.x("close")), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t2) {
              this._lngLat = e.bK.convert(t2), this._pos = null, this._trackPointer = false, this._update();
              const i2 = this._map;
              return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
            }
            trackPointer() {
              this._trackPointer = true, this._pos = null, this._update();
              const e2 = this._map;
              return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(e2) {
              return this.setDOMContent(document.createTextNode(e2));
            }
            setHTML(e2) {
              const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
              let o2;
              for (i2.innerHTML = e2; o2 = i2.firstChild, o2; )
                t2.appendChild(o2);
              return this.setDOMContent(t2);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(e2) {
              return this.options.maxWidth = e2, this._update(), this;
            }
            setDOMContent(e2) {
              let t2 = this._content;
              if (t2)
                for (; t2.hasChildNodes(); )
                  t2.firstChild && t2.removeChild(t2.firstChild);
              else
                t2 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
              if (t2.appendChild(e2), this.options.closeButton) {
                const e3 = this._closeButton = l("button", "mapboxgl-popup-close-button", t2);
                e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
              }
              return this._update(), this._focusFirstElement(), this;
            }
            addClassName(e2) {
              return this._classList.add(e2), this._updateClassList(), this;
            }
            removeClassName(e2) {
              return this._classList.delete(e2), this._updateClassList(), this;
            }
            setOffset(e2) {
              return this.options.offset = e2, this._update(), this;
            }
            toggleClassName(e2) {
              let t2;
              return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
            }
            _onMouseEvent(e2) {
              this._update(e2.point);
            }
            _getAnchor(e2) {
              if (this.options.anchor)
                return this.options.anchor;
              const t2 = this._map, i2 = this._container, o2 = this._pos;
              if (!t2 || !i2 || !o2)
                return "bottom";
              const r2 = i2.offsetWidth, s2 = i2.offsetHeight, a2 = o2.x < r2 / 2, n2 = o2.x > t2.transform.width - r2 / 2;
              if (o2.y + e2 < s2)
                return a2 ? "top-left" : n2 ? "top-right" : "top";
              if (o2.y > t2.transform.height - s2) {
                if (a2)
                  return "bottom-left";
                if (n2)
                  return "bottom-right";
              }
              return a2 ? "left" : n2 ? "right" : "bottom";
            }
            _updateClassList() {
              const e2 = this._container;
              if (!e2)
                return;
              const t2 = [...this._classList];
              t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
            }
            _update(t2) {
              const i2 = this._map, o2 = this._content;
              if (!i2 || !this._lngLat && !this._trackPointer || !o2)
                return;
              let r2 = this._container;
              if (r2 || (r2 = this._container = l("div", "mapboxgl-popup", i2.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", r2), r2.appendChild(o2)), this.options.maxWidth && r2.style.maxWidth !== this.options.maxWidth && (r2.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = zn(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
                const o3 = this._pos = this._trackPointer && t2 instanceof e.P ? t2 : i2.project(this._lngLat), r3 = jn(this.options.offset), s2 = this._anchor = this._getAnchor(r3.y), a2 = jn(this.options.offset, s2), n2 = o3.add(a2).round();
                i2._requestDomTask(() => {
                  this._container && s2 && (this._container.style.transform = `${On[s2]} translate(${n2.x}px,${n2.y}px)`);
                });
              }
              if (!this._marker && i2._showingGlobe()) {
                const t3 = e.dz(i2.transform, this._lngLat) ? 0 : 1;
                this._setOpacity(t3);
              }
              this._updateClassList();
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const e2 = this._container.querySelector(Gn);
              e2 && e2.focus();
            }
            _onClose() {
              this.remove();
            }
            _setOpacity(e2) {
              this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
            }
          }, Marker: Fn, Style: co, LngLat: e.bK, LngLatBounds: e.as, Point: e.P, MercatorCoordinate: e.a5, FreeCameraOptions: Ui, Evented: e.E, config: e.e, prewarm: e.dE, clearPrewarmedResources: e.dF, get accessToken() {
            return e.e.ACCESS_TOKEN;
          }, set accessToken(t2) {
            e.e.ACCESS_TOKEN = t2;
          }, get baseApiUrl() {
            return e.e.API_URL;
          }, set baseApiUrl(t2) {
            e.e.API_URL = t2;
          }, get workerCount() {
            return e.dG.workerCount;
          }, set workerCount(t2) {
            e.dG.workerCount = t2;
          }, get maxParallelImageRequests() {
            return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(t2) {
            e.e.MAX_PARALLEL_IMAGE_REQUESTS = t2;
          }, clearStorage(t2) {
            e.dH(t2);
          }, get workerUrl() {
            return e.dI.workerUrl;
          }, set workerUrl(t2) {
            e.dI.workerUrl = t2;
          }, get workerClass() {
            return e.dI.workerClass;
          }, set workerClass(t2) {
            e.dI.workerClass = t2;
          }, get workerParams() {
            return e.dI.workerParams;
          }, set workerParams(t2) {
            e.dI.workerParams = t2;
          }, get dracoUrl() {
            return e.dJ();
          }, set dracoUrl(t2) {
            e.dK(t2);
          }, get meshoptUrl() {
            return e.dL();
          }, set meshoptUrl(t2) {
            e.dM(t2);
          }, setNow: e.q.setNow, restoreNow: e.q.restoreNow };
        });
        var mapboxgl$1 = mapboxgl2;
        return mapboxgl$1;
      });
    }
  });

  // src/index.ts
  init_live_reload();

  // src/utils/catalogue/catalogueCount.ts
  init_live_reload();
  function updateCatalogueCount() {
    const accordionItems = document.querySelectorAll(".catalogue_side-filter_accordion-item");
    accordionItems.forEach((item) => {
      const checkedInputs = item.querySelectorAll(".w--redirected-checked");
      const countElement = item.querySelector(".catalogue_side-filter_cat-number");
      if (countElement) {
        countElement.textContent = checkedInputs.length.toString();
        if (parseInt(countElement.textContent || "0") > 0) {
          countElement.style.display = "flex";
        } else {
          countElement.style.display = "none";
        }
      }
    });
  }
  document.addEventListener("DOMContentLoaded", () => {
    updateCatalogueCount();
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && mutation.attributeName === "class") {
          updateCatalogueCount();
        }
      });
    });
    const config3 = { attributes: true, attributeFilter: ["class"], subtree: true };
    document.querySelectorAll(".catalogue_side-filter_accordion-item").forEach((item) => {
      observer.observe(item, config3);
    });
  });
  document.addEventListener("change", (event2) => {
    const target = event2.target;
    if (target && target.closest(".catalogue_side-filter_accordion-item")) {
      updateCatalogueCount();
    }
  });
  function catalogueFilterCount() {
    function countAndUpdate(attribute) {
      const collectionList = document.querySelector(".catalogue_content_collection-list.is-filter");
      if (!collectionList)
        return;
      const labelElements = document.querySelectorAll(`[filter-count-label="${attribute}"]`);
      labelElements.forEach((labelElement) => {
        const labelText = labelElement.textContent?.trim();
        if (labelText) {
          const elements = collectionList.querySelectorAll(`[filter-count="${attribute}"]`);
          let count = 0;
          elements.forEach((element) => {
            if (element.textContent && element.textContent.trim() === labelText) {
              count += 1;
            }
          });
          const siblingNumberElement = labelElement.parentElement?.querySelector(
            `[filter-count-number="${attribute}"]`
          );
          if (siblingNumberElement) {
            siblingNumberElement.textContent = count.toString();
          }
        }
      });
    }
    countAndUpdate("terroirs");
    countAndUpdate("varietes");
    countAndUpdate("applications");
    countAndUpdate("profils");
    countAndUpdate("labels");
    countAndUpdate("commerce-e");
    countAndUpdate("agro-e");
    countAndUpdate("transfo");
  }

  // src/utils/catalogue/catalogueFilter.ts
  init_live_reload();
  function catalogueCat() {
    const catalogueCatAll = document.querySelector(
      ".catalogue_top-filter_cat-field.is-all.is-active"
    );
    const catalogueCatFilters = document.querySelectorAll(
      ".catalogue_top-filter_cat-field.is-filter"
    );
    catalogueCatFilters.forEach((filter) => {
      filter.addEventListener("click", () => {
        if (catalogueCatAll) {
          catalogueCatAll.classList.remove("is-active");
        }
      });
    });
    catalogueCatAll?.addEventListener("click", () => {
      catalogueCatAll.classList.add("is-active");
    });
    const catalogueCatAllField = document.querySelector(".catalogue_top-filter_cat-field.is-all");
    const checkNoActiveFilter = () => {
      const activeFilters = document.querySelectorAll(
        ".catalogue_top-filter_cat-field.is-filter.is-active"
      );
      if (activeFilters.length === 0 && catalogueCatAllField) {
        catalogueCatAllField.classList.add("is-active");
      }
    };
    catalogueCatFilters.forEach((filter) => {
      filter.addEventListener("click", () => {
        setTimeout(checkNoActiveFilter, 0);
      });
    });
    checkNoActiveFilter();
  }

  // src/utils/catalogue/catalogueLoader.ts
  init_live_reload();
  function catalogueLoader() {
    const loadingElement = document.querySelector(".section_loader");
    const isLoadElements = document.querySelectorAll(".is-load");
    isLoadElements.forEach((element) => {
      const el = element;
      el.style.opacity = "0";
      el.style.transform = "translateY(-5rem)";
      el.style.display = "none";
    });
    if (loadingElement) {
      const loadEl = loadingElement;
      loadEl.style.transition = "all 250ms ease-in";
      loadEl.style.opacity = "0";
      loadEl.style.transform = "translateY(100%)";
      loadEl.style.display = "none";
    }
    isLoadElements.forEach((element) => {
      const el = element;
      el.style.display = "block";
      setTimeout(() => {
        el.style.transition = "all 250ms ease-in";
        el.style.opacity = "1";
        el.style.transform = "translateY(0)";
      }, 10);
    });
  }

  // src/utils/catalogue/catalogueQuickFix.ts
  init_live_reload();
  function fixCatalogueCategoriesText() {
    const categoryElements = document.querySelectorAll(".catalogue_cards_categorie");
    categoryElements.forEach((element) => {
      if (element instanceof HTMLElement) {
        const trimmedText = element.textContent?.trim();
        switch (trimmedText) {
          case "couvertures pure origine":
            element.textContent = "couverture pure origine";
            break;
          case "chocolats d'atelier":
            element.textContent = "chocolat d'atelier";
            break;
          case "f\xE8ves":
            element.textContent = "f\xE8ve";
            break;
          case "ingr\xE9dients":
            element.textContent = "ingr\xE9dient";
            break;
        }
      }
    });
  }
  function hideEmptyLabelsContainer() {
    const labelsContainers = document.querySelectorAll(".catalogue_cards_sec-labels-w");
    labelsContainers.forEach((container) => {
      if (container instanceof HTMLElement) {
        const { children } = container;
        const allChildrenInvisible = Array.from(children).every(
          (child) => child.classList.contains("w-condition-invisible")
        );
        if (allChildrenInvisible) {
          container.style.display = "none";
        } else {
          container.style.display = "";
        }
      }
    });
  }

  // src/utils/contact/formInput.ts
  init_live_reload();
  function formInputLabels() {
    const formInputs = document.querySelectorAll(".form_input");
    formInputs.forEach((input) => {
      const label = input.nextElementSibling;
      input.addEventListener("click", () => {
        if (label && label.classList.contains("form_label")) {
          label.classList.add("is-active");
        }
      });
      input.addEventListener("input", () => {
        if (label && label.classList.contains("form_label")) {
          if (input.value !== "") {
            label.classList.add("is-active");
          } else {
            label.classList.remove("is-active");
          }
        }
      });
      input.addEventListener("blur", () => {
        if (label && label.classList.contains("form_label") && input.value === "") {
          label.classList.remove("is-active");
        }
      });
    });
  }
  function showSiret() {
    const siretTriggers = document.querySelectorAll("#project_siret-on, #sample_siret-on");
    const siretContainers = document.querySelectorAll("#project_siret-input, #sample_siret-input");
    siretTriggers.forEach((siretTrigger, index) => {
      const siretContainer = siretContainers[index];
      if (siretTrigger && siretContainer) {
        const { parentElement } = siretTrigger;
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName === "class") {
              if (parentElement?.classList.contains("is-active-inputactive")) {
                siretContainer.style.display = "flex";
              } else {
                siretContainer.style.display = "none";
              }
            }
          });
        });
        observer.observe(parentElement, { attributes: true });
      }
    });
  }

  // src/utils/global/loadScript.ts
  init_live_reload();
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = src;
      script.async = true;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
      document.head.appendChild(script);
    });
  }

  // src/utils/global/navbar.ts
  init_live_reload();
  var lastScrollTop = 0;
  function navScroll() {
    const navbar = document.querySelector(".nav_desktop");
    const navButton = navbar?.querySelector(".nav_button-wrapper");
    if (!navbar || !navButton)
      return;
    navbar.style.transition = "transform 0.25s ease-out";
    navButton.style.transition = "transform 0.25s ease-out";
    window.addEventListener("scroll", () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const isScrollingDown = scrollTop > lastScrollTop;
      const isAboveThreshold = scrollTop > 18 * 16;
      if (isScrollingDown && isAboveThreshold) {
        navbar.style.transform = "translateY(-5rem)";
        navButton.style.transform = "translateY(5rem)";
      } else {
        navbar.style.transform = "translateY(0)";
        navButton.style.transform = "translateY(0)";
      }
      lastScrollTop = scrollTop;
    });
  }
  function setCurrentDropdownState() {
    const dropdowns = document.querySelectorAll(".nav_dropdown");
    dropdowns.forEach((dropdown) => {
      const currentRow = dropdown.querySelector(".nav_dropdown-list-row.w--current");
      const toggleLink = dropdown.querySelector(".nav_link-wrapper.is-toggle");
      if (currentRow && toggleLink) {
        toggleLink.classList.add("is-current");
      }
    });
  }
  function setCurrentRowFromURL() {
    const dropdownRows = document.querySelectorAll(".nav_dropdown-list-row");
    const currentURL = window.location.href;
    dropdownRows.forEach((row) => {
      const rowLink = row.getAttribute("href");
      if (!rowLink)
        return;
      const decodedRowLink = decodeURIComponent(rowLink);
      const decodedCurrentURL = decodeURIComponent(currentURL);
      if (decodedCurrentURL.includes(decodedRowLink)) {
        row.classList.add("w--current");
      }
    });
  }

  // src/utils/global/swiper.ts
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/swiper-bundle.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/swiper-core.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/ssr-window.esm.mjs
  init_live_reload();
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend(target, src) {
    if (target === void 0) {
      target = {};
    }
    if (src === void 0) {
      src = {};
    }
    Object.keys(src).forEach((key) => {
      if (typeof target[key] === "undefined")
        target[key] = src[key];
      else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
        extend(target[key], src[key]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend(doc, ssrDocument);
    return doc;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend(win, ssrWindow);
    return win;
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/utils.mjs
  init_live_reload();
  function classesToTokens(classes2) {
    if (classes2 === void 0) {
      classes2 = "";
    }
    return classes2.trim().split(" ").filter((c) => !!c.trim());
  }
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
      }
      try {
        delete object[key];
      } catch (e) {
      }
    });
  }
  function nextTick(callback, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return setTimeout(callback, delay);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis) {
    if (axis === void 0) {
      axis = "x";
    }
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m41;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[12]);
      else
        curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m42;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[13]);
      else
        curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject2(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend2() {
    const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i = 1; i < arguments.length; i += 1) {
      const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll(_ref) {
    let {
      swiper,
      targetPosition,
      side
    } = _ref;
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = "hidden";
        swiper.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = "";
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }
      swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }
  function getSlideTransformEl(slideEl) {
    return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
  }
  function elementChildren(element, selector3) {
    if (selector3 === void 0) {
      selector3 = "";
    }
    const children = [...element.children];
    if (element instanceof HTMLSlotElement) {
      children.push(...element.assignedElements());
    }
    if (!selector3) {
      return children;
    }
    return children.filter((el) => el.matches(selector3));
  }
  function elementIsChildOf(el, parent2) {
    const isChild = parent2.contains(el);
    if (!isChild && parent2 instanceof HTMLSlotElement) {
      const children = [...parent2.assignedElements()];
      return children.includes(el);
    }
    return isChild;
  }
  function showWarning(text) {
    try {
      console.warn(text);
      return;
    } catch (err) {
    }
  }
  function createElement(tag, classes2) {
    if (classes2 === void 0) {
      classes2 = [];
    }
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
    return el;
  }
  function elementOffset(el) {
    const window2 = getWindow();
    const document2 = getDocument();
    const box = el.getBoundingClientRect();
    const body = document2.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
    const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }
  function elementPrevAll(el, selector3) {
    const prevEls = [];
    while (el.previousElementSibling) {
      const prev = el.previousElementSibling;
      if (selector3) {
        if (prev.matches(selector3))
          prevEls.push(prev);
      } else
        prevEls.push(prev);
      el = prev;
    }
    return prevEls;
  }
  function elementNextAll(el, selector3) {
    const nextEls = [];
    while (el.nextElementSibling) {
      const next = el.nextElementSibling;
      if (selector3) {
        if (next.matches(selector3))
          nextEls.push(next);
      } else
        nextEls.push(next);
      el = next;
    }
    return nextEls;
  }
  function elementStyle(el, prop) {
    const window2 = getWindow();
    return window2.getComputedStyle(el, null).getPropertyValue(prop);
  }
  function elementIndex(el) {
    let child = el;
    let i;
    if (child) {
      i = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1)
          i += 1;
      }
      return i;
    }
    return void 0;
  }
  function elementParents(el, selector3) {
    const parents = [];
    let parent2 = el.parentElement;
    while (parent2) {
      if (selector3) {
        if (parent2.matches(selector3))
          parents.push(parent2);
      } else {
        parents.push(parent2);
      }
      parent2 = parent2.parentElement;
    }
    return parents;
  }
  function elementTransitionEnd(el, callback) {
    function fireCallBack(e) {
      if (e.target !== el)
        return;
      callback.call(el, e);
      el.removeEventListener("transitionend", fireCallBack);
    }
    if (callback) {
      el.addEventListener("transitionend", fireCallBack);
    }
  }
  function elementOuterSize(el, size, includeMargins) {
    const window2 = getWindow();
    if (includeMargins) {
      return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
    }
    return el.offsetWidth;
  }
  function makeElementsArray(el) {
    return (Array.isArray(el) ? el : [el]).filter((e) => !!e);
  }
  function getRotateFix(swiper) {
    return (v) => {
      if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
        return v + 1e-3;
      }
      return v;
    };
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/swiper-core.mjs
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }
  var deviceCached;
  function calcDevice(_temp) {
    let {
      userAgent
    } = _temp === void 0 ? {} : _temp;
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad)
        ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    const device = getDevice();
    let needPerspectiveFix = false;
    function isSafari() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    if (isSafari()) {
      const ua = String(window2.navigator.userAgent);
      if (ua.includes("Version/")) {
        const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
        needPerspectiveFix = major < 16 || major === 16 && minor < 2;
      }
    }
    const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
    const isSafariBrowser = isSafari();
    const need3dFix = isSafariBrowser || isWebView && device.ios;
    return {
      isSafari: needPerspectiveFix || isSafariBrowser,
      needPerspectiveFix,
      need3dFix,
      isWebView
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }
  function Resize(_ref) {
    let {
      swiper,
      on,
      emit
    } = _ref;
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      observer = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach((_ref2) => {
            let {
              contentBoxSize,
              contentRect,
              target
            } = _ref2;
            if (target && target !== swiper.el)
              return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      emit("orientationchange");
    };
    on("init", () => {
      if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }
  function Observer(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const observers = [];
    const window2 = getWindow();
    const attach = function(target, options) {
      if (options === void 0) {
        options = {};
      }
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer = new ObserverFunc((mutations) => {
        if (swiper.__preventObserver__)
          return;
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer);
    };
    const init4 = () => {
      if (!swiper.params.observer)
        return;
      if (swiper.params.observeParents) {
        const containerParents = elementParents(swiper.hostEl);
        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      }
      attach(swiper.hostEl, {
        childList: swiper.params.observeSlideChildren
      });
      attach(swiper.wrapperEl, {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach((observer) => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on("init", init4);
    on("destroy", destroy);
  }
  var eventsEmitter = {
    on(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler !== "function")
        return self2;
      const method = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self2.eventsListeners[event2])
          self2.eventsListeners[event2] = [];
        self2.eventsListeners[event2][method](handler);
      });
      return self2;
    },
    once(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler !== "function")
        return self2;
      function onceHandler() {
        self2.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        handler.apply(self2, args);
      }
      onceHandler.__emitterProxy = handler;
      return self2.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler !== "function")
        return self2;
      const method = priority ? "unshift" : "push";
      if (self2.eventsAnyListeners.indexOf(handler) < 0) {
        self2.eventsAnyListeners[method](handler);
      }
      return self2;
    },
    offAny(handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsAnyListeners)
        return self2;
      const index = self2.eventsAnyListeners.indexOf(handler);
      if (index >= 0) {
        self2.eventsAnyListeners.splice(index, 1);
      }
      return self2;
    },
    off(events2, handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsListeners)
        return self2;
      events2.split(" ").forEach((event2) => {
        if (typeof handler === "undefined") {
          self2.eventsListeners[event2] = [];
        } else if (self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler, index) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self2.eventsListeners[event2].splice(index, 1);
            }
          });
        }
      });
      return self2;
    },
    emit() {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsListeners)
        return self2;
      let events2;
      let data;
      let context3;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data = args.slice(1, args.length);
        context3 = self2;
      } else {
        events2 = args[0].events;
        data = args[0].data;
        context3 = args[0].context || self2;
      }
      data.unshift(context3);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
          self2.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context3, [event2, ...data]);
          });
        }
        if (self2.eventsListeners && self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context3, data);
          });
        }
      });
      return self2;
    }
  };
  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = el.clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = el.clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    }
    width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
    height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
    if (Number.isNaN(width))
      width = 0;
    if (Number.isNaN(height))
      height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }
  function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {
      wrapperEl,
      slidesEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;
    slides.forEach((slideEl) => {
      if (rtl) {
        slideEl.style.marginLeft = "";
      } else {
        slideEl.style.marginRight = "";
      }
      slideEl.style.marginBottom = "";
      slideEl.style.marginTop = "";
    });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
      swiper.grid.initSlides(slides);
    } else if (swiper.grid) {
      swiper.grid.unsetSlides();
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
      return typeof params.breakpoints[key].slidesPerView !== "undefined";
    }).length > 0;
    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      let slide2;
      if (slides[i])
        slide2 = slides[i];
      if (gridEnabled) {
        swiper.grid.updateSlide(i, slide2, slides);
      }
      if (slides[i] && elementStyle(slide2, "display") === "none")
        continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i].style[swiper.getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide2);
        const currentTransform = slide2.style.transform;
        const currentWebKitTransform = slide2.style.webkitTransform;
        if (currentTransform) {
          slide2.style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
        } else {
          const width = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide2;
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide2.style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
        if (slides[i]) {
          slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3)
          slidePosition = 0;
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
      wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths)
          slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (isVirtual && params.loop) {
      const size = slidesSizesGrid[0] + spaceBetween;
      if (params.slidesPerGroup > 1) {
        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
        const groupSize = size * params.slidesPerGroup;
        for (let i = 0; i < groups; i += 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
        }
      }
      for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
        if (params.slidesPerGroup === 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + size);
        }
        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
        swiper.virtualSize += size;
      }
    }
    if (snapGrid.length === 0)
      snapGrid = [0];
    if (spaceBetween !== 0) {
      const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
      slides.filter((_, slideIndex) => {
        if (!params.cssMode || params.loop)
          return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).forEach((slideEl) => {
        slideEl.style[key] = `${spaceBetween}px`;
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
      snapGrid = snapGrid.map((snap3) => {
        if (snap3 <= 0)
          return -offsetBefore;
        if (snap3 > maxSnap)
          return maxSnap + offsetAfter;
        return snap3;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
      if (allSlidesSize + offsetSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
        snapGrid.forEach((snap3, snapIndex) => {
          snapGrid[snapIndex] = snap3 - allSlidesOffset;
        });
        slidesGrid.forEach((snap3, snapIndex) => {
          slidesGrid[snapIndex] = snap3 + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow)
        swiper.checkOverflow();
      swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    swiper.emit("slidesUpdated");
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded)
          swiper.el.classList.add(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.el.classList.remove(backFaceHiddenClass);
      }
    }
  }
  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i;
    if (typeof speed === "number") {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index) => {
      if (isVirtual) {
        return swiper.slides[swiper.getSlideIndexByData(index)];
      }
      return swiper.slides[index];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || []).forEach((slide2) => {
          activeSlides.push(slide2);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          const index = swiper.activeIndex + i;
          if (index > swiper.slides.length && !isVirtual)
            break;
          activeSlides.push(getSlideByIndex(index));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== "undefined") {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }
    if (newHeight || newHeight === 0)
      swiper.wrapperEl.style.height = `${newHeight}px`;
  }
  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
  }
  var toggleSlideClasses$1 = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) {
      slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
      slideEl.classList.remove(className);
    }
  };
  function updateSlidesProgress(translate2) {
    if (translate2 === void 0) {
      translate2 = this && this.translate || 0;
    }
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0)
      return;
    if (typeof slides[0].swiperSlideOffset === "undefined")
      swiper.updateSlidesOffset();
    let offsetCenter = -translate2;
    if (rtl)
      offsetCenter = translate2;
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slide2 = slides[i];
      let slideOffset = slide2.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide2);
        swiper.visibleSlidesIndexes.push(i);
      }
      toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
      toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
      slide2.progress = rtl ? -slideProgress : slideProgress;
      slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
  }
  function updateProgress(translate2) {
    const swiper = this;
    if (typeof translate2 === "undefined") {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd,
      progressLoop
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate2 - swiper.minTranslate()) / translatesDiff;
      const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
      const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
      isBeginning = isBeginningRounded || progress <= 0;
      isEnd = isEndRounded || progress >= 1;
      if (isBeginningRounded)
        progress = 0;
      if (isEndRounded)
        progress = 1;
    }
    if (params.loop) {
      const firstSlideIndex = swiper.getSlideIndexByData(0);
      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
      const translateAbs = Math.abs(translate2);
      if (translateAbs >= firstSlideTranslate) {
        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
      } else {
        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
      }
      if (progressLoop > 1)
        progressLoop -= 1;
    }
    Object.assign(swiper, {
      progress,
      progressLoop,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
      swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) {
      swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
  }
  var toggleSlideClasses = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) {
      slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
      slideEl.classList.remove(className);
    }
  };
  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      slidesEl,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = (selector3) => {
      return elementChildren(slidesEl, `.${params.slideClass}${selector3}, swiper-slide${selector3}`)[0];
    };
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) {
      if (params.loop) {
        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
        if (slideIndex < 0)
          slideIndex = swiper.virtual.slides.length + slideIndex;
        if (slideIndex >= swiper.virtual.slides.length)
          slideIndex -= swiper.virtual.slides.length;
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
      } else {
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
      }
    } else {
      if (gridEnabled) {
        activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];
        nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];
        prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];
      } else {
        activeSlide = slides[activeIndex];
      }
    }
    if (activeSlide) {
      if (!gridEnabled) {
        nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !nextSlide) {
          nextSlide = slides[0];
        }
        prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !prevSlide === 0) {
          prevSlide = slides[slides.length - 1];
        }
      }
    }
    slides.forEach((slideEl) => {
      toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
      toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
      toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
    });
    swiper.emitSlidesClasses();
  }
  var processLazyPreloader = (swiper, imageEl) => {
    if (!swiper || swiper.destroyed || !swiper.params)
      return;
    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
      let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      if (!lazyEl && swiper.isElement) {
        if (slideEl.shadowRoot) {
          lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        } else {
          requestAnimationFrame(() => {
            if (slideEl.shadowRoot) {
              lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
              if (lazyEl)
                lazyEl.remove();
            }
          });
        }
      }
      if (lazyEl)
        lazyEl.remove();
    }
  };
  var unlazy = (swiper, index) => {
    if (!swiper.slides[index])
      return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl)
      imageEl.removeAttribute("loading");
  };
  var preload = (swiper) => {
    if (!swiper || swiper.destroyed || !swiper.params)
      return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0)
      return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
      const activeColumn = activeIndex;
      const preloadColumns = [activeColumn - amount];
      preloadColumns.push(...Array.from({
        length: amount
      }).map((_, i) => {
        return activeColumn + slidesPerView + i;
      }));
      swiper.slides.forEach((slideEl, i) => {
        if (preloadColumns.includes(slideEl.column))
          unlazy(swiper, i);
      });
      return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
      for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
        const realIndex = (i % len + len) % len;
        if (realIndex < activeIndex || realIndex > slideIndexLastInView)
          unlazy(swiper, realIndex);
      }
    } else {
      for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
        if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
          unlazy(swiper, i);
        }
      }
    }
  };
  function getActiveIndexByTranslate(swiper) {
    const {
      slidesGrid,
      params
    } = swiper;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate2 >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
    return activeIndex;
  }
  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = (aIndex) => {
      let realIndex2 = aIndex - swiper.virtual.slidesBefore;
      if (realIndex2 < 0) {
        realIndex2 = swiper.virtual.slides.length + realIndex2;
      }
      if (realIndex2 >= swiper.virtual.slides.length) {
        realIndex2 -= swiper.virtual.slides.length;
      }
      return realIndex2;
    };
    if (typeof activeIndex === "undefined") {
      activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate2) >= 0) {
      snapIndex = snapGrid.indexOf(translate2);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit("snapIndexChange");
      }
      return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.realIndex = getVirtualRealIndex(activeIndex);
      return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
      realIndex = getVirtualRealIndex(activeIndex);
    } else if (gridEnabled) {
      const firstSlideInColumn = swiper.slides.filter((slideEl) => slideEl.column === activeIndex)[0];
      let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
      if (Number.isNaN(activeSlideIndex)) {
        activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
      }
      realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
      const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
      if (slideIndex) {
        realIndex = parseInt(slideIndex, 10);
      } else {
        realIndex = activeIndex;
      }
    } else {
      realIndex = activeIndex;
    }
    Object.assign(swiper, {
      previousSnapIndex,
      snapIndex,
      previousRealIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    if (swiper.initialized) {
      preload(swiper);
    }
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
      }
      swiper.emit("slideChange");
    }
  }
  function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
      [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {
        if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
          slide2 = pathEl;
        }
      });
    }
    let slideFound = false;
    let slideIndex;
    if (slide2) {
      for (let i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide2) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }
    if (slide2 && slideFound) {
      swiper.clickedSlide = slide2;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = void 0;
      swiper.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }
  var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };
  function getSwiperTranslate(axis) {
    if (axis === void 0) {
      axis = this.isHorizontal() ? "x" : "y";
    }
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate: translate2,
      wrapperEl
    } = swiper;
    if (params.virtualTranslate) {
      return rtl ? -translate2 : translate2;
    }
    if (params.cssMode) {
      return translate2;
    }
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl)
      currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }
  function setTranslate(translate2, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      wrapperEl,
      progress
    } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper.isHorizontal()) {
      x = rtl ? -translate2 : translate2;
    } else {
      y = translate2;
    }
    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      if (swiper.isHorizontal()) {
        x -= swiper.cssOverflowAdjustment();
      } else {
        y -= swiper.cssOverflowAdjustment();
      }
      wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
    }
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate2);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
  }
  function minTranslate() {
    return -this.snapGrid[0];
  }
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) {
      translate2 = 0;
    }
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (translateBounds === void 0) {
      translateBounds = true;
    }
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate2 > minTranslate2)
      newTranslate = minTranslate2;
    else if (translateBounds && translate2 < maxTranslate2)
      newTranslate = maxTranslate2;
    else
      newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionEnd");
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionStart");
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {
            if (!swiper || swiper.destroyed)
              return;
            if (e.target !== this)
              return;
            swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            swiper.animating = false;
            if (runCallbacks) {
              swiper.emit("transitionEnd");
            }
          };
        }
        swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }
  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };
  function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
      swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
    }
    swiper.emit("setTransition", duration, byController);
  }
  function transitionEmit(_ref) {
    let {
      swiper,
      runCallbacks,
      direction,
      step
    } = _ref;
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex)
        dir = "next";
      else if (activeIndex < previousIndex)
        dir = "prev";
      else
        dir = "reset";
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }
      swiper.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }
  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode)
      return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "Start"
    });
  }
  function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode)
      return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "End"
    });
  }
  var transition = {
    setTransition,
    transitionStart,
    transitionEnd
  };
  function slideTo(index, speed, runCallbacks, internal, initial) {
    if (index === void 0) {
      index = 0;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index === "string") {
      index = parseInt(index, 10);
    }
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0)
      slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;
    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    const translate2 = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate2 * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
        if (typeof slidesGrid[i + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit("beforeSlideChangeStart");
    }
    swiper.updateProgress(translate2);
    let direction;
    if (slideIndex > activeIndex)
      direction = "next";
    else if (slideIndex < activeIndex)
      direction = "prev";
    else
      direction = "reset";
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const isInitialVirtual = isVirtual && initial;
    if (!isInitialVirtual && (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate)) {
      swiper.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper.setTranslate(translate2);
      }
      if (direction !== "reset") {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t = rtl ? translate2 : -translate2;
      if (speed === 0) {
        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = "none";
          swiper._immediateVirtual = true;
        }
        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
          swiper._cssModeVirtualInitialSet = true;
          requestAnimationFrame(() => {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
          });
        } else {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        }
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = "";
            swiper._immediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate2);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {
          if (!swiper || swiper.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
  }
  function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) {
      index = 0;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index === "string") {
      const indexAsNumber = parseInt(index, 10);
      index = indexAsNumber;
    }
    const swiper = this;
    if (swiper.destroyed)
      return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index;
    if (swiper.params.loop) {
      if (swiper.virtual && swiper.params.virtual.enabled) {
        newIndex = newIndex + swiper.virtual.slidesBefore;
      } else {
        let targetSlideIndex;
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          targetSlideIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          targetSlideIndex = swiper.getSlideIndexByData(newIndex);
        }
        const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
        const {
          centeredSlides
        } = swiper.params;
        let slidesPerView = swiper.params.slidesPerView;
        if (slidesPerView === "auto") {
          slidesPerView = swiper.slidesPerViewDynamic();
        } else {
          slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
          if (centeredSlides && slidesPerView % 2 === 0) {
            slidesPerView = slidesPerView + 1;
          }
        }
        let needLoopFix = cols - targetSlideIndex < slidesPerView;
        if (centeredSlides) {
          needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
        }
        if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) {
          needLoopFix = false;
        }
        if (needLoopFix) {
          const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
          swiper.loopFix({
            direction,
            slideTo: true,
            activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
            slideRealIndex: direction === "next" ? swiper.realIndex : void 0
          });
        }
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          newIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          newIndex = swiper.getSlideIndexByData(newIndex);
        }
      }
    }
    requestAnimationFrame(() => {
      swiper.slideTo(newIndex, speed, runCallbacks, internal);
    });
    return swiper;
  }
  function slideNext(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      enabled,
      params,
      animating
    } = swiper;
    if (!enabled || swiper.destroyed)
      return swiper;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding)
        return false;
      swiper.loopFix({
        direction: "next"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
      if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
        requestAnimationFrame(() => {
          swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        });
        return true;
      }
    }
    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  function slidePrev(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled,
      animating
    } = swiper;
    if (!enabled || swiper.destroyed)
      return swiper;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding)
        return false;
      swiper.loopFix({
        direction: "prev"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize3(val) {
      if (val < 0)
        return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize3(translate2);
    const normalizedSnapGrid = snapGrid.map((val) => normalize3(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap3, snapIndex) => {
        if (normalizedTranslate >= snap3) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0)
        prevIndex = swiper.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(prevIndex, speed, runCallbacks, internal);
      });
      return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  function slideReset(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    if (swiper.destroyed)
      return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (threshold === void 0) {
      threshold = 0.5;
    }
    const swiper = this;
    if (swiper.destroyed)
      return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }
  function slideToClickedSlide() {
    const swiper = this;
    if (swiper.destroyed)
      return;
    const {
      params,
      slidesEl
    } = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
      if (swiper.animating)
        return;
      realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };
  function loopCreate(slideRealIndex) {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
      return;
    const initSlides = () => {
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      slides.forEach((el, index) => {
        el.setAttribute("data-swiper-slide-index", index);
      });
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = (amountOfSlides) => {
      for (let i = 0; i < amountOfSlides; i += 1) {
        const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
        swiper.slidesEl.append(slideEl);
      }
    };
    if (shouldFillGroup) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else if (shouldFillGrid) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else {
      initSlides();
    }
    swiper.loopFix({
      slideRealIndex,
      direction: params.centeredSlides ? void 0 : "next"
    });
  }
  function loopFix(_temp) {
    let {
      slideRealIndex,
      slideTo: slideTo2 = true,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController,
      byMousewheel
    } = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop)
      return;
    swiper.emit("beforeLoopFix");
    const {
      slides,
      allowSlidePrev,
      allowSlideNext,
      slidesEl,
      params
    } = swiper;
    const {
      centeredSlides
    } = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
      if (slideTo2) {
        if (!params.centeredSlides && swiper.snapIndex === 0) {
          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit("loopFix");
      return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === "auto") {
      slidesPerView = swiper.slidesPerViewDynamic();
    } else {
      slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
      if (centeredSlides && slidesPerView % 2 === 0) {
        slidesPerView = slidesPerView + 1;
      }
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) {
      loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    }
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides) {
      showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
    } else if (gridEnabled && params.grid.fill === "row") {
      showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    }
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === "undefined") {
      activeSlideIndex = swiper.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);
    } else {
      activeIndex = activeSlideIndex;
    }
    const isNext = direction === "next" || !direction;
    const isPrev = direction === "prev" || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
    if (activeColIndexWithShift < loopedSlides) {
      slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
      for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
        const index = i - Math.floor(i / cols) * cols;
        if (gridEnabled) {
          const colIndexToPrepend = cols - index - 1;
          for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {
            if (slides[i2].column === colIndexToPrepend)
              prependSlidesIndexes.push(i2);
          }
        } else {
          prependSlidesIndexes.push(cols - index - 1);
        }
      }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
      slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
      for (let i = 0; i < slidesAppended; i += 1) {
        const index = i - Math.floor(i / cols) * cols;
        if (gridEnabled) {
          slides.forEach((slide2, slideIndex) => {
            if (slide2.column === index)
              appendSlidesIndexes.push(slideIndex);
          });
        } else {
          appendSlidesIndexes.push(index);
        }
      }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
    if (isPrev) {
      prependSlidesIndexes.forEach((index) => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.prepend(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
      });
    }
    if (isNext) {
      appendSlidesIndexes.forEach((index) => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.append(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
      });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === "auto") {
      swiper.updateSlides();
    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
      swiper.slides.forEach((slide2, slideIndex) => {
        swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
      });
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (slideTo2) {
      if (prependSlidesIndexes.length > 0 && isPrev) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          if (setTranslate2) {
            const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
            swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
            swiper.touchEventsData.currentTranslate = swiper.translate;
          }
        }
      } else if (appendSlidesIndexes.length > 0 && isNext) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
        }
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
      const loopParams = {
        slideRealIndex,
        direction,
        setTranslate: setTranslate2,
        activeSlideIndex,
        byController: true
      };
      if (Array.isArray(swiper.controller.control)) {
        swiper.controller.control.forEach((c) => {
          if (!c.destroyed && c.params.loop)
            c.loopFix({
              ...loopParams,
              slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false
            });
        });
      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
        swiper.controller.control.loopFix({
          ...loopParams,
          slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        });
      }
    }
    swiper.emit("loopFix");
  }
  function loopDestroy() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
      return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl) => {
      const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
      newSlidesOrder[index] = slideEl;
    });
    swiper.slides.forEach((slideEl) => {
      slideEl.removeAttribute("data-swiper-slide-index");
    });
    newSlidesOrder.forEach((slideEl) => {
      slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
  }
  var loop = {
    loopCreate,
    loopFix,
    loopDestroy
  };
  function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
      return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };
  function closestElement(selector3, base) {
    if (base === void 0) {
      base = this;
    }
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow())
        return null;
      if (el.assignedSlot)
        el = el.assignedSlot;
      const found = el.closest(selector3);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function preventEdgeSwipe(swiper, event2, startX) {
    const window2 = getWindow();
    const {
      params
    } = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
        return true;
      }
      return false;
    }
    return true;
  }
  function onTouchStart(event2) {
    const swiper = this;
    const document2 = getDocument();
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    const data = swiper.touchEventsData;
    if (e.type === "pointerdown") {
      if (data.pointerId !== null && data.pointerId !== e.pointerId) {
        return;
      }
      data.pointerId = e.pointerId;
    } else if (e.type === "touchstart" && e.targetTouches.length === 1) {
      data.touchId = e.targetTouches[0].identifier;
    }
    if (e.type === "touchstart") {
      preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
      return;
    }
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && e.pointerType === "mouse")
      return;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }
    let targetEl = e.target;
    if (params.touchEventsTarget === "wrapper") {
      if (!elementIsChildOf(targetEl, swiper.wrapperEl))
        return;
    }
    if ("which" in e && e.which === 3)
      return;
    if ("button" in e && e.button > 0)
      return;
    if (data.isTouched && data.isMoved)
      return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = e.composedPath ? e.composedPath() : e.path;
    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
      targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!targetEl.closest(params.swipeHandler))
        return;
    }
    touches.currentX = e.pageX;
    touches.currentY = e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    if (!preventEdgeSwipe(swiper, e, startX)) {
      return;
    }
    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0)
      data.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data.focusableElements)) {
      preventDefault = false;
      if (targetEl.nodeName === "SELECT") {
        data.isTouched = false;
      }
    }
    if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl && (e.pointerType === "mouse" || e.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) {
      document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
      e.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }
    swiper.emit("touchStart", e);
  }
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && event2.pointerType === "mouse")
      return;
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    if (e.type === "pointermove") {
      if (data.touchId !== null)
        return;
      const id = e.pointerId;
      if (id !== data.pointerId)
        return;
    }
    let targetTouch;
    if (e.type === "touchmove") {
      targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data.touchId)
        return;
    } else {
      targetTouch = e;
    }
    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit("touchMoveOpposite", e);
      }
      return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      if (!e.target.matches(data.focusableElements)) {
        swiper.allowClick = false;
      }
      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }
      return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }
    if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== e.target && e.pointerType !== "mouse") {
      document2.activeElement.blur();
    }
    if (document2.activeElement) {
      if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data.allowTouchCallbacks) {
      swiper.emit("touchMove", e);
    }
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
      return;
    if (typeof data.isScrolling === "undefined") {
      let touchAngle;
      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data.isScrolling) {
      swiper.emit("touchMoveOpposite", e);
    }
    if (typeof data.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }
    if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
      data.isTouched = false;
      return;
    }
    if (!data.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
      diff = Math.abs(diff) * (rtl ? 1 : -1);
      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
      diff = -diff;
      touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
    if (!data.isMoved) {
      if (isLoop && allowLoopFix) {
        swiper.loopFix({
          direction: swiper.swipeDirection
        });
      }
      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        const evt = new window.CustomEvent("transitionend", {
          bubbles: true,
          cancelable: true,
          detail: {
            bySwiperTouchMove: true
          }
        });
        swiper.wrapperEl.dispatchEvent(evt);
      }
      data.allowMomentumBounce = false;
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit("sliderFirstMove", e);
    }
    let loopFixed;
    (/* @__PURE__ */ new Date()).getTime();
    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
        startTranslate: data.currentTranslate
      });
      data.loopSwapReset = true;
      data.startTranslate = data.currentTranslate;
      return;
    }
    swiper.emit("sliderMove", e);
    data.isMoved = true;
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0) {
      if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
        swiper.loopFix({
          direction: "prev",
          setTranslate: true,
          activeSlideIndex: 0
        });
      }
      if (data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        }
      }
    } else if (diff < 0) {
      if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
        swiper.loopFix({
          direction: "next",
          setTranslate: true,
          activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
        });
      }
      if (data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
      }
    }
    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode)
      return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    }
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
  }
  function onTouchEnd(event2) {
    const swiper = this;
    const data = swiper.touchEventsData;
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    let targetTouch;
    const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
    if (!isTouchEvent) {
      if (data.touchId !== null)
        return;
      if (e.pointerId !== data.pointerId)
        return;
      targetTouch = e;
    } else {
      targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data.touchId)
        return;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) {
      const proceed = ["pointercancel", "contextmenu"].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
      if (!proceed) {
        return;
      }
    }
    data.pointerId = null;
    data.touchId = null;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && e.pointerType === "mouse")
      return;
    if (data.allowTouchCallbacks) {
      swiper.emit("touchEnd", e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
      const pathTree = e.path || e.composedPath && e.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
      swiper.emit("tap click", e);
      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit("doubleTap doubleClick", e);
      }
    }
    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed)
        swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i + increment2] !== "undefined") {
        if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment2] - slidesGrid[i];
        }
      } else if (swipeToLast || currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio)
          swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
        else
          swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === "next") {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper.swipeDirection === "prev") {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }
  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0)
      return;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      if (swiper.params.loop && !isVirtual) {
        swiper.slideToLoop(swiper.realIndex, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      clearTimeout(swiper.autoplay.resizeTimeout);
      swiper.autoplay.resizeTimeout = setTimeout(() => {
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          swiper.autoplay.resume();
        }
      }, 500);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }
  function onClick(e) {
    const swiper = this;
    if (!swiper.enabled)
      return;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks)
        e.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }
  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled)
      return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === 0)
      swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
  }
  function onLoad(e) {
    const swiper = this;
    processLazyPreloader(swiper, e.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
      return;
    }
    swiper.update();
  }
  function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded)
      return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) {
      swiper.el.style.touchAction = "auto";
    }
  }
  var events = (swiper, method) => {
    const document2 = getDocument();
    const {
      params,
      el,
      wrapperEl,
      device
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!el || typeof el === "string")
      return;
    document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
      passive: false,
      capture
    });
    el[domMethod]("touchstart", swiper.onTouchStart, {
      passive: false
    });
    el[domMethod]("pointerdown", swiper.onTouchStart, {
      passive: false
    });
    document2[domMethod]("touchmove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("pointermove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("touchend", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerup", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointercancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("touchcancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerout", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerleave", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("contextmenu", swiper.onTouchEnd, {
      passive: true
    });
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper[swiperMethod]("observerUpdate", onResize, true);
    }
    el[domMethod]("load", swiper.onLoad, {
      capture: true
    });
  };
  function attachEvents() {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, "on");
  }
  function detachEvents() {
    const swiper = this;
    events(swiper, "off");
  }
  var events$1 = {
    attachEvents,
    detachEvents
  };
  var isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper = this;
    const {
      realIndex,
      initialized,
      params,
      el
    } = swiper;
    const breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
      return;
    const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint)
      return;
    const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasGrabCursor = swiper.params.grabCursor;
    const isGrabCursor = breakpointParams.grabCursor;
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    if (wasGrabCursor && !isGrabCursor) {
      swiper.unsetGrabCursor();
    } else if (!wasGrabCursor && isGrabCursor) {
      swiper.setGrabCursor();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop) => {
      if (typeof breakpointParams[prop] === "undefined")
        return;
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (initialized) {
      if (needsReLoop) {
        swiper.loopDestroy();
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (!wasLoop && hasLoop) {
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (wasLoop && !hasLoop) {
        swiper.loopDestroy();
      }
    }
    swiper.emit("breakpoint", breakpointParams);
  }
  function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) {
      base = "window";
    }
    if (!breakpoints2 || base === "container" && !containerEl)
      return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints2).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value
      } = points[i];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }
  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };
  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      el,
      device
    } = swiper;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "free-mode": swiper.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
  }
  function removeClasses() {
    const swiper = this;
    const {
      el,
      classNames
    } = swiper;
    if (!el || typeof el === "string")
      return;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
  }
  var classes = {
    addClasses,
    removeClasses
  };
  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? "lock" : "unlock");
    }
  }
  var checkOverflow$1 = {
    checkOverflow
  };
  var defaults = {
    init: true,
    direction: "horizontal",
    oneWayMovement: false,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: "swiper",
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
      if (obj === void 0) {
        obj = {};
      }
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend2(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
        params[moduleParamName].auto = true;
      }
      if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
        params[moduleParamName].auto = true;
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend2(allModulesParams, obj);
        return;
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName])
        params[moduleParamName] = {
          enabled: false
        };
      extend2(allModulesParams, obj);
    };
  }
  var prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
  };
  var extendedDefaults = {};
  var Swiper = class _Swiper {
    constructor() {
      let el;
      let params;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params)
        params = {};
      params = extend2({}, params);
      if (el && !params.el)
        params.el = el;
      const document2 = getDocument();
      if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
        const swipers = [];
        document2.querySelectorAll(params.el).forEach((containerEl) => {
          const newParams = extend2({}, params, {
            el: containerEl
          });
          swipers.push(new _Swiper(newParams));
        });
        return swipers;
      }
      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper.modules.forEach((mod) => {
        mod({
          params,
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      });
      const swiperParams = extend2({}, defaults, allModulesParams);
      swiper.params = extend2({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend2({}, swiper.params);
      swiper.passedParams = extend2({}, params);
      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach((eventName) => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }
      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      }
      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper.params.direction === "horizontal";
        },
        isVertical() {
          return swiper.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit("_swiper");
      if (swiper.params.init) {
        swiper.init();
      }
      return swiper;
    }
    getDirectionLabel(property) {
      if (this.isHorizontal()) {
        return property;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property];
    }
    getSlideIndex(slideEl) {
      const {
        slidesEl,
        params
      } = this;
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      const firstSlideIndex = elementIndex(slides[0]);
      return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
      return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
    }
    recalcSlides() {
      const swiper = this;
      const {
        slidesEl,
        params
      } = swiper;
      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
      const swiper = this;
      if (swiper.enabled)
        return;
      swiper.enabled = true;
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }
      swiper.emit("enable");
    }
    disable() {
      const swiper = this;
      if (!swiper.enabled)
        return;
      swiper.enabled = false;
      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }
      swiper.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el)
        return;
      const cls = swiper.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed)
        return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el)
        return;
      const updates = [];
      swiper.slides.forEach((slideEl) => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit("_slideClass", slideEl, classNames);
      });
      swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view, exact) {
      if (view === void 0) {
        view = "current";
      }
      if (exact === void 0) {
        exact = false;
      }
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;
      if (typeof params.slidesPerView === "number")
        return params.slidesPerView;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
        let breakLoop;
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += Math.ceil(slides[i].swiperSlideSize);
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed)
        return;
      const {
        snapGrid,
        params
      } = swiper;
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        }
      });
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
        setTranslate2();
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
          translated = swiper.slideTo(slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate) {
      if (needUpdate === void 0) {
        needUpdate = true;
      }
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper;
      }
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.forEach((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper.emit("changeDirection");
      if (needUpdate)
        swiper.update();
      return swiper;
    }
    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr")
        return;
      swiper.rtl = direction === "rtl";
      swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
      if (swiper.rtl) {
        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "rtl";
      } else {
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "ltr";
      }
      swiper.update();
    }
    mount(element) {
      const swiper = this;
      if (swiper.mounted)
        return true;
      let el = element || swiper.params.el;
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      if (!el) {
        return false;
      }
      el.swiper = swiper;
      if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
        swiper.isElement = true;
      }
      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = el.shadowRoot.querySelector(getWrapperSelector());
          return res;
        }
        return elementChildren(el, getWrapperSelector())[0];
      };
      let wrapperEl = getWrapper();
      if (!wrapperEl && swiper.params.createElements) {
        wrapperEl = createElement("div", swiper.params.wrapperClass);
        el.append(wrapperEl);
        elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
          wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper, {
        el,
        wrapperEl,
        slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
        hostEl: swiper.isElement ? el.parentNode.host : el,
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
        rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
        wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper = this;
      if (swiper.initialized)
        return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false)
        return swiper;
      swiper.emit("beforeInit");
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.addClasses();
      swiper.updateSize();
      swiper.updateSlides();
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }
      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }
      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      }
      if (swiper.params.loop) {
        swiper.loopCreate();
      }
      swiper.attachEvents();
      const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
      if (swiper.isElement) {
        lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
      }
      lazyElements.forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        } else {
          imageEl.addEventListener("load", (e) => {
            processLazyPreloader(swiper, e.target);
          });
        }
      });
      preload(swiper);
      swiper.initialized = true;
      preload(swiper);
      swiper.emit("init");
      swiper.emit("afterInit");
      return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) {
        deleteInstance = true;
      }
      if (cleanStyles === void 0) {
        cleanStyles = true;
      }
      const swiper = this;
      const {
        params,
        el,
        wrapperEl,
        slides
      } = swiper;
      if (typeof swiper.params === "undefined" || swiper.destroyed) {
        return null;
      }
      swiper.emit("beforeDestroy");
      swiper.initialized = false;
      swiper.detachEvents();
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (cleanStyles) {
        swiper.removeClasses();
        if (el && typeof el !== "string") {
          el.removeAttribute("style");
        }
        if (wrapperEl) {
          wrapperEl.removeAttribute("style");
        }
        if (slides && slides.length) {
          slides.forEach((slideEl) => {
            slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            slideEl.removeAttribute("style");
            slideEl.removeAttribute("data-swiper-slide-index");
          });
        }
      }
      swiper.emit("destroy");
      Object.keys(swiper.eventsListeners).forEach((eventName) => {
        swiper.off(eventName);
      });
      if (deleteInstance !== false) {
        if (swiper.el && typeof swiper.el !== "string") {
          swiper.el.swiper = null;
        }
        deleteProps(swiper);
      }
      swiper.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults;
    }
    static installModule(mod) {
      if (!_Swiper.prototype.__modules__)
        _Swiper.prototype.__modules__ = [];
      const modules2 = _Swiper.prototype.__modules__;
      if (typeof mod === "function" && modules2.indexOf(mod) < 0) {
        modules2.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach((m) => _Swiper.installModule(m));
        return _Swiper;
      }
      _Swiper.installModule(module);
      return _Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/virtual.mjs
  init_live_reload();
  function Virtual(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    extendParams({
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: true,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    });
    let cssModeTimeout;
    const document2 = getDocument();
    swiper.virtual = {
      cache: {},
      from: void 0,
      to: void 0,
      slides: [],
      offset: 0,
      slidesGrid: []
    };
    const tempDOM = document2.createElement("div");
    function renderSlide(slide2, index) {
      const params = swiper.params.virtual;
      if (params.cache && swiper.virtual.cache[index]) {
        return swiper.virtual.cache[index];
      }
      let slideEl;
      if (params.renderSlide) {
        slideEl = params.renderSlide.call(swiper, slide2, index);
        if (typeof slideEl === "string") {
          tempDOM.innerHTML = slideEl;
          slideEl = tempDOM.children[0];
        }
      } else if (swiper.isElement) {
        slideEl = createElement("swiper-slide");
      } else {
        slideEl = createElement("div", swiper.params.slideClass);
      }
      slideEl.setAttribute("data-swiper-slide-index", index);
      if (!params.renderSlide) {
        slideEl.innerHTML = slide2;
      }
      if (params.cache) {
        swiper.virtual.cache[index] = slideEl;
      }
      return slideEl;
    }
    function update2(force, beforeInit) {
      const {
        slidesPerView,
        slidesPerGroup,
        centeredSlides,
        loop: isLoop,
        initialSlide
      } = swiper.params;
      if (beforeInit && !isLoop && initialSlide > 0) {
        return;
      }
      const {
        addSlidesBefore,
        addSlidesAfter
      } = swiper.params.virtual;
      const {
        from: previousFrom,
        to: previousTo,
        slides,
        slidesGrid: previousSlidesGrid,
        offset: previousOffset
      } = swiper.virtual;
      if (!swiper.params.cssMode) {
        swiper.updateActiveIndex();
      }
      const activeIndex = swiper.activeIndex || 0;
      let offsetProp;
      if (swiper.rtlTranslate)
        offsetProp = "right";
      else
        offsetProp = swiper.isHorizontal() ? "left" : "top";
      let slidesAfter;
      let slidesBefore;
      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
        slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
      }
      let from = activeIndex - slidesBefore;
      let to = activeIndex + slidesAfter;
      if (!isLoop) {
        from = Math.max(from, 0);
        to = Math.min(to, slides.length - 1);
      }
      let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
      if (isLoop && activeIndex >= slidesBefore) {
        from -= slidesBefore;
        if (!centeredSlides)
          offset += swiper.slidesGrid[0];
      } else if (isLoop && activeIndex < slidesBefore) {
        from = -slidesBefore;
        if (centeredSlides)
          offset += swiper.slidesGrid[0];
      }
      Object.assign(swiper.virtual, {
        from,
        to,
        offset,
        slidesGrid: swiper.slidesGrid,
        slidesBefore,
        slidesAfter
      });
      function onRendered() {
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        emit("virtualUpdate");
      }
      if (previousFrom === from && previousTo === to && !force) {
        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
          swiper.slides.forEach((slideEl) => {
            slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
          });
        }
        swiper.updateProgress();
        emit("virtualUpdate");
        return;
      }
      if (swiper.params.virtual.renderExternal) {
        swiper.params.virtual.renderExternal.call(swiper, {
          offset,
          from,
          to,
          slides: function getSlides() {
            const slidesToRender = [];
            for (let i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }
            return slidesToRender;
          }()
        });
        if (swiper.params.virtual.renderExternalUpdate) {
          onRendered();
        } else {
          emit("virtualUpdate");
        }
        return;
      }
      const prependIndexes = [];
      const appendIndexes = [];
      const getSlideIndex = (index) => {
        let slideIndex = index;
        if (index < 0) {
          slideIndex = slides.length + index;
        } else if (slideIndex >= slides.length) {
          slideIndex = slideIndex - slides.length;
        }
        return slideIndex;
      };
      if (force) {
        swiper.slides.filter((el) => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach((slideEl) => {
          slideEl.remove();
        });
      } else {
        for (let i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            const slideIndex = getSlideIndex(i);
            swiper.slides.filter((el) => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach((slideEl) => {
              slideEl.remove();
            });
          }
        }
      }
      const loopFrom = isLoop ? -slides.length : 0;
      const loopTo = isLoop ? slides.length * 2 : slides.length;
      for (let i = loopFrom; i < loopTo; i += 1) {
        if (i >= from && i <= to) {
          const slideIndex = getSlideIndex(i);
          if (typeof previousTo === "undefined" || force) {
            appendIndexes.push(slideIndex);
          } else {
            if (i > previousTo)
              appendIndexes.push(slideIndex);
            if (i < previousFrom)
              prependIndexes.push(slideIndex);
          }
        }
      }
      appendIndexes.forEach((index) => {
        swiper.slidesEl.append(renderSlide(slides[index], index));
      });
      if (isLoop) {
        for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
          const index = prependIndexes[i];
          swiper.slidesEl.prepend(renderSlide(slides[index], index));
        }
      } else {
        prependIndexes.sort((a, b) => b - a);
        prependIndexes.forEach((index) => {
          swiper.slidesEl.prepend(renderSlide(slides[index], index));
        });
      }
      elementChildren(swiper.slidesEl, ".swiper-slide, swiper-slide").forEach((slideEl) => {
        slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
      });
      onRendered();
    }
    function appendSlide2(slides) {
      if (typeof slides === "object" && "length" in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i])
            swiper.virtual.slides.push(slides[i]);
        }
      } else {
        swiper.virtual.slides.push(slides);
      }
      update2(true);
    }
    function prependSlide2(slides) {
      const activeIndex = swiper.activeIndex;
      let newActiveIndex = activeIndex + 1;
      let numberOfNewSlides = 1;
      if (Array.isArray(slides)) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i])
            swiper.virtual.slides.unshift(slides[i]);
        }
        newActiveIndex = activeIndex + slides.length;
        numberOfNewSlides = slides.length;
      } else {
        swiper.virtual.slides.unshift(slides);
      }
      if (swiper.params.virtual.cache) {
        const cache = swiper.virtual.cache;
        const newCache = {};
        Object.keys(cache).forEach((cachedIndex) => {
          const cachedEl = cache[cachedIndex];
          const cachedElIndex = cachedEl.getAttribute("data-swiper-slide-index");
          if (cachedElIndex) {
            cachedEl.setAttribute("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides);
          }
          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
        });
        swiper.virtual.cache = newCache;
      }
      update2(true);
      swiper.slideTo(newActiveIndex, 0);
    }
    function removeSlide2(slidesIndexes) {
      if (typeof slidesIndexes === "undefined" || slidesIndexes === null)
        return;
      let activeIndex = swiper.activeIndex;
      if (Array.isArray(slidesIndexes)) {
        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes[i]];
            Object.keys(swiper.virtual.cache).forEach((key) => {
              if (key > slidesIndexes) {
                swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
                delete swiper.virtual.cache[key];
              }
            });
          }
          swiper.virtual.slides.splice(slidesIndexes[i], 1);
          if (slidesIndexes[i] < activeIndex)
            activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
      } else {
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes];
          Object.keys(swiper.virtual.cache).forEach((key) => {
            if (key > slidesIndexes) {
              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
              swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
              delete swiper.virtual.cache[key];
            }
          });
        }
        swiper.virtual.slides.splice(slidesIndexes, 1);
        if (slidesIndexes < activeIndex)
          activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
      update2(true);
      swiper.slideTo(activeIndex, 0);
    }
    function removeAllSlides2() {
      swiper.virtual.slides = [];
      if (swiper.params.virtual.cache) {
        swiper.virtual.cache = {};
      }
      update2(true);
      swiper.slideTo(0, 0);
    }
    on("beforeInit", () => {
      if (!swiper.params.virtual.enabled)
        return;
      let domSlidesAssigned;
      if (typeof swiper.passedParams.virtual.slides === "undefined") {
        const slides = [...swiper.slidesEl.children].filter((el) => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
        if (slides && slides.length) {
          swiper.virtual.slides = [...slides];
          domSlidesAssigned = true;
          slides.forEach((slideEl, slideIndex) => {
            slideEl.setAttribute("data-swiper-slide-index", slideIndex);
            swiper.virtual.cache[slideIndex] = slideEl;
            slideEl.remove();
          });
        }
      }
      if (!domSlidesAssigned) {
        swiper.virtual.slides = swiper.params.virtual.slides;
      }
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
      update2(false, true);
    });
    on("setTranslate", () => {
      if (!swiper.params.virtual.enabled)
        return;
      if (swiper.params.cssMode && !swiper._immediateVirtual) {
        clearTimeout(cssModeTimeout);
        cssModeTimeout = setTimeout(() => {
          update2();
        }, 100);
      } else {
        update2();
      }
    });
    on("init update resize", () => {
      if (!swiper.params.virtual.enabled)
        return;
      if (swiper.params.cssMode) {
        setCSSProperty(swiper.wrapperEl, "--swiper-virtual-size", `${swiper.virtualSize}px`);
      }
    });
    Object.assign(swiper.virtual, {
      appendSlide: appendSlide2,
      prependSlide: prependSlide2,
      removeSlide: removeSlide2,
      removeAllSlides: removeAllSlides2,
      update: update2
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/keyboard.mjs
  init_live_reload();
  function Keyboard(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const document2 = getDocument();
    const window2 = getWindow();
    swiper.keyboard = {
      enabled: false
    };
    extendParams({
      keyboard: {
        enabled: false,
        onlyInViewport: true,
        pageUpDown: true
      }
    });
    function handle(event2) {
      if (!swiper.enabled)
        return;
      const {
        rtlTranslate: rtl
      } = swiper;
      let e = event2;
      if (e.originalEvent)
        e = e.originalEvent;
      const kc = e.keyCode || e.charCode;
      const pageUpDown = swiper.params.keyboard.pageUpDown;
      const isPageUp = pageUpDown && kc === 33;
      const isPageDown = pageUpDown && kc === 34;
      const isArrowLeft = kc === 37;
      const isArrowRight = kc === 39;
      const isArrowUp = kc === 38;
      const isArrowDown = kc === 40;
      if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
        return false;
      }
      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
        return false;
      }
      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return void 0;
      }
      if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea")) {
        return void 0;
      }
      if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
        let inView = false;
        if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
          return void 0;
        }
        const el = swiper.el;
        const swiperWidth = el.clientWidth;
        const swiperHeight = el.clientHeight;
        const windowWidth = window2.innerWidth;
        const windowHeight = window2.innerHeight;
        const swiperOffset = elementOffset(el);
        if (rtl)
          swiperOffset.left -= el.scrollLeft;
        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
        for (let i = 0; i < swiperCoord.length; i += 1) {
          const point = swiperCoord[i];
          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
            if (point[0] === 0 && point[1] === 0)
              continue;
            inView = true;
          }
        }
        if (!inView)
          return void 0;
      }
      if (swiper.isHorizontal()) {
        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;
        }
        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)
          swiper.slideNext();
        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)
          swiper.slidePrev();
      } else {
        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;
        }
        if (isPageDown || isArrowDown)
          swiper.slideNext();
        if (isPageUp || isArrowUp)
          swiper.slidePrev();
      }
      emit("keyPress", kc);
      return void 0;
    }
    function enable() {
      if (swiper.keyboard.enabled)
        return;
      document2.addEventListener("keydown", handle);
      swiper.keyboard.enabled = true;
    }
    function disable() {
      if (!swiper.keyboard.enabled)
        return;
      document2.removeEventListener("keydown", handle);
      swiper.keyboard.enabled = false;
    }
    on("init", () => {
      if (swiper.params.keyboard.enabled) {
        enable();
      }
    });
    on("destroy", () => {
      if (swiper.keyboard.enabled) {
        disable();
      }
    });
    Object.assign(swiper.keyboard, {
      enable,
      disable
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/mousewheel.mjs
  init_live_reload();
  function Mousewheel(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const window2 = getWindow();
    extendParams({
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarget: "container",
        thresholdDelta: null,
        thresholdTime: null,
        noMousewheelClass: "swiper-no-mousewheel"
      }
    });
    swiper.mousewheel = {
      enabled: false
    };
    let timeout;
    let lastScrollTime = now();
    let lastEventBeforeSnap;
    const recentWheelEvents = [];
    function normalize3(e) {
      const PIXEL_STEP = 10;
      const LINE_HEIGHT = 40;
      const PAGE_HEIGHT = 800;
      let sX = 0;
      let sY = 0;
      let pX = 0;
      let pY = 0;
      if ("detail" in e) {
        sY = e.detail;
      }
      if ("wheelDelta" in e) {
        sY = -e.wheelDelta / 120;
      }
      if ("wheelDeltaY" in e) {
        sY = -e.wheelDeltaY / 120;
      }
      if ("wheelDeltaX" in e) {
        sX = -e.wheelDeltaX / 120;
      }
      if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }
      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;
      if ("deltaY" in e) {
        pY = e.deltaY;
      }
      if ("deltaX" in e) {
        pX = e.deltaX;
      }
      if (e.shiftKey && !pX) {
        pX = pY;
        pY = 0;
      }
      if ((pX || pY) && e.deltaMode) {
        if (e.deltaMode === 1) {
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      }
      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }
      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }
      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    }
    function handleMouseEnter() {
      if (!swiper.enabled)
        return;
      swiper.mouseEntered = true;
    }
    function handleMouseLeave() {
      if (!swiper.enabled)
        return;
      swiper.mouseEntered = false;
    }
    function animateSlider(newEvent) {
      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
        return false;
      }
      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
        return false;
      }
      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
        return true;
      }
      if (newEvent.direction < 0) {
        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
          swiper.slideNext();
          emit("scroll", newEvent.raw);
        }
      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
        swiper.slidePrev();
        emit("scroll", newEvent.raw);
      }
      lastScrollTime = new window2.Date().getTime();
      return false;
    }
    function releaseScroll(newEvent) {
      const params = swiper.params.mousewheel;
      if (newEvent.direction < 0) {
        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
          return true;
        }
      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
        return true;
      }
      return false;
    }
    function handle(event2) {
      let e = event2;
      let disableParentSwiper = true;
      if (!swiper.enabled)
        return;
      if (event2.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`))
        return;
      const params = swiper.params.mousewheel;
      if (swiper.params.cssMode) {
        e.preventDefault();
      }
      let targetEl = swiper.el;
      if (swiper.params.mousewheel.eventsTarget !== "container") {
        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
      }
      const targetElContainsTarget = targetEl && targetEl.contains(e.target);
      if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges)
        return true;
      if (e.originalEvent)
        e = e.originalEvent;
      let delta = 0;
      const rtlFactor = swiper.rtlTranslate ? -1 : 1;
      const data = normalize3(e);
      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
            delta = -data.pixelX * rtlFactor;
          else
            return true;
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
          delta = -data.pixelY;
        else
          return true;
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }
      if (delta === 0)
        return true;
      if (params.invert)
        delta = -delta;
      let positions = swiper.getTranslate() + delta * params.sensitivity;
      if (positions >= swiper.minTranslate())
        positions = swiper.minTranslate();
      if (positions <= swiper.maxTranslate())
        positions = swiper.maxTranslate();
      disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
      if (disableParentSwiper && swiper.params.nested)
        e.stopPropagation();
      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event2
        };
        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift();
        }
        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
        recentWheelEvents.push(newEvent);
        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
            animateSlider(newEvent);
          }
        } else {
          animateSlider(newEvent);
        }
        if (releaseScroll(newEvent)) {
          return true;
        }
      } else {
        const newEvent = {
          time: now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta)
        };
        const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
        if (!ignoreWheelEvents) {
          lastEventBeforeSnap = void 0;
          let position = swiper.getTranslate() + delta * params.sensitivity;
          const wasBeginning = swiper.isBeginning;
          const wasEnd = swiper.isEnd;
          if (position >= swiper.minTranslate())
            position = swiper.minTranslate();
          if (position <= swiper.maxTranslate())
            position = swiper.maxTranslate();
          swiper.setTransition(0);
          swiper.setTranslate(position);
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
            swiper.updateSlidesClasses();
          }
          if (swiper.params.loop) {
            swiper.loopFix({
              direction: newEvent.direction < 0 ? "next" : "prev",
              byMousewheel: true
            });
          }
          if (swiper.params.freeMode.sticky) {
            clearTimeout(timeout);
            timeout = void 0;
            if (recentWheelEvents.length >= 15) {
              recentWheelEvents.shift();
            }
            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
            const firstEvent = recentWheelEvents[0];
            recentWheelEvents.push(newEvent);
            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
              recentWheelEvents.splice(0);
            } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
              const snapToThreshold = delta > 0 ? 0.8 : 0.2;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              timeout = nextTick(() => {
                if (swiper.destroyed || !swiper.params)
                  return;
                swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
              }, 0);
            }
            if (!timeout) {
              timeout = nextTick(() => {
                if (swiper.destroyed || !swiper.params)
                  return;
                const snapToThreshold = 0.5;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
              }, 500);
            }
          }
          if (!ignoreWheelEvents)
            emit("scroll", e);
          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)
            swiper.autoplay.stop();
          if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
            return true;
          }
        }
      }
      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;
      return false;
    }
    function events2(method) {
      let targetEl = swiper.el;
      if (swiper.params.mousewheel.eventsTarget !== "container") {
        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
      }
      targetEl[method]("mouseenter", handleMouseEnter);
      targetEl[method]("mouseleave", handleMouseLeave);
      targetEl[method]("wheel", handle);
    }
    function enable() {
      if (swiper.params.cssMode) {
        swiper.wrapperEl.removeEventListener("wheel", handle);
        return true;
      }
      if (swiper.mousewheel.enabled)
        return false;
      events2("addEventListener");
      swiper.mousewheel.enabled = true;
      return true;
    }
    function disable() {
      if (swiper.params.cssMode) {
        swiper.wrapperEl.addEventListener(event, handle);
        return true;
      }
      if (!swiper.mousewheel.enabled)
        return false;
      events2("removeEventListener");
      swiper.mousewheel.enabled = false;
      return true;
    }
    on("init", () => {
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        disable();
      }
      if (swiper.params.mousewheel.enabled)
        enable();
    });
    on("destroy", () => {
      if (swiper.params.cssMode) {
        enable();
      }
      if (swiper.mousewheel.enabled)
        disable();
    });
    Object.assign(swiper.mousewheel, {
      enable,
      disable
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/navigation.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/create-element-if-not-defined.mjs
  init_live_reload();
  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach((key) => {
        if (!params[key] && params.auto === true) {
          let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
          if (!element) {
            element = createElement("div", checkProps[key]);
            element.className = checkProps[key];
            swiper.el.append(element);
          }
          params[key] = element;
          originalParams[key] = element;
        }
      });
    }
    return params;
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/navigation.mjs
  function Navigation(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    });
    swiper.navigation = {
      nextEl: null,
      prevEl: null
    };
    function getEl(el) {
      let res;
      if (el && typeof el === "string" && swiper.isElement) {
        res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
        if (res)
          return res;
      }
      if (el) {
        if (typeof el === "string")
          res = [...document.querySelectorAll(el)];
        if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
          res = swiper.el.querySelector(el);
        } else if (res && res.length === 1) {
          res = res[0];
        }
      }
      if (el && !res)
        return el;
      return res;
    }
    function toggleEl(el, disabled) {
      const params = swiper.params.navigation;
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        if (subEl) {
          subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
          if (subEl.tagName === "BUTTON")
            subEl.disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
          }
        }
      });
    }
    function update2() {
      const {
        nextEl,
        prevEl
      } = swiper.navigation;
      if (swiper.params.loop) {
        toggleEl(prevEl, false);
        toggleEl(nextEl, false);
        return;
      }
      toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
      toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e) {
      e.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)
        return;
      swiper.slidePrev();
      emit("navigationPrev");
    }
    function onNextClick(e) {
      e.preventDefault();
      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
        return;
      swiper.slideNext();
      emit("navigationNext");
    }
    function init4() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      });
      if (!(params.nextEl || params.prevEl))
        return;
      let nextEl = getEl(params.nextEl);
      let prevEl = getEl(params.prevEl);
      Object.assign(swiper.navigation, {
        nextEl,
        prevEl
      });
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const initButton = (el, dir) => {
        if (el) {
          el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
        }
        if (!swiper.enabled && el) {
          el.classList.add(...params.lockClass.split(" "));
        }
      };
      nextEl.forEach((el) => initButton(el, "next"));
      prevEl.forEach((el) => initButton(el, "prev"));
    }
    function destroy() {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const destroyButton = (el, dir) => {
        el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
        el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
      };
      nextEl.forEach((el) => destroyButton(el, "next"));
      prevEl.forEach((el) => destroyButton(el, "prev"));
    }
    on("init", () => {
      if (swiper.params.navigation.enabled === false) {
        disable();
      } else {
        init4();
        update2();
      }
    });
    on("toEdge fromEdge lock unlock", () => {
      update2();
    });
    on("destroy", () => {
      destroy();
    });
    on("enable disable", () => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      if (swiper.enabled) {
        update2();
        return;
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
    });
    on("click", (_s, e) => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const targetEl = e.target;
      let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
      if (swiper.isElement && !targetIsButton) {
        const path = e.path || e.composedPath && e.composedPath();
        if (path) {
          targetIsButton = path.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
        }
      }
      if (swiper.params.navigation.hideOnClick && !targetIsButton) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
          return;
        let isHidden;
        if (nextEl.length) {
          isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        } else if (prevEl.length) {
          isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          emit("navigationShow");
        } else {
          emit("navigationHide");
        }
        [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
      init4();
      update2();
    };
    const disable = () => {
      swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
      destroy();
    };
    Object.assign(swiper.navigation, {
      enable,
      disable,
      update: update2,
      init: init4,
      destroy
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/pagination.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/classes-to-selector.mjs
  init_live_reload();
  function classesToSelector(classes2) {
    if (classes2 === void 0) {
      classes2 = "";
    }
    return `.${classes2.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/pagination.mjs
  function Pagination(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const pfx = "swiper-pagination";
    extendParams({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: "bullets",
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: (number) => number,
        formatFractionTotal: (number) => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper.pagination = {
      el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
      return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
    }
    function setSideBullets(bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper.params.pagination;
      if (!bulletEl)
        return;
      bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}`);
        bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
        if (bulletEl) {
          bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
        }
      }
    }
    function getMoveDirection(prevIndex, nextIndex, length) {
      prevIndex = prevIndex % length;
      nextIndex = nextIndex % length;
      if (nextIndex === prevIndex + 1) {
        return "next";
      } else if (nextIndex === prevIndex - 1) {
        return "previous";
      }
      return;
    }
    function onBulletClick(e) {
      const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
      if (!bulletEl) {
        return;
      }
      e.preventDefault();
      const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
      if (swiper.params.loop) {
        if (swiper.realIndex === index)
          return;
        const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
        if (moveDirection === "next") {
          swiper.slideNext();
        } else if (moveDirection === "previous") {
          swiper.slidePrev();
        } else {
          swiper.slideToLoop(index);
        }
      } else {
        swiper.slideTo(index);
      }
    }
    function update2() {
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (isPaginationDisabled())
        return;
      let el = swiper.pagination.el;
      el = makeElementsArray(el);
      let current;
      let previousIndex;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.loop) {
        previousIndex = swiper.previousRealIndex || 0;
        current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
      } else if (typeof swiper.snapIndex !== "undefined") {
        current = swiper.snapIndex;
        previousIndex = swiper.previousSnapIndex;
      } else {
        previousIndex = swiper.previousIndex || 0;
        current = swiper.activeIndex || 0;
      }
      if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
          el.forEach((subEl) => {
            subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
          });
          if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
            dynamicBulletIndex += current - (previousIndex || 0);
            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }
          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.forEach((bulletEl) => {
          const classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s) => typeof s === "string" && s.includes(" ") ? s.split(" ") : s).flat();
          bulletEl.classList.remove(...classesToRemove);
        });
        if (el.length > 1) {
          bullets.forEach((bullet) => {
            const bulletIndex = elementIndex(bullet);
            if (bulletIndex === current) {
              bullet.classList.add(...params.bulletActiveClass.split(" "));
            } else if (swiper.isElement) {
              bullet.setAttribute("part", "bullet");
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
              }
              if (bulletIndex === firstIndex) {
                setSideBullets(bullet, "prev");
              }
              if (bulletIndex === lastIndex) {
                setSideBullets(bullet, "next");
              }
            }
          });
        } else {
          const bullet = bullets[current];
          if (bullet) {
            bullet.classList.add(...params.bulletActiveClass.split(" "));
          }
          if (swiper.isElement) {
            bullets.forEach((bulletEl, bulletIndex) => {
              bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
            });
          }
          if (params.dynamicBullets) {
            const firstDisplayedBullet = bullets[firstIndex];
            const lastDisplayedBullet = bullets[lastIndex];
            for (let i = firstIndex; i <= lastIndex; i += 1) {
              if (bullets[i]) {
                bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
              }
            }
            setSideBullets(firstDisplayedBullet, "prev");
            setSideBullets(lastDisplayedBullet, "next");
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? "right" : "left";
          bullets.forEach((bullet) => {
            bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
          });
        }
      }
      el.forEach((subEl, subElIndex) => {
        if (params.type === "fraction") {
          subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
            fractionEl.textContent = params.formatFractionCurrent(current + 1);
          });
          subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
            totalEl.textContent = params.formatFractionTotal(total);
          });
        }
        if (params.type === "progressbar") {
          let progressbarDirection;
          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
          } else {
            progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
          }
          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;
          if (progressbarDirection === "horizontal") {
            scaleX = scale;
          } else {
            scaleY = scale;
          }
          subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
          });
        }
        if (params.type === "custom" && params.renderCustom) {
          subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
          if (subElIndex === 0)
            emit("paginationRender", subEl);
        } else {
          if (subElIndex === 0)
            emit("paginationRender", subEl);
          emit("paginationUpdate", subEl);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
        }
      });
    }
    function render3() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled())
        return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
      let el = swiper.pagination.el;
      el = makeElementsArray(el);
      let paginationHTML = "";
      if (params.type === "bullets") {
        let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }
        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
      }
      if (params.type === "fraction") {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
        }
      }
      if (params.type === "progressbar") {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
      }
      swiper.pagination.bullets = [];
      el.forEach((subEl) => {
        if (params.type !== "custom") {
          subEl.innerHTML = paginationHTML || "";
        }
        if (params.type === "bullets") {
          swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
        }
      });
      if (params.type !== "custom") {
        emit("paginationRender", el[0]);
      }
    }
    function init4() {
      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
        el: "swiper-pagination"
      });
      const params = swiper.params.pagination;
      if (!params.el)
        return;
      let el;
      if (typeof params.el === "string" && swiper.isElement) {
        el = swiper.el.querySelector(params.el);
      }
      if (!el && typeof params.el === "string") {
        el = [...document.querySelectorAll(params.el)];
      }
      if (!el) {
        el = params.el;
      }
      if (!el || el.length === 0)
        return;
      if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
        el = [...swiper.el.querySelectorAll(params.el)];
        if (el.length > 1) {
          el = el.filter((subEl) => {
            if (elementParents(subEl, ".swiper")[0] !== swiper.el)
              return false;
            return true;
          })[0];
        }
      }
      if (Array.isArray(el) && el.length === 1)
        el = el[0];
      Object.assign(swiper.pagination, {
        el
      });
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        if (params.type === "bullets" && params.clickable) {
          subEl.classList.add(...(params.clickableClass || "").split(" "));
        }
        subEl.classList.add(params.modifierClass + params.type);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.type === "bullets" && params.dynamicBullets) {
          subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;
          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }
        if (params.type === "progressbar" && params.progressbarOpposite) {
          subEl.classList.add(params.progressbarOppositeClass);
        }
        if (params.clickable) {
          subEl.addEventListener("click", onBulletClick);
        }
        if (!swiper.enabled) {
          subEl.classList.add(params.lockClass);
        }
      });
    }
    function destroy() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled())
        return;
      let el = swiper.pagination.el;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => {
          subEl.classList.remove(params.hiddenClass);
          subEl.classList.remove(params.modifierClass + params.type);
          subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
          if (params.clickable) {
            subEl.classList.remove(...(params.clickableClass || "").split(" "));
            subEl.removeEventListener("click", onBulletClick);
          }
        });
      }
      if (swiper.pagination.bullets)
        swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
    }
    on("changeDirection", () => {
      if (!swiper.pagination || !swiper.pagination.el)
        return;
      const params = swiper.params.pagination;
      let {
        el
      } = swiper.pagination;
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.classList.remove(params.horizontalClass, params.verticalClass);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      });
    });
    on("init", () => {
      if (swiper.params.pagination.enabled === false) {
        disable();
      } else {
        init4();
        render3();
        update2();
      }
    });
    on("activeIndexChange", () => {
      if (typeof swiper.snapIndex === "undefined") {
        update2();
      }
    });
    on("snapIndexChange", () => {
      update2();
    });
    on("snapGridLengthChange", () => {
      render3();
      update2();
    });
    on("destroy", () => {
      destroy();
    });
    on("enable disable", () => {
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass));
      }
    });
    on("lock unlock", () => {
      update2();
    });
    on("click", (_s, e) => {
      const targetEl = e.target;
      const el = makeElementsArray(swiper.pagination.el);
      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
          return;
        const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          emit("paginationShow");
        } else {
          emit("paginationHide");
        }
        el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
      }
      init4();
      render3();
      update2();
    };
    const disable = () => {
      swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
      let {
        el
      } = swiper.pagination;
      if (el) {
        el = makeElementsArray(el);
        el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
      }
      destroy();
    };
    Object.assign(swiper.pagination, {
      enable,
      disable,
      render: render3,
      update: update2,
      init: init4,
      destroy
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/scrollbar.mjs
  init_live_reload();
  function Scrollbar(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const document2 = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
      scrollbar: {
        el: null,
        dragSize: "auto",
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: "swiper-scrollbar-lock",
        dragClass: "swiper-scrollbar-drag",
        scrollbarDisabledClass: "swiper-scrollbar-disabled",
        horizontalClass: `swiper-scrollbar-horizontal`,
        verticalClass: `swiper-scrollbar-vertical`
      }
    });
    swiper.scrollbar = {
      el: null,
      dragEl: null
    };
    function setTranslate2() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
        return;
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper;
      const {
        dragEl,
        el
      } = scrollbar;
      const params = swiper.params.scrollbar;
      const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
      let newSize = dragSize;
      let newPos = (trackSize - dragSize) * progress;
      if (rtl) {
        newPos = -newPos;
        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }
      if (swiper.isHorizontal()) {
        dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
        dragEl.style.width = `${newSize}px`;
      } else {
        dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
        dragEl.style.height = `${newSize}px`;
      }
      if (params.hide) {
        clearTimeout(timeout);
        el.style.opacity = 1;
        timeout = setTimeout(() => {
          el.style.opacity = 0;
          el.style.transitionDuration = "400ms";
        }, 1e3);
      }
    }
    function setTransition2(duration) {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
        return;
      swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
    }
    function updateSize2() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
        return;
      const {
        scrollbar
      } = swiper;
      const {
        dragEl,
        el
      } = scrollbar;
      dragEl.style.width = "";
      dragEl.style.height = "";
      trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
      if (swiper.params.scrollbar.dragSize === "auto") {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }
      if (swiper.isHorizontal()) {
        dragEl.style.width = `${dragSize}px`;
      } else {
        dragEl.style.height = `${dragSize}px`;
      }
      if (divider >= 1) {
        el.style.display = "none";
      } else {
        el.style.display = "";
      }
      if (swiper.params.scrollbar.hide) {
        el.style.opacity = 0;
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        scrollbar.el.classList[swiper.isLocked ? "add" : "remove"](swiper.params.scrollbar.lockClass);
      }
    }
    function getPointerPosition(e) {
      return swiper.isHorizontal() ? e.clientX : e.clientY;
    }
    function setDragPosition(e) {
      const {
        scrollbar,
        rtlTranslate: rtl
      } = swiper;
      const {
        el
      } = scrollbar;
      let positionRatio;
      positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);
      if (rtl) {
        positionRatio = 1 - positionRatio;
      }
      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    function onDragStart(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        wrapperEl
      } = swiper;
      const {
        el,
        dragEl
      } = scrollbar;
      isTouched = true;
      dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
      e.preventDefault();
      e.stopPropagation();
      wrapperEl.style.transitionDuration = "100ms";
      dragEl.style.transitionDuration = "100ms";
      setDragPosition(e);
      clearTimeout(dragTimeout);
      el.style.transitionDuration = "0ms";
      if (params.hide) {
        el.style.opacity = 1;
      }
      if (swiper.params.cssMode) {
        swiper.wrapperEl.style["scroll-snap-type"] = "none";
      }
      emit("scrollbarDragStart", e);
    }
    function onDragMove(e) {
      const {
        scrollbar,
        wrapperEl
      } = swiper;
      const {
        el,
        dragEl
      } = scrollbar;
      if (!isTouched)
        return;
      if (e.preventDefault && e.cancelable)
        e.preventDefault();
      else
        e.returnValue = false;
      setDragPosition(e);
      wrapperEl.style.transitionDuration = "0ms";
      el.style.transitionDuration = "0ms";
      dragEl.style.transitionDuration = "0ms";
      emit("scrollbarDragMove", e);
    }
    function onDragEnd(e) {
      const params = swiper.params.scrollbar;
      const {
        scrollbar,
        wrapperEl
      } = swiper;
      const {
        el
      } = scrollbar;
      if (!isTouched)
        return;
      isTouched = false;
      if (swiper.params.cssMode) {
        swiper.wrapperEl.style["scroll-snap-type"] = "";
        wrapperEl.style.transitionDuration = "";
      }
      if (params.hide) {
        clearTimeout(dragTimeout);
        dragTimeout = nextTick(() => {
          el.style.opacity = 0;
          el.style.transitionDuration = "400ms";
        }, 1e3);
      }
      emit("scrollbarDragEnd", e);
      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    }
    function events2(method) {
      const {
        scrollbar,
        params
      } = swiper;
      const el = scrollbar.el;
      if (!el)
        return;
      const target = el;
      const activeListener = params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      const passiveListener = params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (!target)
        return;
      const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
      target[eventMethod]("pointerdown", onDragStart, activeListener);
      document2[eventMethod]("pointermove", onDragMove, activeListener);
      document2[eventMethod]("pointerup", onDragEnd, passiveListener);
    }
    function enableDraggable() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
        return;
      events2("on");
    }
    function disableDraggable() {
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
        return;
      events2("off");
    }
    function init4() {
      const {
        scrollbar,
        el: swiperEl
      } = swiper;
      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
        el: "swiper-scrollbar"
      });
      const params = swiper.params.scrollbar;
      if (!params.el)
        return;
      let el;
      if (typeof params.el === "string" && swiper.isElement) {
        el = swiper.el.querySelector(params.el);
      }
      if (!el && typeof params.el === "string") {
        el = document2.querySelectorAll(params.el);
        if (!el.length)
          return;
      } else if (!el) {
        el = params.el;
      }
      if (swiper.params.uniqueNavElements && typeof params.el === "string" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
        el = swiperEl.querySelector(params.el);
      }
      if (el.length > 0)
        el = el[0];
      el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      let dragEl;
      if (el) {
        dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
        if (!dragEl) {
          dragEl = createElement("div", swiper.params.scrollbar.dragClass);
          el.append(dragEl);
        }
      }
      Object.assign(scrollbar, {
        el,
        dragEl
      });
      if (params.draggable) {
        enableDraggable();
      }
      if (el) {
        el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
      }
    }
    function destroy() {
      const params = swiper.params.scrollbar;
      const el = swiper.scrollbar.el;
      if (el) {
        el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
      }
      disableDraggable();
    }
    on("changeDirection", () => {
      if (!swiper.scrollbar || !swiper.scrollbar.el)
        return;
      const params = swiper.params.scrollbar;
      let {
        el
      } = swiper.scrollbar;
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.classList.remove(params.horizontalClass, params.verticalClass);
        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      });
    });
    on("init", () => {
      if (swiper.params.scrollbar.enabled === false) {
        disable();
      } else {
        init4();
        updateSize2();
        setTranslate2();
      }
    });
    on("update resize observerUpdate lock unlock changeDirection", () => {
      updateSize2();
    });
    on("setTranslate", () => {
      setTranslate2();
    });
    on("setTransition", (_s, duration) => {
      setTransition2(duration);
    });
    on("enable disable", () => {
      const {
        el
      } = swiper.scrollbar;
      if (el) {
        el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
      }
    });
    on("destroy", () => {
      destroy();
    });
    const enable = () => {
      swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
      if (swiper.scrollbar.el) {
        swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
      }
      init4();
      updateSize2();
      setTranslate2();
    };
    const disable = () => {
      swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
      if (swiper.scrollbar.el) {
        swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
      }
      destroy();
    };
    Object.assign(swiper.scrollbar, {
      enable,
      disable,
      updateSize: updateSize2,
      setTranslate: setTranslate2,
      init: init4,
      destroy
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/parallax.mjs
  init_live_reload();
  function Parallax(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      parallax: {
        enabled: false
      }
    });
    const elementsSelector = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]";
    const setTransform = (el, progress) => {
      const {
        rtl
      } = swiper;
      const rtlFactor = rtl ? -1 : 1;
      const p = el.getAttribute("data-swiper-parallax") || "0";
      let x = el.getAttribute("data-swiper-parallax-x");
      let y = el.getAttribute("data-swiper-parallax-y");
      const scale = el.getAttribute("data-swiper-parallax-scale");
      const opacity = el.getAttribute("data-swiper-parallax-opacity");
      const rotate = el.getAttribute("data-swiper-parallax-rotate");
      if (x || y) {
        x = x || "0";
        y = y || "0";
      } else if (swiper.isHorizontal()) {
        x = p;
        y = "0";
      } else {
        y = p;
        x = "0";
      }
      if (x.indexOf("%") >= 0) {
        x = `${parseInt(x, 10) * progress * rtlFactor}%`;
      } else {
        x = `${x * progress * rtlFactor}px`;
      }
      if (y.indexOf("%") >= 0) {
        y = `${parseInt(y, 10) * progress}%`;
      } else {
        y = `${y * progress}px`;
      }
      if (typeof opacity !== "undefined" && opacity !== null) {
        const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
        el.style.opacity = currentOpacity;
      }
      let transform = `translate3d(${x}, ${y}, 0px)`;
      if (typeof scale !== "undefined" && scale !== null) {
        const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
        transform += ` scale(${currentScale})`;
      }
      if (rotate && typeof rotate !== "undefined" && rotate !== null) {
        const currentRotate = rotate * progress * -1;
        transform += ` rotate(${currentRotate}deg)`;
      }
      el.style.transform = transform;
    };
    const setTranslate2 = () => {
      const {
        el,
        slides,
        progress,
        snapGrid,
        isElement
      } = swiper;
      const elements = elementChildren(el, elementsSelector);
      if (swiper.isElement) {
        elements.push(...elementChildren(swiper.hostEl, elementsSelector));
      }
      elements.forEach((subEl) => {
        setTransform(subEl, progress);
      });
      slides.forEach((slideEl, slideIndex) => {
        let slideProgress = slideEl.progress;
        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
        }
        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach((subEl) => {
          setTransform(subEl, slideProgress);
        });
      });
    };
    const setTransition2 = function(duration) {
      if (duration === void 0) {
        duration = swiper.params.speed;
      }
      const {
        el,
        hostEl
      } = swiper;
      const elements = [...el.querySelectorAll(elementsSelector)];
      if (swiper.isElement) {
        elements.push(...hostEl.querySelectorAll(elementsSelector));
      }
      elements.forEach((parallaxEl) => {
        let parallaxDuration = parseInt(parallaxEl.getAttribute("data-swiper-parallax-duration"), 10) || duration;
        if (duration === 0)
          parallaxDuration = 0;
        parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
      });
    };
    on("beforeInit", () => {
      if (!swiper.params.parallax.enabled)
        return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    });
    on("init", () => {
      if (!swiper.params.parallax.enabled)
        return;
      setTranslate2();
    });
    on("setTranslate", () => {
      if (!swiper.params.parallax.enabled)
        return;
      setTranslate2();
    });
    on("setTransition", (_swiper, duration) => {
      if (!swiper.params.parallax.enabled)
        return;
      setTransition2(duration);
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/zoom.mjs
  init_live_reload();
  function Zoom(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const window2 = getWindow();
    extendParams({
      zoom: {
        enabled: false,
        limitToOriginalSize: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: "swiper-zoom-container",
        zoomedSlideClass: "swiper-slide-zoomed"
      }
    });
    swiper.zoom = {
      enabled: false
    };
    let currentScale = 1;
    let isScaling = false;
    let fakeGestureTouched;
    let fakeGestureMoved;
    const evCache = [];
    const gesture = {
      originX: 0,
      originY: 0,
      slideEl: void 0,
      slideWidth: void 0,
      slideHeight: void 0,
      imageEl: void 0,
      imageWrapEl: void 0,
      maxRatio: 3
    };
    const image = {
      isTouched: void 0,
      isMoved: void 0,
      currentX: void 0,
      currentY: void 0,
      minX: void 0,
      minY: void 0,
      maxX: void 0,
      maxY: void 0,
      width: void 0,
      height: void 0,
      startX: void 0,
      startY: void 0,
      touchesStart: {},
      touchesCurrent: {}
    };
    const velocity = {
      x: void 0,
      y: void 0,
      prevPositionX: void 0,
      prevPositionY: void 0,
      prevTime: void 0
    };
    let scale = 1;
    Object.defineProperty(swiper.zoom, "scale", {
      get() {
        return scale;
      },
      set(value) {
        if (scale !== value) {
          const imageEl = gesture.imageEl;
          const slideEl = gesture.slideEl;
          emit("zoomChange", value, imageEl, slideEl);
        }
        scale = value;
      }
    });
    function getDistanceBetweenTouches() {
      if (evCache.length < 2)
        return 1;
      const x1 = evCache[0].pageX;
      const y1 = evCache[0].pageY;
      const x2 = evCache[1].pageX;
      const y2 = evCache[1].pageY;
      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      return distance;
    }
    function getMaxRatio() {
      const params = swiper.params.zoom;
      const maxRatio = gesture.imageWrapEl.getAttribute("data-swiper-zoom") || params.maxRatio;
      if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
        const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
        return Math.min(imageMaxRatio, maxRatio);
      }
      return maxRatio;
    }
    function getScaleOrigin() {
      if (evCache.length < 2)
        return {
          x: null,
          y: null
        };
      const box = gesture.imageEl.getBoundingClientRect();
      return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window2.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window2.scrollY) / currentScale];
    }
    function getSlideSelector() {
      return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    }
    function eventWithinSlide(e) {
      const slideSelector = getSlideSelector();
      if (e.target.matches(slideSelector))
        return true;
      if (swiper.slides.filter((slideEl) => slideEl.contains(e.target)).length > 0)
        return true;
      return false;
    }
    function eventWithinZoomContainer(e) {
      const selector3 = `.${swiper.params.zoom.containerClass}`;
      if (e.target.matches(selector3))
        return true;
      if ([...swiper.hostEl.querySelectorAll(selector3)].filter((containerEl) => containerEl.contains(e.target)).length > 0)
        return true;
      return false;
    }
    function onGestureStart(e) {
      if (e.pointerType === "mouse") {
        evCache.splice(0, evCache.length);
      }
      if (!eventWithinSlide(e))
        return;
      const params = swiper.params.zoom;
      fakeGestureTouched = false;
      fakeGestureMoved = false;
      evCache.push(e);
      if (evCache.length < 2) {
        return;
      }
      fakeGestureTouched = true;
      gesture.scaleStart = getDistanceBetweenTouches();
      if (!gesture.slideEl) {
        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
        if (!gesture.slideEl)
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
        if (imageEl) {
          imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
        }
        gesture.imageEl = imageEl;
        if (imageEl) {
          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
        } else {
          gesture.imageWrapEl = void 0;
        }
        if (!gesture.imageWrapEl) {
          gesture.imageEl = void 0;
          return;
        }
        gesture.maxRatio = getMaxRatio();
      }
      if (gesture.imageEl) {
        const [originX, originY] = getScaleOrigin();
        gesture.originX = originX;
        gesture.originY = originY;
        gesture.imageEl.style.transitionDuration = "0ms";
      }
      isScaling = true;
    }
    function onGestureChange(e) {
      if (!eventWithinSlide(e))
        return;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;
      const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);
      if (pointerIndex >= 0)
        evCache[pointerIndex] = e;
      if (evCache.length < 2) {
        return;
      }
      fakeGestureMoved = true;
      gesture.scaleMove = getDistanceBetweenTouches();
      if (!gesture.imageEl) {
        return;
      }
      zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
      }
      if (zoom.scale < params.minRatio) {
        zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
      }
      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    }
    function onGestureEnd(e) {
      if (!eventWithinSlide(e))
        return;
      if (e.pointerType === "mouse" && e.type === "pointerout")
        return;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;
      const pointerIndex = evCache.findIndex((cachedEv) => cachedEv.pointerId === e.pointerId);
      if (pointerIndex >= 0)
        evCache.splice(pointerIndex, 1);
      if (!fakeGestureTouched || !fakeGestureMoved) {
        return;
      }
      fakeGestureTouched = false;
      fakeGestureMoved = false;
      if (!gesture.imageEl)
        return;
      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
      currentScale = zoom.scale;
      isScaling = false;
      if (zoom.scale > 1 && gesture.slideEl) {
        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
      } else if (zoom.scale <= 1 && gesture.slideEl) {
        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
      }
      if (zoom.scale === 1) {
        gesture.originX = 0;
        gesture.originY = 0;
        gesture.slideEl = void 0;
      }
    }
    let allowTouchMoveTimeout;
    function allowTouchMove() {
      swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
    }
    function preventTouchMove() {
      clearTimeout(allowTouchMoveTimeout);
      swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
      allowTouchMoveTimeout = setTimeout(() => {
        if (swiper.destroyed)
          return;
        allowTouchMove();
      });
    }
    function onTouchStart2(e) {
      const device = swiper.device;
      if (!gesture.imageEl)
        return;
      if (image.isTouched)
        return;
      if (device.android && e.cancelable)
        e.preventDefault();
      image.isTouched = true;
      const event2 = evCache.length > 0 ? evCache[0] : e;
      image.touchesStart.x = event2.pageX;
      image.touchesStart.y = event2.pageY;
    }
    function onTouchMove2(e) {
      if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
        return;
      }
      const zoom = swiper.zoom;
      if (!gesture.imageEl) {
        return;
      }
      if (!image.isTouched || !gesture.slideEl) {
        return;
      }
      if (!image.isMoved) {
        image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
        image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
        image.startX = getTranslate(gesture.imageWrapEl, "x") || 0;
        image.startY = getTranslate(gesture.imageWrapEl, "y") || 0;
        gesture.slideWidth = gesture.slideEl.offsetWidth;
        gesture.slideHeight = gesture.slideEl.offsetHeight;
        gesture.imageWrapEl.style.transitionDuration = "0ms";
      }
      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
      image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
      const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
      if (touchesDiff > 5) {
        swiper.allowClick = false;
      }
      if (!image.isMoved && !isScaling) {
        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
          image.isTouched = false;
          allowTouchMove();
          return;
        }
        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
          image.isTouched = false;
          allowTouchMove();
          return;
        }
      }
      if (e.cancelable) {
        e.preventDefault();
      }
      e.stopPropagation();
      preventTouchMove();
      image.isMoved = true;
      const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
      const {
        originX,
        originY
      } = gesture;
      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
      if (image.currentX < image.minX) {
        image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
      }
      if (image.currentX > image.maxX) {
        image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
      }
      if (image.currentY < image.minY) {
        image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
      }
      if (image.currentY > image.maxY) {
        image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
      }
      if (!velocity.prevPositionX)
        velocity.prevPositionX = image.touchesCurrent.x;
      if (!velocity.prevPositionY)
        velocity.prevPositionY = image.touchesCurrent.y;
      if (!velocity.prevTime)
        velocity.prevTime = Date.now();
      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)
        velocity.x = 0;
      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)
        velocity.y = 0;
      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();
      gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
    }
    function onTouchEnd2() {
      const zoom = swiper.zoom;
      if (!gesture.imageEl)
        return;
      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }
      image.isTouched = false;
      image.isMoved = false;
      let momentumDurationX = 300;
      let momentumDurationY = 300;
      const momentumDistanceX = velocity.x * momentumDurationX;
      const newPositionX = image.currentX + momentumDistanceX;
      const momentumDistanceY = velocity.y * momentumDurationY;
      const newPositionY = image.currentY + momentumDistanceY;
      if (velocity.x !== 0)
        momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      if (velocity.y !== 0)
        momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
      image.currentX = newPositionX;
      image.currentY = newPositionY;
      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
      gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
      gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
    }
    function onTransitionEnd() {
      const zoom = swiper.zoom;
      if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
        if (gesture.imageEl) {
          gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
        }
        if (gesture.imageWrapEl) {
          gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
        }
        gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
        zoom.scale = 1;
        currentScale = 1;
        gesture.slideEl = void 0;
        gesture.imageEl = void 0;
        gesture.imageWrapEl = void 0;
        gesture.originX = 0;
        gesture.originY = 0;
      }
    }
    function zoomIn(e) {
      const zoom = swiper.zoom;
      const params = swiper.params.zoom;
      if (!gesture.slideEl) {
        if (e && e.target) {
          gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
        }
        if (!gesture.slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
          } else {
            gesture.slideEl = swiper.slides[swiper.activeIndex];
          }
        }
        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
        if (imageEl) {
          imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
        }
        gesture.imageEl = imageEl;
        if (imageEl) {
          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
        } else {
          gesture.imageWrapEl = void 0;
        }
      }
      if (!gesture.imageEl || !gesture.imageWrapEl)
        return;
      if (swiper.params.cssMode) {
        swiper.wrapperEl.style.overflow = "hidden";
        swiper.wrapperEl.style.touchAction = "none";
      }
      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
      let touchX;
      let touchY;
      let offsetX;
      let offsetY;
      let diffX;
      let diffY;
      let translateX;
      let translateY;
      let imageWidth;
      let imageHeight;
      let scaledWidth;
      let scaledHeight;
      let translateMinX;
      let translateMinY;
      let translateMaxX;
      let translateMaxY;
      let slideWidth;
      let slideHeight;
      if (typeof image.touchesStart.x === "undefined" && e) {
        touchX = e.pageX;
        touchY = e.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }
      const forceZoomRatio = typeof e === "number" ? e : null;
      if (currentScale === 1 && forceZoomRatio) {
        touchX = void 0;
        touchY = void 0;
        image.touchesStart.x = void 0;
        image.touchesStart.y = void 0;
      }
      const maxRatio = getMaxRatio();
      zoom.scale = forceZoomRatio || maxRatio;
      currentScale = forceZoomRatio || maxRatio;
      if (e && !(currentScale === 1 && forceZoomRatio)) {
        slideWidth = gesture.slideEl.offsetWidth;
        slideHeight = gesture.slideEl.offsetHeight;
        offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;
        offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;
        diffX = offsetX + slideWidth / 2 - touchX;
        diffY = offsetY + slideHeight / 2 - touchY;
        imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
        imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;
        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;
        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;
        if (translateX < translateMinX) {
          translateX = translateMinX;
        }
        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }
        if (translateY < translateMinY) {
          translateY = translateMinY;
        }
        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }
      if (forceZoomRatio && zoom.scale === 1) {
        gesture.originX = 0;
        gesture.originY = 0;
      }
      gesture.imageWrapEl.style.transitionDuration = "300ms";
      gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
      gesture.imageEl.style.transitionDuration = "300ms";
      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    }
    function zoomOut() {
      const zoom = swiper.zoom;
      const params = swiper.params.zoom;
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
        if (imageEl) {
          imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
        }
        gesture.imageEl = imageEl;
        if (imageEl) {
          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
        } else {
          gesture.imageWrapEl = void 0;
        }
      }
      if (!gesture.imageEl || !gesture.imageWrapEl)
        return;
      if (swiper.params.cssMode) {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.style.touchAction = "";
      }
      zoom.scale = 1;
      currentScale = 1;
      image.touchesStart.x = void 0;
      image.touchesStart.y = void 0;
      gesture.imageWrapEl.style.transitionDuration = "300ms";
      gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
      gesture.imageEl.style.transitionDuration = "300ms";
      gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
      gesture.slideEl = void 0;
      gesture.originX = 0;
      gesture.originY = 0;
    }
    function zoomToggle(e) {
      const zoom = swiper.zoom;
      if (zoom.scale && zoom.scale !== 1) {
        zoomOut();
      } else {
        zoomIn(e);
      }
    }
    function getListeners() {
      const passiveListener = swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      const activeListenerWithCapture = swiper.params.passiveListeners ? {
        passive: false,
        capture: true
      } : true;
      return {
        passiveListener,
        activeListenerWithCapture
      };
    }
    function enable() {
      const zoom = swiper.zoom;
      if (zoom.enabled)
        return;
      zoom.enabled = true;
      const {
        passiveListener,
        activeListenerWithCapture
      } = getListeners();
      swiper.wrapperEl.addEventListener("pointerdown", onGestureStart, passiveListener);
      swiper.wrapperEl.addEventListener("pointermove", onGestureChange, activeListenerWithCapture);
      ["pointerup", "pointercancel", "pointerout"].forEach((eventName) => {
        swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
      });
      swiper.wrapperEl.addEventListener("pointermove", onTouchMove2, activeListenerWithCapture);
    }
    function disable() {
      const zoom = swiper.zoom;
      if (!zoom.enabled)
        return;
      zoom.enabled = false;
      const {
        passiveListener,
        activeListenerWithCapture
      } = getListeners();
      swiper.wrapperEl.removeEventListener("pointerdown", onGestureStart, passiveListener);
      swiper.wrapperEl.removeEventListener("pointermove", onGestureChange, activeListenerWithCapture);
      ["pointerup", "pointercancel", "pointerout"].forEach((eventName) => {
        swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
      });
      swiper.wrapperEl.removeEventListener("pointermove", onTouchMove2, activeListenerWithCapture);
    }
    on("init", () => {
      if (swiper.params.zoom.enabled) {
        enable();
      }
    });
    on("destroy", () => {
      disable();
    });
    on("touchStart", (_s, e) => {
      if (!swiper.zoom.enabled)
        return;
      onTouchStart2(e);
    });
    on("touchEnd", (_s, e) => {
      if (!swiper.zoom.enabled)
        return;
      onTouchEnd2();
    });
    on("doubleTap", (_s, e) => {
      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        zoomToggle(e);
      }
    });
    on("transitionEnd", () => {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        onTransitionEnd();
      }
    });
    on("slideChange", () => {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        onTransitionEnd();
      }
    });
    Object.assign(swiper.zoom, {
      enable,
      disable,
      in: zoomIn,
      out: zoomOut,
      toggle: zoomToggle
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/controller.mjs
  init_live_reload();
  function Controller(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      controller: {
        control: void 0,
        inverse: false,
        by: "slide"
        // or 'container'
      }
    });
    swiper.controller = {
      control: void 0
    };
    function LinearSpline(x, y) {
      const binarySearch = /* @__PURE__ */ function search() {
        let maxIndex;
        let minIndex;
        let guess;
        return (array, val) => {
          minIndex = -1;
          maxIndex = array.length;
          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;
            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }
          return maxIndex;
        };
      }();
      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1;
      let i1;
      let i3;
      this.interpolate = function interpolate3(x2) {
        if (!x2)
          return 0;
        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1;
        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
      };
      return this;
    }
    function getInterpolateFunction(c) {
      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
    }
    function setTranslate2(_t, byController) {
      const controlled = swiper.controller.control;
      let multiplier;
      let controlledTranslate;
      const Swiper2 = swiper.constructor;
      function setControlledTranslate(c) {
        if (c.destroyed)
          return;
        const translate2 = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
        if (swiper.params.controller.by === "slide") {
          getInterpolateFunction(c);
          controlledTranslate = -swiper.controller.spline.interpolate(-translate2);
        }
        if (!controlledTranslate || swiper.params.controller.by === "container") {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
          if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
            multiplier = 1;
          }
          controlledTranslate = (translate2 - swiper.minTranslate()) * multiplier + c.minTranslate();
        }
        if (swiper.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }
        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }
      if (Array.isArray(controlled)) {
        for (let i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper2 && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    }
    function setTransition2(duration, byController) {
      const Swiper2 = swiper.constructor;
      const controlled = swiper.controller.control;
      let i;
      function setControlledTransition(c) {
        if (c.destroyed)
          return;
        c.setTransition(duration, swiper);
        if (duration !== 0) {
          c.transitionStart();
          if (c.params.autoHeight) {
            nextTick(() => {
              c.updateAutoHeight();
            });
          }
          elementTransitionEnd(c.wrapperEl, () => {
            if (!controlled)
              return;
            c.transitionEnd();
          });
        }
      }
      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper2 && byController !== controlled) {
        setControlledTransition(controlled);
      }
    }
    function removeSpline() {
      if (!swiper.controller.control)
        return;
      if (swiper.controller.spline) {
        swiper.controller.spline = void 0;
        delete swiper.controller.spline;
      }
    }
    on("beforeInit", () => {
      if (typeof window !== "undefined" && // eslint-disable-line
      (typeof swiper.params.controller.control === "string" || swiper.params.controller.control instanceof HTMLElement)) {
        const controlElements = typeof swiper.params.controller.control === "string" ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];
        controlElements.forEach((controlElement) => {
          if (!swiper.controller.control)
            swiper.controller.control = [];
          if (controlElement && controlElement.swiper) {
            swiper.controller.control.push(controlElement.swiper);
          } else if (controlElement) {
            const eventName = `${swiper.params.eventsPrefix}init`;
            const onControllerSwiper = (e) => {
              swiper.controller.control.push(e.detail[0]);
              swiper.update();
              controlElement.removeEventListener(eventName, onControllerSwiper);
            };
            controlElement.addEventListener(eventName, onControllerSwiper);
          }
        });
        return;
      }
      swiper.controller.control = swiper.params.controller.control;
    });
    on("update", () => {
      removeSpline();
    });
    on("resize", () => {
      removeSpline();
    });
    on("observerUpdate", () => {
      removeSpline();
    });
    on("setTranslate", (_s, translate2, byController) => {
      if (!swiper.controller.control || swiper.controller.control.destroyed)
        return;
      swiper.controller.setTranslate(translate2, byController);
    });
    on("setTransition", (_s, duration, byController) => {
      if (!swiper.controller.control || swiper.controller.control.destroyed)
        return;
      swiper.controller.setTransition(duration, byController);
    });
    Object.assign(swiper.controller, {
      setTranslate: setTranslate2,
      setTransition: setTransition2
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/a11y.mjs
  init_live_reload();
  function A11y(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      a11y: {
        enabled: true,
        notificationClass: "swiper-notification",
        prevSlideMessage: "Previous slide",
        nextSlideMessage: "Next slide",
        firstSlideMessage: "This is the first slide",
        lastSlideMessage: "This is the last slide",
        paginationBulletMessage: "Go to slide {{index}}",
        slideLabelMessage: "{{index}} / {{slidesLength}}",
        containerMessage: null,
        containerRoleDescriptionMessage: null,
        containerRole: null,
        itemRoleDescriptionMessage: null,
        slideRole: "group",
        id: null,
        scrollOnFocus: true
      }
    });
    swiper.a11y = {
      clicked: false
    };
    let liveRegion = null;
    let preventFocusHandler;
    let focusTargetSlideEl;
    let visibilityChangedTimestamp = (/* @__PURE__ */ new Date()).getTime();
    function notify(message) {
      const notification = liveRegion;
      if (notification.length === 0)
        return;
      notification.innerHTML = "";
      notification.innerHTML = message;
    }
    function getRandomNumber(size) {
      if (size === void 0) {
        size = 16;
      }
      const randomChar = () => Math.round(16 * Math.random()).toString(16);
      return "x".repeat(size).replace(/x/g, randomChar);
    }
    function makeElFocusable(el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("tabIndex", "0");
      });
    }
    function makeElNotFocusable(el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("tabIndex", "-1");
      });
    }
    function addElRole(el, role) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("role", role);
      });
    }
    function addElRoleDescription(el, description) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("aria-roledescription", description);
      });
    }
    function addElControls(el, controls) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("aria-controls", controls);
      });
    }
    function addElLabel(el, label) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("aria-label", label);
      });
    }
    function addElId(el, id) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("id", id);
      });
    }
    function addElLive(el, live) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("aria-live", live);
      });
    }
    function disableEl(el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("aria-disabled", true);
      });
    }
    function enableEl(el) {
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        subEl.setAttribute("aria-disabled", false);
      });
    }
    function onEnterOrSpaceKey(e) {
      if (e.keyCode !== 13 && e.keyCode !== 32)
        return;
      const params = swiper.params.a11y;
      const targetEl = e.target;
      if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
        if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass)))
          return;
      }
      if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
        const prevEls = makeElementsArray(swiper.navigation.prevEl);
        const nextEls = makeElementsArray(swiper.navigation.nextEl);
        if (nextEls.includes(targetEl)) {
          if (!(swiper.isEnd && !swiper.params.loop)) {
            swiper.slideNext();
          }
          if (swiper.isEnd) {
            notify(params.lastSlideMessage);
          } else {
            notify(params.nextSlideMessage);
          }
        }
        if (prevEls.includes(targetEl)) {
          if (!(swiper.isBeginning && !swiper.params.loop)) {
            swiper.slidePrev();
          }
          if (swiper.isBeginning) {
            notify(params.firstSlideMessage);
          } else {
            notify(params.prevSlideMessage);
          }
        }
      }
      if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
        targetEl.click();
      }
    }
    function updateNavigation() {
      if (swiper.params.loop || swiper.params.rewind || !swiper.navigation)
        return;
      const {
        nextEl,
        prevEl
      } = swiper.navigation;
      if (prevEl) {
        if (swiper.isBeginning) {
          disableEl(prevEl);
          makeElNotFocusable(prevEl);
        } else {
          enableEl(prevEl);
          makeElFocusable(prevEl);
        }
      }
      if (nextEl) {
        if (swiper.isEnd) {
          disableEl(nextEl);
          makeElNotFocusable(nextEl);
        } else {
          enableEl(nextEl);
          makeElFocusable(nextEl);
        }
      }
    }
    function hasPagination() {
      return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
    }
    function hasClickablePagination() {
      return hasPagination() && swiper.params.pagination.clickable;
    }
    function updatePagination() {
      const params = swiper.params.a11y;
      if (!hasPagination())
        return;
      swiper.pagination.bullets.forEach((bulletEl) => {
        if (swiper.params.pagination.clickable) {
          makeElFocusable(bulletEl);
          if (!swiper.params.pagination.renderBullet) {
            addElRole(bulletEl, "button");
            addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
          }
        }
        if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
          bulletEl.setAttribute("aria-current", "true");
        } else {
          bulletEl.removeAttribute("aria-current");
        }
      });
    }
    const initNavEl = (el, wrapperId, message) => {
      makeElFocusable(el);
      if (el.tagName !== "BUTTON") {
        addElRole(el, "button");
        el.addEventListener("keydown", onEnterOrSpaceKey);
      }
      addElLabel(el, message);
      addElControls(el, wrapperId);
    };
    const handlePointerDown = (e) => {
      if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {
        preventFocusHandler = true;
      }
      swiper.a11y.clicked = true;
    };
    const handlePointerUp = () => {
      preventFocusHandler = false;
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (!swiper.destroyed) {
            swiper.a11y.clicked = false;
          }
        });
      });
    };
    const onVisibilityChange = (e) => {
      visibilityChangedTimestamp = (/* @__PURE__ */ new Date()).getTime();
    };
    const handleFocus = (e) => {
      if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus)
        return;
      if ((/* @__PURE__ */ new Date()).getTime() - visibilityChangedTimestamp < 100)
        return;
      const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      if (!slideEl || !swiper.slides.includes(slideEl))
        return;
      focusTargetSlideEl = slideEl;
      const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
      const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
      if (isActive || isVisible)
        return;
      if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents)
        return;
      if (swiper.isHorizontal()) {
        swiper.el.scrollLeft = 0;
      } else {
        swiper.el.scrollTop = 0;
      }
      requestAnimationFrame(() => {
        if (preventFocusHandler)
          return;
        if (swiper.params.loop) {
          swiper.slideToLoop(parseInt(slideEl.getAttribute("data-swiper-slide-index")), 0);
        } else {
          swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
        }
        preventFocusHandler = false;
      });
    };
    const initSlides = () => {
      const params = swiper.params.a11y;
      if (params.itemRoleDescriptionMessage) {
        addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
      }
      if (params.slideRole) {
        addElRole(swiper.slides, params.slideRole);
      }
      const slidesLength = swiper.slides.length;
      if (params.slideLabelMessage) {
        swiper.slides.forEach((slideEl, index) => {
          const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10) : index;
          const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
          addElLabel(slideEl, ariaLabelMessage);
        });
      }
    };
    const init4 = () => {
      const params = swiper.params.a11y;
      swiper.el.append(liveRegion);
      const containerEl = swiper.el;
      if (params.containerRoleDescriptionMessage) {
        addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
      }
      if (params.containerMessage) {
        addElLabel(containerEl, params.containerMessage);
      }
      if (params.containerRole) {
        addElRole(containerEl, params.containerRole);
      }
      const wrapperEl = swiper.wrapperEl;
      const wrapperId = params.id || wrapperEl.getAttribute("id") || `swiper-wrapper-${getRandomNumber(16)}`;
      const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
      addElId(wrapperEl, wrapperId);
      addElLive(wrapperEl, live);
      initSlides();
      let {
        nextEl,
        prevEl
      } = swiper.navigation ? swiper.navigation : {};
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      if (nextEl) {
        nextEl.forEach((el) => initNavEl(el, wrapperId, params.nextSlideMessage));
      }
      if (prevEl) {
        prevEl.forEach((el) => initNavEl(el, wrapperId, params.prevSlideMessage));
      }
      if (hasClickablePagination()) {
        const paginationEl = makeElementsArray(swiper.pagination.el);
        paginationEl.forEach((el) => {
          el.addEventListener("keydown", onEnterOrSpaceKey);
        });
      }
      const document2 = getDocument();
      document2.addEventListener("visibilitychange", onVisibilityChange);
      swiper.el.addEventListener("focus", handleFocus, true);
      swiper.el.addEventListener("focus", handleFocus, true);
      swiper.el.addEventListener("pointerdown", handlePointerDown, true);
      swiper.el.addEventListener("pointerup", handlePointerUp, true);
    };
    function destroy() {
      if (liveRegion)
        liveRegion.remove();
      let {
        nextEl,
        prevEl
      } = swiper.navigation ? swiper.navigation : {};
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      if (nextEl) {
        nextEl.forEach((el) => el.removeEventListener("keydown", onEnterOrSpaceKey));
      }
      if (prevEl) {
        prevEl.forEach((el) => el.removeEventListener("keydown", onEnterOrSpaceKey));
      }
      if (hasClickablePagination()) {
        const paginationEl = makeElementsArray(swiper.pagination.el);
        paginationEl.forEach((el) => {
          el.removeEventListener("keydown", onEnterOrSpaceKey);
        });
      }
      const document2 = getDocument();
      document2.removeEventListener("visibilitychange", onVisibilityChange);
      if (swiper.el && typeof swiper.el !== "string") {
        swiper.el.removeEventListener("focus", handleFocus, true);
        swiper.el.removeEventListener("pointerdown", handlePointerDown, true);
        swiper.el.removeEventListener("pointerup", handlePointerUp, true);
      }
    }
    on("beforeInit", () => {
      liveRegion = createElement("span", swiper.params.a11y.notificationClass);
      liveRegion.setAttribute("aria-live", "assertive");
      liveRegion.setAttribute("aria-atomic", "true");
    });
    on("afterInit", () => {
      if (!swiper.params.a11y.enabled)
        return;
      init4();
    });
    on("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
      if (!swiper.params.a11y.enabled)
        return;
      initSlides();
    });
    on("fromEdge toEdge afterInit lock unlock", () => {
      if (!swiper.params.a11y.enabled)
        return;
      updateNavigation();
    });
    on("paginationUpdate", () => {
      if (!swiper.params.a11y.enabled)
        return;
      updatePagination();
    });
    on("destroy", () => {
      if (!swiper.params.a11y.enabled)
        return;
      destroy();
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/history.mjs
  init_live_reload();
  function History(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      history: {
        enabled: false,
        root: "",
        replaceState: false,
        key: "slides",
        keepQuery: false
      }
    });
    let initialized = false;
    let paths = {};
    const slugify = (text) => {
      return text.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
    };
    const getPathValues = (urlOverride) => {
      const window2 = getWindow();
      let location2;
      if (urlOverride) {
        location2 = new URL(urlOverride);
      } else {
        location2 = window2.location;
      }
      const pathArray = location2.pathname.slice(1).split("/").filter((part) => part !== "");
      const total = pathArray.length;
      const key = pathArray[total - 2];
      const value = pathArray[total - 1];
      return {
        key,
        value
      };
    };
    const setHistory = (key, index) => {
      const window2 = getWindow();
      if (!initialized || !swiper.params.history.enabled)
        return;
      let location2;
      if (swiper.params.url) {
        location2 = new URL(swiper.params.url);
      } else {
        location2 = window2.location;
      }
      const slide2 = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${index}"]`) : swiper.slides[index];
      let value = slugify(slide2.getAttribute("data-history"));
      if (swiper.params.history.root.length > 0) {
        let root = swiper.params.history.root;
        if (root[root.length - 1] === "/")
          root = root.slice(0, root.length - 1);
        value = `${root}/${key ? `${key}/` : ""}${value}`;
      } else if (!location2.pathname.includes(key)) {
        value = `${key ? `${key}/` : ""}${value}`;
      }
      if (swiper.params.history.keepQuery) {
        value += location2.search;
      }
      const currentState = window2.history.state;
      if (currentState && currentState.value === value) {
        return;
      }
      if (swiper.params.history.replaceState) {
        window2.history.replaceState({
          value
        }, null, value);
      } else {
        window2.history.pushState({
          value
        }, null, value);
      }
    };
    const scrollToSlide = (speed, value, runCallbacks) => {
      if (value) {
        for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
          const slide2 = swiper.slides[i];
          const slideHistory = slugify(slide2.getAttribute("data-history"));
          if (slideHistory === value) {
            const index = swiper.getSlideIndex(slide2);
            swiper.slideTo(index, speed, runCallbacks);
          }
        }
      } else {
        swiper.slideTo(0, speed, runCallbacks);
      }
    };
    const setHistoryPopState = () => {
      paths = getPathValues(swiper.params.url);
      scrollToSlide(swiper.params.speed, paths.value, false);
    };
    const init4 = () => {
      const window2 = getWindow();
      if (!swiper.params.history)
        return;
      if (!window2.history || !window2.history.pushState) {
        swiper.params.history.enabled = false;
        swiper.params.hashNavigation.enabled = true;
        return;
      }
      initialized = true;
      paths = getPathValues(swiper.params.url);
      if (!paths.key && !paths.value) {
        if (!swiper.params.history.replaceState) {
          window2.addEventListener("popstate", setHistoryPopState);
        }
        return;
      }
      scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
      if (!swiper.params.history.replaceState) {
        window2.addEventListener("popstate", setHistoryPopState);
      }
    };
    const destroy = () => {
      const window2 = getWindow();
      if (!swiper.params.history.replaceState) {
        window2.removeEventListener("popstate", setHistoryPopState);
      }
    };
    on("init", () => {
      if (swiper.params.history.enabled) {
        init4();
      }
    });
    on("destroy", () => {
      if (swiper.params.history.enabled) {
        destroy();
      }
    });
    on("transitionEnd _freeModeNoMomentumRelease", () => {
      if (initialized) {
        setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    });
    on("slideChange", () => {
      if (initialized && swiper.params.cssMode) {
        setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/hash-navigation.mjs
  init_live_reload();
  function HashNavigation(_ref) {
    let {
      swiper,
      extendParams,
      emit,
      on
    } = _ref;
    let initialized = false;
    const document2 = getDocument();
    const window2 = getWindow();
    extendParams({
      hashNavigation: {
        enabled: false,
        replaceState: false,
        watchState: false,
        getSlideIndex(_s, hash) {
          if (swiper.virtual && swiper.params.virtual.enabled) {
            const slideWithHash = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-hash") === hash)[0];
            if (!slideWithHash)
              return 0;
            const index = parseInt(slideWithHash.getAttribute("data-swiper-slide-index"), 10);
            return index;
          }
          return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
        }
      }
    });
    const onHashChange = () => {
      emit("hashChange");
      const newHash = document2.location.hash.replace("#", "");
      const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
      const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") : "";
      if (newHash !== activeSlideHash) {
        const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
        if (typeof newIndex === "undefined" || Number.isNaN(newIndex))
          return;
        swiper.slideTo(newIndex);
      }
    };
    const setHash = () => {
      if (!initialized || !swiper.params.hashNavigation.enabled)
        return;
      const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
      const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") || activeSlideEl.getAttribute("data-history") : "";
      if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
        window2.history.replaceState(null, null, `#${activeSlideHash}` || "");
        emit("hashSet");
      } else {
        document2.location.hash = activeSlideHash || "";
        emit("hashSet");
      }
    };
    const init4 = () => {
      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled)
        return;
      initialized = true;
      const hash = document2.location.hash.replace("#", "");
      if (hash) {
        const speed = 0;
        const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
        swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
      }
      if (swiper.params.hashNavigation.watchState) {
        window2.addEventListener("hashchange", onHashChange);
      }
    };
    const destroy = () => {
      if (swiper.params.hashNavigation.watchState) {
        window2.removeEventListener("hashchange", onHashChange);
      }
    };
    on("init", () => {
      if (swiper.params.hashNavigation.enabled) {
        init4();
      }
    });
    on("destroy", () => {
      if (swiper.params.hashNavigation.enabled) {
        destroy();
      }
    });
    on("transitionEnd _freeModeNoMomentumRelease", () => {
      if (initialized) {
        setHash();
      }
    });
    on("slideChange", () => {
      if (initialized && swiper.params.cssMode) {
        setHash();
      }
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/autoplay.mjs
  init_live_reload();
  function Autoplay(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit,
      params
    } = _ref;
    swiper.autoplay = {
      running: false,
      paused: false,
      timeLeft: 0
    };
    extendParams({
      autoplay: {
        enabled: false,
        delay: 3e3,
        waitForTransition: true,
        disableOnInteraction: false,
        stopOnLastSlide: false,
        reverseDirection: false,
        pauseOnMouseEnter: false
      }
    });
    let timeout;
    let raf;
    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayTimeLeft;
    let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    let wasPaused;
    let isTouched;
    let pausedByTouch;
    let touchStartTimeout;
    let slideChanged;
    let pausedByInteraction;
    let pausedByPointerEnter;
    function onTransitionEnd(e) {
      if (!swiper || swiper.destroyed || !swiper.wrapperEl)
        return;
      if (e.target !== swiper.wrapperEl)
        return;
      swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
      if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
        return;
      }
      resume();
    }
    const calcTimeLeft = () => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      if (swiper.autoplay.paused) {
        wasPaused = true;
      } else if (wasPaused) {
        autoplayDelayCurrent = autoplayTimeLeft;
        wasPaused = false;
      }
      const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();
      swiper.autoplay.timeLeft = timeLeft;
      emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
      raf = requestAnimationFrame(() => {
        calcTimeLeft();
      });
    };
    const getSlideDelay = () => {
      let activeSlideEl;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        activeSlideEl = swiper.slides.filter((slideEl) => slideEl.classList.contains("swiper-slide-active"))[0];
      } else {
        activeSlideEl = swiper.slides[swiper.activeIndex];
      }
      if (!activeSlideEl)
        return void 0;
      const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
      return currentSlideDelay;
    };
    const run = (delayForce) => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      cancelAnimationFrame(raf);
      calcTimeLeft();
      let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
      autoplayDelayTotal = swiper.params.autoplay.delay;
      autoplayDelayCurrent = swiper.params.autoplay.delay;
      const currentSlideDelay = getSlideDelay();
      if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
        delay = currentSlideDelay;
        autoplayDelayTotal = currentSlideDelay;
        autoplayDelayCurrent = currentSlideDelay;
      }
      autoplayTimeLeft = delay;
      const speed = swiper.params.speed;
      const proceed = () => {
        if (!swiper || swiper.destroyed)
          return;
        if (swiper.params.autoplay.reverseDirection) {
          if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
            swiper.slidePrev(speed, true, true);
            emit("autoplay");
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, speed, true, true);
            emit("autoplay");
          }
        } else {
          if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
            swiper.slideNext(speed, true, true);
            emit("autoplay");
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(0, speed, true, true);
            emit("autoplay");
          }
        }
        if (swiper.params.cssMode) {
          autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
          requestAnimationFrame(() => {
            run();
          });
        }
      };
      if (delay > 0) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          proceed();
        }, delay);
      } else {
        requestAnimationFrame(() => {
          proceed();
        });
      }
      return delay;
    };
    const start = () => {
      autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
      swiper.autoplay.running = true;
      run();
      emit("autoplayStart");
    };
    const stop = () => {
      swiper.autoplay.running = false;
      clearTimeout(timeout);
      cancelAnimationFrame(raf);
      emit("autoplayStop");
    };
    const pause = (internal, reset) => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      clearTimeout(timeout);
      if (!internal) {
        pausedByInteraction = true;
      }
      const proceed = () => {
        emit("autoplayPause");
        if (swiper.params.autoplay.waitForTransition) {
          swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd);
        } else {
          resume();
        }
      };
      swiper.autoplay.paused = true;
      if (reset) {
        if (slideChanged) {
          autoplayTimeLeft = swiper.params.autoplay.delay;
        }
        slideChanged = false;
        proceed();
        return;
      }
      const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
      autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);
      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop)
        return;
      if (autoplayTimeLeft < 0)
        autoplayTimeLeft = 0;
      proceed();
    };
    const resume = () => {
      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running)
        return;
      autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
      if (pausedByInteraction) {
        pausedByInteraction = false;
        run(autoplayTimeLeft);
      } else {
        run();
      }
      swiper.autoplay.paused = false;
      emit("autoplayResume");
    };
    const onVisibilityChange = () => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      const document2 = getDocument();
      if (document2.visibilityState === "hidden") {
        pausedByInteraction = true;
        pause(true);
      }
      if (document2.visibilityState === "visible") {
        resume();
      }
    };
    const onPointerEnter = (e) => {
      if (e.pointerType !== "mouse")
        return;
      pausedByInteraction = true;
      pausedByPointerEnter = true;
      if (swiper.animating || swiper.autoplay.paused)
        return;
      pause(true);
    };
    const onPointerLeave = (e) => {
      if (e.pointerType !== "mouse")
        return;
      pausedByPointerEnter = false;
      if (swiper.autoplay.paused) {
        resume();
      }
    };
    const attachMouseEvents = () => {
      if (swiper.params.autoplay.pauseOnMouseEnter) {
        swiper.el.addEventListener("pointerenter", onPointerEnter);
        swiper.el.addEventListener("pointerleave", onPointerLeave);
      }
    };
    const detachMouseEvents = () => {
      if (swiper.el && typeof swiper.el !== "string") {
        swiper.el.removeEventListener("pointerenter", onPointerEnter);
        swiper.el.removeEventListener("pointerleave", onPointerLeave);
      }
    };
    const attachDocumentEvents = () => {
      const document2 = getDocument();
      document2.addEventListener("visibilitychange", onVisibilityChange);
    };
    const detachDocumentEvents = () => {
      const document2 = getDocument();
      document2.removeEventListener("visibilitychange", onVisibilityChange);
    };
    on("init", () => {
      if (swiper.params.autoplay.enabled) {
        attachMouseEvents();
        attachDocumentEvents();
        start();
      }
    });
    on("destroy", () => {
      detachMouseEvents();
      detachDocumentEvents();
      if (swiper.autoplay.running) {
        stop();
      }
    });
    on("_freeModeStaticRelease", () => {
      if (pausedByTouch || pausedByInteraction) {
        resume();
      }
    });
    on("_freeModeNoMomentumRelease", () => {
      if (!swiper.params.autoplay.disableOnInteraction) {
        pause(true, true);
      } else {
        stop();
      }
    });
    on("beforeTransitionStart", (_s, speed, internal) => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        pause(true, true);
      } else {
        stop();
      }
    });
    on("sliderFirstMove", () => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
        return;
      }
      isTouched = true;
      pausedByTouch = false;
      pausedByInteraction = false;
      touchStartTimeout = setTimeout(() => {
        pausedByInteraction = true;
        pausedByTouch = true;
        pause(true);
      }, 200);
    });
    on("touchEnd", () => {
      if (swiper.destroyed || !swiper.autoplay.running || !isTouched)
        return;
      clearTimeout(touchStartTimeout);
      clearTimeout(timeout);
      if (swiper.params.autoplay.disableOnInteraction) {
        pausedByTouch = false;
        isTouched = false;
        return;
      }
      if (pausedByTouch && swiper.params.cssMode)
        resume();
      pausedByTouch = false;
      isTouched = false;
    });
    on("slideChange", () => {
      if (swiper.destroyed || !swiper.autoplay.running)
        return;
      slideChanged = true;
    });
    Object.assign(swiper.autoplay, {
      start,
      stop,
      pause,
      resume
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/thumbs.mjs
  init_live_reload();
  function Thumb(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: true,
        autoScrollOffset: 0,
        slideThumbActiveClass: "swiper-slide-thumb-active",
        thumbsContainerClass: "swiper-thumbs"
      }
    });
    let initialized = false;
    let swiperCreated = false;
    swiper.thumbs = {
      swiper: null
    };
    function onThumbClick() {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      const clickedIndex = thumbsSwiper.clickedIndex;
      const clickedSlide = thumbsSwiper.clickedSlide;
      if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass))
        return;
      if (typeof clickedIndex === "undefined" || clickedIndex === null)
        return;
      let slideToIndex;
      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
      } else {
        slideToIndex = clickedIndex;
      }
      if (swiper.params.loop) {
        swiper.slideToLoop(slideToIndex);
      } else {
        swiper.slideTo(slideToIndex);
      }
    }
    function init4() {
      const {
        thumbs: thumbsParams
      } = swiper.params;
      if (initialized)
        return false;
      initialized = true;
      const SwiperClass = swiper.constructor;
      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper.thumbs.swiper = thumbsParams.swiper;
        Object.assign(swiper.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        Object.assign(swiper.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        swiper.thumbs.swiper.update();
      } else if (isObject2(thumbsParams.swiper)) {
        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
        Object.assign(thumbsSwiperParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
        swiperCreated = true;
      }
      swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
      swiper.thumbs.swiper.on("tap", onThumbClick);
      return true;
    }
    function update2(initial) {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
      let thumbsToActivate = 1;
      const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
        thumbsToActivate = swiper.params.slidesPerView;
      }
      if (!swiper.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }
      thumbsToActivate = Math.floor(thumbsToActivate);
      thumbsSwiper.slides.forEach((slideEl) => slideEl.classList.remove(thumbActiveClass));
      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach((slideEl) => {
            slideEl.classList.add(thumbActiveClass);
          });
        }
      } else {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          if (thumbsSwiper.slides[swiper.realIndex + i]) {
            thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
          }
        }
      }
      const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
        const currentThumbsIndex = thumbsSwiper.activeIndex;
        let newThumbsIndex;
        let direction;
        if (thumbsSwiper.params.loop) {
          const newThumbsSlide = thumbsSwiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") === `${swiper.realIndex}`)[0];
          newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
          direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
        } else {
          newThumbsIndex = swiper.realIndex;
          direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
        }
        if (useOffset) {
          newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
        }
        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1)
            ;
          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
        }
      }
    }
    on("beforeInit", () => {
      const {
        thumbs
      } = swiper.params;
      if (!thumbs || !thumbs.swiper)
        return;
      if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
        const document2 = getDocument();
        const getThumbsElementAndInit = () => {
          const thumbsElement = typeof thumbs.swiper === "string" ? document2.querySelector(thumbs.swiper) : thumbs.swiper;
          if (thumbsElement && thumbsElement.swiper) {
            thumbs.swiper = thumbsElement.swiper;
            init4();
            update2(true);
          } else if (thumbsElement) {
            const eventName = `${swiper.params.eventsPrefix}init`;
            const onThumbsSwiper = (e) => {
              thumbs.swiper = e.detail[0];
              thumbsElement.removeEventListener(eventName, onThumbsSwiper);
              init4();
              update2(true);
              thumbs.swiper.update();
              swiper.update();
            };
            thumbsElement.addEventListener(eventName, onThumbsSwiper);
          }
          return thumbsElement;
        };
        const watchForThumbsToAppear = () => {
          if (swiper.destroyed)
            return;
          const thumbsElement = getThumbsElementAndInit();
          if (!thumbsElement) {
            requestAnimationFrame(watchForThumbsToAppear);
          }
        };
        requestAnimationFrame(watchForThumbsToAppear);
      } else {
        init4();
        update2(true);
      }
    });
    on("slideChange update resize observerUpdate", () => {
      update2();
    });
    on("setTransition", (_s, duration) => {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      thumbsSwiper.setTransition(duration);
    });
    on("beforeDestroy", () => {
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper || thumbsSwiper.destroyed)
        return;
      if (swiperCreated) {
        thumbsSwiper.destroy();
      }
    });
    Object.assign(swiper.thumbs, {
      init: init4,
      update: update2
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/free-mode.mjs
  init_live_reload();
  function freeMode(_ref) {
    let {
      swiper,
      extendParams,
      emit,
      once
    } = _ref;
    extendParams({
      freeMode: {
        enabled: false,
        momentum: true,
        momentumRatio: 1,
        momentumBounce: true,
        momentumBounceRatio: 1,
        momentumVelocityRatio: 1,
        sticky: false,
        minimumVelocity: 0.02
      }
    });
    function onTouchStart2() {
      if (swiper.params.cssMode)
        return;
      const translate2 = swiper.getTranslate();
      swiper.setTranslate(translate2);
      swiper.setTransition(0);
      swiper.touchEventsData.velocities.length = 0;
      swiper.freeMode.onTouchEnd({
        currentPos: swiper.rtl ? swiper.translate : -swiper.translate
      });
    }
    function onTouchMove2() {
      if (swiper.params.cssMode)
        return;
      const {
        touchEventsData: data,
        touches
      } = swiper;
      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? "startX" : "startY"],
          time: data.touchStartTime
        });
      }
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
        time: now()
      });
    }
    function onTouchEnd2(_ref2) {
      let {
        currentPos
      } = _ref2;
      if (swiper.params.cssMode)
        return;
      const {
        params,
        wrapperEl,
        rtlTranslate: rtl,
        snapGrid,
        touchEventsData: data
      } = swiper;
      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime;
      if (currentPos < -swiper.minTranslate()) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (currentPos > -swiper.maxTranslate()) {
        if (swiper.slides.length < snapGrid.length) {
          swiper.slideTo(snapGrid.length - 1);
        } else {
          swiper.slideTo(swiper.slides.length - 1);
        }
        return;
      }
      if (params.freeMode.momentum) {
        if (data.velocities.length > 1) {
          const lastMoveEvent = data.velocities.pop();
          const velocityEvent = data.velocities.pop();
          const distance = lastMoveEvent.position - velocityEvent.position;
          const time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;
          if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
            swiper.velocity = 0;
          }
          if (time > 150 || now() - lastMoveEvent.time > 300) {
            swiper.velocity = 0;
          }
        } else {
          swiper.velocity = 0;
        }
        swiper.velocity *= params.freeMode.momentumVelocityRatio;
        data.velocities.length = 0;
        let momentumDuration = 1e3 * params.freeMode.momentumRatio;
        const momentumDistance = swiper.velocity * momentumDuration;
        let newPosition = swiper.translate + momentumDistance;
        if (rtl)
          newPosition = -newPosition;
        let doBounce = false;
        let afterBouncePosition;
        const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
        let needsLoopFix;
        if (newPosition < swiper.maxTranslate()) {
          if (params.freeMode.momentumBounce) {
            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
              newPosition = swiper.maxTranslate() - bounceAmount;
            }
            afterBouncePosition = swiper.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.maxTranslate();
          }
          if (params.loop && params.centeredSlides)
            needsLoopFix = true;
        } else if (newPosition > swiper.minTranslate()) {
          if (params.freeMode.momentumBounce) {
            if (newPosition - swiper.minTranslate() > bounceAmount) {
              newPosition = swiper.minTranslate() + bounceAmount;
            }
            afterBouncePosition = swiper.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.minTranslate();
          }
          if (params.loop && params.centeredSlides)
            needsLoopFix = true;
        } else if (params.freeMode.sticky) {
          let nextSlide;
          for (let j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }
          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }
          newPosition = -newPosition;
        }
        if (needsLoopFix) {
          once("transitionEnd", () => {
            swiper.loopFix();
          });
        }
        if (swiper.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
          }
          if (params.freeMode.sticky) {
            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
            if (moveDistance < currentSlideSize) {
              momentumDuration = params.speed;
            } else if (moveDistance < 2 * currentSlideSize) {
              momentumDuration = params.speed * 1.5;
            } else {
              momentumDuration = params.speed * 2.5;
            }
          }
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        }
        if (params.freeMode.momentumBounce && doBounce) {
          swiper.updateProgress(afterBouncePosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          swiper.animating = true;
          elementTransitionEnd(wrapperEl, () => {
            if (!swiper || swiper.destroyed || !data.allowMomentumBounce)
              return;
            emit("momentumBounce");
            swiper.setTransition(params.speed);
            setTimeout(() => {
              swiper.setTranslate(afterBouncePosition);
              elementTransitionEnd(wrapperEl, () => {
                if (!swiper || swiper.destroyed)
                  return;
                swiper.transitionEnd();
              });
            }, 0);
          });
        } else if (swiper.velocity) {
          emit("_freeModeNoMomentumRelease");
          swiper.updateProgress(newPosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          if (!swiper.animating) {
            swiper.animating = true;
            elementTransitionEnd(wrapperEl, () => {
              if (!swiper || swiper.destroyed)
                return;
              swiper.transitionEnd();
            });
          }
        } else {
          swiper.updateProgress(newPosition);
        }
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      } else if (params.freeMode) {
        emit("_freeModeNoMomentumRelease");
      }
      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
        emit("_freeModeStaticRelease");
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
    }
    Object.assign(swiper, {
      freeMode: {
        onTouchStart: onTouchStart2,
        onTouchMove: onTouchMove2,
        onTouchEnd: onTouchEnd2
      }
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/grid.mjs
  init_live_reload();
  function Grid(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      grid: {
        rows: 1,
        fill: "column"
      }
    });
    let slidesNumberEvenToRows;
    let slidesPerRow;
    let numFullColumns;
    let wasMultiRow;
    const getSpaceBetween = () => {
      let spaceBetween = swiper.params.spaceBetween;
      if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
      } else if (typeof spaceBetween === "string") {
        spaceBetween = parseFloat(spaceBetween);
      }
      return spaceBetween;
    };
    const initSlides = (slides) => {
      const {
        slidesPerView
      } = swiper.params;
      const {
        rows,
        fill
      } = swiper.params.grid;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
      numFullColumns = Math.floor(slidesLength / rows);
      if (Math.floor(slidesLength / rows) === slidesLength / rows) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
      }
      if (slidesPerView !== "auto" && fill === "row") {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
      }
      slidesPerRow = slidesNumberEvenToRows / rows;
    };
    const unsetSlides = () => {
      if (swiper.slides) {
        swiper.slides.forEach((slide2) => {
          if (slide2.swiperSlideGridSet) {
            slide2.style.height = "";
            slide2.style[swiper.getDirectionLabel("margin-top")] = "";
          }
        });
      }
    };
    const updateSlide = (i, slide2, slides) => {
      const {
        slidesPerGroup
      } = swiper.params;
      const spaceBetween = getSpaceBetween();
      const {
        rows,
        fill
      } = swiper.params.grid;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
      let newSlideOrderIndex;
      let column;
      let row;
      if (fill === "row" && slidesPerGroup > 1) {
        const groupIndex = Math.floor(i / (slidesPerGroup * rows));
        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
        const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
        slide2.style.order = newSlideOrderIndex;
      } else if (fill === "column") {
        column = Math.floor(i / rows);
        row = i - column * rows;
        if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
          row += 1;
          if (row >= rows) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }
      slide2.row = row;
      slide2.column = column;
      slide2.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;
      slide2.style[swiper.getDirectionLabel("margin-top")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : "";
      slide2.swiperSlideGridSet = true;
    };
    const updateWrapperSize = (slideSize, snapGrid) => {
      const {
        centeredSlides,
        roundLengths
      } = swiper.params;
      const spaceBetween = getSpaceBetween();
      const {
        rows
      } = swiper.params.grid;
      swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
      swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
      if (!swiper.params.cssMode) {
        swiper.wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
      }
      if (centeredSlides) {
        const newSlidesGrid = [];
        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (roundLengths)
            slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i] < swiper.virtualSize + snapGrid[0])
            newSlidesGrid.push(slidesGridItem);
        }
        snapGrid.splice(0, snapGrid.length);
        snapGrid.push(...newSlidesGrid);
      }
    };
    const onInit = () => {
      wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
    };
    const onUpdate = () => {
      const {
        params,
        el
      } = swiper;
      const isMultiRow = params.grid && params.grid.rows > 1;
      if (wasMultiRow && !isMultiRow) {
        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
        numFullColumns = 1;
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        el.classList.add(`${params.containerModifierClass}grid`);
        if (params.grid.fill === "column") {
          el.classList.add(`${params.containerModifierClass}grid-column`);
        }
        swiper.emitContainerClasses();
      }
      wasMultiRow = isMultiRow;
    };
    on("init", onInit);
    on("update", onUpdate);
    swiper.grid = {
      initSlides,
      unsetSlides,
      updateSlide,
      updateWrapperSize
    };
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/manipulation.mjs
  init_live_reload();
  function appendSlide(slides) {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (params.loop) {
      swiper.loopDestroy();
    }
    const appendElement = (slideEl) => {
      if (typeof slideEl === "string") {
        const tempDOM = document.createElement("div");
        tempDOM.innerHTML = slideEl;
        slidesEl.append(tempDOM.children[0]);
        tempDOM.innerHTML = "";
      } else {
        slidesEl.append(slideEl);
      }
    };
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          appendElement(slides[i]);
      }
    } else {
      appendElement(slides);
    }
    swiper.recalcSlides();
    if (params.loop) {
      swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
      swiper.update();
    }
  }
  function prependSlide(slides) {
    const swiper = this;
    const {
      params,
      activeIndex,
      slidesEl
    } = swiper;
    if (params.loop) {
      swiper.loopDestroy();
    }
    let newActiveIndex = activeIndex + 1;
    const prependElement = (slideEl) => {
      if (typeof slideEl === "string") {
        const tempDOM = document.createElement("div");
        tempDOM.innerHTML = slideEl;
        slidesEl.prepend(tempDOM.children[0]);
        tempDOM.innerHTML = "";
      } else {
        slidesEl.prepend(slideEl);
      }
    };
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          prependElement(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
    } else {
      prependElement(slides);
    }
    swiper.recalcSlides();
    if (params.loop) {
      swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
      swiper.update();
    }
    swiper.slideTo(newActiveIndex, 0, false);
  }
  function addSlide(index, slides) {
    const swiper = this;
    const {
      params,
      activeIndex,
      slidesEl
    } = swiper;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.recalcSlides();
    }
    const baseLength = swiper.slides.length;
    if (index <= 0) {
      swiper.prependSlide(slides);
      return;
    }
    if (index >= baseLength) {
      swiper.appendSlide(slides);
      return;
    }
    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    const slidesBuffer = [];
    for (let i = baseLength - 1; i >= index; i -= 1) {
      const currentSlide = swiper.slides[i];
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          slidesEl.append(slides[i]);
      }
      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      slidesEl.append(slides);
    }
    for (let i = 0; i < slidesBuffer.length; i += 1) {
      slidesEl.append(slidesBuffer[i]);
    }
    swiper.recalcSlides();
    if (params.loop) {
      swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
      swiper.update();
    }
    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }
  function removeSlide(slidesIndexes) {
    const swiper = this;
    const {
      params,
      activeIndex
    } = swiper;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
    }
    let newActiveIndex = activeIndexBuffer;
    let indexToRemove;
    if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
      for (let i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];
        if (swiper.slides[indexToRemove])
          swiper.slides[indexToRemove].remove();
        if (indexToRemove < newActiveIndex)
          newActiveIndex -= 1;
      }
      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;
      if (swiper.slides[indexToRemove])
        swiper.slides[indexToRemove].remove();
      if (indexToRemove < newActiveIndex)
        newActiveIndex -= 1;
      newActiveIndex = Math.max(newActiveIndex, 0);
    }
    swiper.recalcSlides();
    if (params.loop) {
      swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
      swiper.update();
    }
    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }
  function removeAllSlides() {
    const swiper = this;
    const slidesIndexes = [];
    for (let i = 0; i < swiper.slides.length; i += 1) {
      slidesIndexes.push(i);
    }
    swiper.removeSlide(slidesIndexes);
  }
  function Manipulation(_ref) {
    let {
      swiper
    } = _ref;
    Object.assign(swiper, {
      appendSlide: appendSlide.bind(swiper),
      prependSlide: prependSlide.bind(swiper),
      addSlide: addSlide.bind(swiper),
      removeSlide: removeSlide.bind(swiper),
      removeAllSlides: removeAllSlides.bind(swiper)
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-fade.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/effect-init.mjs
  init_live_reload();
  function effectInit(params) {
    const {
      effect,
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams,
      perspective,
      recreateShadows,
      getEffectParams
    } = params;
    on("beforeInit", () => {
      if (swiper.params.effect !== effect)
        return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
      if (perspective && perspective()) {
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      }
      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper.params, overwriteParamsResult);
      Object.assign(swiper.originalParams, overwriteParamsResult);
    });
    on("setTranslate", () => {
      if (swiper.params.effect !== effect)
        return;
      setTranslate2();
    });
    on("setTransition", (_s, duration) => {
      if (swiper.params.effect !== effect)
        return;
      setTransition2(duration);
    });
    on("transitionEnd", () => {
      if (swiper.params.effect !== effect)
        return;
      if (recreateShadows) {
        if (!getEffectParams || !getEffectParams().slideShadows)
          return;
        swiper.slides.forEach((slideEl) => {
          slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => shadowEl.remove());
        });
        recreateShadows();
      }
    });
    let requireUpdateOnVirtual;
    on("virtualUpdate", () => {
      if (swiper.params.effect !== effect)
        return;
      if (!swiper.slides.length) {
        requireUpdateOnVirtual = true;
      }
      requestAnimationFrame(() => {
        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
          setTranslate2();
          requireUpdateOnVirtual = false;
        }
      });
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/effect-target.mjs
  init_live_reload();
  function effectTarget(effectParams, slideEl) {
    const transformEl = getSlideTransformEl(slideEl);
    if (transformEl !== slideEl) {
      transformEl.style.backfaceVisibility = "hidden";
      transformEl.style["-webkit-backface-visibility"] = "hidden";
    }
    return transformEl;
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/effect-virtual-transition-end.mjs
  init_live_reload();
  function effectVirtualTransitionEnd(_ref) {
    let {
      swiper,
      duration,
      transformElements,
      allSlides
    } = _ref;
    const {
      activeIndex
    } = swiper;
    const getSlide = (el) => {
      if (!el.parentElement) {
        const slide2 = swiper.slides.filter((slideEl) => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
        return slide2;
      }
      return el.parentElement;
    };
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let transitionEndTarget;
      if (allSlides) {
        transitionEndTarget = transformElements;
      } else {
        transitionEndTarget = transformElements.filter((transformEl) => {
          const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
          return swiper.getSlideIndex(el) === activeIndex;
        });
      }
      transitionEndTarget.forEach((el) => {
        elementTransitionEnd(el, () => {
          if (eventTriggered)
            return;
          if (!swiper || swiper.destroyed)
            return;
          eventTriggered = true;
          swiper.animating = false;
          const evt = new window.CustomEvent("transitionend", {
            bubbles: true,
            cancelable: true
          });
          swiper.wrapperEl.dispatchEvent(evt);
        });
      });
    }
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-fade.mjs
  function EffectFade(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      fadeEffect: {
        crossFade: false
      }
    });
    const setTranslate2 = () => {
      const {
        slides
      } = swiper;
      const params = swiper.params.fadeEffect;
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = swiper.slides[i];
        const offset = slideEl.swiperSlideOffset;
        let tx = -offset;
        if (!swiper.params.virtualTranslate)
          tx -= swiper.translate;
        let ty = 0;
        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }
        const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.opacity = slideOpacity;
        targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
      }
    };
    const setTransition2 = (duration) => {
      const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
      transformElements.forEach((el) => {
        el.style.transitionDuration = `${duration}ms`;
      });
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformElements,
        allSlides: true
      });
    };
    effectInit({
      effect: "fade",
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-cube.mjs
  init_live_reload();
  function EffectCube(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94
      }
    });
    const createSlideShadows = (slideEl, progress, isHorizontal) => {
      let shadowBefore = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
      let shadowAfter = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
      if (!shadowBefore) {
        shadowBefore = createElement("div", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? "left" : "top"}`.split(" "));
        slideEl.append(shadowBefore);
      }
      if (!shadowAfter) {
        shadowAfter = createElement("div", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? "right" : "bottom"}`.split(" "));
        slideEl.append(shadowAfter);
      }
      if (shadowBefore)
        shadowBefore.style.opacity = Math.max(-progress, 0);
      if (shadowAfter)
        shadowAfter.style.opacity = Math.max(progress, 0);
    };
    const recreateShadows = () => {
      const isHorizontal = swiper.isHorizontal();
      swiper.slides.forEach((slideEl) => {
        const progress = Math.max(Math.min(slideEl.progress, 1), -1);
        createSlideShadows(slideEl, progress, isHorizontal);
      });
    };
    const setTranslate2 = () => {
      const {
        el,
        wrapperEl,
        slides,
        width: swiperWidth,
        height: swiperHeight,
        rtlTranslate: rtl,
        size: swiperSize,
        browser: browser2
      } = swiper;
      const r = getRotateFix(swiper);
      const params = swiper.params.cubeEffect;
      const isHorizontal = swiper.isHorizontal();
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let wrapperRotate = 0;
      let cubeShadowEl;
      if (params.shadow) {
        if (isHorizontal) {
          cubeShadowEl = swiper.wrapperEl.querySelector(".swiper-cube-shadow");
          if (!cubeShadowEl) {
            cubeShadowEl = createElement("div", "swiper-cube-shadow");
            swiper.wrapperEl.append(cubeShadowEl);
          }
          cubeShadowEl.style.height = `${swiperWidth}px`;
        } else {
          cubeShadowEl = el.querySelector(".swiper-cube-shadow");
          if (!cubeShadowEl) {
            cubeShadowEl = createElement("div", "swiper-cube-shadow");
            el.append(cubeShadowEl);
          }
        }
      }
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = slides[i];
        let slideIndex = i;
        if (isVirtual) {
          slideIndex = parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10);
        }
        let slideAngle = slideIndex * 90;
        let round = Math.floor(slideAngle / 360);
        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }
        const progress = Math.max(Math.min(slideEl.progress, 1), -1);
        let tx = 0;
        let ty = 0;
        let tz = 0;
        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + round * 4 * swiperSize;
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = 3 * swiperSize + swiperSize * 4 * round;
        }
        if (rtl) {
          tx = -tx;
        }
        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }
        const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
        if (progress <= 1 && progress > -1) {
          wrapperRotate = slideIndex * 90 + progress * 90;
          if (rtl)
            wrapperRotate = -slideIndex * 90 - progress * 90;
        }
        slideEl.style.transform = transform;
        if (params.slideShadows) {
          createSlideShadows(slideEl, progress, isHorizontal);
        }
      }
      wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
      wrapperEl.style["-webkit-transform-origin"] = `50% 50% -${swiperSize / 2}px`;
      if (params.shadow) {
        if (isHorizontal) {
          cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
        } else {
          const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
          const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
          const scale1 = params.shadowScale;
          const scale2 = params.shadowScale / multiplier;
          const offset = params.shadowOffset;
          cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
        }
      }
      const zFactor = (browser2.isSafari || browser2.isWebView) && browser2.needPerspectiveFix ? -swiperSize / 2 : 0;
      wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;
      wrapperEl.style.setProperty("--swiper-cube-translate-z", `${zFactor}px`);
    };
    const setTransition2 = (duration) => {
      const {
        el,
        slides
      } = swiper;
      slides.forEach((slideEl) => {
        slideEl.style.transitionDuration = `${duration}ms`;
        slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((subEl) => {
          subEl.style.transitionDuration = `${duration}ms`;
        });
      });
      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
        const shadowEl = el.querySelector(".swiper-cube-shadow");
        if (shadowEl)
          shadowEl.style.transitionDuration = `${duration}ms`;
      }
    };
    effectInit({
      effect: "cube",
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      recreateShadows,
      getEffectParams: () => swiper.params.cubeEffect,
      perspective: () => true,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true
      })
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-flip.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/shared/create-shadow.mjs
  init_live_reload();
  function createShadow(suffix, slideEl, side) {
    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}${suffix ? ` swiper-slide-shadow-${suffix}` : ""}`;
    const shadowContainer = getSlideTransformEl(slideEl);
    let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(" ").join(".")}`);
    if (!shadowEl) {
      shadowEl = createElement("div", shadowClass.split(" "));
      shadowContainer.append(shadowEl);
    }
    return shadowEl;
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-flip.mjs
  function EffectFlip(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      flipEffect: {
        slideShadows: true,
        limitRotation: true
      }
    });
    const createSlideShadows = (slideEl, progress) => {
      let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
      let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
      if (!shadowBefore) {
        shadowBefore = createShadow("flip", slideEl, swiper.isHorizontal() ? "left" : "top");
      }
      if (!shadowAfter) {
        shadowAfter = createShadow("flip", slideEl, swiper.isHorizontal() ? "right" : "bottom");
      }
      if (shadowBefore)
        shadowBefore.style.opacity = Math.max(-progress, 0);
      if (shadowAfter)
        shadowAfter.style.opacity = Math.max(progress, 0);
    };
    const recreateShadows = () => {
      swiper.params.flipEffect;
      swiper.slides.forEach((slideEl) => {
        let progress = slideEl.progress;
        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min(slideEl.progress, 1), -1);
        }
        createSlideShadows(slideEl, progress);
      });
    };
    const setTranslate2 = () => {
      const {
        slides,
        rtlTranslate: rtl
      } = swiper;
      const params = swiper.params.flipEffect;
      const rotateFix = getRotateFix(swiper);
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = slides[i];
        let progress = slideEl.progress;
        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min(slideEl.progress, 1), -1);
        }
        const offset = slideEl.swiperSlideOffset;
        const rotate = -180 * progress;
        let rotateY = rotate;
        let rotateX = 0;
        let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
        let ty = 0;
        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }
        slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
        if (params.slideShadows) {
          createSlideShadows(slideEl, progress);
        }
        const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.transform = transform;
      }
    };
    const setTransition2 = (duration) => {
      const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
      transformElements.forEach((el) => {
        el.style.transitionDuration = `${duration}ms`;
        el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => {
          shadowEl.style.transitionDuration = `${duration}ms`;
        });
      });
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformElements
      });
    };
    effectInit({
      effect: "flip",
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      recreateShadows,
      getEffectParams: () => swiper.params.flipEffect,
      perspective: () => true,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-coverflow.mjs
  init_live_reload();
  function EffectCoverflow(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: true
      }
    });
    const setTranslate2 = () => {
      const {
        width: swiperWidth,
        height: swiperHeight,
        slides,
        slidesSizesGrid
      } = swiper;
      const params = swiper.params.coverflowEffect;
      const isHorizontal = swiper.isHorizontal();
      const transform = swiper.translate;
      const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
      const rotate = isHorizontal ? params.rotate : -params.rotate;
      const translate2 = params.depth;
      const r = getRotateFix(swiper);
      for (let i = 0, length = slides.length; i < length; i += 1) {
        const slideEl = slides[i];
        const slideSize = slidesSizesGrid[i];
        const slideOffset = slideEl.swiperSlideOffset;
        const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
        const offsetMultiplier = typeof params.modifier === "function" ? params.modifier(centerOffset) : centerOffset * params.modifier;
        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
        let translateZ = -translate2 * Math.abs(offsetMultiplier);
        let stretch = params.stretch;
        if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
          stretch = parseFloat(params.stretch) / 100 * slideSize;
        }
        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
        if (Math.abs(translateX) < 1e-3)
          translateX = 0;
        if (Math.abs(translateY) < 1e-3)
          translateY = 0;
        if (Math.abs(translateZ) < 1e-3)
          translateZ = 0;
        if (Math.abs(rotateY) < 1e-3)
          rotateY = 0;
        if (Math.abs(rotateX) < 1e-3)
          rotateX = 0;
        if (Math.abs(scale) < 1e-3)
          scale = 0;
        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.transform = slideTransform;
        slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
        if (params.slideShadows) {
          let shadowBeforeEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
          let shadowAfterEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
          if (!shadowBeforeEl) {
            shadowBeforeEl = createShadow("coverflow", slideEl, isHorizontal ? "left" : "top");
          }
          if (!shadowAfterEl) {
            shadowAfterEl = createShadow("coverflow", slideEl, isHorizontal ? "right" : "bottom");
          }
          if (shadowBeforeEl)
            shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          if (shadowAfterEl)
            shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
        }
      }
    };
    const setTransition2 = (duration) => {
      const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
      transformElements.forEach((el) => {
        el.style.transitionDuration = `${duration}ms`;
        el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => {
          shadowEl.style.transitionDuration = `${duration}ms`;
        });
      });
    };
    effectInit({
      effect: "coverflow",
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true
      })
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-creative.mjs
  init_live_reload();
  function EffectCreative(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      creativeEffect: {
        limitProgress: 1,
        shadowPerProgress: false,
        progressMultiplier: 1,
        perspective: true,
        prev: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        },
        next: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        }
      }
    });
    const getTranslateValue = (value) => {
      if (typeof value === "string")
        return value;
      return `${value}px`;
    };
    const setTranslate2 = () => {
      const {
        slides,
        wrapperEl,
        slidesSizesGrid
      } = swiper;
      const params = swiper.params.creativeEffect;
      const {
        progressMultiplier: multiplier
      } = params;
      const isCenteredSlides = swiper.params.centeredSlides;
      const rotateFix = getRotateFix(swiper);
      if (isCenteredSlides) {
        const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
        wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
      }
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = slides[i];
        const slideProgress = slideEl.progress;
        const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
        let originalProgress = progress;
        if (!isCenteredSlides) {
          originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
        }
        const offset = slideEl.swiperSlideOffset;
        const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
        const r = [0, 0, 0];
        let custom = false;
        if (!swiper.isHorizontal()) {
          t[1] = t[0];
          t[0] = 0;
        }
        let data = {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          scale: 1,
          opacity: 1
        };
        if (progress < 0) {
          data = params.next;
          custom = true;
        } else if (progress > 0) {
          data = params.prev;
          custom = true;
        }
        t.forEach((value, index) => {
          t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
        });
        r.forEach((value, index) => {
          let val = data.rotate[index] * Math.abs(progress * multiplier);
          r[index] = val;
        });
        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const translateString = t.join(", ");
        const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;
        const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
        const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
        const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
        if (custom && data.shadow || !custom) {
          let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
          if (!shadowEl && data.shadow) {
            shadowEl = createShadow("creative", slideEl);
          }
          if (shadowEl) {
            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
            shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
          }
        }
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.transform = transform;
        targetEl.style.opacity = opacityString;
        if (data.origin) {
          targetEl.style.transformOrigin = data.origin;
        }
      }
    };
    const setTransition2 = (duration) => {
      const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
      transformElements.forEach((el) => {
        el.style.transitionDuration = `${duration}ms`;
        el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl) => {
          shadowEl.style.transitionDuration = `${duration}ms`;
        });
      });
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformElements,
        allSlides: true
      });
    };
    effectInit({
      effect: "creative",
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => swiper.params.creativeEffect.perspective,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/modules/effect-cards.mjs
  init_live_reload();
  function EffectCards(_ref) {
    let {
      swiper,
      extendParams,
      on
    } = _ref;
    extendParams({
      cardsEffect: {
        slideShadows: true,
        rotate: true,
        perSlideRotate: 2,
        perSlideOffset: 8
      }
    });
    const setTranslate2 = () => {
      const {
        slides,
        activeIndex,
        rtlTranslate: rtl
      } = swiper;
      const params = swiper.params.cardsEffect;
      const {
        startTranslate,
        isTouched
      } = swiper.touchEventsData;
      const currentTranslate = rtl ? -swiper.translate : swiper.translate;
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = slides[i];
        const slideProgress = slideEl.progress;
        const progress = Math.min(Math.max(slideProgress, -4), 4);
        let offset = slideEl.swiperSlideOffset;
        if (swiper.params.centeredSlides && !swiper.params.cssMode) {
          swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
        }
        if (swiper.params.centeredSlides && swiper.params.cssMode) {
          offset -= slides[0].swiperSlideOffset;
        }
        let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
        let tY = 0;
        const tZ = -100 * Math.abs(progress);
        let scale = 1;
        let rotate = -params.perSlideRotate * progress;
        let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
        const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
        const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
        const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
        if (isSwipeToNext || isSwipeToPrev) {
          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
          rotate += -28 * progress * subProgress;
          scale += -0.5 * subProgress;
          tXAdd += 96 * subProgress;
          tY = `${-25 * subProgress * Math.abs(progress)}%`;
        }
        if (progress < 0) {
          tX = `calc(${tX}px ${rtl ? "-" : "+"} (${tXAdd * Math.abs(progress)}%))`;
        } else if (progress > 0) {
          tX = `calc(${tX}px ${rtl ? "-" : "+"} (-${tXAdd * Math.abs(progress)}%))`;
        } else {
          tX = `${tX}px`;
        }
        if (!swiper.isHorizontal()) {
          const prevY = tY;
          tY = tX;
          tX = prevY;
        }
        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
        const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
        if (params.slideShadows) {
          let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
          if (!shadowEl) {
            shadowEl = createShadow("cards", slideEl);
          }
          if (shadowEl)
            shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
        }
        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.transform = transform;
      }
    };
    const setTransition2 = (duration) => {
      const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
      transformElements.forEach((el) => {
        el.style.transitionDuration = `${duration}ms`;
        el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl) => {
          shadowEl.style.transitionDuration = `${duration}ms`;
        });
      });
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformElements
      });
    };
    effectInit({
      effect: "cards",
      swiper,
      on,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  // node_modules/.pnpm/swiper@11.1.14/node_modules/swiper/swiper-bundle.mjs
  var modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
  Swiper.use(modules);

  // src/utils/global/swiper.ts
  function swiperHpPicture() {
    new Swiper(".swiper.is-slider-picture", {
      direction: "horizontal",
      slidesPerView: 1,
      speed: 400,
      loop: true,
      navigation: {
        nextEl: ".slider-picture_button-next",
        prevEl: ".slider-picture_button-prev"
      }
    });
  }
  function swiperHpTestimonial() {
    new Swiper(".swiper.is-hp-testimonials", {
      direction: "horizontal",
      slidesPerView: 2,
      spaceBetween: 80,
      speed: 400,
      loop: true,
      mousewheel: {
        forceToAxis: true
      },
      navigation: {
        nextEl: ".hp_testimonials_btn-next",
        prevEl: ".hp_testimonials_btn-prev"
      }
    });
  }
  function swiperBlogAutres() {
    new Swiper(".swiper.is-blog", {
      direction: "horizontal",
      slidesPerView: 3,
      spaceBetween: 3.5 * 16,
      speed: 400,
      loop: true,
      mousewheel: {
        forceToAxis: true
      },
      navigation: {
        nextEl: ".hp-slider-picture_button-next",
        prevEl: ".hp-slider-picture_button-prev"
      }
    });
  }
  function swiperProduitsCarousel() {
    new Swiper(".swiper.is-produit-hero-caroussel", {
      direction: "horizontal",
      slidesPerView: 1,
      spaceBetween: 32,
      speed: 400,
      loop: true,
      effect: "fade",
      mousewheel: {
        forceToAxis: true
      },
      navigation: {
        nextEl: ".produit_hero_swiper-btn-next",
        prevEl: ".produit_hero_swiper-btn-prev"
      }
    });
  }
  function swiperProduitsAutres() {
    new Swiper(".swiper.is-m-categorie", {
      direction: "horizontal",
      slidesPerView: 3,
      spaceBetween: 32,
      speed: 400,
      loop: false,
      effect: "slide",
      mousewheel: {
        forceToAxis: true
      },
      navigation: {
        nextEl: ".produit_m-categorie_swiper-btn-prev",
        prevEl: ".produit_m-categorie_swiper-btn-next"
      }
    });
  }
  function swiperChronologie() {
    new Swiper(".swiper.is-chronologie", {
      direction: "horizontal",
      slidesPerView: 5,
      spaceBetween: 3.5 * 16,
      speed: 400,
      loop: false,
      mousewheel: {
        forceToAxis: true
      },
      autoplay: {
        delay: 5e3,
        pauseOnMouseEnter: true,
        disableOnInteraction: false,
        reverseDirection: false
      },
      navigation: {
        nextEl: ".a-propos_chronologie_navigation.is-right",
        prevEl: ".a-propos_chronologie_navigation.is-left"
      }
    });
  }
  function swiperCoopHero() {
    new Swiper(".swiper.is-coop-hero", {
      direction: "horizontal",
      slidesPerView: 1,
      autoplay: {
        delay: 3e3,
        // Ajouter un dlai
        disableOnInteraction: false
        // Continuer l'autoplay aprs interaction
      },
      speed: 400,
      loop: true,
      navigation: {
        nextEl: ".coop_hero_button.is-next",
        prevEl: ".coop_hero_button.is-prev"
      },
      pagination: {
        el: ".coop_hero_pagination",
        clickable: true,
        bulletClass: "swiper-pagination-bullet",
        bulletActiveClass: "swiper-pagination-bullet-active"
      }
    });
  }
  function swiperLastPosts() {
    new Swiper(".swiper.is-post", {
      direction: "horizontal",
      slidesPerView: 3,
      autoplay: {
        delay: 3e3,
        // Ajouter un dlai
        disableOnInteraction: false
        // Continuer l'autoplay aprs interaction
      },
      speed: 400,
      loop: true,
      navigation: {
        nextEl: ".article_last-posts_btn-next",
        prevEl: ".article_last-posts_btn-prev"
      },
      pagination: {
        el: ".article_last-posts_pagination",
        clickable: true,
        bulletClass: "swiper-pagination-bullet",
        bulletActiveClass: "swiper-pagination-bullet-active"
      }
    });
  }

  // src/utils/home/home.ts
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js
  init_live_reload();
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i = _harnessPlugins.length;
      while (i-- && !_harnessPlugins[i].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i];
    }
    i = targets.length;
    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v) {
    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l = toFind.length, i = 0;
    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
    }
    return i < l;
  };
  var _lazyRender = function _lazyRender2() {
    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p) {
    return p;
  };
  var _setDefaults = function _setDefaults2(obj, defaults3) {
    for (var p in defaults3) {
      p in obj || (obj[p] = defaults3[p]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults3) {
      for (var p in defaults3) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults3[p]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent2 = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent2) {
        func(vars, parent2.vars.defaults);
        parent2 = parent2.parent || parent2._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a2) {
    var i = a1.length, match = i === a2.length;
    while (match && i-- && a1[i] === a2[i]) {
    }
    return i < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent2, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent2[lastProp], t;
    if (sortBy) {
      t = child[sortBy];
      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent2[firstProp];
      parent2[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent2[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent2;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent2, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent2[firstProp] === child) {
      parent2[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent2[lastProp] === child) {
      parent2[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a = animation;
      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent2 = animation.parent;
    while (parent2 && parent2.parent) {
      parent2._dirty = 1;
      parent2.totalDuration();
      parent2 = parent2.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent2 = animation._dp;
    if (parent2 && parent2.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent2._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent2._dirty || _uncache(parent2, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t = timeline2;
        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime);
          t = t._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent2 = _ref.parent;
    return parent2 && parent2._ts && parent2._initted && !parent2._lock && (parent2.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent2));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent2;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent2 = timeline2;
      while (parent2 && !("immediateRender" in irVars)) {
        irVars = parent2.vars.defaults || {};
        parent2 = _isNotFalse(parent2.vars.inherit) && parent2.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v) {
    return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v) {
      return _clamp(min, max, v);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v) {
      var el = value.current || value.nativeElement || value;
      return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a) {
    return a.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v) {
    if (_isFunction(v)) {
      return v;
    }
    var vars = _isObject(v) ? v : {
      each: v
    }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i, target, a) {
      var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
          }
          wrapAt < l && wrapAt--;
        }
        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }
      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v) {
    var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
    return function(raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray = _isArray(snapTo), radius, is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;
      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }
        if (dx < min) {
          min = dx;
          closest = i;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v, f) {
        return f(v);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev = 0, s = "", i, nums, end, isArray;
    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s + value.substr(prev, value.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p2) {
      return (1 - p2) * start + p2 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p, i, interpolators, l, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;
        for (i = 1; i < l; i++) {
          interpolators.push(interpolate2(start[i - 1], start[i]));
        }
        l--;
        func = function func2(p2) {
          p2 *= l;
          var i2 = Math.min(il, ~~p2);
          return interpolators[i2](p2 - i2);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func2(p2) {
          return _renderPropTweens(p2, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p, distance, label;
    for (p in labels) {
      distance = labels[p] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v = animation.vars, callback = v[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v[type + "Params"];
    scope = v.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3)
      return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h, m1, m2) {
    h += h < 0 ? 1 : h > 1 ? -1 : 0;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v, toHSL, forceAlpha) {
    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;
    if (!a) {
      if (v.substr(-1) === ",") {
        v = v.substr(0, v.length - 1);
      }
      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length < 6) {
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
        }
        if (v.length === 9) {
          a = parseInt(v.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
        }
        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & _255, v & _255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_strictNumExp);
        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1);
          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v.indexOf("=")) {
          a = v.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v.match(_strictNumExp) || _colorLookup.transparent;
      }
      a = a.map(Number);
    }
    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }
      a[0] = ~~(h + 0.5);
      a[1] = ~~(s * 100 + 0.5);
      a[2] = ~~(l * 100 + 0.5);
    }
    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  };
  var _colorOrderData = function _colorOrderData2(v) {
    var values = [], c = [], i = -1;
    v.split(_colorExp).forEach(function(v2) {
      var a = v2.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  };
  var _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
    var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
    if (!colors) {
      return s;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;
      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }
    return result + shell[l];
  };
  var _colorExp = function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }
    return new RegExp(s + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a) {
    var combined = a.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime3 = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime3(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners3 = [], _id, _req, _raf, _self, _delta, _i2, _tick = function _tick2(v) {
      var elapsed = _getTime3() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i2 = 0; _i2 < _listeners3.length; _i2++) {
          _listeners3[_i2](time, _delta, frame, v);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f) {
            return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t, d, f, v) {
          callback(t, d, f, v);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners3[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners3.indexOf(callback)) && _listeners3.splice(i, 1) && _i2 >= i && _i2--;
      },
      _listeners: _listeners3
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length, index, val, parsedVal;
    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p) {
      return 1 - ease(1 - p);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p) {
        return 1 - easeIn(1 - p);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p) {
      return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
    var power = i < 5 ? i + 1 : i;
    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
      return Math.pow(p, power);
    } : function(p) {
      return p;
    }, function(p) {
      return 1 - Math.pow(1 - p, power);
    }, function(p) {
      return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n, c) {
    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p) {
    return p ? Math.pow(2, 10 * (p - 1)) : 0;
  });
  _insertEase("Circ", function(p) {
    return -(_sqrt(1 - p * p) - 1);
  });
  _insertEase("Sine", function(p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p) {
        return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent2 = this._dp;
      if (parent2 && parent2.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent2._dp || parent2.parent || _postAddChecks(parent2, this);
        while (parent2 && parent2.parent) {
          if (parent2.parent._time !== parent2._start + (parent2._ts >= 0 ? parent2._tTime / parent2._ts : (parent2.totalDuration() - parent2._tTime) / -parent2._ts)) {
            parent2.totalTime(parent2._tTime, true);
          }
          parent2 = parent2.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent2 = this.parent || this._dp;
        parent2 && (parent2._sort || !this.parent) && _addToTimeline(parent2, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent2 = this.parent || this._dp;
      return !parent2 ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent2.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (this._initted || this._startAt) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent2 = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent2 || this._ts && this._initted && parent2.isActive() && (rawTime = parent2.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve) {
        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
          resolve(f);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && time && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i = animations.length;
      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }
        child = child._next;
      }
      return a;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent2;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent2 = self2.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent2 && !self2._dp || parent2 && parent2.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop);
      start = a[0];
      end = a[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i = plugin._props.length;
        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent2 = tween.parent, fullTargets = parent2 && parent2.data === "nested" ? parent2.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent2,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent2
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;
      while (i--) {
        pt = lookup[i][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i = ptCache.length;
    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;
        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p, a;
    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults3 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent2 = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults3 || {},
          targets: parent2 && parent2.data === "nested" ? parent2.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }
          for (i = 0; i < l; i++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l === 1 && copy.delay) {
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a, kf, v;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p in keyframes) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
            }
            for (p in copy) {
              a = copy[p].sort(function(a2, b) {
                return a2.t - b.t;
              });
              time = 0;
              for (i = 0; i < a.length; i++) {
                kf = a[i];
                v = {
                  ease: kf.e,
                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                };
                v[p] = kf.v;
                tl.to(parsedTargets, v, time);
                time += v.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent2, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent2._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent2.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render3(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (time && !prevTime && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        return this.parent ? _interrupt(this) : this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p = {};
          _forEachName(vars, function(name) {
            return p[name] = 1;
          });
          vars = p;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i = parsedTargets.length;
      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];
          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }
          for (p in props) {
            pt = curLookup && curLookup[p];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s = "";
    if (!ratio && data.b) {
      s = data.b;
    } else if (ratio === 1 && data.e) {
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
        pt = pt._next;
      }
      s += data.c;
    }
    data.set(data.t, data.p, s, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent2) {
    var pt = parent2._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent2._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f) {
      return f();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c) {
        var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;
        for (p in queries) {
          match = _win.matchMedia(queries[p]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c) {
        return c.onMatch(c, function(func) {
          return c.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self2 = this, f = function f2() {
        var prev = _context, prevSelector = self2.selector, result;
        prev && prev !== self2 && prev.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f;
      return name === _isFunction ? f(self2, function(func2) {
        return self2.add(null, func2);
      }) : name ? self2[name] = f : f;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a = [];
      this.data.forEach(function(e) {
        return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
      });
      return a;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i2 = _this4.data.length, t;
          while (i2--) {
            t = _this4.data[i2];
            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t2) {
            return {
              g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,
              t: t2
            };
          }).sort(function(a, b) {
            return b.g - a.g || -Infinity;
          }).forEach(function(o) {
            return o.t.revert(revert);
          });
          i2 = _this4.data.length;
          while (i2--) {
            t = _this4.data[i2];
            if (t instanceof Timeline) {
              if (t.data !== "nested") {
                t.scrollTrigger && t.scrollTrigger.revert();
                t.kill();
              }
            } else {
              !(t instanceof Tween) && t.revert && t.revert(revert);
            }
          }
          _this4._r.forEach(function(f) {
            return f(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e) {
          return e.kill && e.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i = _media.length;
        while (i--) {
          _media[i].id === this.id && _media.splice(i, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
      _context && !context3.selector && (context3.selector = _context.selector);
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context3, function(f) {
        return context3.add(null, f);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c) {
        return c.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t) {
          return gsap.quickSetter(t, property, unit);
        }), l = setters.length;
        return function(value) {
          var i = l;
          while (i--) {
            setters[i](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p2 = new Plugin();
        _quickTween._pt = 0;
        p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p2.render(1, p2);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
      return Plugin ? setter : function(value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _merge22;
      var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults2(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults3 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults3), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c) {
        var cond = c.conditions, found, p;
        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }
        found && c.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a = _listeners[type] || (_listeners[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a = _listeners[type], i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p, i, pt;
    for (p in modifiers) {
      i = targets.length;
      while (i--) {
        pt = tween._ptLookup[i][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init4(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt, v;
      this.tween = tween;
      for (p in vars) {
        v = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
        pt.op = p;
        pt.b = v;
        this._props.push(p);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    init: function init2(target, value) {
      var i = value.length;
      while (i--) {
        this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.12.5";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js
  init_live_reload();
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p) {
          return _saveStyle2.call(_this, p, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;
    for (i = 0; i < props.length; i += 3) {
      props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
    }
    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i = _reverting2();
      if ((!i || !i.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && properties.split(",").forEach(function(p) {
      return saver.save(p);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e && e.style ? e : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e = element || _tempDiv, s = e.style, i = 5;
    if (property in s && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i-- && !(_prefixes[i] + property in s)) {
    }
    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox;
        this.getBBox = _getBBoxHack2;
      } catch (e) {
      }
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i = attributesArray.length;
    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent2, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent2 = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent2 = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent2 || parent2 === _doc2 || !parent2.appendChild) {
      parent2 = _doc2.body;
    }
    cache = parent2._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v ? target.style[property] = v : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent2, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent2 === target && (style.position = "static");
        parent2.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent2.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent2);
        cache.time = _ticker.time;
        cache.width = parent2[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a = [start, end];
    _colorStringFilter(a);
    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x = split[0], y = split[1] || "50%";
    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      value = x;
      x = y;
      y = value;
    }
    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;
        while (--i > -1) {
          prop = props[i];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent2, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent2 = target.parentNode;
      if (!parent2 || !target.offsetParent) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent2.insertBefore(target, nextSibling) : parent2 ? parent2.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a = matrix[0];
      b = matrix[1];
      c = matrix[2];
      d = matrix[3];
      x = a12 = matrix[4];
      y = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        }
        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a * a + b * b + c * c));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a, vars;
      if (arguments.length < 4) {
        a = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }
      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }
        endValue = vars[p];
        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type !== "undefined") {
          if (startAt && p in startAt) {
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
          } else {
            startValue = _get(target, p);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }
          isTransformRelated = p in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p);
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // src/utils/home/home.ts
  var ressourcesHover = () => {
    const cards = document.querySelectorAll(".hp_ressources_small-card");
    cards.forEach((card) => {
      const textContent = card.querySelector(".hp_ressources_sc_text-content");
      if (textContent) {
        card.addEventListener("mouseenter", () => {
          gsapWithCSS.to(textContent, {
            top: "0rem",
            /// Final Position hover
            backgroundColor: "rgba(90, 31, 27, 0.8)",
            // background with 80% opacity
            duration: 0.5,
            ease: "power3.out"
          });
        });
        card.addEventListener("mouseleave", () => {
          gsapWithCSS.to(textContent, {
            top: "19rem",
            // Initial position at mouseleave
            backgroundColor: "transparent",
            // Initial background-color
            duration: 0.5,
            ease: "power3.out"
          });
        });
      }
    });
  };
  function initTerroirsHover() {
    const cards = document.querySelectorAll(".hp_terroirs_big-card");
    cards.forEach((card) => {
      card.addEventListener("mouseenter", (e) => {
        const title = e.currentTarget.querySelector(
          ".hp_terroirs_bc-text-content"
        );
        const hoverContent = e.currentTarget.querySelector(
          ".hp_terroirs_bc-hover-content"
        );
        if (title) {
          title.style.transform = "translateY(-6rem)";
          title.style.transition = "transform 0.3s ease-out";
        }
        if (hoverContent) {
          hoverContent.style.opacity = "1";
          hoverContent.style.transition = "opacity 0.3s ease-out";
        }
      });
      card.addEventListener("mouseleave", (e) => {
        const title = e.currentTarget.querySelector(
          ".hp_terroirs_bc-text-content"
        );
        const hoverContent = e.currentTarget.querySelector(
          ".hp_terroirs_bc-hover-content"
        );
        if (title) {
          title.style.transform = "translateY(0)";
          title.style.transition = "transform 0.3s ease-out";
        }
        if (hoverContent) {
          hoverContent.style.opacity = "0";
          hoverContent.style.transition = "opacity 0.3s ease-out";
        }
      });
    });
  }
  function initSmallTerroirsHover() {
    const smallCards = document.querySelectorAll(".hp_terroirs_small-card");
    smallCards.forEach((card) => {
      card.addEventListener("mouseenter", (e) => {
        const textContent = e.currentTarget.querySelector(
          ".hp_terroirs_sc-text-content"
        );
        const hoverContent = e.currentTarget.querySelector(
          ".hp_terroirs_bc-hover-content"
        );
        if (textContent) {
          textContent.style.transform = "translateY(-2rem)";
          textContent.style.transition = "transform 0.3s ease-out";
        }
        if (hoverContent) {
          hoverContent.style.opacity = "1";
          hoverContent.style.transition = "opacity 0.3s ease-out";
        }
      });
      card.addEventListener("mouseleave", (e) => {
        const textContent = e.currentTarget.querySelector(
          ".hp_terroirs_sc-text-content"
        );
        const hoverContent = e.currentTarget.querySelector(
          ".hp_terroirs_bc-hover-content"
        );
        if (textContent) {
          textContent.style.transform = "translateY(0)";
          textContent.style.transition = "transform 0.3s ease-out";
        }
        if (hoverContent) {
          hoverContent.style.opacity = "0";
          hoverContent.style.transition = "opacity 0.3s ease-out";
        }
      });
    });
  }
  function initProductsHover() {
    document.querySelectorAll(".hp_products_card").forEach((card) => {
      const handleHover = (isEntering) => {
        const selectors = {
          overlay: ".hp_products_card-overlay",
          description: ".hp_products_card-text-description",
          link: ".hp_products_card-link",
          title: ".hp_products_card-title"
        };
        Object.entries(selectors).forEach(([key, selector3]) => {
          const element = card.querySelector(selector3);
          if (!element)
            return;
          const baseStyles = {
            transition: "all 0.3s ease-out"
          };
          if (key !== "title") {
            baseStyles.opacity = isEntering ? "1" : "0";
          }
          if (key === "title") {
            baseStyles.transform = `translateY(${isEntering ? "-0.2rem" : "0"})`;
          }
          Object.assign(element.style, baseStyles);
          if (key === "description" || key === "link") {
            element.style.display = isEntering ? "block" : "none";
          }
        });
      };
      card.addEventListener("mouseenter", () => handleHover(true));
      card.addEventListener("mouseleave", () => handleHover(false));
    });
  }

  // src/utils/map/map.ts
  init_live_reload();
  var import_mapbox_gl = __toESM(require_mapbox_gl(), 1);
  import_mapbox_gl.default.accessToken = "pk.eyJ1IjoiY2FjYW9zcGhlcmUiLCJhIjoiY20yYWw5YXlvMGZ2dDJqczdsYm13bzA4aSJ9.cO_ViZ1EjIMOCjXv17TtQA";
  function initializeMap() {
    const monument = [-58.443832, -14.235004];
    const map = new import_mapbox_gl.default.Map({
      container: "map",
      style: "mapbox://styles/cacaosphere/cm2d1jo0100ut01pe2m9de4am",
      center: monument,
      zoom: 3,
      projection: "globe"
    });
    let currentPopup;
    let currentMarker;
    let currentItem;
    const items = document.querySelectorAll(".map-coop_list");
    items.forEach((cmsItem) => {
      const lat = cmsItem.querySelector(".map-coop_item-lat")?.innerText ?? "";
      const lon = cmsItem.querySelector(".map-coop_item-lon")?.innerText ?? "";
      const body = cmsItem.querySelector(".map-coop_popup");
      const el = document.createElement("div");
      el.classList.add("star");
      const popup = new import_mapbox_gl.default.Popup({
        offset: 25,
        closeButton: false,
        maxWidth: "auto"
      }).setHTML(body.outerHTML);
      new import_mapbox_gl.default.Marker(el).setLngLat([parseFloat(lon), parseFloat(lat)]).setPopup(popup).addTo(map);
      map.on("click", (e) => {
        if (e.originalEvent.srcElement instanceof HTMLElement && e.originalEvent.srcElement.ariaLabel === "Map") {
          currentMarker?.classList.remove("show");
        }
      });
      el.addEventListener("click", () => {
        popup.addTo(map);
        if (currentMarker) {
          currentItem?.classList.remove("active");
          currentMarker.classList.remove("show");
          currentPopup?.remove();
        }
        currentItem = cmsItem;
        currentItem.classList.add("active");
        currentMarker = el;
        currentMarker.classList.add("show");
        map.flyTo({
          center: [parseFloat(lon), parseFloat(lat)],
          zoom: 8,
          essential: true
        });
      });
      el.addEventListener("mouseover", () => {
        popup.addTo(map);
        el.classList.add("show");
      });
      el.addEventListener("mouseout", () => {
        if (currentMarker !== el) {
          popup.remove();
          el.classList.remove("show");
        }
      });
      cmsItem.addEventListener("click", () => {
        map.flyTo({
          center: [parseFloat(lon), parseFloat(lat)],
          zoom: 8,
          essential: true
        });
        if (currentMarker) {
          currentItem?.classList.remove("active");
          currentMarker.classList.remove("show");
          currentPopup?.remove();
        }
        popup.addTo(map);
        el.classList.add("show");
        currentMarker = el;
        currentPopup = popup;
        currentItem = cmsItem;
        currentItem.classList.add("active");
      });
      cmsItem.addEventListener("mouseover", () => {
        popup.addTo(map);
        el.classList.add("show");
      });
      cmsItem.addEventListener("mouseout", () => {
        if (currentMarker !== el) {
          popup.remove();
          el.classList.remove("show");
        }
      });
    });
  }

  // src/utils/produits/catalogueFormTrigger.ts
  init_live_reload();
  function catalogueFormTrigger() {
    const triggerButton = document.querySelector("#cache-trigger");
    if (triggerButton) {
      triggerButton.addEventListener("click", () => {
        const productName = triggerButton.getAttribute("produit");
        if (productName) {
          window.localStorage.setItem("selectedProduct", productName);
          const stored = window.localStorage.getItem("selectedProduct");
          if (!stored) {
            window.localStorage.setItem("selectedProduct", productName);
          }
        }
      });
    }
    if (window.location.pathname === "/contact") {
      const storedProduct = localStorage.getItem("selectedProduct");
      if (storedProduct) {
        const checkboxes = document.querySelectorAll(".w-checkbox.form_checkbox");
        checkboxes.forEach((checkbox) => {
          if (checkbox instanceof HTMLElement) {
            const checkboxId = checkbox.getAttribute("id");
            if (checkboxId === storedProduct) {
              const input = checkbox.querySelector("input");
              if (input instanceof HTMLInputElement) {
                input.dispatchEvent(new Event("change"));
                input.dispatchEvent(new Event("input"));
                input.click();
              }
            }
          }
        });
        setTimeout(() => {
          localStorage.removeItem("selectedProduct");
        }, 5e3);
      }
    }
  }

  // src/utils/produits/catalogueSameCat.ts
  init_live_reload();
  function catalogueSameCat() {
    const mainCategorySection = document.querySelector(".section_produit_m-categorie");
    const categoryId = mainCategorySection?.getAttribute("id");
    if (categoryId) {
      const swiperSlides = document.querySelectorAll(".swiper-slide.is-m-categorie");
      swiperSlides.forEach((slide2) => {
        const slideEl = slide2;
        const displayAttr = slide2.getAttribute("display");
        if (displayAttr === categoryId) {
          slideEl.style.display = "block";
        } else {
          slideEl.style.display = "none";
        }
      });
    }
  }

  // src/utils/ressources/blog.ts
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js
  init_live_reload();
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var gsap2;
  var _coreInitted2;
  var _clamp3;
  var _win3;
  var _doc3;
  var _docEl;
  var _body;
  var _isTouch;
  var _pointerType;
  var ScrollTrigger;
  var _root;
  var _normalizer;
  var _eventTypes;
  var _context2;
  var _getGSAP = function _getGSAP2() {
    return gsap2 || typeof window !== "undefined" && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
  };
  var _startup = 1;
  var _observers = [];
  var _scrollers = [];
  var _proxies = [];
  var _getTime = Date.now;
  var _bridge = function _bridge2(name, value) {
    return value;
  };
  var _integrate = function _integrate2() {
    var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    _scrollers = scrollers;
    _proxies = proxies;
    _bridge = function _bridge3(name, value) {
      return data[name](value);
    };
  };
  var _getProxyProp = function _getProxyProp2(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  };
  var _isViewport = function _isViewport2(el) {
    return !!~_root.indexOf(el);
  };
  var _addListener = function _addListener2(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  };
  var _removeListener = function _removeListener2(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _scrollLeft = "scrollLeft";
  var _scrollTop = "scrollTop";
  var _onScroll = function _onScroll2() {
    return _normalizer && _normalizer.isPressed || _scrollers.cache++;
  };
  var _scrollCacheFunc = function _scrollCacheFunc2(f, doNotCache) {
    var cachingFunc = function cachingFunc2(value) {
      if (value || value === 0) {
        _startup && (_win3.history.scrollRestoration = "manual");
        var isNormalizing = _normalizer && _normalizer.isPressed;
        value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
        f(value);
        cachingFunc2.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value);
      } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge("ref")) {
        cachingFunc2.cacheID = _scrollers.cache;
        cachingFunc2.v = f();
      }
      return cachingFunc2.v + cachingFunc2.offset;
    };
    cachingFunc.offset = 0;
    return f && cachingFunc;
  };
  var _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(value, _vertical.sc()) : _win3.pageXOffset || _doc3[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
    })
  };
  var _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(_horizontal.sc(), value) : _win3.pageYOffset || _doc3[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
    })
  };
  var _getTarget = function _getTarget2(t, self2) {
    return (self2 && self2._ctx && self2._ctx.selector || gsap2.utils.toArray)(t)[0] || (typeof t === "string" && gsap2.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  };
  var _getScrollFunc = function _getScrollFunc2(element, _ref) {
    var s = _ref.s, sc = _ref.sc;
    _isViewport(element) && (element = _doc3.scrollingElement || _docEl);
    var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;
    !~i && (i = _scrollers.push(element) - 1);
    _scrollers[i + offset] || _addListener(element, "scroll", _onScroll);
    var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
      return arguments.length ? element[s] = value : element[s];
    })));
    func.target = element;
    prev || (func.smooth = gsap2.getProperty(element, "scrollBehavior") === "smooth");
    return func;
  };
  var _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {
    var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update2 = function update3(value2, force) {
      var t = _getTime();
      if (force || t - t1 > min) {
        v2 = v1;
        v1 = value2;
        t2 = t1;
        t1 = t;
      } else if (useDelta) {
        v1 += value2;
      } else {
        v1 = v2 + (value2 - v2) / (t - t2) * (t1 - t2);
      }
    }, reset = function reset2() {
      v2 = v1 = useDelta ? 0 : v1;
      t2 = t1 = 0;
    }, getVelocity = function getVelocity2(latestValue) {
      var tOld = t2, vOld = v2, t = _getTime();
      (latestValue || latestValue === 0) && latestValue !== v1 && update2(latestValue);
      return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;
    };
    return {
      update: update2,
      reset,
      getVelocity
    };
  };
  var _getEvent = function _getEvent2(e, preventDefault) {
    preventDefault && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  };
  var _getAbsoluteMax = function _getAbsoluteMax2(a) {
    var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  };
  var _setScrollTrigger = function _setScrollTrigger2() {
    ScrollTrigger = gsap2.core.globals().ScrollTrigger;
    ScrollTrigger && ScrollTrigger.core && _integrate();
  };
  var _initCore3 = function _initCore4(core) {
    gsap2 = core || _getGSAP();
    if (!_coreInitted2 && gsap2 && typeof document !== "undefined" && document.body) {
      _win3 = window;
      _doc3 = document;
      _docEl = _doc3.documentElement;
      _body = _doc3.body;
      _root = [_win3, _doc3, _docEl, _body];
      _clamp3 = gsap2.utils.clamp;
      _context2 = gsap2.core.context || function() {
      };
      _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
      _isTouch = Observer2.isTouch = _win3.matchMedia && _win3.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win3 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer2.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function() {
        return _startup = 0;
      }, 500);
      _setScrollTrigger();
      _coreInitted2 = 1;
    }
    return _coreInitted2;
  };
  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer2 = /* @__PURE__ */ function() {
    function Observer3(vars) {
      this.init(vars);
    }
    var _proto = Observer3.prototype;
    _proto.init = function init4(vars) {
      _coreInitted2 || _initCore3(gsap2) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger || _setScrollTrigger();
      var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event2 = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick2 = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl;
      this.vars = vars;
      ignore && (ignore = gsap2.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce = debounce !== false;
      lineHeight || (lineHeight = parseFloat(_win3.getComputedStyle(_body).lineHeight) || 22);
      var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self2 = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc3, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {
        return onClickTime = _getTime();
      }, _ignoreCheck = function _ignoreCheck2(e, isPointerOrTouch) {
        return (self2.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      }, onStopFunc = function onStopFunc2() {
        self2._vx.reset();
        self2._vy.reset();
        onStopDelayedCall.pause();
        onStop && onStop(self2);
      }, update2 = function update3() {
        var dx = self2.deltaX = _getAbsoluteMax(deltaX), dy = self2.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
        onChange && (changedX || changedY) && onChange(self2, dx, dy, deltaX, deltaY);
        if (changedX) {
          onRight && self2.deltaX > 0 && onRight(self2);
          onLeft && self2.deltaX < 0 && onLeft(self2);
          onChangeX && onChangeX(self2);
          onToggleX && self2.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self2);
          prevDeltaX = self2.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }
        if (changedY) {
          onDown && self2.deltaY > 0 && onDown(self2);
          onUp && self2.deltaY < 0 && onUp(self2);
          onChangeY && onChangeY(self2);
          onToggleY && self2.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self2);
          prevDeltaY = self2.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }
        if (moved || dragged) {
          onMove && onMove(self2);
          if (dragged) {
            onDrag(self2);
            dragged = false;
          }
          moved = false;
        }
        locked && !(locked = false) && onLockAxis && onLockAxis(self2);
        if (wheeled) {
          onWheel(self2);
          wheeled = false;
        }
        id = 0;
      }, onDelta = function onDelta2(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;
        self2._vx.update(x);
        self2._vy.update(y);
        debounce ? id || (id = requestAnimationFrame(update2)) : update2();
      }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x, y) {
        if (lockAxis && !axis) {
          self2.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }
        if (axis !== "y") {
          deltaX[2] += x;
          self2._vx.update(x, true);
        }
        if (axis !== "x") {
          deltaY[2] += y;
          self2._vy.update(y, true);
        }
        debounce ? id || (id = requestAnimationFrame(update2)) : update2();
      }, _onDrag = function _onDrag2(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        e = _getEvent(e, preventDefault);
        var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y, isDragging = self2.isDragging;
        self2.x = x;
        self2.y = y;
        if (isDragging || Math.abs(self2.startX - x) >= dragMinimum || Math.abs(self2.startY - y) >= dragMinimum) {
          onDrag && (dragged = true);
          isDragging || (self2.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
          isDragging || onDragStart && onDragStart(self2);
        }
      }, _onPress = self2.onPress = function(e) {
        if (_ignoreCheck(e, 1) || e && e.button) {
          return;
        }
        self2.axis = axis = null;
        onStopDelayedCall.pause();
        self2.isPressed = true;
        e = _getEvent(e);
        prevDeltaX = prevDeltaY = 0;
        self2.startX = self2.x = e.clientX;
        self2.startY = self2.y = e.clientY;
        self2._vx.reset();
        self2._vy.reset();
        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);
        self2.deltaX = self2.deltaY = 0;
        onPress && onPress(self2);
      }, _onRelease = self2.onRelease = function(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }
        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        var isTrackingDrag = !isNaN(self2.y - self2.startY), wasDragging = self2.isDragging, isDragNotClick = wasDragging && (Math.abs(self2.x - self2.startX) > 3 || Math.abs(self2.y - self2.startY) > 3), eventData = _getEvent(e);
        if (!isDragNotClick && isTrackingDrag) {
          self2._vx.reset();
          self2._vy.reset();
          if (preventDefault && allowClicks) {
            gsap2.delayedCall(0.08, function() {
              if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win3, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }
        self2.isDragging = self2.isGesturing = self2.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        onDragEnd && wasDragging && onDragEnd(self2);
        onRelease && onRelease(self2, isDragNotClick);
      }, _onGestureStart = function _onGestureStart2(e) {
        return e.touches && e.touches.length > 1 && (self2.isGesturing = true) && onGestureStart(e, self2.isDragging);
      }, _onGestureEnd = function _onGestureEnd2() {
        return (self2.isGesturing = false) || onGestureEnd(self2);
      }, onScroll2 = function onScroll3(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = scrollFuncX(), y = scrollFuncY();
        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
        scrollX = x;
        scrollY = y;
        onStop && onStopDelayedCall.restart(true);
      }, _onWheel = function _onWheel2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        e = _getEvent(e, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win3.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      }, _onMove = function _onMove2(e) {
        if (_ignoreCheck(e)) {
          return;
        }
        var x = e.clientX, y = e.clientY, dx = x - self2.x, dy = y - self2.y;
        self2.x = x;
        self2.y = y;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      }, _onHover = function _onHover2(e) {
        self2.event = e;
        onHover(self2);
      }, _onHoverEnd = function _onHoverEnd2(e) {
        self2.event = e;
        onHoverEnd(self2);
      }, _onClick = function _onClick2(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick2(self2);
      };
      onStopDelayedCall = self2._dc = gsap2.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self2.deltaX = self2.deltaY = 0;
      self2._vx = _getVelocityProp(0, 50, true);
      self2._vy = _getVelocityProp(0, 50, true);
      self2.scrollX = scrollFuncX;
      self2.scrollY = scrollFuncY;
      self2.isDragging = self2.isGesturing = self2.isPressed = false;
      _context2(this);
      self2.enable = function(e) {
        if (!self2.isEnabled) {
          _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll2, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);
          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener(target, _eventTypes[0], _onPress, passive, capture);
            _addListener(ownerDoc, _eventTypes[2], _onRelease);
            _addListener(ownerDoc, _eventTypes[3], _onRelease);
            allowClicks && _addListener(target, "click", clickCapture, true, true);
            onClick2 && _addListener(target, "click", _onClick);
            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener(target, _pointerType + "move", _onMove);
          }
          self2.isEnabled = true;
          e && e.type && _onPress(e);
          onEnable && onEnable(self2);
        }
        return self2;
      };
      self2.disable = function() {
        if (self2.isEnabled) {
          _observers.filter(function(o) {
            return o !== self2 && _isViewport(o.target);
          }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          if (self2.isPressed) {
            self2._vx.reset();
            self2._vy.reset();
            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }
          _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll2, capture);
          _removeListener(target, "wheel", _onWheel, capture);
          _removeListener(target, _eventTypes[0], _onPress, capture);
          _removeListener(ownerDoc, _eventTypes[2], _onRelease);
          _removeListener(ownerDoc, _eventTypes[3], _onRelease);
          _removeListener(target, "click", clickCapture, true);
          _removeListener(target, "click", _onClick);
          _removeListener(ownerDoc, "gesturestart", _onGestureStart);
          _removeListener(ownerDoc, "gestureend", _onGestureEnd);
          _removeListener(target, _pointerType + "enter", _onHover);
          _removeListener(target, _pointerType + "leave", _onHoverEnd);
          _removeListener(target, _pointerType + "move", _onMove);
          self2.isEnabled = self2.isPressed = self2.isDragging = false;
          onDisable && onDisable(self2);
        }
      };
      self2.kill = self2.revert = function() {
        self2.disable();
        var i = _observers.indexOf(self2);
        i >= 0 && _observers.splice(i, 1);
        _normalizer === self2 && (_normalizer = 0);
      };
      _observers.push(self2);
      isNormalizer && _isViewport(target) && (_normalizer = self2);
      self2.enable(event2);
    };
    _createClass(Observer3, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);
    return Observer3;
  }();
  Observer2.version = "3.12.5";
  Observer2.create = function(vars) {
    return new Observer2(vars);
  };
  Observer2.register = _initCore3;
  Observer2.getAll = function() {
    return _observers.slice();
  };
  Observer2.getById = function(id) {
    return _observers.filter(function(o) {
      return o.vars.id === id;
    })[0];
  };
  _getGSAP() && gsap2.registerPlugin(Observer2);

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js
  var gsap3;
  var _coreInitted3;
  var _win4;
  var _doc4;
  var _docEl2;
  var _body2;
  var _root2;
  var _resizeDelay;
  var _toArray;
  var _clamp4;
  var _time2;
  var _syncInterval;
  var _refreshing;
  var _pointerIsDown;
  var _transformProp2;
  var _i;
  var _prevWidth;
  var _prevHeight;
  var _autoRefresh;
  var _sort;
  var _suppressOverwrites2;
  var _ignoreResize;
  var _normalizer2;
  var _ignoreMobileResize;
  var _baseScreenHeight;
  var _baseScreenWidth;
  var _fixIOSBug;
  var _context3;
  var _scrollRestoration;
  var _div100vh;
  var _100vh;
  var _isReverted;
  var _clampingMax;
  var _limitCallbacks;
  var _startup2 = 1;
  var _getTime2 = Date.now;
  var _time1 = _getTime2();
  var _lastScrollTime = 0;
  var _enabled = 0;
  var _parseClamp = function _parseClamp2(value, type, self2) {
    var clamp3 = _isString3(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
    self2["_" + type + "Clamp"] = clamp3;
    return clamp3 ? value.substr(6, value.length - 7) : value;
  };
  var _keepClamp = function _keepClamp2(value, clamp3) {
    return clamp3 && (!_isString3(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
  };
  var _rafBugFix = function _rafBugFix2() {
    return _enabled && requestAnimationFrame(_rafBugFix2);
  };
  var _pointerDownHandler = function _pointerDownHandler2() {
    return _pointerIsDown = 1;
  };
  var _pointerUpHandler = function _pointerUpHandler2() {
    return _pointerIsDown = 0;
  };
  var _passThrough3 = function _passThrough4(v) {
    return v;
  };
  var _round3 = function _round4(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _windowExists5 = function _windowExists6() {
    return typeof window !== "undefined";
  };
  var _getGSAP3 = function _getGSAP4() {
    return gsap3 || _windowExists5() && (gsap3 = window.gsap) && gsap3.registerPlugin && gsap3;
  };
  var _isViewport3 = function _isViewport4(e) {
    return !!~_root2.indexOf(e);
  };
  var _getViewportDimension = function _getViewportDimension2(dimensionProperty) {
    return (dimensionProperty === "Height" ? _100vh : _win4["inner" + dimensionProperty]) || _docEl2["client" + dimensionProperty] || _body2["client" + dimensionProperty];
  };
  var _getBoundsFunc = function _getBoundsFunc2(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport3(element) ? function() {
      _winOffsets.width = _win4.innerWidth;
      _winOffsets.height = _100vh;
      return _winOffsets;
    } : function() {
      return _getBounds(element);
    });
  };
  var _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref) {
    var d = _ref.d, d2 = _ref.d2, a = _ref.a;
    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
      return a()[d];
    } : function() {
      return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0;
    };
  };
  var _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
      return _winOffsets;
    };
  };
  var _maxScroll = function _maxScroll2(element, _ref2) {
    var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;
    return Math.max(0, (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport3(element) ? (_docEl2[s] || _body2[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2]);
  };
  var _iterateAutoRefresh = function _iterateAutoRefresh2(func, events2) {
    for (var i = 0; i < _autoRefresh.length; i += 3) {
      (!events2 || ~events2.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
    }
  };
  var _isString3 = function _isString4(value) {
    return typeof value === "string";
  };
  var _isFunction3 = function _isFunction4(value) {
    return typeof value === "function";
  };
  var _isNumber3 = function _isNumber4(value) {
    return typeof value === "number";
  };
  var _isObject3 = function _isObject4(value) {
    return typeof value === "object";
  };
  var _endAnimation = function _endAnimation2(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  };
  var _callback3 = function _callback4(self2, func) {
    if (self2.enabled) {
      var result = self2._ctx ? self2._ctx.add(function() {
        return func(self2);
      }) : func(self2);
      result && result.totalTime && (self2.callbackAnimation = result);
    }
  };
  var _abs = Math.abs;
  var _left = "left";
  var _top = "top";
  var _right = "right";
  var _bottom = "bottom";
  var _width = "width";
  var _height = "height";
  var _Right = "Right";
  var _Left = "Left";
  var _Top = "Top";
  var _Bottom = "Bottom";
  var _padding = "padding";
  var _margin = "margin";
  var _Width = "Width";
  var _Height = "Height";
  var _px = "px";
  var _getComputedStyle = function _getComputedStyle2(element) {
    return _win4.getComputedStyle(element);
  };
  var _makePositionable = function _makePositionable2(element) {
    var position = _getComputedStyle(element).position;
    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  };
  var _setDefaults3 = function _setDefaults4(obj, defaults3) {
    for (var p in defaults3) {
      p in obj || (obj[p] = defaults3[p]);
    }
    return obj;
  };
  var _getBounds = function _getBounds2(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp2] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap3.to(element, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
    }).progress(1), bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  };
  var _getSize = function _getSize2(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  };
  var _getLabelRatioArray = function _getLabelRatioArray2(timeline2) {
    var a = [], labels = timeline2.labels, duration = timeline2.duration(), p;
    for (p in labels) {
      a.push(labels[p] / duration);
    }
    return a;
  };
  var _getClosestLabel = function _getClosestLabel2(animation) {
    return function(value) {
      return gsap3.utils.snap(_getLabelRatioArray(animation), value);
    };
  };
  var _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {
    var snap3 = gsap3.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a2, b) {
      return a2 - b;
    });
    return a ? function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var i;
      if (!direction) {
        return snap3(value);
      }
      if (direction > 0) {
        value -= threshold;
        for (i = 0; i < a.length; i++) {
          if (a[i] >= value) {
            return a[i];
          }
        }
        return a[i - 1];
      } else {
        i = a.length;
        value += threshold;
        while (i--) {
          if (a[i] <= value) {
            return a[i];
          }
        }
      }
      return a[0];
    } : function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var snapped = snap3(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap3(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  };
  var _getLabelAtDirection = function _getLabelAtDirection2(timeline2) {
    return function(value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline2))(value, st.direction);
    };
  };
  var _multiListener = function _multiListener2(func, element, types, callback) {
    return types.split(",").forEach(function(type) {
      return func(element, type, callback);
    });
  };
  var _addListener3 = function _addListener4(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  };
  var _removeListener3 = function _removeListener4(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _wheelListener = function _wheelListener2(func, el, scrollFunc) {
    scrollFunc = scrollFunc && scrollFunc.wheelHandler;
    if (scrollFunc) {
      func(el, "wheel", scrollFunc);
      func(el, "touchmove", scrollFunc);
    }
  };
  var _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  };
  var _defaults2 = {
    toggleActions: "play",
    anticipatePin: 0
  };
  var _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  };
  var _offsetToPx = function _offsetToPx2(value, size) {
    if (_isString3(value)) {
      var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size / 100);
        value = value.substr(0, eqIndex - 1);
      }
      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
    }
    return value;
  };
  var _createMarker = function _createMarker2(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
    var e = _doc4.createElement("div"), useFixedPosition = _isViewport3(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent2 = useFixedPosition ? _body2 : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e._isStart = isStart;
    e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e.style.cssText = css;
    e.innerText = name || name === 0 ? type + "-" + name : type;
    parent2.children[0] ? parent2.insertBefore(e, parent2.children[0]) : parent2.appendChild(e);
    e._offset = e["offset" + direction.op.d2];
    _positionMarker(e, 0, direction, isStart);
    return e;
  };
  var _positionMarker = function _positionMarker2(marker, start, direction, flipped) {
    var vars = {
      display: "block"
    }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap3.set(marker, vars);
  };
  var _triggers = [];
  var _ids = {};
  var _rafID;
  var _sync = function _sync2() {
    return _getTime2() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  };
  var _onScroll3 = function _onScroll4() {
    if (!_normalizer2 || !_normalizer2.isPressed || _normalizer2.startX > _body2.clientWidth) {
      _scrollers.cache++;
      if (_normalizer2) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll();
      }
      _lastScrollTime || _dispatch3("scrollStart");
      _lastScrollTime = _getTime2();
    }
  };
  var _setBaseDimensions = function _setBaseDimensions2() {
    _baseScreenWidth = _win4.innerWidth;
    _baseScreenHeight = _win4.innerHeight;
  };
  var _onResize = function _onResize2() {
    _scrollers.cache++;
    !_refreshing && !_ignoreResize && !_doc4.fullscreenElement && !_doc4.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win4.innerWidth || Math.abs(_win4.innerHeight - _baseScreenHeight) > _win4.innerHeight * 0.25) && _resizeDelay.restart(true);
  };
  var _listeners2 = {};
  var _emptyArray2 = [];
  var _softRefresh = function _softRefresh2() {
    return _removeListener3(ScrollTrigger2, "scrollEnd", _softRefresh2) || _refreshAll(true);
  };
  var _dispatch3 = function _dispatch4(type) {
    return _listeners2[type] && _listeners2[type].map(function(f) {
      return f();
    }) || _emptyArray2;
  };
  var _savedStyles = [];
  var _revertRecorded = function _revertRecorded2(media) {
    for (var i = 0; i < _savedStyles.length; i += 5) {
      if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
        _savedStyles[i].style.cssText = _savedStyles[i + 1];
        _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
        _savedStyles[i + 3].uncache = 1;
      }
    }
  };
  var _revertAll = function _revertAll2(kill, media) {
    var trigger;
    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];
      if (trigger && (!media || trigger._ctx === media)) {
        if (kill) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }
    _isReverted = true;
    media && _revertRecorded(media);
    media || _dispatch3("revert");
  };
  var _clearScrollMemory = function _clearScrollMemory2(scrollRestoration, force) {
    _scrollers.cache++;
    (force || !_refreshingAll) && _scrollers.forEach(function(obj) {
      return _isFunction3(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString3(scrollRestoration) && (_win4.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  };
  var _refreshingAll;
  var _refreshID = 0;
  var _queueRefreshID;
  var _queueRefreshAll = function _queueRefreshAll2() {
    if (_queueRefreshID !== _refreshID) {
      var id = _queueRefreshID = _refreshID;
      requestAnimationFrame(function() {
        return id === _refreshID && _refreshAll(true);
      });
    }
  };
  var _refresh100vh = function _refresh100vh2() {
    _body2.appendChild(_div100vh);
    _100vh = !_normalizer2 && _div100vh.offsetHeight || _win4.innerHeight;
    _body2.removeChild(_div100vh);
  };
  var _hideAllMarkers = function _hideAllMarkers2(hide) {
    return _toArray(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(el) {
      return el.style.display = hide ? "none" : "block";
    });
  };
  var _refreshAll = function _refreshAll2(force, skipRevert) {
    if (_lastScrollTime && !force && !_isReverted) {
      _addListener3(ScrollTrigger2, "scrollEnd", _softRefresh);
      return;
    }
    _refresh100vh();
    _refreshingAll = ScrollTrigger2.isRefreshing = true;
    _scrollers.forEach(function(obj) {
      return _isFunction3(obj) && ++obj.cacheID && (obj.rec = obj());
    });
    var refreshInits = _dispatch3("refreshInit");
    _sort && ScrollTrigger2.sort();
    skipRevert || _revertAll();
    _scrollers.forEach(function(obj) {
      if (_isFunction3(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto");
        obj(0);
      }
    });
    _triggers.slice(0).forEach(function(t) {
      return t.refresh();
    });
    _isReverted = false;
    _triggers.forEach(function(t) {
      if (t._subPinOffset && t.pin) {
        var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight", original = t.pin[prop];
        t.revert(true, 1);
        t.adjustPinSpacing(t.pin[prop] - original);
        t.refresh();
      }
    });
    _clampingMax = 1;
    _hideAllMarkers(true);
    _triggers.forEach(function(t) {
      var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === "max" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;
      (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);
    });
    _hideAllMarkers(false);
    _clampingMax = 0;
    refreshInits.forEach(function(result) {
      return result && result.render && result.render(-1);
    });
    _scrollers.forEach(function(obj) {
      if (_isFunction3(obj)) {
        obj.smooth && requestAnimationFrame(function() {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });
    _clearScrollMemory(_scrollRestoration, 1);
    _resizeDelay.pause();
    _refreshID++;
    _refreshingAll = 2;
    _updateAll(2);
    _triggers.forEach(function(t) {
      return _isFunction3(t.vars.onRefresh) && t.vars.onRefresh(t);
    });
    _refreshingAll = ScrollTrigger2.isRefreshing = false;
    _dispatch3("refresh");
  };
  var _lastScroll = 0;
  var _direction = 1;
  var _primary;
  var _updateAll = function _updateAll2(force) {
    if (force === 2 || !_refreshingAll && !_isReverted) {
      ScrollTrigger2.isUpdating = true;
      _primary && _primary.update(0);
      var l = _triggers.length, time = _getTime2(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();
      _direction = _lastScroll > scroll ? -1 : 1;
      _refreshingAll || (_lastScroll = scroll);
      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
          _lastScrollTime = 0;
          _dispatch3("scrollEnd");
        }
        _time2 = _time1;
        _time1 = time;
      }
      if (_direction < 0) {
        _i = l;
        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
        _direction = 1;
      } else {
        for (_i = 0; _i < l; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }
      ScrollTrigger2.isUpdating = false;
    }
    _rafID = 0;
  };
  var _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"];
  var _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]);
  var _swapPinOut = function _swapPinOut2(pin, spacer, state) {
    _setState(state);
    var cache = pin._gsap;
    if (cache.spacerIsNative) {
      _setState(cache.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent2 = spacer.parentNode;
      if (parent2) {
        parent2.insertBefore(pin, spacer);
        parent2.removeChild(spacer);
      }
    }
    pin._gsap.swappedIn = false;
  };
  var _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;
      while (i--) {
        p = _propNamesToCopy[i];
        spacerStyle[p] = cs[p];
      }
      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
      _setState(spacerState);
      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];
      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }
      pin._gsap.swappedIn = true;
    }
  };
  var _capsExp2 = /([A-Z])/g;
  var _setState = function _setState2(state) {
    if (state) {
      var style = state.t.style, l = state.length, i = 0, p, value;
      (state.t._gsap || gsap3.core.getCache(state.t)).uncache = 1;
      for (; i < l; i += 2) {
        value = state[i + 1];
        p = state[i];
        if (value) {
          style[p] = value;
        } else if (style[p]) {
          style.removeProperty(p.replace(_capsExp2, "-$1").toLowerCase());
        }
      }
    }
  };
  var _getState = function _getState2(element) {
    var l = _stateProps.length, style = element.style, state = [], i = 0;
    for (; i < l; i++) {
      state.push(_stateProps[i], style[_stateProps[i]]);
    }
    state.t = element;
    return state;
  };
  var _copyState = function _copyState2(state, override, omitOffsets) {
    var result = [], l = state.length, i = omitOffsets ? 8 : 0, p;
    for (; i < l; i += 2) {
      p = state[i];
      result.push(p, p in override ? override[p] : state[i + 1]);
    }
    result.t = state.t;
    return result;
  };
  var _winOffsets = {
    left: 0,
    top: 0
  };
  var _parsePosition3 = function _parsePosition4(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self2, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
    _isFunction3(value) && (value = value(self2));
    if (_isString3(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }
    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;
    containerAnimation && containerAnimation.seek(0);
    isNaN(value) || (value = +value);
    if (!_isNumber3(value)) {
      _isFunction3(trigger) && (trigger = trigger(self2));
      var offsets = (value || "0").split(" "), bounds, localOffset, globalOffset, display;
      element = _getTarget(trigger, self2) || _body2;
      bounds = _getBounds(element) || {};
      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }
      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset;
    } else {
      containerAnimation && (value = gsap3.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
      markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
    }
    if (clampZeroProp) {
      self2[clampZeroProp] = value || -1e-3;
      value < 0 && (value = 0);
    }
    if (marker) {
      var position = value + scrollerSize, isStart = marker._isStart;
      p1 = "scroll" + direction.d2;
      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body2[p1], _docEl2[p1]) : marker.parentNode[p1]) <= position + 1);
      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }
    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }
    containerAnimation && containerAnimation.seek(time);
    return containerAnimation ? value : Math.round(value);
  };
  var _prefixExp = /(webkit|moz|length|cssText|inset)/i;
  var _reparent = function _reparent2(element, parent2, top, left) {
    if (element.parentNode !== parent2) {
      var style = element.style, p, cs;
      if (parent2 === _body2) {
        element._stOrig = style.cssText;
        cs = _getComputedStyle(element);
        for (p in cs) {
          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
            style[p] = cs[p];
          }
        }
        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }
      gsap3.core.getCache(element).uncache = 1;
      parent2.appendChild(element);
    }
  };
  var _interruptionTracker = function _interruptionTracker2(getValueFunc, initialValue, onInterrupt) {
    var last1 = initialValue, last2 = last1;
    return function(value) {
      var current = Math.round(getValueFunc());
      if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
        value = current;
        onInterrupt && onInterrupt();
      }
      last2 = last1;
      last1 = value;
      return value;
    };
  };
  var _shiftMarker = function _shiftMarker2(marker, direction, value) {
    var vars = {};
    vars[direction.p] = "+=" + value;
    gsap3.set(marker, vars);
  };
  var _getTweenCreator = function _getTweenCreator2(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction), prop = "_scroll" + direction.p2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {
      var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};
      initialValue = initialValue || getScroll();
      var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {
        tween.kill();
        getTween2.tween = 0;
      });
      change2 = change1 && change2 || 0;
      change1 = change1 || scrollTo - initialValue;
      tween && tween.kill();
      vars[prop] = scrollTo;
      vars.inherit = false;
      vars.modifiers = modifiers;
      modifiers[prop] = function() {
        return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
      };
      vars.onUpdate = function() {
        _scrollers.cache++;
        getTween2.tween && _updateAll();
      };
      vars.onComplete = function() {
        getTween2.tween = 0;
        onComplete && onComplete.call(tween);
      };
      tween = getTween2.tween = gsap3.to(scroller, vars);
      return tween;
    };
    scroller[prop] = getScroll;
    getScroll.wheelHandler = function() {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };
    _addListener3(scroller, "wheel", getScroll.wheelHandler);
    ScrollTrigger2.isTouch && _addListener3(scroller, "touchmove", getScroll.wheelHandler);
    return getTween;
  };
  var ScrollTrigger2 = /* @__PURE__ */ function() {
    function ScrollTrigger3(vars, animation) {
      _coreInitted3 || ScrollTrigger3.register(gsap3) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
      _context3(this);
      this.init(vars, animation);
    }
    var _proto = ScrollTrigger3.prototype;
    _proto.init = function init4(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true);
      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough3;
        return;
      }
      vars = _setDefaults3(_isString3(vars) || _isNumber3(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults2);
      var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap3 = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win4), scrollerCache = gsap3.core.getCache(scroller), isViewport = _isViewport3(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : _defaults2.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self2 = this, onRefreshInit = vars.onRefreshInit && function() {
        return vars.onRefreshInit(self2);
      }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap22, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;
      self2._startClamp = self2._endClamp = false;
      self2._dir = direction;
      anticipatePin *= 45;
      self2.scroller = scroller;
      self2.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self2.vars = vars;
      animation = animation || vars.animation;
      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self2);
      }
      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self2.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
      self2.scrubDuration = function(value) {
        scrubSmooth = _isNumber3(value) && value;
        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap3.to(animation, {
            ease: "expo",
            totalProgress: "+=0",
            inherit: false,
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self2);
            }
          });
        }
      };
      if (animation) {
        animation.vars.lazy = false;
        animation._initted && !self2.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
        self2.animation = animation.pause();
        animation.scrollTrigger = self2;
        self2.scrubDuration(scrub);
        snap1 = 0;
        id || (id = animation.vars.id);
      }
      if (snap3) {
        if (!_isObject3(snap3) || snap3.push) {
          snap3 = {
            snapTo: snap3
          };
        }
        "scrollBehavior" in _body2.style && gsap3.set(isViewport ? [_body2, _docEl2] : scroller, {
          scrollBehavior: "auto"
        });
        _scrollers.forEach(function(o) {
          return _isFunction3(o) && o.target === (isViewport ? _doc4.scrollingElement || _docEl2 : scroller) && (o.smooth = false);
        });
        snapFunc = _isFunction3(snap3.snapTo) ? snap3.snapTo : snap3.snapTo === "labels" ? _getClosestLabel(animation) : snap3.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap3.directional !== false ? function(value, st) {
          return _snapDirectional(snap3.snapTo)(value, _getTime2() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap3.utils.snap(snap3.snapTo);
        snapDurClamp = snap3.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject3(snapDurClamp) ? _clamp4(snapDurClamp.min, snapDurClamp.max) : _clamp4(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap3.delayedCall(snap3.delay || scrubSmooth / 2 || 0.1, function() {
          var scroll = scrollFunc(), refreshedRecently = _getTime2() - lastRefresh < 500, tween = tweenTo.tween;
          if ((refreshedRecently || Math.abs(self2.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
            var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap22) / (_getTime2() - _time2) * 1e3 || 0, change1 = gsap3.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap3.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap3, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
            endValue = snapFunc(naturalEnd, self2);
            _isNumber3(endValue) || (endValue = naturalEnd);
            endScroll = Math.round(start + endValue * change);
            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                return;
              }
              if (snap3.inertia === false) {
                change1 = endValue - progress;
              }
              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap3.ease || "power3",
                data: _abs(endScroll - scroll),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self2);
                },
                onComplete: function onComplete() {
                  self2.update();
                  lastSnap = scrollFunc();
                  if (animation) {
                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                  }
                  snap1 = snap22 = animation && !isToggle ? animation.totalProgress() : self2.progress;
                  onSnapComplete && onSnapComplete(self2);
                  _onComplete && _onComplete(self2);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self2, tweenTo.tween);
            }
          } else if (self2.isActive && lastSnap !== scroll) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }
      id && (_ids[id] = self2);
      trigger = self2.trigger = _getTarget(trigger || pin !== true && pin);
      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self2));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString3(toggleClass) && (toggleClass = {
        targets: trigger,
        className: toggleClass
      });
      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
        self2.pin = pin;
        pinCache = gsap3.core.getCache(pin);
        if (!pinCache.spacer) {
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }
          pinCache.spacer = spacer = pinSpacer || _doc4.createElement("div");
          spacer.classList.add("pin-spacer");
          id && spacer.classList.add("pin-spacer-" + id);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }
        vars.force3D !== false && gsap3.set(pin, {
          force3D: true
        });
        self2.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap3.getProperty(pin);
        pinSetter = gsap3.quickSetter(pin, direction.a, _px);
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin);
      }
      if (markers) {
        markerVars = _isObject3(markers) ? _setDefaults3(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset = markerStartTrigger["offset" + direction.op.d2];
        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
        markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap3.quickSetter([markerStart, markerEnd], direction.a, _px));
        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body2 : scroller);
          gsap3.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap3.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap3.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }
      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function() {
          self2.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }
      self2.previous = function() {
        return _triggers[_triggers.indexOf(self2) - 1];
      };
      self2.next = function() {
        return _triggers[_triggers.indexOf(self2) + 1];
      };
      self2.revert = function(revert, temp) {
        if (!temp) {
          return self2.kill(true);
        }
        var r = revert !== false || !self2.enabled, prevRefreshing = _refreshing;
        if (r !== self2.isReverted) {
          if (r) {
            prevScroll = Math.max(scrollFunc(), self2.scroll.rec || 0);
            prevProgress = self2.progress;
            prevAnimProgress = animation && animation.progress();
          }
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
            return m.style.display = r ? "none" : "block";
          });
          if (r) {
            _refreshing = self2;
            self2.update(r);
          }
          if (pin && (!pinReparent || !self2.isActive)) {
            if (r) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }
          r || self2.update(r);
          _refreshing = prevRefreshing;
          self2.isReverted = r;
        }
      };
      self2.refresh = function(soft, force, position, pinOffset) {
        if ((_refreshing || !self2.enabled) && !force) {
          return;
        }
        if (pin && soft && _lastScrollTime) {
          _addListener3(ScrollTrigger3, "scrollEnd", _softRefresh);
          return;
        }
        !_refreshingAll && onRefreshInit && onRefreshInit(self2);
        _refreshing = self2;
        if (tweenTo.tween && !position) {
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }
        scrubTween && scrubTween.pause();
        invalidateOnRefresh && animation && animation.revert({
          kill: false
        }).invalidate();
        self2.isReverted || self2.revert(true, true);
        self2._subPinOffset = false;
        var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset2 = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject3(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject3(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self2.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self2), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self2)) || 0, i = triggerIndex, cs2, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;
        if (markers && _isObject3(position)) {
          markerStartOffset = gsap3.getProperty(markerStartTrigger, direction.p);
          markerEndOffset = gsap3.getProperty(markerEndTrigger, direction.p);
        }
        while (i--) {
          curTrigger = _triggers[i];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self2);
          curPin = curTrigger.pin;
          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger);
            curTrigger.revert(true, true);
          }
          if (curTrigger !== _triggers[i]) {
            triggerIndex--;
            i--;
          }
        }
        _isFunction3(parsedStart) && (parsedStart = parsedStart(self2));
        parsedStart = _parseClamp(parsedStart, "start", self2);
        start = _parsePosition3(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self2._startClamp && "_startClamp") || (pin ? -1e-3 : 0);
        _isFunction3(parsedEnd) && (parsedEnd = parsedEnd(self2));
        if (_isString3(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString3(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset2 = _offsetToPx(parsedEnd.substr(2), size);
            parsedEnd = _isString3(parsedStart) ? parsedStart : (containerAnimation ? gsap3.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset2;
            parsedEndTrigger = trigger;
          }
        }
        parsedEnd = _parseClamp(parsedEnd, "end", self2);
        end = Math.max(start, _parsePosition3(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset2, markerEnd, markerEndTrigger, self2, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self2._endClamp && "_endClamp")) || -1e-3;
        offset2 = 0;
        i = triggerIndex;
        while (i--) {
          curTrigger = _triggers[i];
          curPin = curTrigger.pin;
          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs2 = curTrigger.end - (self2._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
              offset2 += cs2 * (1 - curTrigger.progress);
            }
            curPin === pin && (otherPinOffset += cs2);
          }
        }
        start += offset2;
        end += offset2;
        self2._startClamp && (self2._startClamp += offset2);
        if (self2._endClamp && !_refreshingAll) {
          self2._endClamp = end || -1e-3;
          end = Math.min(end, _maxScroll(scroller, direction));
        }
        change = end - start || (start -= 0.01) && 1e-3;
        if (isFirstRefresh) {
          prevProgress = gsap3.utils.clamp(0, 1, gsap3.utils.normalize(start, end, prevScroll));
        }
        self2._pinPush = otherPinOffset;
        if (markerStart && offset2) {
          cs2 = {};
          cs2[direction.a] = "+=" + offset2;
          pinnedContainer && (cs2[direction.p] = "-=" + scrollFunc());
          gsap3.set([markerStart, markerEnd], cs2);
        }
        if (pin && !(_clampingMax && self2.end >= _maxScroll(scroller, direction))) {
          cs2 = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = scrollFunc();
          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
          if (!max && end > 1) {
            forcedOverflow = (isViewport ? _doc4.scrollingElement || _docEl2 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };
            if (isViewport && _getComputedStyle(_body2)["overflow" + direction.a.toUpperCase()] !== "scroll") {
              forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
            }
          }
          _swapPinIn(pin, spacer, cs2);
          pinState = _getState(pin);
          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
            if (i) {
              spacerState.push(direction.d, i + _px);
              spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
            }
            _setState(spacerState);
            if (pinnedContainer) {
              _triggers.forEach(function(t) {
                if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                  t._subPinOffset = true;
                }
              });
            }
            useFixedPosition && scrollFunc(prevScroll);
          } else {
            i = _getSize(pin, direction);
            i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px);
          }
          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs2[_padding];
            override[_padding + _Top] = cs2[_padding + _Top];
            override[_padding + _Right] = cs2[_padding + _Right];
            override[_padding + _Bottom] = cs2[_padding + _Bottom];
            override[_padding + _Left] = cs2[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }
          if (animation) {
            initted = animation._initted;
            _suppressOverwrites2(1);
            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime());
            _suppressOverwrites2(0);
          } else {
            pinChange = change;
          }
          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          bounds = trigger.parentNode;
          while (bounds && bounds !== _body2) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }
            bounds = bounds.parentNode;
          }
        }
        revertedPins && revertedPins.forEach(function(t) {
          return t.revert(false, true);
        });
        self2.start = start;
        self2.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self2.scroll.rec = 0;
        }
        self2.revert(false, true);
        lastRefresh = _getTime2();
        if (snapDelayedCall) {
          lastSnap = -1;
          snapDelayedCall.restart(true);
        }
        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);
        if (isFirstRefresh || prevProgress !== self2.progress || containerAnimation || invalidateOnRefresh) {
          animation && !isToggle && animation.totalProgress(containerAnimation && start < -1e-3 && !prevProgress ? gsap3.utils.normalize(start, end, 0) : prevProgress, true);
          self2.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }
        pin && pinSpacing && (spacer._pinOffset = Math.round(self2.progress * pinChange));
        scrubTween && scrubTween.invalidate();
        if (!isNaN(markerStartOffset)) {
          markerStartOffset -= gsap3.getProperty(markerStartTrigger, direction.p);
          markerEndOffset -= gsap3.getProperty(markerEndTrigger, direction.p);
          _shiftMarker(markerStartTrigger, direction, markerStartOffset);
          _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
          _shiftMarker(markerEndTrigger, direction, markerEndOffset);
          _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
        }
        isFirstRefresh && !_refreshingAll && self2.update();
        if (onRefresh && !_refreshingAll && !executingOnRefresh) {
          executingOnRefresh = true;
          onRefresh(self2);
          executingOnRefresh = false;
        }
      };
      self2.getVelocity = function() {
        return (scrollFunc() - scroll2) / (_getTime2() - _time2) * 1e3 || 0;
      };
      self2.endAnimation = function() {
        _endAnimation(self2.callbackAnimation);
        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self2.direction < 0, 1);
        }
      };
      self2.labelToScroll = function(label) {
        return animation && animation.labels && (start || self2.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };
      self2.getTrailing = function(name) {
        var i = _triggers.indexOf(self2), a = self2.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
        return (_isString3(name) ? a.filter(function(t) {
          return t.vars.preventOverlaps === name;
        }) : a).filter(function(t) {
          return self2.direction > 0 ? t.end <= start : t.start >= end;
        });
      };
      self2.update = function(reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }
        var scroll = _refreshingAll === true ? prevScroll : self2.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress2 = self2.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll;
          if (snap3) {
            snap22 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        }
        if (anticipatePin && pin && !_refreshing && !_startup2 && _lastScrollTime) {
          if (!clipped && start < scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 1e-4;
          } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 0.9999;
          }
        }
        if (clipped !== prevProgress2 && self2.enabled) {
          isActive = self2.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress2 && prevProgress2 < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress2;
          self2.direction = clipped > prevProgress2 ? 1 : -1;
          self2.progress = clipped;
          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;
            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }
          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction3(preventOverlaps) ? preventOverlaps(self2) : self2.getTrailing(preventOverlaps).forEach(function(t) {
            return t.endAnimation();
          }));
          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup2) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
            }
          }
          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
            if (!useFixedPosition) {
              pinSetter(_round3(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true), _offset = scroll - start;
                  _reparent(pin, _body2, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }
              _setState(isActive || isAtMax ? pinActiveState : pinState);
              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }
          snap3 && !tweenTo.tween && !_refreshing && !_startup2 && snapDelayedCall.restart(true);
          toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
          });
          onUpdate && !isToggle && !reset && onUpdate(self2);
          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }
              onUpdate && onUpdate(self2);
            }
            if (toggled || !_limitCallbacks) {
              onToggle && toggled && _callback3(self2, onToggle);
              callbacks[toggleState] && _callback3(self2, callbacks[toggleState]);
              once && (clipped === 1 ? self2.kill(false, 1) : callbacks[toggleState] = 0);
              if (!toggled) {
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback3(self2, callbacks[toggleState]);
              }
            }
            if (fastScrollEnd && !isActive && Math.abs(self2.getVelocity()) > (_isNumber3(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self2.callbackAnimation);
              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self2);
          }
        }
        if (markerEndSetter) {
          var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
          markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n);
        }
        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };
      self2.enable = function(reset, refresh) {
        if (!self2.enabled) {
          self2.enabled = true;
          _addListener3(scroller, "resize", _onResize);
          isViewport || _addListener3(scroller, "scroll", _onScroll3);
          onRefreshInit && _addListener3(ScrollTrigger3, "refreshInit", onRefreshInit);
          if (reset !== false) {
            self2.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }
          refresh !== false && self2.refresh();
        }
      };
      self2.getTween = function(snap4) {
        return snap4 && tweenTo ? tweenTo.tween : scrubTween;
      };
      self2.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
        if (containerAnimation) {
          var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;
          newStart = st.start + _change * newStart / duration;
          newEnd = st.start + _change * newEnd / duration;
        }
        self2.refresh(false, false, {
          start: _keepClamp(newStart, keepClamp && !!self2._startClamp),
          end: _keepClamp(newEnd, keepClamp && !!self2._endClamp)
        }, pinOffset);
        self2.update();
      };
      self2.adjustPinSpacing = function(amount) {
        if (spacerState && amount) {
          var i = spacerState.indexOf(direction.d) + 1;
          spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
          _setState(spacerState);
        }
      };
      self2.disable = function(reset, allowAnimation) {
        if (self2.enabled) {
          reset !== false && self2.revert(true, true);
          self2.enabled = self2.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener3(ScrollTrigger3, "refreshInit", onRefreshInit);
          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }
          if (!isViewport) {
            var i = _triggers.length;
            while (i--) {
              if (_triggers[i].scroller === scroller && _triggers[i] !== self2) {
                return;
              }
            }
            _removeListener3(scroller, "resize", _onResize);
            isViewport || _removeListener3(scroller, "scroll", _onScroll3);
          }
        }
      };
      self2.kill = function(revert, allowAnimation) {
        self2.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id && delete _ids[id];
        var i = _triggers.indexOf(self2);
        i >= 0 && _triggers.splice(i, 1);
        i === _i && _direction > 0 && _i--;
        i = 0;
        _triggers.forEach(function(t) {
          return t.scroller === self2.scroller && (i = 1);
        });
        i || _refreshingAll || (self2.scroll.rec = 0);
        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
          return m.parentNode && m.parentNode.removeChild(m);
        });
        _primary === self2 && (_primary = 0);
        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i = 0;
          _triggers.forEach(function(t) {
            return t.pin === pin && i++;
          });
          i || (pinCache.spacer = 0);
        }
        vars.onKill && vars.onKill(self2);
      };
      _triggers.push(self2);
      self2.enable(false, false);
      customRevertReturn && customRevertReturn(self2);
      if (animation && animation.add && !change) {
        var updateFunc = self2.update;
        self2.update = function() {
          self2.update = updateFunc;
          start || end || self2.refresh();
        };
        gsap3.delayedCall(0.01, self2.update);
        change = 0.01;
        start = end = 0;
      } else {
        self2.refresh();
      }
      pin && _queueRefreshAll();
    };
    ScrollTrigger3.register = function register(core) {
      if (!_coreInitted3) {
        gsap3 = core || _getGSAP3();
        _windowExists5() && window.document && ScrollTrigger3.enable();
        _coreInitted3 = _enabled;
      }
      return _coreInitted3;
    };
    ScrollTrigger3.defaults = function defaults3(config3) {
      if (config3) {
        for (var p in config3) {
          _defaults2[p] = config3[p];
        }
      }
      return _defaults2;
    };
    ScrollTrigger3.disable = function disable(reset, kill) {
      _enabled = 0;
      _triggers.forEach(function(trigger) {
        return trigger[kill ? "kill" : "disable"](reset);
      });
      _removeListener3(_win4, "wheel", _onScroll3);
      _removeListener3(_doc4, "scroll", _onScroll3);
      clearInterval(_syncInterval);
      _removeListener3(_doc4, "touchcancel", _passThrough3);
      _removeListener3(_body2, "touchstart", _passThrough3);
      _multiListener(_removeListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
      _multiListener(_removeListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
      _resizeDelay.kill();
      _iterateAutoRefresh(_removeListener3);
      for (var i = 0; i < _scrollers.length; i += 3) {
        _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 1]);
        _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 2]);
      }
    };
    ScrollTrigger3.enable = function enable() {
      _win4 = window;
      _doc4 = document;
      _docEl2 = _doc4.documentElement;
      _body2 = _doc4.body;
      if (gsap3) {
        _toArray = gsap3.utils.toArray;
        _clamp4 = gsap3.utils.clamp;
        _context3 = gsap3.core.context || _passThrough3;
        _suppressOverwrites2 = gsap3.core.suppressOverwrites || _passThrough3;
        _scrollRestoration = _win4.history.scrollRestoration || "auto";
        _lastScroll = _win4.pageYOffset;
        gsap3.core.globals("ScrollTrigger", ScrollTrigger3);
        if (_body2) {
          _enabled = 1;
          _div100vh = document.createElement("div");
          _div100vh.style.height = "100vh";
          _div100vh.style.position = "absolute";
          _refresh100vh();
          _rafBugFix();
          Observer2.register(gsap3);
          ScrollTrigger3.isTouch = Observer2.isTouch;
          _fixIOSBug = Observer2.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
          _ignoreMobileResize = Observer2.isTouch === 1;
          _addListener3(_win4, "wheel", _onScroll3);
          _root2 = [_win4, _doc4, _docEl2, _body2];
          if (gsap3.matchMedia) {
            ScrollTrigger3.matchMedia = function(vars) {
              var mm = gsap3.matchMedia(), p;
              for (p in vars) {
                mm.add(p, vars[p]);
              }
              return mm;
            };
            gsap3.addEventListener("matchMediaInit", function() {
              return _revertAll();
            });
            gsap3.addEventListener("matchMediaRevert", function() {
              return _revertRecorded();
            });
            gsap3.addEventListener("matchMedia", function() {
              _refreshAll(0, 1);
              _dispatch3("matchMedia");
            });
            gsap3.matchMedia("(orientation: portrait)", function() {
              _setBaseDimensions();
              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }
          _setBaseDimensions();
          _addListener3(_doc4, "scroll", _onScroll3);
          var bodyStyle = _body2.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap3.core.Animation.prototype, bounds, i;
          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          });
          bodyStyle.borderTopStyle = "solid";
          bounds = _getBounds(_body2);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
          _syncInterval = setInterval(_sync, 250);
          gsap3.delayedCall(0.5, function() {
            return _startup2 = 0;
          });
          _addListener3(_doc4, "touchcancel", _passThrough3);
          _addListener3(_body2, "touchstart", _passThrough3);
          _multiListener(_addListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
          _multiListener(_addListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
          _transformProp2 = gsap3.utils.checkPrefix("transform");
          _stateProps.push(_transformProp2);
          _coreInitted3 = _getTime2();
          _resizeDelay = gsap3.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc4, "visibilitychange", function() {
            var w = _win4.innerWidth, h = _win4.innerHeight;
            if (_doc4.hidden) {
              _prevWidth = w;
              _prevHeight = h;
            } else if (_prevWidth !== w || _prevHeight !== h) {
              _onResize();
            }
          }, _doc4, "DOMContentLoaded", _refreshAll, _win4, "load", _refreshAll, _win4, "resize", _onResize];
          _iterateAutoRefresh(_addListener3);
          _triggers.forEach(function(trigger) {
            return trigger.enable(0, 1);
          });
          for (i = 0; i < _scrollers.length; i += 3) {
            _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 1]);
            _wheelListener(_removeListener3, _scrollers[i], _scrollers[i + 2]);
          }
        }
      }
    };
    ScrollTrigger3.config = function config3(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms = vars.syncInterval;
      ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger3.isTouch === 1 && vars.ignoreMobileResize);
      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener3) || _iterateAutoRefresh(_addListener3, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };
    ScrollTrigger3.scrollerProxy = function scrollerProxy(target, vars) {
      var t = _getTarget(target), i = _scrollers.indexOf(t), isViewport = _isViewport3(t);
      if (~i) {
        _scrollers.splice(i, isViewport ? 6 : 2);
      }
      if (vars) {
        isViewport ? _proxies.unshift(_win4, vars, _body2, vars, _docEl2, vars) : _proxies.unshift(t, vars);
      }
    };
    ScrollTrigger3.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function(t) {
        return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
      });
    };
    ScrollTrigger3.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString3(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win4.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win4.innerHeight;
    };
    ScrollTrigger3.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString3(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset) / _win4.innerWidth : (bounds.top + offset) / _win4.innerHeight;
    };
    ScrollTrigger3.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function(t) {
        return t.vars.id !== "ScrollSmoother" && t.kill();
      });
      if (allowListeners !== true) {
        var listeners = _listeners2.killAll || [];
        _listeners2 = {};
        listeners.forEach(function(f) {
          return f();
        });
      }
    };
    return ScrollTrigger3;
  }();
  ScrollTrigger2.version = "3.12.5";
  ScrollTrigger2.saveStyles = function(targets) {
    return targets ? _toArray(targets).forEach(function(target) {
      if (target && target.style) {
        var i = _savedStyles.indexOf(target);
        i >= 0 && _savedStyles.splice(i, 5);
        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap3.core.getCache(target), _context3());
      }
    }) : _savedStyles;
  };
  ScrollTrigger2.revert = function(soft, media) {
    return _revertAll(!soft, media);
  };
  ScrollTrigger2.create = function(vars, animation) {
    return new ScrollTrigger2(vars, animation);
  };
  ScrollTrigger2.refresh = function(safe) {
    return safe ? _onResize() : (_coreInitted3 || ScrollTrigger2.register()) && _refreshAll(true);
  };
  ScrollTrigger2.update = function(force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };
  ScrollTrigger2.clearScrollMemory = _clearScrollMemory;
  ScrollTrigger2.maxScroll = function(element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger2.getScrollFunc = function(element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger2.getById = function(id) {
    return _ids[id];
  };
  ScrollTrigger2.getAll = function() {
    return _triggers.filter(function(t) {
      return t.vars.id !== "ScrollSmoother";
    });
  };
  ScrollTrigger2.isScrolling = function() {
    return !!_lastScrollTime;
  };
  ScrollTrigger2.snapDirectional = _snapDirectional;
  ScrollTrigger2.addEventListener = function(type, callback) {
    var a = _listeners2[type] || (_listeners2[type] = []);
    ~a.indexOf(callback) || a.push(callback);
  };
  ScrollTrigger2.removeEventListener = function(type, callback) {
    var a = _listeners2[type], i = a && a.indexOf(callback);
    i >= 0 && a.splice(i, 1);
  };
  ScrollTrigger2.batch = function(targets, vars) {
    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {
      var elements = [], triggers = [], delay = gsap3.delayedCall(interval, function() {
        callback(elements, triggers);
        elements = [];
        triggers = [];
      }).pause();
      return function(self2) {
        elements.length || delay.restart(true);
        elements.push(self2.trigger);
        triggers.push(self2);
        batchMax <= elements.length && delay.progress(1);
      };
    }, p;
    for (p in vars) {
      varsCopy[p] = p.substr(0, 2) === "on" && _isFunction3(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
    }
    if (_isFunction3(batchMax)) {
      batchMax = batchMax();
      _addListener3(ScrollTrigger2, "refresh", function() {
        return batchMax = vars.batchMax();
      });
    }
    _toArray(targets).forEach(function(target) {
      var config3 = {};
      for (p in varsCopy) {
        config3[p] = varsCopy[p];
      }
      config3.trigger = target;
      result.push(ScrollTrigger2.create(config3));
    });
    return result;
  };
  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier2(scrollFunc, current, end, max) {
    current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
    return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  };
  var _allowNativePanning = function _allowNativePanning2(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer2.isTouch ? " pinch-zoom" : "") : "none";
    }
    target === _docEl2 && _allowNativePanning2(_body2, direction);
  };
  var _overflow = {
    auto: 1,
    scroll: 1
  };
  var _nestedScroll = function _nestedScroll2(_ref5) {
    var event2 = _ref5.event, target = _ref5.target, axis = _ref5.axis;
    var node = (event2.changedTouches ? event2.changedTouches[0] : event2).target, cache = node._gsap || gsap3.core.getCache(node), time = _getTime2(), cs;
    if (!cache._isScrollT || time - cache._isScrollT > 2e3) {
      while (node && node !== _body2 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }
      cache._isScroll = node && node !== target && !_isViewport3(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache._isScrollT = time;
    }
    if (cache._isScroll || axis === "x") {
      event2.stopPropagation();
      event2._gsapAllow = true;
    }
  };
  var _inputObserver = function _inputObserver2(target, type, inputs, nested) {
    return Observer2.create({
      target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener3(_doc4, Observer2.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener3(_doc4, Observer2.eventTypes[0], _captureInputs, true);
      }
    });
  };
  var _inputExp = /(input|label|select|textarea)/i;
  var _inputIsFocused;
  var _captureInputs = function _captureInputs2(e) {
    var isInput = _inputExp.test(e.target.tagName);
    if (isInput || _inputIsFocused) {
      e._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  };
  var _getScrollNormalizer = function _getScrollNormalizer2(vars) {
    _isObject3(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";
    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self2, maxY, target = _getTarget(vars.target) || _docEl2, smoother = gsap3.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer2.isTouch && _win4.visualViewport ? _win4.visualViewport.scale * _win4.visualViewport.width : _win4.outerWidth) / _win4.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction3(momentum) ? function() {
      return momentum(self2);
    } : function() {
      return momentum || 2.8;
    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove2() {
      return skipTouchMove = false;
    }, scrollClampX = _passThrough3, scrollClampY = _passThrough3, updateClamps = function updateClamps2() {
      maxY = _maxScroll(target, _vertical);
      scrollClampY = _clamp4(_fixIOSBug ? 1 : 0, maxY);
      normalizeScrollX && (scrollClampX = _clamp4(0, _maxScroll(target, _horizontal)));
      lastRefreshID = _refreshID;
    }, removeContentOffset = function removeContentOffset2() {
      content._gsap.y = _round3(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
      content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
    }, ignoreDrag = function ignoreDrag2() {
      if (skipTouchMove) {
        requestAnimationFrame(resumeTouchMove);
        var offset = _round3(self2.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);
        if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
          scrollFuncY.offset = scroll - scrollFuncY.v;
          var y = _round3((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
          content._gsap.y = y + "px";
          scrollFuncY.cacheID = _scrollers.cache;
          _updateAll();
        }
        return true;
      }
      scrollFuncY.offset && removeContentOffset();
      skipTouchMove = true;
    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize2 = function onResize3() {
      updateClamps();
      if (tween.isActive() && tween.vars.scrollY > maxY) {
        scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
      }
    };
    content && gsap3.set(content, {
      y: "+=0"
    });
    vars.ignoreCheck = function(e) {
      return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self2.isGesturing || e.touches && e.touches.length > 1;
    };
    vars.onPress = function() {
      skipTouchMove = false;
      var prevScale = scale;
      scale = _round3((_win4.visualViewport && _win4.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };
    vars.onRelease = vars.onGestureStart = function(self3, wasDragging) {
      scrollFuncY.offset && removeContentOffset();
      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _scrollers.cache++;
        var dur = resolveMomentumDuration(), currentScroll, endScroll;
        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self3.velocityX / 0.227;
          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }
        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self3.velocityY / 0.227;
        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);
        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          gsap3.to({}, {
            onUpdate: onResize2,
            duration: dur
          });
        }
      }
      onRelease && onRelease(self3);
    };
    vars.onWheel = function() {
      tween._ts && tween.pause();
      if (_getTime2() - wheelRefresh > 1e3) {
        lastRefreshID = 0;
        wheelRefresh = _getTime2();
      }
    };
    vars.onChange = function(self3, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self3.startX - self3.x) : scrollFuncX() + dx - xArray[1]));
      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self3.startY - self3.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);
        isTouch && y !== yClamped && (startScrollY += yClamped - y);
        scrollFuncY(yClamped);
      }
      (dy || dx) && _updateAll();
    };
    vars.onEnable = function() {
      _allowNativePanning(target, normalizeScrollX ? false : "x");
      ScrollTrigger2.addEventListener("refresh", onResize2);
      _addListener3(_win4, "resize", onResize2);
      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }
      inputObserver.enable();
    };
    vars.onDisable = function() {
      _allowNativePanning(target, true);
      _removeListener3(_win4, "resize", onResize2);
      ScrollTrigger2.removeEventListener("refresh", onResize2);
      inputObserver.kill();
    };
    vars.lockAxis = vars.lockAxis !== false;
    self2 = new Observer2(vars);
    self2.iOS = _fixIOSBug;
    _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
    _fixIOSBug && gsap3.ticker.add(_passThrough3);
    onStopDelayedCall = self2._dc;
    tween = gsap3.to(self2, {
      ease: "power4",
      paused: true,
      inherit: false,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {
          return tween.pause();
        })
      },
      onUpdate: _updateAll,
      onComplete: onStopDelayedCall.vars.onComplete
    });
    return self2;
  };
  ScrollTrigger2.sort = function(func) {
    return _triggers.sort(func || function(a, b) {
      return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
    });
  };
  ScrollTrigger2.observe = function(vars) {
    return new Observer2(vars);
  };
  ScrollTrigger2.normalizeScroll = function(vars) {
    if (typeof vars === "undefined") {
      return _normalizer2;
    }
    if (vars === true && _normalizer2) {
      return _normalizer2.enable();
    }
    if (vars === false) {
      _normalizer2 && _normalizer2.kill();
      _normalizer2 = vars;
      return;
    }
    var normalizer = vars instanceof Observer2 ? vars : _getScrollNormalizer(vars);
    _normalizer2 && _normalizer2.target === normalizer.target && _normalizer2.kill();
    _isViewport3(normalizer.target) && (_normalizer2 = normalizer);
    return normalizer;
  };
  ScrollTrigger2.core = {
    // smaller file size way to leverage in ScrollSmoother and Observer
    _getVelocityProp,
    _inputObserver,
    _scrollers,
    _proxies,
    bridge: {
      // when normalizeScroll sets the scroll position (ss = setScroll)
      ss: function ss() {
        _lastScrollTime || _dispatch3("scrollStart");
        _lastScrollTime = _getTime2();
      },
      // a way to get the _refreshing value in Observer
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP3() && gsap3.registerPlugin(ScrollTrigger2);

  // src/utils/ressources/blog.ts
  gsapWithCSS.registerPlugin(ScrollTrigger2);
  function checkURLParameter() {
    const sectionState1 = document.querySelector(".section_state1");
    const sectionState2 = document.querySelector(".section_state2");
    const sectionGuideEtude = document.querySelector(".section_blog_guide");
    const sectionState3 = document.querySelector(".section_state3");
    if (!sectionState1 || !sectionState2 || !sectionState3 || !sectionGuideEtude) {
      return;
    }
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("tous-les-articles")) {
      sectionState1.style.display = "none";
      sectionState2.style.display = "block";
      sectionGuideEtude.style.display = "none";
      sectionState3.style.display = "none";
    }
  }
  function initBlogSections() {
    const sectionState1 = document.querySelector(".section_state1");
    const sectionState2 = document.querySelector(".section_state2");
    const sectionState3 = document.querySelector(".section_state3");
    const blogField = document.querySelector("#blog-field");
    if (!sectionState1 || !sectionState2 || !sectionState3 || !blogField) {
      return;
    }
    sectionState1.style.display = "block";
    sectionState2.style.display = "none";
    sectionState3.style.display = "none";
    checkURLParameter();
    blogField.addEventListener("click", () => {
      sectionState1.style.display = "none";
      sectionState2.style.display = "block";
      sectionState3.style.display = "none";
    });
    blogField.addEventListener("input", () => {
      const inputValue = blogField.value;
      if (inputValue === "") {
        sectionState1.style.display = "none";
        sectionState2.style.display = "block";
        sectionState3.style.display = "none";
      } else {
        sectionState1.style.display = "none";
        sectionState2.style.display = "none";
        sectionState3.style.display = "block";
      }
    });
  }
  function mirrorBlogSearch() {
    const blogField = document.querySelector("#blog-field");
    const searchMirror = document.getElementById("blog-all-articles_search-mirror");
    if (!blogField || !searchMirror) {
      return;
    }
    blogField.addEventListener("input", () => {
      const inputText = blogField.value;
      searchMirror.innerHTML = `&nbsp;${inputText}`;
    });
  }
  function searchBarPlaceholderStyling() {
    const inputField = document.querySelector(".header_v3_blog-field");
    if (!inputField) {
      return;
    }
    inputField.addEventListener("input", () => {
      if (inputField.value.trim() !== "") {
        inputField.classList.add("placeholder-active");
      } else {
        inputField.classList.remove("placeholder-active");
      }
    });
  }
  function animateBigCardRessource() {
    const element = document.querySelector(".ressources_bc-top-row");
    if (element) {
      gsapWithCSS.set(element, {
        borderRadius: "0.5rem 5rem 0.5rem 5rem"
      });
      element.addEventListener("mouseenter", () => {
        gsapWithCSS.to(element, {
          duration: 0.3,
          // Dure de l'animation
          borderRadius: "5rem 0.5rem 5rem 0.5rem",
          // Inverted value
          ease: "power2.out"
        });
      });
      element.addEventListener("mouseleave", () => {
        gsapWithCSS.to(element, {
          duration: 0.3,
          borderRadius: "0.5rem 5rem 0.5rem 5rem",
          // Return to initial value
          ease: "power2.out"
        });
      });
    }
  }
  function animateSmallCardRessource() {
    const elements = document.querySelectorAll(".hp_blog_sc-img-container");
    elements.forEach((element) => {
      const frontImage = element.querySelector(".hp_blog_sc-img-front");
      const hoverImage = element.querySelector(".hp_blog_sc-img-hover");
      if (frontImage && hoverImage) {
        gsapWithCSS.set(element, {
          borderRadius: "0.5rem 2.5rem 0.5rem 2.5rem"
        });
        gsapWithCSS.set(frontImage, { opacity: 1 });
        gsapWithCSS.set(hoverImage, { opacity: 0, position: "absolute", top: 0, left: 0 });
        element.addEventListener("mouseenter", () => {
          gsapWithCSS.to(element, {
            duration: 0.3,
            borderRadius: "2.5rem 0.5rem 2.5rem 0.5rem",
            ease: "power2.out"
          });
          gsapWithCSS.to(frontImage, { opacity: 0, duration: 0.3, ease: "power2.out" });
          gsapWithCSS.to(hoverImage, { opacity: 1, duration: 0.3, ease: "power2.out" });
        });
        element.addEventListener("mouseleave", () => {
          gsapWithCSS.to(element, {
            duration: 0.3,
            borderRadius: "0.5rem 2.5rem 0.5rem 2.5rem",
            ease: "power2.out"
          });
          gsapWithCSS.to(frontImage, { opacity: 1, duration: 0.3, ease: "power2.out" });
          gsapWithCSS.to(hoverImage, { opacity: 0, duration: 0.3, ease: "power2.out" });
        });
      }
    });
  }
  function animateLastNewsCard() {
    const elements = document.querySelectorAll(".blog_last-posts_img-wrapper");
    elements.forEach((element) => {
      const overlay = element.querySelector(".blog_last-posts_overlay");
      gsapWithCSS.set(element, {
        borderRadius: "2.5rem 0.5rem 2.5rem 0.5rem",
        borderColor: "#f4dddc",
        borderWidth: "1px",
        // Make sure the border is visible
        borderStyle: "solid"
        // Make sure the border is solid type
      });
      if (overlay) {
        gsapWithCSS.set(overlay, { opacity: 0 });
      }
      element.addEventListener("mouseenter", () => {
        gsapWithCSS.to(element, {
          duration: 0.3,
          borderRadius: "0.5rem 2.5rem 0.5rem 2.5rem",
          ease: "power2.out"
        });
        if (overlay) {
          gsapWithCSS.to(overlay, {
            duration: 0.3,
            opacity: 0.2,
            ease: "power2.out"
          });
        }
      });
      element.addEventListener("mouseleave", () => {
        gsapWithCSS.to(element, {
          duration: 0.3,
          borderRadius: "2.5rem 0.5rem 2.5rem 0.5rem",
          borderColor: "#f4dddc",
          ease: "power2.out"
        });
        if (overlay) {
          gsapWithCSS.to(overlay, {
            duration: 0.3,
            opacity: 0,
            ease: "power2.out"
          });
        }
      });
    });
  }
  function animateSpecialSelectCard() {
    const elements = document.querySelectorAll(".blog_last-posts_selection-img-wrapper");
    elements.forEach((element) => {
      gsapWithCSS.set(element, {
        borderRadius: "1rem 0.25rem 1rem 0.25rem",
        borderColor: "#f4dddc",
        borderWidth: "1px",
        borderStyle: "solid"
        // Make sure the border is solid type
      });
      element.addEventListener("mouseenter", () => {
        gsapWithCSS.to(element, {
          duration: 0.3,
          borderRadius: "0.25rem 1rem 0.25rem 1rem",
          borderColor: "#5a1f1b",
          ease: "power2.out"
        });
      });
      element.addEventListener("mouseleave", () => {
        gsapWithCSS.to(element, {
          duration: 0.3,
          borderRadius: "1rem 0.25rem 1rem 0.25rem",
          borderColor: "#f4dddc",
          ease: "power2.out"
        });
      });
    });
  }
  function handleGuideFilter() {
    if (window.location.href.includes("?category=Guide")) {
      const sectionState1 = document.querySelector(".section_state1");
      const sectionState2 = document.querySelector(".section_state2");
      const sectionsBlogMenu = document.querySelectorAll(".section_blog_menu");
      const sectionAllArticles = document.querySelector(".section_blog_all-articles");
      const sectionGuideEtude = document.querySelector(".section_blog_guide");
      const sectionState3 = document.querySelector(".section_state3");
      if (sectionState1 && sectionState2 && sectionState3 && sectionsBlogMenu && sectionAllArticles && sectionGuideEtude) {
        sectionState1.style.display = "none";
        sectionState2.style.display = "block";
        sectionsBlogMenu.forEach((menu) => {
          menu.style.display = "none";
        });
        sectionAllArticles.style.display = "none";
        sectionGuideEtude.style.display = "block";
        sectionState3.style.display = "none";
      }
    }
  }
  function observeTocLinks() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && mutation.target instanceof HTMLElement) {
          if (mutation.target.matches('[fs-toc-element="link"].w--current')) {
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none">
            <g clip-path="url(#clip0_2387_2341)">
              <path d="M7.42179 0.189242C7.67405 0.208795 7.92601 0.230771 8.1774 0.256517C8.153 0.260093 7.93519 0.246207 8.07987 0.264084C8.02129 0.263611 7.858 0.245045 7.80416 0.233561L7.84377 0.243852C7.67098 0.215777 7.54985 0.2307 7.66279 0.246434L7.64801 0.245237C7.48864 0.216462 7.32898 0.190109 7.16876 0.164292C7.34636 0.174349 7.30435 0.188563 7.51775 0.205647C7.45073 0.199716 7.43135 0.192553 7.42179 0.189242Z" fill="#42612D"/>
              <!-- Ajoutez ici le reste de votre SVG -->
            </g>
            <defs>
              <clipPath id="clip0_2387_2341">
                <rect width="12" height="12" fill="white"/>
              </clipPath>
            </defs>
          </svg>`;
            if (!mutation.target.querySelector("svg")) {
              mutation.target.insertAdjacentHTML("beforeend", svg);
            }
          }
        }
      });
    });
    const links = document.querySelectorAll('[fs-toc-element="link"]');
    links.forEach((link) => {
      observer.observe(link, { attributes: true });
    });
  }

  // src/utils/ressources/faq.ts
  init_live_reload();
  gsapWithCSS.registerPlugin(ScrollTrigger2);
  function filterFAQCategories() {
    const inputField = document.querySelector(".header_v3_blog-field");
    const faqCategories = document.querySelectorAll(".faq_header-cat");
    const mirrorSearchContent = document.querySelector(".faq_mirror-search-content");
    const handleInput = () => {
      if (!inputField || !mirrorSearchContent)
        return;
      const inputValue = inputField.value.trim();
      if (inputValue) {
        faqCategories.forEach((category) => {
          category.style.display = "none";
        });
        mirrorSearchContent.style.display = "flex";
        mirrorSearchContent.style.flexDirection = "row";
        mirrorSearchContent.style.gap = "0.25rem";
      } else {
        faqCategories.forEach((category) => {
          category.style.display = "";
        });
        mirrorSearchContent.style.display = "none";
      }
    };
    if (inputField) {
      inputField.addEventListener("input", handleInput);
    }
  }
  function mirrorFaqSearch() {
    const faqField = document.querySelector("#faq-field");
    const searchMirror = document.getElementById("faq_search-mirror");
    if (!faqField || !searchMirror) {
      return;
    }
    faqField.addEventListener("input", () => {
      const inputText = faqField.value;
      searchMirror.innerHTML = `&nbsp;${inputText}`;
    });
  }
  function linkFaqCategoryAnimations() {
    const linksAndTriggers = [
      { link: "#link-cat1", trigger: "#faq-cat1", icon: ".faq_cat-row:nth-child(1) .faq_cat-icon" },
      { link: "#link-cat2", trigger: "#faq-cat2", icon: ".faq_cat-row:nth-child(2) .faq_cat-icon" },
      { link: "#link-cat3", trigger: "#faq-cat3", icon: ".faq_cat-row:nth-child(3) .faq_cat-icon" },
      { link: "#link-cat4", trigger: "#faq-cat4", icon: ".faq_cat-row:nth-child(4) .faq_cat-icon" },
      { link: "#link-cat5", trigger: "#faq-cat5", icon: ".faq_cat-row:nth-child(5) .faq_cat-icon" }
    ];
    linksAndTriggers.forEach(({ link, trigger, icon }) => {
      const linkElement = document.querySelector(link);
      const iconElement = document.querySelector(icon);
      gsapWithCSS.set(iconElement, { opacity: 0 });
      gsapWithCSS.set(linkElement, { color: "rgb(90, 31, 27)" });
      gsapWithCSS.to(linkElement, {
        scrollTrigger: {
          trigger,
          start: "top center",
          end: "bottom center",
          onEnter: () => {
            gsapWithCSS.to(iconElement, { opacity: 1, duration: 0.3, ease: "power2.out" });
            gsapWithCSS.to(linkElement, { color: "#42612d", duration: 0.3, ease: "power2.out" });
          },
          onLeaveBack: () => {
            gsapWithCSS.to(iconElement, { opacity: 0, duration: 0.3, ease: "power2.out" });
            gsapWithCSS.to(linkElement, { color: "rgb(90, 31, 27)", duration: 0.3, ease: "power2.out" });
          }
        }
      });
    });
    const faqLeftCol = document.querySelector(".faq_left-col");
    if (faqLeftCol) {
      faqLeftCol.style.position = "sticky";
      faqLeftCol.style.top = "5rem";
    }
  }

  // src/utils/ressources/hub.ts
  init_live_reload();
  function showMoreItems(type) {
    const toggleButton = document.getElementById(`hub-show-${type}`);
    const wrapper = document.querySelector(`.hub_${type}_list-wrapper2`);
    if (!toggleButton || !wrapper)
      return;
    let isVisible = false;
    const originalText = toggleButton.textContent || "";
    const getLessText = (itemType) => {
      const texts = {
        testimonial: "Voir moins de t\xE9moignages",
        galerie: "Voir moins de r\xE9alisations",
        download: "Voir moins de t\xE9l\xE9chargements",
        action: "Voir moins de vid\xE9os"
      };
      return texts[itemType];
    };
    toggleButton.addEventListener("click", () => {
      isVisible = !isVisible;
      wrapper.style.display = isVisible ? "block" : "none";
      toggleButton.textContent = isVisible ? getLessText(type) : originalText;
    });
  }
  function hoverOnActionCard() {
    const cards = document.querySelectorAll(".hub_action_card");
    cards.forEach((card) => {
      const overlay = card.querySelector(".hub_action_overlay");
      const textContent = card.querySelector(".hub_action_text-content");
      if (overlay && textContent) {
        card.addEventListener("mouseenter", () => {
          overlay.style.opacity = "80%";
          gsapWithCSS.to(textContent, {
            duration: 0.3,
            bottom: "-2rem",
            ease: "power3.out"
          });
        });
        card.addEventListener("mouseleave", () => {
          overlay.style.opacity = "0%";
          gsapWithCSS.to(textContent, {
            duration: 0.3,
            bottom: "-9.1rem",
            ease: "power3.out"
          });
        });
      }
    });
  }
  function showContentTestimonialCard() {
    const moreWrappers = document.querySelectorAll(".hub_testimonial_logo-more-wrapper");
    const lessWrappers = document.querySelectorAll(
      ".hub_testimonial_hover-less-logo-wrapper"
    );
    const frontCards = document.querySelectorAll(".hub_testimonial_front-card");
    const hoverCards = document.querySelectorAll(".hub_testimonial_hover-card");
    moreWrappers.forEach((moreWrapper, index) => {
      const frontCard = frontCards[index];
      const hoverCard = hoverCards[index];
      moreWrapper.addEventListener("click", () => {
        frontCard.style.transition = "opacity 0.3s ease";
        hoverCard.style.transition = "opacity 0.3s ease";
        frontCard.style.opacity = "0";
        hoverCard.style.opacity = "1";
        hoverCard.style.zIndex = "1";
        setTimeout(() => {
          frontCard.classList.add("hidden");
        }, 300);
      });
    });
    lessWrappers.forEach((lessWrapper, index) => {
      const frontCard = frontCards[index];
      const hoverCard = hoverCards[index];
      lessWrapper.addEventListener("click", () => {
        frontCard.classList.remove("hidden");
        frontCard.style.opacity = "1";
        hoverCard.style.opacity = "0";
        hoverCard.style.zIndex = "-1";
        setTimeout(() => {
          hoverCard.style.transition = "opacity 0.3s ease";
          hoverCard.style.opacity = "0";
        }, 0);
      });
    });
  }
  var animateHubGalerieCardHover = () => {
    const cards = document.querySelectorAll(".hub_galerie_card");
    cards.forEach((card) => {
      const textContent = card.querySelector(".hub_galerie_text-content");
      if (textContent) {
        card.addEventListener("mouseenter", () => {
          gsapWithCSS.to(textContent, {
            top: "0rem",
            /// Final Position hover
            backgroundColor: "rgba(90, 31, 27, 0.8)",
            // background with 80% opacity
            duration: 0.5,
            ease: "power3.out"
          });
        });
        card.addEventListener("mouseleave", () => {
          gsapWithCSS.to(textContent, {
            top: "15rem",
            // Initial position at mouseleave
            backgroundColor: "transparent",
            // Initial background-color
            duration: 0.5,
            ease: "power3.out"
          });
        });
      }
    });
  };
  function applyMarginToHubGalerie() {
    const cards = document.querySelectorAll(".hub_galerie_card");
    cards.forEach((card, index) => {
      if (index % 2 === 0) {
        card.style.marginTop = "2.5rem";
      }
    });
  }
  var animateDownloadCardHover = () => {
    const cards = document.querySelectorAll(".hub_donwload_card");
    cards.forEach((card) => {
      const textContent = card.querySelector(".hub_download_bottom-content");
      const logoWrapper = card.querySelector(".hub_donwload_logo-wrapper.is-visible");
      if (textContent && logoWrapper) {
        card.addEventListener("mouseenter", () => {
          gsapWithCSS.to(textContent, {
            top: "0rem",
            // Final Position hover
            backgroundColor: "rgba(90, 31, 27, 0.8)",
            // background with 80% opacity
            duration: 0.5,
            ease: "power3.out"
          });
          gsapWithCSS.to(logoWrapper, {
            display: "none",
            duration: 0
          });
        });
        card.addEventListener("mouseleave", () => {
          gsapWithCSS.to(textContent, {
            top: "17rem",
            // Initial position at mouseleave
            backgroundColor: "transparent",
            // Initial background color
            duration: 0.5,
            ease: "power3.out"
          });
          gsapWithCSS.to(logoWrapper, {
            display: "block",
            duration: 0
          });
        });
      }
    });
  };

  // src/index.ts
  window.Webflow ||= [];
  window.Webflow.push(() => {
    Promise.all([
      loadScript(
        "https://cdn.jsdelivr.net/npm/@finsweet/attributes-scrolldisable@1/scrolldisable.js"
      ),
      loadScript("https://cdn.jsdelivr.net/npm/@finsweet/attributes-cmsload@1/cmsload.js"),
      loadScript("https://cdn.jsdelivr.net/npm/@finsweet/attributes-selectcustom@1/selectcustom.js"),
      loadScript("https://cdn.jsdelivr.net/npm/@finsweet/cookie-consent@1/fs-cc.js"),
      loadScript("https://cdn.jsdelivr.net/npm/@finsweet/attributes-accordion@1/accordion.js"),
      loadScript("https://cdn.jsdelivr.net/npm/@finsweet/attributes-cmsstatic@1/cmsstatic.js"),
      loadScript("https://cdn.jsdelivr.net/npm/@finsweet/attributes-inputactive@1/inputactive.js"),
      setTimeout(() => {
        loadScript("https://cdn.jsdelivr.net/npm/@finsweet/attributes-cmsfilter@1/cmsfilter.js");
      }, 250)
    ]);
    if (window.innerWidth > 992) {
      navScroll();
      setCurrentDropdownState();
      setCurrentRowFromURL();
    }
    swiperHpPicture();
    swiperHpTestimonial();
    swiperBlogAutres();
    swiperChronologie();
    swiperCoopHero();
    animateBigCardRessource();
    animateSmallCardRessource();
    animateLastNewsCard();
    animateSpecialSelectCard();
    catalogueFormTrigger();
    if (window.location.pathname === "/") {
      ressourcesHover();
      initTerroirsHover();
      initSmallTerroirsHover();
      initProductsHover();
    }
    if (window.location.href.includes("cooperatives")) {
      initializeMap();
    }
    if (window.location.href.includes("hub")) {
      hoverOnActionCard();
      showContentTestimonialCard();
      animateHubGalerieCardHover();
      applyMarginToHubGalerie();
      animateDownloadCardHover();
      ["testimonial", "galerie", "download", "action"].forEach(
        (type) => showMoreItems(type)
      );
    }
    if (window.location.href.includes("faq")) {
      filterFAQCategories();
      mirrorFaqSearch();
      linkFaqCategoryAnimations();
    }
    initBlogSections();
    mirrorBlogSearch();
    checkURLParameter();
    searchBarPlaceholderStyling();
    handleGuideFilter();
    swiperLastPosts();
    observeTocLinks();
    formInputLabels();
    if (window.location.pathname === "/catalogue") {
      catalogueCat();
      fixCatalogueCategoriesText();
      hideEmptyLabelsContainer();
      const loadPromise = new Promise((resolve) => {
        setTimeout(resolve, 3500);
      });
      loadPromise.then(() => {
        catalogueFilterCount();
        updateCatalogueCount();
        catalogueLoader();
      });
    }
    if (window.location.pathname.startsWith("/catalogue-produit")) {
      catalogueSameCat();
      swiperProduitsAutres();
      swiperProduitsCarousel();
      fixCatalogueCategoriesText();
      hideEmptyLabelsContainer();
    }
    if (window.location.pathname === "/contact") {
      showSiret();
    }
  });
})();
/*! Bundled license information:

mapbox-gl/dist/mapbox-gl.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/Observer.js:
  (*!
   * Observer 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrollTrigger.js:
  (*!
   * ScrollTrigger 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
*/
//# sourceMappingURL=index.js.map
